/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ((function(modules) {
	// Check all modules for deduplicated modules
	for(var i in modules) {
		if(Object.prototype.hasOwnProperty.call(modules, i)) {
			switch(typeof modules[i]) {
			case "function": break;
			case "object":
				// Module can be created from a template
				modules[i] = (function(_m) {
					var args = _m.slice(1), fn = modules[_m[0]];
					return function (a,b,c) {
						fn.apply(this, [a,b,c].concat(args));
					};
				}(modules[i]));
				break;
			default:
				// Module is a copy of another module
				modules[i] = modules[modules[i]];
				break;
			}
		}
	}
	return modules;
}([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _react = __webpack_require__(13);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(98);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _app = __webpack_require__(86);
	
	var _app2 = _interopRequireDefault(_app);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_reactDom2.default.render(_react2.default.createElement(_app2.default, null), document.getElementById('root'));

/***/ },
/* 1 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	function invariant(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}
	
	module.exports = invariant;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 3 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	'use strict';
	
	/**
	 * WARNING: DO NOT manually require this module.
	 * This is a replacement for `invariant(...)` used by the error code system
	 * and will _only_ be required by the corresponding babel pass.
	 * It always throws.
	 */
	
	function reactProdInvariant(code) {
	  var argCount = arguments.length - 1;
	
	  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;
	
	  for (var argIdx = 0; argIdx < argCount; argIdx++) {
	    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
	  }
	
	  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';
	
	  var error = new Error(message);
	  error.name = 'Invariant Violation';
	  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame
	
	  throw error;
	}
	
	module.exports = reactProdInvariant;

/***/ },
/* 4 */
[211, 15],
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var DOMProperty = __webpack_require__(16);
	var ReactDOMComponentFlags = __webpack_require__(61);
	
	var invariant = __webpack_require__(2);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var Flags = ReactDOMComponentFlags;
	
	var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);
	
	/**
	 * Drill down (through composites and empty components) until we get a host or
	 * host text component.
	 *
	 * This is pretty polymorphic but unavoidable with the current structure we have
	 * for `_renderedChildren`.
	 */
	function getRenderedHostOrTextFromComponent(component) {
	  var rendered;
	  while (rendered = component._renderedComponent) {
	    component = rendered;
	  }
	  return component;
	}
	
	/**
	 * Populate `_hostNode` on the rendered host/text component with the given
	 * DOM node. The passed `inst` can be a composite.
	 */
	function precacheNode(inst, node) {
	  var hostInst = getRenderedHostOrTextFromComponent(inst);
	  hostInst._hostNode = node;
	  node[internalInstanceKey] = hostInst;
	}
	
	function uncacheNode(inst) {
	  var node = inst._hostNode;
	  if (node) {
	    delete node[internalInstanceKey];
	    inst._hostNode = null;
	  }
	}
	
	/**
	 * Populate `_hostNode` on each child of `inst`, assuming that the children
	 * match up with the DOM (element) children of `node`.
	 *
	 * We cache entire levels at once to avoid an n^2 problem where we access the
	 * children of a node sequentially and have to walk from the start to our target
	 * node every time.
	 *
	 * Since we update `_renderedChildren` and the actual DOM at (slightly)
	 * different times, we could race here and see a newer `_renderedChildren` than
	 * the DOM nodes we see. To avoid this, ReactMultiChild calls
	 * `prepareToManageChildren` before we change `_renderedChildren`, at which
	 * time the container's child nodes are always cached (until it unmounts).
	 */
	function precacheChildNodes(inst, node) {
	  if (inst._flags & Flags.hasCachedChildNodes) {
	    return;
	  }
	  var children = inst._renderedChildren;
	  var childNode = node.firstChild;
	  outer: for (var name in children) {
	    if (!children.hasOwnProperty(name)) {
	      continue;
	    }
	    var childInst = children[name];
	    var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
	    if (childID === 0) {
	      // We're currently unmounting this child in ReactMultiChild; skip it.
	      continue;
	    }
	    // We assume the child nodes are in the same order as the child instances.
	    for (; childNode !== null; childNode = childNode.nextSibling) {
	      if (childNode.nodeType === 1 && childNode.getAttribute(ATTR_NAME) === String(childID) || childNode.nodeType === 8 && childNode.nodeValue === ' react-text: ' + childID + ' ' || childNode.nodeType === 8 && childNode.nodeValue === ' react-empty: ' + childID + ' ') {
	        precacheNode(childInst, childNode);
	        continue outer;
	      }
	    }
	    // We reached the end of the DOM children without finding an ID match.
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unable to find element with ID %s.', childID) : _prodInvariant('32', childID) : void 0;
	  }
	  inst._flags |= Flags.hasCachedChildNodes;
	}
	
	/**
	 * Given a DOM node, return the closest ReactDOMComponent or
	 * ReactDOMTextComponent instance ancestor.
	 */
	function getClosestInstanceFromNode(node) {
	  if (node[internalInstanceKey]) {
	    return node[internalInstanceKey];
	  }
	
	  // Walk up the tree until we find an ancestor whose instance we have cached.
	  var parents = [];
	  while (!node[internalInstanceKey]) {
	    parents.push(node);
	    if (node.parentNode) {
	      node = node.parentNode;
	    } else {
	      // Top of the tree. This node must not be part of a React tree (or is
	      // unmounted, potentially).
	      return null;
	    }
	  }
	
	  var closest;
	  var inst;
	  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
	    closest = inst;
	    if (parents.length) {
	      precacheChildNodes(inst, node);
	    }
	  }
	
	  return closest;
	}
	
	/**
	 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
	 * instance, or null if the node was not rendered by this React.
	 */
	function getInstanceFromNode(node) {
	  var inst = getClosestInstanceFromNode(node);
	  if (inst != null && inst._hostNode === node) {
	    return inst;
	  } else {
	    return null;
	  }
	}
	
	/**
	 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
	 * DOM node.
	 */
	function getNodeFromInstance(inst) {
	  // Without this first invariant, passing a non-DOM-component triggers the next
	  // invariant for a missing parent, which is super confusing.
	  !(inst._hostNode !== undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	
	  if (inst._hostNode) {
	    return inst._hostNode;
	  }
	
	  // Walk up the tree until we find an ancestor whose DOM node we have cached.
	  var parents = [];
	  while (!inst._hostNode) {
	    parents.push(inst);
	    !inst._hostParent ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React DOM tree root should always have a node reference.') : _prodInvariant('34') : void 0;
	    inst = inst._hostParent;
	  }
	
	  // Now parents contains each ancestor that does *not* have a cached native
	  // node, and `inst` is the deepest ancestor that does.
	  for (; parents.length; inst = parents.pop()) {
	    precacheChildNodes(inst, inst._hostNode);
	  }
	
	  return inst._hostNode;
	}
	
	var ReactDOMComponentTree = {
	  getClosestInstanceFromNode: getClosestInstanceFromNode,
	  getInstanceFromNode: getInstanceFromNode,
	  getNodeFromInstance: getNodeFromInstance,
	  precacheChildNodes: precacheChildNodes,
	  precacheNode: precacheNode,
	  uncacheNode: uncacheNode
	};
	
	module.exports = ReactDOMComponentTree;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 6 */
/***/ function(module, exports) {

	'use strict';
	/* eslint-disable no-unused-vars */
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	
	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}
	
		return Object(val);
	}
	
	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}
	
			// Detect buggy property enumeration order in older V8 versions.
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}
	
			return true;
		} catch (e) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}
	
	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;
	
		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);
	
			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}
	
			if (Object.getOwnPropertySymbols) {
				symbols = Object.getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}
	
		return to;
	};


/***/ },
/* 7 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {
	
	  canUseDOM: canUseDOM,
	
	  canUseWorkers: typeof Worker !== 'undefined',
	
	  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
	
	  canUseViewport: canUseDOM && !!window.screen,
	
	  isInWorker: !canUseDOM // For now, this is true - might change in the future.
	
	};
	
	module.exports = ExecutionEnvironment;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(19);
	
	var ReactCurrentOwner = __webpack_require__(11);
	
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(12);
	
	function isNative(fn) {
	  // Based on isNative() from Lodash
	  var funcToString = Function.prototype.toString;
	  var hasOwnProperty = Object.prototype.hasOwnProperty;
	  var reIsNative = RegExp('^' + funcToString
	  // Take an example native function source for comparison
	  .call(hasOwnProperty)
	  // Strip regex characters so we can use it for regex
	  .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	  // Remove hasOwnProperty from the template to make it generic
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
	  try {
	    var source = funcToString.call(fn);
	    return reIsNative.test(source);
	  } catch (err) {
	    return false;
	  }
	}
	
	var canUseCollections =
	// Array.from
	typeof Array.from === 'function' &&
	// Map
	typeof Map === 'function' && isNative(Map) &&
	// Map.prototype.keys
	Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
	// Set
	typeof Set === 'function' && isNative(Set) &&
	// Set.prototype.keys
	Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);
	
	if (canUseCollections) {
	  var itemMap = new Map();
	  var rootIDSet = new Set();
	
	  var setItem = function (id, item) {
	    itemMap.set(id, item);
	  };
	  var getItem = function (id) {
	    return itemMap.get(id);
	  };
	  var removeItem = function (id) {
	    itemMap['delete'](id);
	  };
	  var getItemIDs = function () {
	    return Array.from(itemMap.keys());
	  };
	
	  var addRoot = function (id) {
	    rootIDSet.add(id);
	  };
	  var removeRoot = function (id) {
	    rootIDSet['delete'](id);
	  };
	  var getRootIDs = function () {
	    return Array.from(rootIDSet.keys());
	  };
	} else {
	  var itemByKey = {};
	  var rootByKey = {};
	
	  // Use non-numeric keys to prevent V8 performance issues:
	  // https://github.com/facebook/react/pull/7232
	  var getKeyFromID = function (id) {
	    return '.' + id;
	  };
	  var getIDFromKey = function (key) {
	    return parseInt(key.substr(1), 10);
	  };
	
	  var setItem = function (id, item) {
	    var key = getKeyFromID(id);
	    itemByKey[key] = item;
	  };
	  var getItem = function (id) {
	    var key = getKeyFromID(id);
	    return itemByKey[key];
	  };
	  var removeItem = function (id) {
	    var key = getKeyFromID(id);
	    delete itemByKey[key];
	  };
	  var getItemIDs = function () {
	    return Object.keys(itemByKey).map(getIDFromKey);
	  };
	
	  var addRoot = function (id) {
	    var key = getKeyFromID(id);
	    rootByKey[key] = true;
	  };
	  var removeRoot = function (id) {
	    var key = getKeyFromID(id);
	    delete rootByKey[key];
	  };
	  var getRootIDs = function () {
	    return Object.keys(rootByKey).map(getIDFromKey);
	  };
	}
	
	var unmountedIDs = [];
	
	function purgeDeep(id) {
	  var item = getItem(id);
	  if (item) {
	    var childIDs = item.childIDs;
	
	    removeItem(id);
	    childIDs.forEach(purgeDeep);
	  }
	}
	
	function describeComponentFrame(name, source, ownerName) {
	  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
	}
	
	function getDisplayName(element) {
	  if (element == null) {
	    return '#empty';
	  } else if (typeof element === 'string' || typeof element === 'number') {
	    return '#text';
	  } else if (typeof element.type === 'string') {
	    return element.type;
	  } else {
	    return element.type.displayName || element.type.name || 'Unknown';
	  }
	}
	
	function describeID(id) {
	  var name = ReactComponentTreeHook.getDisplayName(id);
	  var element = ReactComponentTreeHook.getElement(id);
	  var ownerID = ReactComponentTreeHook.getOwnerID(id);
	  var ownerName;
	  if (ownerID) {
	    ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
	  }
	  process.env.NODE_ENV !== 'production' ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
	  return describeComponentFrame(name, element && element._source, ownerName);
	}
	
	var ReactComponentTreeHook = {
	  onSetChildren: function (id, nextChildIDs) {
	    var item = getItem(id);
	    !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
	    item.childIDs = nextChildIDs;
	
	    for (var i = 0; i < nextChildIDs.length; i++) {
	      var nextChildID = nextChildIDs[i];
	      var nextChild = getItem(nextChildID);
	      !nextChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
	      !(nextChild.childIDs != null || typeof nextChild.element !== 'object' || nextChild.element == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;
	      !nextChild.isMounted ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
	      if (nextChild.parentID == null) {
	        nextChild.parentID = id;
	        // TODO: This shouldn't be necessary but mounting a new root during in
	        // componentWillMount currently causes not-yet-mounted components to
	        // be purged from our tree data so their parent id is missing.
	      }
	      !(nextChild.parentID === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
	    }
	  },
	  onBeforeMountComponent: function (id, element, parentID) {
	    var item = {
	      element: element,
	      parentID: parentID,
	      text: null,
	      childIDs: [],
	      isMounted: false,
	      updateCount: 0
	    };
	    setItem(id, item);
	  },
	  onBeforeUpdateComponent: function (id, element) {
	    var item = getItem(id);
	    if (!item || !item.isMounted) {
	      // We may end up here as a result of setState() in componentWillUnmount().
	      // In this case, ignore the element.
	      return;
	    }
	    item.element = element;
	  },
	  onMountComponent: function (id) {
	    var item = getItem(id);
	    !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
	    item.isMounted = true;
	    var isRoot = item.parentID === 0;
	    if (isRoot) {
	      addRoot(id);
	    }
	  },
	  onUpdateComponent: function (id) {
	    var item = getItem(id);
	    if (!item || !item.isMounted) {
	      // We may end up here as a result of setState() in componentWillUnmount().
	      // In this case, ignore the element.
	      return;
	    }
	    item.updateCount++;
	  },
	  onUnmountComponent: function (id) {
	    var item = getItem(id);
	    if (item) {
	      // We need to check if it exists.
	      // `item` might not exist if it is inside an error boundary, and a sibling
	      // error boundary child threw while mounting. Then this instance never
	      // got a chance to mount, but it still gets an unmounting event during
	      // the error boundary cleanup.
	      item.isMounted = false;
	      var isRoot = item.parentID === 0;
	      if (isRoot) {
	        removeRoot(id);
	      }
	    }
	    unmountedIDs.push(id);
	  },
	  purgeUnmountedComponents: function () {
	    if (ReactComponentTreeHook._preventPurging) {
	      // Should only be used for testing.
	      return;
	    }
	
	    for (var i = 0; i < unmountedIDs.length; i++) {
	      var id = unmountedIDs[i];
	      purgeDeep(id);
	    }
	    unmountedIDs.length = 0;
	  },
	  isMounted: function (id) {
	    var item = getItem(id);
	    return item ? item.isMounted : false;
	  },
	  getCurrentStackAddendum: function (topElement) {
	    var info = '';
	    if (topElement) {
	      var name = getDisplayName(topElement);
	      var owner = topElement._owner;
	      info += describeComponentFrame(name, topElement._source, owner && owner.getName());
	    }
	
	    var currentOwner = ReactCurrentOwner.current;
	    var id = currentOwner && currentOwner._debugID;
	
	    info += ReactComponentTreeHook.getStackAddendumByID(id);
	    return info;
	  },
	  getStackAddendumByID: function (id) {
	    var info = '';
	    while (id) {
	      info += describeID(id);
	      id = ReactComponentTreeHook.getParentID(id);
	    }
	    return info;
	  },
	  getChildIDs: function (id) {
	    var item = getItem(id);
	    return item ? item.childIDs : [];
	  },
	  getDisplayName: function (id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (!element) {
	      return null;
	    }
	    return getDisplayName(element);
	  },
	  getElement: function (id) {
	    var item = getItem(id);
	    return item ? item.element : null;
	  },
	  getOwnerID: function (id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (!element || !element._owner) {
	      return null;
	    }
	    return element._owner._debugID;
	  },
	  getParentID: function (id) {
	    var item = getItem(id);
	    return item ? item.parentID : null;
	  },
	  getSource: function (id) {
	    var item = getItem(id);
	    var element = item ? item.element : null;
	    var source = element != null ? element._source : null;
	    return source;
	  },
	  getText: function (id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (typeof element === 'string') {
	      return element;
	    } else if (typeof element === 'number') {
	      return '' + element;
	    } else {
	      return null;
	    }
	  },
	  getUpdateCount: function (id) {
	    var item = getItem(id);
	    return item ? item.updateCount : 0;
	  },
	
	
	  getRootIDs: getRootIDs,
	  getRegisteredIDs: getItemIDs
	};
	
	module.exports = ReactComponentTreeHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	// Trust the developer to only use ReactInstrumentation with a __DEV__ check
	
	var debugTool = null;
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactDebugTool = __webpack_require__(127);
	  debugTool = ReactDebugTool;
	}
	
	module.exports = { debugTool: debugTool };
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3),
	    _assign = __webpack_require__(6);
	
	var CallbackQueue = __webpack_require__(59);
	var PooledClass = __webpack_require__(17);
	var ReactFeatureFlags = __webpack_require__(64);
	var ReactReconciler = __webpack_require__(22);
	var Transaction = __webpack_require__(31);
	
	var invariant = __webpack_require__(2);
	
	var dirtyComponents = [];
	var updateBatchNumber = 0;
	var asapCallbackQueue = CallbackQueue.getPooled();
	var asapEnqueued = false;
	
	var batchingStrategy = null;
	
	function ensureInjected() {
	  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;
	}
	
	var NESTED_UPDATES = {
	  initialize: function () {
	    this.dirtyComponentsLength = dirtyComponents.length;
	  },
	  close: function () {
	    if (this.dirtyComponentsLength !== dirtyComponents.length) {
	      // Additional updates were enqueued by componentDidUpdate handlers or
	      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
	      // these new updates so that if A's componentDidUpdate calls setState on
	      // B, B will update before the callback A's updater provided when calling
	      // setState.
	      dirtyComponents.splice(0, this.dirtyComponentsLength);
	      flushBatchedUpdates();
	    } else {
	      dirtyComponents.length = 0;
	    }
	  }
	};
	
	var UPDATE_QUEUEING = {
	  initialize: function () {
	    this.callbackQueue.reset();
	  },
	  close: function () {
	    this.callbackQueue.notifyAll();
	  }
	};
	
	var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
	
	function ReactUpdatesFlushTransaction() {
	  this.reinitializeTransaction();
	  this.dirtyComponentsLength = null;
	  this.callbackQueue = CallbackQueue.getPooled();
	  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* useCreateElement */true);
	}
	
	_assign(ReactUpdatesFlushTransaction.prototype, Transaction, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  destructor: function () {
	    this.dirtyComponentsLength = null;
	    CallbackQueue.release(this.callbackQueue);
	    this.callbackQueue = null;
	    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
	    this.reconcileTransaction = null;
	  },
	
	  perform: function (method, scope, a) {
	    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
	    // with this transaction's wrappers around it.
	    return Transaction.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
	  }
	});
	
	PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
	
	function batchedUpdates(callback, a, b, c, d, e) {
	  ensureInjected();
	  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
	}
	
	/**
	 * Array comparator for ReactComponents by mount ordering.
	 *
	 * @param {ReactComponent} c1 first component you're comparing
	 * @param {ReactComponent} c2 second component you're comparing
	 * @return {number} Return value usable by Array.prototype.sort().
	 */
	function mountOrderComparator(c1, c2) {
	  return c1._mountOrder - c2._mountOrder;
	}
	
	function runBatchedUpdates(transaction) {
	  var len = transaction.dirtyComponentsLength;
	  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;
	
	  // Since reconciling a component higher in the owner hierarchy usually (not
	  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
	  // them before their children by sorting the array.
	  dirtyComponents.sort(mountOrderComparator);
	
	  // Any updates enqueued while reconciling must be performed after this entire
	  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and
	  // C, B could update twice in a single batch if C's render enqueues an update
	  // to B (since B would have already updated, we should skip it, and the only
	  // way we can know to do so is by checking the batch counter).
	  updateBatchNumber++;
	
	  for (var i = 0; i < len; i++) {
	    // If a component is unmounted before pending changes apply, it will still
	    // be here, but we assume that it has cleared its _pendingCallbacks and
	    // that performUpdateIfNecessary is a noop.
	    var component = dirtyComponents[i];
	
	    // If performUpdateIfNecessary happens to enqueue any new updates, we
	    // shouldn't execute the callbacks until the next render happens, so
	    // stash the callbacks first
	    var callbacks = component._pendingCallbacks;
	    component._pendingCallbacks = null;
	
	    var markerName;
	    if (ReactFeatureFlags.logTopLevelRenders) {
	      var namedComponent = component;
	      // Duck type TopLevelWrapper. This is probably always true.
	      if (component._currentElement.type.isReactTopLevelWrapper) {
	        namedComponent = component._renderedComponent;
	      }
	      markerName = 'React update: ' + namedComponent.getName();
	      console.time(markerName);
	    }
	
	    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);
	
	    if (markerName) {
	      console.timeEnd(markerName);
	    }
	
	    if (callbacks) {
	      for (var j = 0; j < callbacks.length; j++) {
	        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
	      }
	    }
	  }
	}
	
	var flushBatchedUpdates = function () {
	  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
	  // array and perform any updates enqueued by mount-ready handlers (i.e.,
	  // componentDidUpdate) but we need to check here too in order to catch
	  // updates enqueued by setState callbacks and asap calls.
	  while (dirtyComponents.length || asapEnqueued) {
	    if (dirtyComponents.length) {
	      var transaction = ReactUpdatesFlushTransaction.getPooled();
	      transaction.perform(runBatchedUpdates, null, transaction);
	      ReactUpdatesFlushTransaction.release(transaction);
	    }
	
	    if (asapEnqueued) {
	      asapEnqueued = false;
	      var queue = asapCallbackQueue;
	      asapCallbackQueue = CallbackQueue.getPooled();
	      queue.notifyAll();
	      CallbackQueue.release(queue);
	    }
	  }
	};
	
	/**
	 * Mark a component as needing a rerender, adding an optional callback to a
	 * list of functions which will be executed once the rerender occurs.
	 */
	function enqueueUpdate(component) {
	  ensureInjected();
	
	  // Various parts of our code (such as ReactCompositeComponent's
	  // _renderValidatedComponent) assume that calls to render aren't nested;
	  // verify that that's the case. (This is called by each top-level update
	  // function, like setState, forceUpdate, etc.; creation and
	  // destruction of top-level components is guarded in ReactMount.)
	
	  if (!batchingStrategy.isBatchingUpdates) {
	    batchingStrategy.batchedUpdates(enqueueUpdate, component);
	    return;
	  }
	
	  dirtyComponents.push(component);
	  if (component._updateBatchNumber == null) {
	    component._updateBatchNumber = updateBatchNumber + 1;
	  }
	}
	
	/**
	 * Enqueue a callback to be run at the end of the current batching cycle. Throws
	 * if no updates are currently being performed.
	 */
	function asap(callback, context) {
	  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context whereupdates are not being batched.') : _prodInvariant('125') : void 0;
	  asapCallbackQueue.enqueue(callback, context);
	  asapEnqueued = true;
	}
	
	var ReactUpdatesInjection = {
	  injectReconcileTransaction: function (ReconcileTransaction) {
	    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;
	    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
	  },
	
	  injectBatchingStrategy: function (_batchingStrategy) {
	    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;
	    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;
	    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;
	    batchingStrategy = _batchingStrategy;
	  }
	};
	
	var ReactUpdates = {
	  /**
	   * React references `ReactReconcileTransaction` using this property in order
	   * to allow dependency injection.
	   *
	   * @internal
	   */
	  ReactReconcileTransaction: null,
	
	  batchedUpdates: batchedUpdates,
	  enqueueUpdate: enqueueUpdate,
	  flushBatchedUpdates: flushBatchedUpdates,
	  injection: ReactUpdatesInjection,
	  asap: asap
	};
	
	module.exports = ReactUpdates;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 11 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	/**
	 * Keeps track of the current owner.
	 *
	 * The current owner is the component who should own any components that are
	 * currently being constructed.
	 */
	var ReactCurrentOwner = {
	
	  /**
	   * @internal
	   * @type {ReactComponent}
	   */
	  current: null
	
	};
	
	module.exports = ReactCurrentOwner;

/***/ },
/* 12 */
[211, 56],
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(23);


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var PooledClass = __webpack_require__(17);
	
	var emptyFunction = __webpack_require__(15);
	var warning = __webpack_require__(4);
	
	var didWarnForAddedNewProperty = false;
	var isProxySupported = typeof Proxy === 'function';
	
	var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var EventInterface = {
	  type: null,
	  target: null,
	  // currentTarget is set when dispatching; no use in copying it here
	  currentTarget: emptyFunction.thatReturnsNull,
	  eventPhase: null,
	  bubbles: null,
	  cancelable: null,
	  timeStamp: function (event) {
	    return event.timeStamp || Date.now();
	  },
	  defaultPrevented: null,
	  isTrusted: null
	};
	
	/**
	 * Synthetic events are dispatched by event plugins, typically in response to a
	 * top-level event delegation handler.
	 *
	 * These systems should generally use pooling to reduce the frequency of garbage
	 * collection. The system should check `isPersistent` to determine whether the
	 * event should be released into the pool after being dispatched. Users that
	 * need a persisted event should invoke `persist`.
	 *
	 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
	 * normalizing browser quirks. Subclasses do not necessarily have to implement a
	 * DOM interface; custom application-specific events can also subclass this.
	 *
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {*} targetInst Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @param {DOMEventTarget} nativeEventTarget Target node.
	 */
	function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
	  if (process.env.NODE_ENV !== 'production') {
	    // these have a getter/setter for warnings
	    delete this.nativeEvent;
	    delete this.preventDefault;
	    delete this.stopPropagation;
	  }
	
	  this.dispatchConfig = dispatchConfig;
	  this._targetInst = targetInst;
	  this.nativeEvent = nativeEvent;
	
	  var Interface = this.constructor.Interface;
	  for (var propName in Interface) {
	    if (!Interface.hasOwnProperty(propName)) {
	      continue;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      delete this[propName]; // this has a getter/setter for warnings
	    }
	    var normalize = Interface[propName];
	    if (normalize) {
	      this[propName] = normalize(nativeEvent);
	    } else {
	      if (propName === 'target') {
	        this.target = nativeEventTarget;
	      } else {
	        this[propName] = nativeEvent[propName];
	      }
	    }
	  }
	
	  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
	  if (defaultPrevented) {
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  } else {
	    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
	  }
	  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
	  return this;
	}
	
	_assign(SyntheticEvent.prototype, {
	
	  preventDefault: function () {
	    this.defaultPrevented = true;
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }
	
	    if (event.preventDefault) {
	      event.preventDefault();
	    } else if (typeof event.returnValue !== 'unknown') {
	      // eslint-disable-line valid-typeof
	      event.returnValue = false;
	    }
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  },
	
	  stopPropagation: function () {
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }
	
	    if (event.stopPropagation) {
	      event.stopPropagation();
	    } else if (typeof event.cancelBubble !== 'unknown') {
	      // eslint-disable-line valid-typeof
	      // The ChangeEventPlugin registers a "propertychange" event for
	      // IE. This event does not support bubbling or cancelling, and
	      // any references to cancelBubble throw "Member not found".  A
	      // typeof check of "unknown" circumvents this issue (and is also
	      // IE specific).
	      event.cancelBubble = true;
	    }
	
	    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * We release all dispatched `SyntheticEvent`s after each event loop, adding
	   * them back into the pool. This allows a way to hold onto a reference that
	   * won't be added back into the pool.
	   */
	  persist: function () {
	    this.isPersistent = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * Checks if this event should be released back into the pool.
	   *
	   * @return {boolean} True if this should not be released, false otherwise.
	   */
	  isPersistent: emptyFunction.thatReturnsFalse,
	
	  /**
	   * `PooledClass` looks for `destructor` on each instance it releases.
	   */
	  destructor: function () {
	    var Interface = this.constructor.Interface;
	    for (var propName in Interface) {
	      if (process.env.NODE_ENV !== 'production') {
	        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
	      } else {
	        this[propName] = null;
	      }
	    }
	    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
	      this[shouldBeReleasedProperties[i]] = null;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
	      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
	      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
	    }
	  }
	
	});
	
	SyntheticEvent.Interface = EventInterface;
	
	if (process.env.NODE_ENV !== 'production') {
	  if (isProxySupported) {
	    /*eslint-disable no-func-assign */
	    SyntheticEvent = new Proxy(SyntheticEvent, {
	      construct: function (target, args) {
	        return this.apply(target, Object.create(target.prototype), args);
	      },
	      apply: function (constructor, that, args) {
	        return new Proxy(constructor.apply(that, args), {
	          set: function (target, prop, value) {
	            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
	              process.env.NODE_ENV !== 'production' ? warning(didWarnForAddedNewProperty || target.isPersistent(), 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re adding a new property in the synthetic event object. ' + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;
	              didWarnForAddedNewProperty = true;
	            }
	            target[prop] = value;
	            return true;
	          }
	        });
	      }
	    });
	    /*eslint-enable no-func-assign */
	  }
	}
	/**
	 * Helper to reduce boilerplate when creating subclasses.
	 *
	 * @param {function} Class
	 * @param {?object} Interface
	 */
	SyntheticEvent.augmentClass = function (Class, Interface) {
	  var Super = this;
	
	  var E = function () {};
	  E.prototype = Super.prototype;
	  var prototype = new E();
	
	  _assign(prototype, Class.prototype);
	  Class.prototype = prototype;
	  Class.prototype.constructor = Class;
	
	  Class.Interface = _assign({}, Super.Interface, Interface);
	  Class.augmentClass = Super.augmentClass;
	
	  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
	};
	
	PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);
	
	module.exports = SyntheticEvent;
	
	/**
	  * Helper to nullify syntheticEvent instance properties when destructing
	  *
	  * @param {object} SyntheticEvent
	  * @param {String} propName
	  * @return {object} defineProperty object
	  */
	function getPooledWarningPropertyDefinition(propName, getVal) {
	  var isFunction = typeof getVal === 'function';
	  return {
	    configurable: true,
	    set: set,
	    get: get
	  };
	
	  function set(val) {
	    var action = isFunction ? 'setting the method' : 'setting the property';
	    warn(action, 'This is effectively a no-op');
	    return val;
	  }
	
	  function get() {
	    var action = isFunction ? 'accessing the method' : 'accessing the property';
	    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
	    warn(action, result);
	    return getVal;
	  }
	
	  function warn(action, result) {
	    var warningCondition = false;
	    process.env.NODE_ENV !== 'production' ? warning(warningCondition, 'This synthetic event is reused for performance reasons. If you\'re seeing this, ' + 'you\'re %s `%s` on a released/nullified synthetic event. %s. ' + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 15 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}
	
	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	var emptyFunction = function emptyFunction() {};
	
	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};
	
	module.exports = emptyFunction;

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var invariant = __webpack_require__(2);
	
	function checkMask(value, bitmask) {
	  return (value & bitmask) === bitmask;
	}
	
	var DOMPropertyInjection = {
	  /**
	   * Mapping from normalized, camelcased property names to a configuration that
	   * specifies how the associated DOM property should be accessed or rendered.
	   */
	  MUST_USE_PROPERTY: 0x1,
	  HAS_BOOLEAN_VALUE: 0x4,
	  HAS_NUMERIC_VALUE: 0x8,
	  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
	  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,
	
	  /**
	   * Inject some specialized knowledge about the DOM. This takes a config object
	   * with the following properties:
	   *
	   * isCustomAttribute: function that given an attribute name will return true
	   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
	   * attributes where it's impossible to enumerate all of the possible
	   * attribute names,
	   *
	   * Properties: object mapping DOM property name to one of the
	   * DOMPropertyInjection constants or null. If your attribute isn't in here,
	   * it won't get written to the DOM.
	   *
	   * DOMAttributeNames: object mapping React attribute name to the DOM
	   * attribute name. Attribute names not specified use the **lowercase**
	   * normalized name.
	   *
	   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
	   * attribute namespace URL. (Attribute names not specified use no namespace.)
	   *
	   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
	   * Property names not specified use the normalized name.
	   *
	   * DOMMutationMethods: Properties that require special mutation methods. If
	   * `value` is undefined, the mutation method should unset the property.
	   *
	   * @param {object} domPropertyConfig the config as described above.
	   */
	  injectDOMPropertyConfig: function (domPropertyConfig) {
	    var Injection = DOMPropertyInjection;
	    var Properties = domPropertyConfig.Properties || {};
	    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
	    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
	    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
	    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
	
	    if (domPropertyConfig.isCustomAttribute) {
	      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
	    }
	
	    for (var propName in Properties) {
	      !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property \'%s\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : _prodInvariant('48', propName) : void 0;
	
	      var lowerCased = propName.toLowerCase();
	      var propConfig = Properties[propName];
	
	      var propertyInfo = {
	        attributeName: lowerCased,
	        attributeNamespace: null,
	        propertyName: propName,
	        mutationMethod: null,
	
	        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
	        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
	        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
	        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
	        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
	      };
	      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : _prodInvariant('50', propName) : void 0;
	
	      if (process.env.NODE_ENV !== 'production') {
	        DOMProperty.getPossibleStandardName[lowerCased] = propName;
	      }
	
	      if (DOMAttributeNames.hasOwnProperty(propName)) {
	        var attributeName = DOMAttributeNames[propName];
	        propertyInfo.attributeName = attributeName;
	        if (process.env.NODE_ENV !== 'production') {
	          DOMProperty.getPossibleStandardName[attributeName] = propName;
	        }
	      }
	
	      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
	        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
	      }
	
	      if (DOMPropertyNames.hasOwnProperty(propName)) {
	        propertyInfo.propertyName = DOMPropertyNames[propName];
	      }
	
	      if (DOMMutationMethods.hasOwnProperty(propName)) {
	        propertyInfo.mutationMethod = DOMMutationMethods[propName];
	      }
	
	      DOMProperty.properties[propName] = propertyInfo;
	    }
	  }
	};
	
	/* eslint-disable max-len */
	var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
	/* eslint-enable max-len */
	
	/**
	 * DOMProperty exports lookup objects that can be used like functions:
	 *
	 *   > DOMProperty.isValid['id']
	 *   true
	 *   > DOMProperty.isValid['foobar']
	 *   undefined
	 *
	 * Although this may be confusing, it performs better in general.
	 *
	 * @see http://jsperf.com/key-exists
	 * @see http://jsperf.com/key-missing
	 */
	var DOMProperty = {
	
	  ID_ATTRIBUTE_NAME: 'data-reactid',
	  ROOT_ATTRIBUTE_NAME: 'data-reactroot',
	
	  ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
	  ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',
	
	  /**
	   * Map from property "standard name" to an object with info about how to set
	   * the property in the DOM. Each object contains:
	   *
	   * attributeName:
	   *   Used when rendering markup or with `*Attribute()`.
	   * attributeNamespace
	   * propertyName:
	   *   Used on DOM node instances. (This includes properties that mutate due to
	   *   external factors.)
	   * mutationMethod:
	   *   If non-null, used instead of the property or `setAttribute()` after
	   *   initial render.
	   * mustUseProperty:
	   *   Whether the property must be accessed and mutated as an object property.
	   * hasBooleanValue:
	   *   Whether the property should be removed when set to a falsey value.
	   * hasNumericValue:
	   *   Whether the property must be numeric or parse as a numeric and should be
	   *   removed when set to a falsey value.
	   * hasPositiveNumericValue:
	   *   Whether the property must be positive numeric or parse as a positive
	   *   numeric and should be removed when set to a falsey value.
	   * hasOverloadedBooleanValue:
	   *   Whether the property can be used as a flag as well as with a value.
	   *   Removed when strictly equal to false; present without a value when
	   *   strictly equal to true; present with a value otherwise.
	   */
	  properties: {},
	
	  /**
	   * Mapping from lowercase property names to the properly cased version, used
	   * to warn in the case of missing properties. Available only in __DEV__.
	   *
	   * autofocus is predefined, because adding it to the property whitelist
	   * causes unintended side effects.
	   *
	   * @type {Object}
	   */
	  getPossibleStandardName: process.env.NODE_ENV !== 'production' ? { autofocus: 'autoFocus' } : null,
	
	  /**
	   * All of the isCustomAttribute() functions that have been injected.
	   */
	  _isCustomAttributeFunctions: [],
	
	  /**
	   * Checks whether a property name is a custom attribute.
	   * @method
	   */
	  isCustomAttribute: function (attributeName) {
	    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
	      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
	      if (isCustomAttributeFn(attributeName)) {
	        return true;
	      }
	    }
	    return false;
	  },
	
	  injection: DOMPropertyInjection
	};
	
	module.exports = DOMProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 17 */
[210, 3, 2],
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(34);
	
	var ReactCurrentOwner = __webpack_require__(11);
	
	var warning = __webpack_require__(12);
	var canDefineProperty = __webpack_require__(54);
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	var REACT_ELEMENT_TYPE = __webpack_require__(83);
	
	var RESERVED_PROPS = {
	  key: true,
	  ref: true,
	  __self: true,
	  __source: true
	};
	
	var specialPropKeyWarningShown, specialPropRefWarningShown;
	
	function hasValidRef(config) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (hasOwnProperty.call(config, 'ref')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.ref !== undefined;
	}
	
	function hasValidKey(config) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (hasOwnProperty.call(config, 'key')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.key !== undefined;
	}
	
	function defineKeyPropWarningGetter(props, displayName) {
	  var warnAboutAccessingKey = function () {
	    if (!specialPropKeyWarningShown) {
	      specialPropKeyWarningShown = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
	    }
	  };
	  warnAboutAccessingKey.isReactWarning = true;
	  Object.defineProperty(props, 'key', {
	    get: warnAboutAccessingKey,
	    configurable: true
	  });
	}
	
	function defineRefPropWarningGetter(props, displayName) {
	  var warnAboutAccessingRef = function () {
	    if (!specialPropRefWarningShown) {
	      specialPropRefWarningShown = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
	    }
	  };
	  warnAboutAccessingRef.isReactWarning = true;
	  Object.defineProperty(props, 'ref', {
	    get: warnAboutAccessingRef,
	    configurable: true
	  });
	}
	
	/**
	 * Factory method to create a new React element. This no longer adheres to
	 * the class pattern, so do not use new to call it. Also, no instanceof check
	 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
	 * if something is a React Element.
	 *
	 * @param {*} type
	 * @param {*} key
	 * @param {string|object} ref
	 * @param {*} self A *temporary* helper to detect places where `this` is
	 * different from the `owner` when React.createElement is called, so that we
	 * can warn. We want to get rid of owner and replace string `ref`s with arrow
	 * functions, and as long as `this` and owner are the same, there will be no
	 * change in behavior.
	 * @param {*} source An annotation object (added by a transpiler or otherwise)
	 * indicating filename, line number, and/or other information.
	 * @param {*} owner
	 * @param {*} props
	 * @internal
	 */
	var ReactElement = function (type, key, ref, self, source, owner, props) {
	  var element = {
	    // This tag allow us to uniquely identify this as a React Element
	    $$typeof: REACT_ELEMENT_TYPE,
	
	    // Built-in properties that belong on the element
	    type: type,
	    key: key,
	    ref: ref,
	    props: props,
	
	    // Record the component responsible for creating this element.
	    _owner: owner
	  };
	
	  if (process.env.NODE_ENV !== 'production') {
	    // The validation flag is currently mutative. We put it on
	    // an external backing store so that we can freeze the whole object.
	    // This can be replaced with a WeakMap once they are implemented in
	    // commonly used development environments.
	    element._store = {};
	
	    // To make comparing ReactElements easier for testing purposes, we make
	    // the validation flag non-enumerable (where possible, which should
	    // include every environment we run tests in), so the test framework
	    // ignores it.
	    if (canDefineProperty) {
	      Object.defineProperty(element._store, 'validated', {
	        configurable: false,
	        enumerable: false,
	        writable: true,
	        value: false
	      });
	      // self and source are DEV only properties.
	      Object.defineProperty(element, '_self', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: self
	      });
	      // Two elements created in two different places should be considered
	      // equal for testing purposes and therefore we hide it from enumeration.
	      Object.defineProperty(element, '_source', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: source
	      });
	    } else {
	      element._store.validated = false;
	      element._self = self;
	      element._source = source;
	    }
	    if (Object.freeze) {
	      Object.freeze(element.props);
	      Object.freeze(element);
	    }
	  }
	
	  return element;
	};
	
	/**
	 * Create and return a new ReactElement of the given type.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement
	 */
	ReactElement.createElement = function (type, config, children) {
	  var propName;
	
	  // Reserved names are extracted
	  var props = {};
	
	  var key = null;
	  var ref = null;
	  var self = null;
	  var source = null;
	
	  if (config != null) {
	    if (hasValidRef(config)) {
	      ref = config.ref;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }
	
	    self = config.__self === undefined ? null : config.__self;
	    source = config.__source === undefined ? null : config.__source;
	    // Remaining properties are added to a new props object
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (Object.freeze) {
	        Object.freeze(childArray);
	      }
	    }
	    props.children = childArray;
	  }
	
	  // Resolve default props
	  if (type && type.defaultProps) {
	    var defaultProps = type.defaultProps;
	    for (propName in defaultProps) {
	      if (props[propName] === undefined) {
	        props[propName] = defaultProps[propName];
	      }
	    }
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    if (key || ref) {
	      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
	        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
	        if (key) {
	          defineKeyPropWarningGetter(props, displayName);
	        }
	        if (ref) {
	          defineRefPropWarningGetter(props, displayName);
	        }
	      }
	    }
	  }
	  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
	};
	
	/**
	 * Return a function that produces ReactElements of a given type.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.createfactory
	 */
	ReactElement.createFactory = function (type) {
	  var factory = ReactElement.createElement.bind(null, type);
	  // Expose the type on the factory and the prototype so that it can be
	  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
	  // This should not be named `constructor` since this may not be the function
	  // that created the element, and it may not even be a constructor.
	  // Legacy hook TODO: Warn if this is accessed
	  factory.type = type;
	  return factory;
	};
	
	ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
	  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
	
	  return newElement;
	};
	
	/**
	 * Clone and return a new ReactElement using element as the starting point.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement
	 */
	ReactElement.cloneElement = function (element, config, children) {
	  var propName;
	
	  // Original props are copied
	  var props = _assign({}, element.props);
	
	  // Reserved names are extracted
	  var key = element.key;
	  var ref = element.ref;
	  // Self is preserved since the owner is preserved.
	  var self = element._self;
	  // Source is preserved since cloneElement is unlikely to be targeted by a
	  // transpiler, and the original source is probably a better indicator of the
	  // true owner.
	  var source = element._source;
	
	  // Owner will be preserved, unless ref is overridden
	  var owner = element._owner;
	
	  if (config != null) {
	    if (hasValidRef(config)) {
	      // Silently steal the ref from the parent.
	      ref = config.ref;
	      owner = ReactCurrentOwner.current;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }
	
	    // Remaining properties override existing props
	    var defaultProps;
	    if (element.type && element.type.defaultProps) {
	      defaultProps = element.type.defaultProps;
	    }
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        if (config[propName] === undefined && defaultProps !== undefined) {
	          // Resolve default props
	          props[propName] = defaultProps[propName];
	        } else {
	          props[propName] = config[propName];
	        }
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  return ReactElement(element.type, key, ref, self, source, owner, props);
	};
	
	/**
	 * Verifies the object is a ReactElement.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid component.
	 * @final
	 */
	ReactElement.isValidElement = function (object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	};
	
	module.exports = ReactElement;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 19 */
3,
/* 20 */
2,
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMNamespaces = __webpack_require__(36);
	var setInnerHTML = __webpack_require__(33);
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(43);
	var setTextContent = __webpack_require__(77);
	
	var ELEMENT_NODE_TYPE = 1;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	/**
	 * In IE (8-11) and Edge, appending nodes with no children is dramatically
	 * faster than appending a full subtree, so we essentially queue up the
	 * .appendChild calls here and apply them so each node is added to its parent
	 * before any children are added.
	 *
	 * In other browsers, doing so is slower or neutral compared to the other order
	 * (in Firefox, twice as slow) so we only do this inversion in IE.
	 *
	 * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.
	 */
	var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);
	
	function insertTreeChildren(tree) {
	  if (!enableLazy) {
	    return;
	  }
	  var node = tree.node;
	  var children = tree.children;
	  if (children.length) {
	    for (var i = 0; i < children.length; i++) {
	      insertTreeBefore(node, children[i], null);
	    }
	  } else if (tree.html != null) {
	    setInnerHTML(node, tree.html);
	  } else if (tree.text != null) {
	    setTextContent(node, tree.text);
	  }
	}
	
	var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {
	  // DocumentFragments aren't actually part of the DOM after insertion so
	  // appending children won't update the DOM. We need to ensure the fragment
	  // is properly populated first, breaking out of our lazy approach for just
	  // this level. Also, some <object> plugins (like Flash Player) will read
	  // <param> nodes immediately upon insertion into the DOM, so <object>
	  // must also be populated prior to insertion into the DOM.
	  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
	    insertTreeChildren(tree);
	    parentNode.insertBefore(tree.node, referenceNode);
	  } else {
	    parentNode.insertBefore(tree.node, referenceNode);
	    insertTreeChildren(tree);
	  }
	});
	
	function replaceChildWithTree(oldNode, newTree) {
	  oldNode.parentNode.replaceChild(newTree.node, oldNode);
	  insertTreeChildren(newTree);
	}
	
	function queueChild(parentTree, childTree) {
	  if (enableLazy) {
	    parentTree.children.push(childTree);
	  } else {
	    parentTree.node.appendChild(childTree.node);
	  }
	}
	
	function queueHTML(tree, html) {
	  if (enableLazy) {
	    tree.html = html;
	  } else {
	    setInnerHTML(tree.node, html);
	  }
	}
	
	function queueText(tree, text) {
	  if (enableLazy) {
	    tree.text = text;
	  } else {
	    setTextContent(tree.node, text);
	  }
	}
	
	function toString() {
	  return this.node.nodeName;
	}
	
	function DOMLazyTree(node) {
	  return {
	    node: node,
	    children: [],
	    html: null,
	    text: null,
	    toString: toString
	  };
	}
	
	DOMLazyTree.insertTreeBefore = insertTreeBefore;
	DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
	DOMLazyTree.queueChild = queueChild;
	DOMLazyTree.queueHTML = queueHTML;
	DOMLazyTree.queueText = queueText;
	
	module.exports = DOMLazyTree;

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactRef = __webpack_require__(141);
	var ReactInstrumentation = __webpack_require__(9);
	
	var warning = __webpack_require__(4);
	
	/**
	 * Helper to call ReactRef.attachRefs with this composite component, split out
	 * to avoid allocations in the transaction mount-ready queue.
	 */
	function attachRefs() {
	  ReactRef.attachRefs(this, this._currentElement);
	}
	
	var ReactReconciler = {
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?object} the containing host component instance
	   * @param {?object} info about the host container
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots
	  ) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);
	      }
	    }
	    var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
	    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
	      }
	    }
	    return markup;
	  },
	
	  /**
	   * Returns a value that can be passed to
	   * ReactComponentEnvironment.replaceNodeWithMarkup.
	   */
	  getHostNode: function (internalInstance) {
	    return internalInstance.getHostNode();
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function (internalInstance, safely) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
	      }
	    }
	    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
	    internalInstance.unmountComponent(safely);
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
	      }
	    }
	  },
	
	  /**
	   * Update a component using a new element.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @internal
	   */
	  receiveComponent: function (internalInstance, nextElement, transaction, context) {
	    var prevElement = internalInstance._currentElement;
	
	    if (nextElement === prevElement && context === internalInstance._context) {
	      // Since elements are immutable after the owner is rendered,
	      // we can do a cheap identity compare here to determine if this is a
	      // superfluous reconcile. It's possible for state to be mutable but such
	      // change should trigger an update of the owner which would recreate
	      // the element. We explicitly check for the existence of an owner since
	      // it's possible for an element created outside a composite to be
	      // deeply mutated and reused.
	
	      // TODO: Bailing out early is just a perf optimization right?
	      // TODO: Removing the return statement should affect correctness?
	      return;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
	      }
	    }
	
	    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
	
	    if (refsChanged) {
	      ReactRef.detachRefs(internalInstance, prevElement);
	    }
	
	    internalInstance.receiveComponent(nextElement, transaction, context);
	
	    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
	      }
	    }
	  },
	
	  /**
	   * Flush any dirty changes in a component.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (internalInstance, transaction, updateBatchNumber) {
	    if (internalInstance._updateBatchNumber !== updateBatchNumber) {
	      // The component's enqueued batch number should always be the current
	      // batch or the following one.
	      process.env.NODE_ENV !== 'production' ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;
	      return;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
	      }
	    }
	    internalInstance.performUpdateIfNecessary(transaction);
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
	      }
	    }
	  }
	
	};
	
	module.exports = ReactReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(34);
	
	var ReactChildren = __webpack_require__(186);
	var ReactComponent = __webpack_require__(51);
	var ReactPureComponent = __webpack_require__(190);
	var ReactClass = __webpack_require__(187);
	var ReactDOMFactories = __webpack_require__(188);
	var ReactElement = __webpack_require__(18);
	var ReactPropTypes = __webpack_require__(189);
	var ReactVersion = __webpack_require__(191);
	
	var onlyChild = __webpack_require__(193);
	var warning = __webpack_require__(12);
	
	var createElement = ReactElement.createElement;
	var createFactory = ReactElement.createFactory;
	var cloneElement = ReactElement.cloneElement;
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactElementValidator = __webpack_require__(84);
	  createElement = ReactElementValidator.createElement;
	  createFactory = ReactElementValidator.createFactory;
	  cloneElement = ReactElementValidator.cloneElement;
	}
	
	var __spread = _assign;
	
	if (process.env.NODE_ENV !== 'production') {
	  var warned = false;
	  __spread = function () {
	    process.env.NODE_ENV !== 'production' ? warning(warned, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.') : void 0;
	    warned = true;
	    return _assign.apply(null, arguments);
	  };
	}
	
	var React = {
	
	  // Modern
	
	  Children: {
	    map: ReactChildren.map,
	    forEach: ReactChildren.forEach,
	    count: ReactChildren.count,
	    toArray: ReactChildren.toArray,
	    only: onlyChild
	  },
	
	  Component: ReactComponent,
	  PureComponent: ReactPureComponent,
	
	  createElement: createElement,
	  cloneElement: cloneElement,
	  isValidElement: ReactElement.isValidElement,
	
	  // Classic
	
	  PropTypes: ReactPropTypes,
	  createClass: ReactClass.createClass,
	  createFactory: createFactory,
	  createMixin: function (mixin) {
	    // Currently a noop. Will be used to validate and trace mixins.
	    return mixin;
	  },
	
	  // This looks DOM specific but these are actually isomorphic helpers
	  // since they are just generating DOM strings.
	  DOM: ReactDOMFactories,
	
	  version: ReactVersion,
	
	  // Deprecated hook for JSX spread, don't use this for anything.
	  __spread: __spread
	};
	
	module.exports = React;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var EventPluginRegistry = __webpack_require__(28);
	var EventPluginUtils = __webpack_require__(37);
	var ReactErrorUtils = __webpack_require__(41);
	
	var accumulateInto = __webpack_require__(71);
	var forEachAccumulated = __webpack_require__(72);
	var invariant = __webpack_require__(2);
	
	/**
	 * Internal store for event listeners
	 */
	var listenerBank = {};
	
	/**
	 * Internal queue of events that have accumulated their dispatches and are
	 * waiting to have their dispatches executed.
	 */
	var eventQueue = null;
	
	/**
	 * Dispatches an event and releases it back into the pool, unless persistent.
	 *
	 * @param {?object} event Synthetic event to be dispatched.
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @private
	 */
	var executeDispatchesAndRelease = function (event, simulated) {
	  if (event) {
	    EventPluginUtils.executeDispatchesInOrder(event, simulated);
	
	    if (!event.isPersistent()) {
	      event.constructor.release(event);
	    }
	  }
	};
	var executeDispatchesAndReleaseSimulated = function (e) {
	  return executeDispatchesAndRelease(e, true);
	};
	var executeDispatchesAndReleaseTopLevel = function (e) {
	  return executeDispatchesAndRelease(e, false);
	};
	
	var getDictionaryKey = function (inst) {
	  // Prevents V8 performance issue:
	  // https://github.com/facebook/react/pull/7232
	  return '.' + inst._rootNodeID;
	};
	
	/**
	 * This is a unified interface for event plugins to be installed and configured.
	 *
	 * Event plugins can implement the following properties:
	 *
	 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
	 *     Required. When a top-level event is fired, this method is expected to
	 *     extract synthetic events that will in turn be queued and dispatched.
	 *
	 *   `eventTypes` {object}
	 *     Optional, plugins that fire events must publish a mapping of registration
	 *     names that are used to register listeners. Values of this mapping must
	 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
	 *
	 *   `executeDispatch` {function(object, function, string)}
	 *     Optional, allows plugins to override how an event gets dispatched. By
	 *     default, the listener is simply invoked.
	 *
	 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
	 *
	 * @public
	 */
	var EventPluginHub = {
	
	  /**
	   * Methods for injecting dependencies.
	   */
	  injection: {
	
	    /**
	     * @param {array} InjectedEventPluginOrder
	     * @public
	     */
	    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
	
	    /**
	     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	     */
	    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
	
	  },
	
	  /**
	   * Stores `listener` at `listenerBank[registrationName][key]`. Is idempotent.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {function} listener The callback to store.
	   */
	  putListener: function (inst, registrationName, listener) {
	    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : _prodInvariant('94', registrationName, typeof listener) : void 0;
	
	    var key = getDictionaryKey(inst);
	    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
	    bankForRegistrationName[key] = listener;
	
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.didPutListener) {
	      PluginModule.didPutListener(inst, registrationName, listener);
	    }
	  },
	
	  /**
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @return {?function} The stored callback.
	   */
	  getListener: function (inst, registrationName) {
	    var bankForRegistrationName = listenerBank[registrationName];
	    var key = getDictionaryKey(inst);
	    return bankForRegistrationName && bankForRegistrationName[key];
	  },
	
	  /**
	   * Deletes a listener from the registration bank.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   */
	  deleteListener: function (inst, registrationName) {
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.willDeleteListener) {
	      PluginModule.willDeleteListener(inst, registrationName);
	    }
	
	    var bankForRegistrationName = listenerBank[registrationName];
	    // TODO: This should never be null -- when is it?
	    if (bankForRegistrationName) {
	      var key = getDictionaryKey(inst);
	      delete bankForRegistrationName[key];
	    }
	  },
	
	  /**
	   * Deletes all listeners for the DOM element with the supplied ID.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   */
	  deleteAllListeners: function (inst) {
	    var key = getDictionaryKey(inst);
	    for (var registrationName in listenerBank) {
	      if (!listenerBank.hasOwnProperty(registrationName)) {
	        continue;
	      }
	
	      if (!listenerBank[registrationName][key]) {
	        continue;
	      }
	
	      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	      if (PluginModule && PluginModule.willDeleteListener) {
	        PluginModule.willDeleteListener(inst, registrationName);
	      }
	
	      delete listenerBank[registrationName][key];
	    }
	  },
	
	  /**
	   * Allows registered plugins an opportunity to extract events from top-level
	   * native browser events.
	   *
	   * @return {*} An accumulation of synthetic events.
	   * @internal
	   */
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var events;
	    var plugins = EventPluginRegistry.plugins;
	    for (var i = 0; i < plugins.length; i++) {
	      // Not every plugin in the ordering may be loaded at runtime.
	      var possiblePlugin = plugins[i];
	      if (possiblePlugin) {
	        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	        if (extractedEvents) {
	          events = accumulateInto(events, extractedEvents);
	        }
	      }
	    }
	    return events;
	  },
	
	  /**
	   * Enqueues a synthetic event that should be dispatched when
	   * `processEventQueue` is invoked.
	   *
	   * @param {*} events An accumulation of synthetic events.
	   * @internal
	   */
	  enqueueEvents: function (events) {
	    if (events) {
	      eventQueue = accumulateInto(eventQueue, events);
	    }
	  },
	
	  /**
	   * Dispatches all synthetic events on the event queue.
	   *
	   * @internal
	   */
	  processEventQueue: function (simulated) {
	    // Set `eventQueue` to null before processing it so that we can tell if more
	    // events get enqueued while processing.
	    var processingEventQueue = eventQueue;
	    eventQueue = null;
	    if (simulated) {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
	    } else {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
	    }
	    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;
	    // This would be a good time to rethrow if any of the event handlers threw.
	    ReactErrorUtils.rethrowCaughtError();
	  },
	
	  /**
	   * These are needed for tests only. Do not use!
	   */
	  __purge: function () {
	    listenerBank = {};
	  },
	
	  __getListenerBank: function () {
	    return listenerBank;
	  }
	
	};
	
	module.exports = EventPluginHub;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(24);
	var EventPluginUtils = __webpack_require__(37);
	
	var accumulateInto = __webpack_require__(71);
	var forEachAccumulated = __webpack_require__(72);
	var warning = __webpack_require__(4);
	
	var getListener = EventPluginHub.getListener;
	
	/**
	 * Some event types have a notion of different registration names for different
	 * "phases" of propagation. This finds listeners by a given phase.
	 */
	function listenerAtPhase(inst, event, propagationPhase) {
	  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
	  return getListener(inst, registrationName);
	}
	
	/**
	 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
	 * here, allows us to not have to bind or create functions for each event.
	 * Mutating the event's members allows us to not have to create a wrapping
	 * "dispatch" object that pairs the event with the listener.
	 */
	function accumulateDirectionalDispatches(inst, phase, event) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;
	  }
	  var listener = listenerAtPhase(inst, event, phase);
	  if (listener) {
	    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	  }
	}
	
	/**
	 * Collect dispatches (must be entirely collected before dispatching - see unit
	 * tests). Lazily allocate the array to conserve memory.  We must loop through
	 * each event and perform the traversal for each one. We cannot perform a
	 * single traversal for the entire collection of events because each event may
	 * have a different target.
	 */
	function accumulateTwoPhaseDispatchesSingle(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
	 */
	function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    var targetInst = event._targetInst;
	    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
	    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Accumulates without regard to direction, does not look for phased
	 * registration names. Same as `accumulateDirectDispatchesSingle` but without
	 * requiring that the `dispatchMarker` be the same as the dispatched ID.
	 */
	function accumulateDispatches(inst, ignoredDirection, event) {
	  if (event && event.dispatchConfig.registrationName) {
	    var registrationName = event.dispatchConfig.registrationName;
	    var listener = getListener(inst, registrationName);
	    if (listener) {
	      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	    }
	  }
	}
	
	/**
	 * Accumulates dispatches on an `SyntheticEvent`, but only for the
	 * `dispatchMarker`.
	 * @param {SyntheticEvent} event
	 */
	function accumulateDirectDispatchesSingle(event) {
	  if (event && event.dispatchConfig.registrationName) {
	    accumulateDispatches(event._targetInst, null, event);
	  }
	}
	
	function accumulateTwoPhaseDispatches(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
	}
	
	function accumulateTwoPhaseDispatchesSkipTarget(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
	}
	
	function accumulateEnterLeaveDispatches(leave, enter, from, to) {
	  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
	}
	
	function accumulateDirectDispatches(events) {
	  forEachAccumulated(events, accumulateDirectDispatchesSingle);
	}
	
	/**
	 * A small set of propagation patterns, each of which will accept a small amount
	 * of information, and generate a set of "dispatch ready event objects" - which
	 * are sets of events that have already been annotated with a set of dispatched
	 * listener functions/ids. The API is designed this way to discourage these
	 * propagation strategies from actually executing the dispatches, since we
	 * always want to collect the entire set of dispatches before executing event a
	 * single one.
	 *
	 * @constructor EventPropagators
	 */
	var EventPropagators = {
	  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	  accumulateDirectDispatches: accumulateDirectDispatches,
	  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
	};
	
	module.exports = EventPropagators;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 26 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * `ReactInstanceMap` maintains a mapping from a public facing stateful
	 * instance (key) and the internal representation (value). This allows public
	 * methods to accept the user facing instance as an argument and map them back
	 * to internal methods.
	 */
	
	// TODO: Replace this with ES6: var ReactInstanceMap = new Map();
	
	var ReactInstanceMap = {
	
	  /**
	   * This API should be called `delete` but we'd have to make sure to always
	   * transform these to strings for IE support. When this transform is fully
	   * supported we can rename it.
	   */
	  remove: function (key) {
	    key._reactInternalInstance = undefined;
	  },
	
	  get: function (key) {
	    return key._reactInternalInstance;
	  },
	
	  has: function (key) {
	    return key._reactInternalInstance !== undefined;
	  },
	
	  set: function (key, value) {
	    key._reactInternalInstance = value;
	  }
	
	};
	
	module.exports = ReactInstanceMap;

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(14);
	
	var getEventTarget = __webpack_require__(46);
	
	/**
	 * @interface UIEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var UIEventInterface = {
	  view: function (event) {
	    if (event.view) {
	      return event.view;
	    }
	
	    var target = getEventTarget(event);
	    if (target.window === target) {
	      // target is a window object
	      return target;
	    }
	
	    var doc = target.ownerDocument;
	    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	    if (doc) {
	      return doc.defaultView || doc.parentWindow;
	    } else {
	      return window;
	    }
	  },
	  detail: function (event) {
	    return event.detail || 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
	
	module.exports = SyntheticUIEvent;

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Injectable ordering of event plugins.
	 */
	var eventPluginOrder = null;
	
	/**
	 * Injectable mapping from names to event plugin modules.
	 */
	var namesToPlugins = {};
	
	/**
	 * Recomputes the plugin list using the injected plugins and plugin ordering.
	 *
	 * @private
	 */
	function recomputePluginOrdering() {
	  if (!eventPluginOrder) {
	    // Wait until an `eventPluginOrder` is injected.
	    return;
	  }
	  for (var pluginName in namesToPlugins) {
	    var pluginModule = namesToPlugins[pluginName];
	    var pluginIndex = eventPluginOrder.indexOf(pluginName);
	    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;
	    if (EventPluginRegistry.plugins[pluginIndex]) {
	      continue;
	    }
	    !pluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;
	    EventPluginRegistry.plugins[pluginIndex] = pluginModule;
	    var publishedEvents = pluginModule.eventTypes;
	    for (var eventName in publishedEvents) {
	      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;
	    }
	  }
	}
	
	/**
	 * Publishes an event so that it can be dispatched by the supplied plugin.
	 *
	 * @param {object} dispatchConfig Dispatch configuration for the event.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @return {boolean} True if the event was successfully published.
	 * @private
	 */
	function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
	  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;
	  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
	
	  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	  if (phasedRegistrationNames) {
	    for (var phaseName in phasedRegistrationNames) {
	      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
	        var phasedRegistrationName = phasedRegistrationNames[phaseName];
	        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
	      }
	    }
	    return true;
	  } else if (dispatchConfig.registrationName) {
	    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
	    return true;
	  }
	  return false;
	}
	
	/**
	 * Publishes a registration name that is used to identify dispatched events and
	 * can be used with `EventPluginHub.putListener` to register listeners.
	 *
	 * @param {string} registrationName Registration name to add.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @private
	 */
	function publishRegistrationName(registrationName, pluginModule, eventName) {
	  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;
	  EventPluginRegistry.registrationNameModules[registrationName] = pluginModule;
	  EventPluginRegistry.registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;
	
	  if (process.env.NODE_ENV !== 'production') {
	    var lowerCasedName = registrationName.toLowerCase();
	    EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;
	
	    if (registrationName === 'onDoubleClick') {
	      EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;
	    }
	  }
	}
	
	/**
	 * Registers plugins so that they can extract and dispatch events.
	 *
	 * @see {EventPluginHub}
	 */
	var EventPluginRegistry = {
	
	  /**
	   * Ordered list of injected plugins.
	   */
	  plugins: [],
	
	  /**
	   * Mapping from event name to dispatch config
	   */
	  eventNameDispatchConfigs: {},
	
	  /**
	   * Mapping from registration name to plugin module
	   */
	  registrationNameModules: {},
	
	  /**
	   * Mapping from registration name to event name
	   */
	  registrationNameDependencies: {},
	
	  /**
	   * Mapping from lowercase registration names to the properly cased version,
	   * used to warn in the case of missing event handlers. Available
	   * only in __DEV__.
	   * @type {Object}
	   */
	  possibleRegistrationNames: process.env.NODE_ENV !== 'production' ? {} : null,
	  // Trust the developer to only use possibleRegistrationNames in __DEV__
	
	  /**
	   * Injects an ordering of plugins (by plugin name). This allows the ordering
	   * to be decoupled from injection of the actual plugins so that ordering is
	   * always deterministic regardless of packaging, on-the-fly injection, etc.
	   *
	   * @param {array} InjectedEventPluginOrder
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginOrder}
	   */
	  injectEventPluginOrder: function (injectedEventPluginOrder) {
	    !!eventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;
	    // Clone the ordering so it cannot be dynamically mutated.
	    eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
	    recomputePluginOrdering();
	  },
	
	  /**
	   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
	   * in the ordering injected by `injectEventPluginOrder`.
	   *
	   * Plugins can be injected as part of page initialization or on-the-fly.
	   *
	   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginsByName}
	   */
	  injectEventPluginsByName: function (injectedNamesToPlugins) {
	    var isOrderingDirty = false;
	    for (var pluginName in injectedNamesToPlugins) {
	      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
	        continue;
	      }
	      var pluginModule = injectedNamesToPlugins[pluginName];
	      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
	        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;
	        namesToPlugins[pluginName] = pluginModule;
	        isOrderingDirty = true;
	      }
	    }
	    if (isOrderingDirty) {
	      recomputePluginOrdering();
	    }
	  },
	
	  /**
	   * Looks up the plugin for the supplied event.
	   *
	   * @param {object} event A synthetic event.
	   * @return {?object} The plugin that created the supplied event.
	   * @internal
	   */
	  getPluginModuleForEvent: function (event) {
	    var dispatchConfig = event.dispatchConfig;
	    if (dispatchConfig.registrationName) {
	      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
	    }
	    if (dispatchConfig.phasedRegistrationNames !== undefined) {
	      // pulling phasedRegistrationNames out of dispatchConfig helps Flow see
	      // that it is not undefined.
	      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	
	      for (var phase in phasedRegistrationNames) {
	        if (!phasedRegistrationNames.hasOwnProperty(phase)) {
	          continue;
	        }
	        var pluginModule = EventPluginRegistry.registrationNameModules[phasedRegistrationNames[phase]];
	        if (pluginModule) {
	          return pluginModule;
	        }
	      }
	    }
	    return null;
	  },
	
	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _resetEventPlugins: function () {
	    eventPluginOrder = null;
	    for (var pluginName in namesToPlugins) {
	      if (namesToPlugins.hasOwnProperty(pluginName)) {
	        delete namesToPlugins[pluginName];
	      }
	    }
	    EventPluginRegistry.plugins.length = 0;
	
	    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
	    for (var eventName in eventNameDispatchConfigs) {
	      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
	        delete eventNameDispatchConfigs[eventName];
	      }
	    }
	
	    var registrationNameModules = EventPluginRegistry.registrationNameModules;
	    for (var registrationName in registrationNameModules) {
	      if (registrationNameModules.hasOwnProperty(registrationName)) {
	        delete registrationNameModules[registrationName];
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
	      for (var lowerCasedName in possibleRegistrationNames) {
	        if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
	          delete possibleRegistrationNames[lowerCasedName];
	        }
	      }
	    }
	  }
	
	};
	
	module.exports = EventPluginRegistry;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var EventPluginRegistry = __webpack_require__(28);
	var ReactEventEmitterMixin = __webpack_require__(131);
	var ViewportMetrics = __webpack_require__(70);
	
	var getVendorPrefixedEventName = __webpack_require__(167);
	var isEventSupported = __webpack_require__(47);
	
	/**
	 * Summary of `ReactBrowserEventEmitter` event handling:
	 *
	 *  - Top-level delegation is used to trap most native browser events. This
	 *    may only occur in the main thread and is the responsibility of
	 *    ReactEventListener, which is injected and can therefore support pluggable
	 *    event sources. This is the only work that occurs in the main thread.
	 *
	 *  - We normalize and de-duplicate events to account for browser quirks. This
	 *    may be done in the worker thread.
	 *
	 *  - Forward these native events (with the associated top-level type used to
	 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
	 *    to extract any synthetic events.
	 *
	 *  - The `EventPluginHub` will then process each event by annotating them with
	 *    "dispatches", a sequence of listeners and IDs that care about that event.
	 *
	 *  - The `EventPluginHub` then dispatches the events.
	 *
	 * Overview of React and the event system:
	 *
	 * +------------+    .
	 * |    DOM     |    .
	 * +------------+    .
	 *       |           .
	 *       v           .
	 * +------------+    .
	 * | ReactEvent |    .
	 * |  Listener  |    .
	 * +------------+    .                         +-----------+
	 *       |           .               +--------+|SimpleEvent|
	 *       |           .               |         |Plugin     |
	 * +-----|------+    .               v         +-----------+
	 * |     |      |    .    +--------------+                    +------------+
	 * |     +-----------.--->|EventPluginHub|                    |    Event   |
	 * |            |    .    |              |     +-----------+  | Propagators|
	 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
	 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
	 * |            |    .    |              |     +-----------+  |  utilities |
	 * |     +-----------.--->|              |                    +------------+
	 * |     |      |    .    +--------------+
	 * +-----|------+    .                ^        +-----------+
	 *       |           .                |        |Enter/Leave|
	 *       +           .                +-------+|Plugin     |
	 * +-------------+   .                         +-----------+
	 * | application |   .
	 * |-------------|   .
	 * |             |   .
	 * |             |   .
	 * +-------------+   .
	 *                   .
	 *    React Core     .  General Purpose Event Plugin System
	 */
	
	var hasEventPageXY;
	var alreadyListeningTo = {};
	var isMonitoringScrollValue = false;
	var reactTopListenersCounter = 0;
	
	// For events like 'submit' which don't consistently bubble (which we trap at a
	// lower node than `document`), binding at `document` would cause duplicate
	// events so we don't include them here
	var topEventMapping = {
	  topAbort: 'abort',
	  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
	  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
	  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
	  topBlur: 'blur',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topChange: 'change',
	  topClick: 'click',
	  topCompositionEnd: 'compositionend',
	  topCompositionStart: 'compositionstart',
	  topCompositionUpdate: 'compositionupdate',
	  topContextMenu: 'contextmenu',
	  topCopy: 'copy',
	  topCut: 'cut',
	  topDoubleClick: 'dblclick',
	  topDrag: 'drag',
	  topDragEnd: 'dragend',
	  topDragEnter: 'dragenter',
	  topDragExit: 'dragexit',
	  topDragLeave: 'dragleave',
	  topDragOver: 'dragover',
	  topDragStart: 'dragstart',
	  topDrop: 'drop',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topFocus: 'focus',
	  topInput: 'input',
	  topKeyDown: 'keydown',
	  topKeyPress: 'keypress',
	  topKeyUp: 'keyup',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topMouseDown: 'mousedown',
	  topMouseMove: 'mousemove',
	  topMouseOut: 'mouseout',
	  topMouseOver: 'mouseover',
	  topMouseUp: 'mouseup',
	  topPaste: 'paste',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topScroll: 'scroll',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topSelectionChange: 'selectionchange',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTextInput: 'textInput',
	  topTimeUpdate: 'timeupdate',
	  topTouchCancel: 'touchcancel',
	  topTouchEnd: 'touchend',
	  topTouchMove: 'touchmove',
	  topTouchStart: 'touchstart',
	  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting',
	  topWheel: 'wheel'
	};
	
	/**
	 * To ensure no conflicts with other potential React instances on the page
	 */
	var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);
	
	function getListeningForDocument(mountAt) {
	  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
	  // directly.
	  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
	    mountAt[topListenersIDKey] = reactTopListenersCounter++;
	    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
	  }
	  return alreadyListeningTo[mountAt[topListenersIDKey]];
	}
	
	/**
	 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
	 * example:
	 *
	 *   EventPluginHub.putListener('myID', 'onClick', myFunction);
	 *
	 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
	 *
	 * @internal
	 */
	var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {
	
	  /**
	   * Injectable event backend
	   */
	  ReactEventListener: null,
	
	  injection: {
	    /**
	     * @param {object} ReactEventListener
	     */
	    injectReactEventListener: function (ReactEventListener) {
	      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
	      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
	    }
	  },
	
	  /**
	   * Sets whether or not any created callbacks should be enabled.
	   *
	   * @param {boolean} enabled True if callbacks should be enabled.
	   */
	  setEnabled: function (enabled) {
	    if (ReactBrowserEventEmitter.ReactEventListener) {
	      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
	    }
	  },
	
	  /**
	   * @return {boolean} True if callbacks are enabled.
	   */
	  isEnabled: function () {
	    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
	  },
	
	  /**
	   * We listen for bubbled touch events on the document object.
	   *
	   * Firefox v8.01 (and possibly others) exhibited strange behavior when
	   * mounting `onmousemove` events at some node that was not the document
	   * element. The symptoms were that if your mouse is not moving over something
	   * contained within that mount point (for example on the background) the
	   * top-level listeners for `onmousemove` won't be called. However, if you
	   * register the `mousemove` on the document object, then it will of course
	   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
	   * top-level listeners to the document object only, at least for these
	   * movement types of events and possibly all events.
	   *
	   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	   *
	   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
	   * they bubble to document.
	   *
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {object} contentDocumentHandle Document which owns the container
	   */
	  listenTo: function (registrationName, contentDocumentHandle) {
	    var mountAt = contentDocumentHandle;
	    var isListening = getListeningForDocument(mountAt);
	    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
	
	    for (var i = 0; i < dependencies.length; i++) {
	      var dependency = dependencies[i];
	      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
	        if (dependency === 'topWheel') {
	          if (isEventSupported('wheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'wheel', mountAt);
	          } else if (isEventSupported('mousewheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'mousewheel', mountAt);
	          } else {
	            // Firefox needs to capture a different mouse scroll event.
	            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);
	          }
	        } else if (dependency === 'topScroll') {
	
	          if (isEventSupported('scroll', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topScroll', 'scroll', mountAt);
	          } else {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topScroll', 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
	          }
	        } else if (dependency === 'topFocus' || dependency === 'topBlur') {
	
	          if (isEventSupported('focus', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topFocus', 'focus', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topBlur', 'blur', mountAt);
	          } else if (isEventSupported('focusin')) {
	            // IE has `focusin` and `focusout` events which bubble.
	            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topFocus', 'focusin', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topBlur', 'focusout', mountAt);
	          }
	
	          // to make sure blur and focus event listeners are only attached once
	          isListening.topBlur = true;
	          isListening.topFocus = true;
	        } else if (topEventMapping.hasOwnProperty(dependency)) {
	          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
	        }
	
	        isListening[dependency] = true;
	      }
	    }
	  },
	
	  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  /**
	   * Protect against document.createEvent() returning null
	   * Some popup blocker extensions appear to do this:
	   * https://github.com/facebook/react/issues/6887
	   */
	  supportsEventPageXY: function () {
	    if (!document.createEvent) {
	      return false;
	    }
	    var ev = document.createEvent('MouseEvent');
	    return ev != null && 'pageX' in ev;
	  },
	
	  /**
	   * Listens to window scroll and resize events. We cache scroll values so that
	   * application code can access them without triggering reflows.
	   *
	   * ViewportMetrics is only used by SyntheticMouse/TouchEvent and only when
	   * pageX/pageY isn't supported (legacy browsers).
	   *
	   * NOTE: Scroll events do not bubble.
	   *
	   * @see http://www.quirksmode.org/dom/events/scroll.html
	   */
	  ensureScrollValueMonitoring: function () {
	    if (hasEventPageXY === undefined) {
	      hasEventPageXY = ReactBrowserEventEmitter.supportsEventPageXY();
	    }
	    if (!hasEventPageXY && !isMonitoringScrollValue) {
	      var refresh = ViewportMetrics.refreshScrollValues;
	      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
	      isMonitoringScrollValue = true;
	    }
	  }
	
	});
	
	module.exports = ReactBrowserEventEmitter;

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(27);
	var ViewportMetrics = __webpack_require__(70);
	
	var getEventModifierState = __webpack_require__(45);
	
	/**
	 * @interface MouseEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var MouseEventInterface = {
	  screenX: null,
	  screenY: null,
	  clientX: null,
	  clientY: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  getModifierState: getEventModifierState,
	  button: function (event) {
	    // Webkit, Firefox, IE9+
	    // which:  1 2 3
	    // button: 0 1 2 (standard)
	    var button = event.button;
	    if ('which' in event) {
	      return button;
	    }
	    // IE<9
	    // which:  undefined
	    // button: 0 0 0
	    // button: 1 4 2 (onmouseup)
	    return button === 2 ? 2 : button === 4 ? 1 : 0;
	  },
	  buttons: null,
	  relatedTarget: function (event) {
	    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
	  },
	  // "Proprietary" Interface.
	  pageX: function (event) {
	    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
	  },
	  pageY: function (event) {
	    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
	
	module.exports = SyntheticMouseEvent;

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var invariant = __webpack_require__(2);
	
	var OBSERVED_ERROR = {};
	
	/**
	 * `Transaction` creates a black box that is able to wrap any method such that
	 * certain invariants are maintained before and after the method is invoked
	 * (Even if an exception is thrown while invoking the wrapped method). Whoever
	 * instantiates a transaction can provide enforcers of the invariants at
	 * creation time. The `Transaction` class itself will supply one additional
	 * automatic invariant for you - the invariant that any transaction instance
	 * should not be run while it is already being run. You would typically create a
	 * single instance of a `Transaction` for reuse multiple times, that potentially
	 * is used to wrap several different methods. Wrappers are extremely simple -
	 * they only require implementing two methods.
	 *
	 * <pre>
	 *                       wrappers (injected at creation time)
	 *                                      +        +
	 *                                      |        |
	 *                    +-----------------|--------|--------------+
	 *                    |                 v        |              |
	 *                    |      +---------------+   |              |
	 *                    |   +--|    wrapper1   |---|----+         |
	 *                    |   |  +---------------+   v    |         |
	 *                    |   |          +-------------+  |         |
	 *                    |   |     +----|   wrapper2  |--------+   |
	 *                    |   |     |    +-------------+  |     |   |
	 *                    |   |     |                     |     |   |
	 *                    |   v     v                     v     v   | wrapper
	 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
	 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
	 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | +---+ +---+   +---------+   +---+ +---+ |
	 *                    |  initialize                    close    |
	 *                    +-----------------------------------------+
	 * </pre>
	 *
	 * Use cases:
	 * - Preserving the input selection ranges before/after reconciliation.
	 *   Restoring selection even in the event of an unexpected error.
	 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
	 *   while guaranteeing that afterwards, the event system is reactivated.
	 * - Flushing a queue of collected DOM mutations to the main UI thread after a
	 *   reconciliation takes place in a worker thread.
	 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
	 *   content.
	 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
	 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
	 * - (Future use case): Layout calculations before and after DOM updates.
	 *
	 * Transactional plugin API:
	 * - A module that has an `initialize` method that returns any precomputation.
	 * - and a `close` method that accepts the precomputation. `close` is invoked
	 *   when the wrapped process is completed, or has failed.
	 *
	 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
	 * that implement `initialize` and `close`.
	 * @return {Transaction} Single transaction for reuse in thread.
	 *
	 * @class Transaction
	 */
	var TransactionImpl = {
	  /**
	   * Sets up this instance so that it is prepared for collecting metrics. Does
	   * so such that this setup method may be used on an instance that is already
	   * initialized, in a way that does not consume additional memory upon reuse.
	   * That can be useful if you decide to make your subclass of this mixin a
	   * "PooledClass".
	   */
	  reinitializeTransaction: function () {
	    this.transactionWrappers = this.getTransactionWrappers();
	    if (this.wrapperInitData) {
	      this.wrapperInitData.length = 0;
	    } else {
	      this.wrapperInitData = [];
	    }
	    this._isInTransaction = false;
	  },
	
	  _isInTransaction: false,
	
	  /**
	   * @abstract
	   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
	   */
	  getTransactionWrappers: null,
	
	  isInTransaction: function () {
	    return !!this._isInTransaction;
	  },
	
	  /**
	   * Executes the function within a safety window. Use this for the top level
	   * methods that result in large amounts of computation/mutations that would
	   * need to be safety checked. The optional arguments helps prevent the need
	   * to bind in many cases.
	   *
	   * @param {function} method Member of scope to call.
	   * @param {Object} scope Scope to invoke from.
	   * @param {Object?=} a Argument to pass to the method.
	   * @param {Object?=} b Argument to pass to the method.
	   * @param {Object?=} c Argument to pass to the method.
	   * @param {Object?=} d Argument to pass to the method.
	   * @param {Object?=} e Argument to pass to the method.
	   * @param {Object?=} f Argument to pass to the method.
	   *
	   * @return {*} Return value from `method`.
	   */
	  perform: function (method, scope, a, b, c, d, e, f) {
	    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
	    var errorThrown;
	    var ret;
	    try {
	      this._isInTransaction = true;
	      // Catching errors makes debugging more difficult, so we start with
	      // errorThrown set to true before setting it to false after calling
	      // close -- if it's still set to true in the finally block, it means
	      // one of these calls threw.
	      errorThrown = true;
	      this.initializeAll(0);
	      ret = method.call(scope, a, b, c, d, e, f);
	      errorThrown = false;
	    } finally {
	      try {
	        if (errorThrown) {
	          // If `method` throws, prefer to show that stack trace over any thrown
	          // by invoking `closeAll`.
	          try {
	            this.closeAll(0);
	          } catch (err) {}
	        } else {
	          // Since `method` didn't throw, we don't want to silence the exception
	          // here.
	          this.closeAll(0);
	        }
	      } finally {
	        this._isInTransaction = false;
	      }
	    }
	    return ret;
	  },
	
	  initializeAll: function (startIndex) {
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      try {
	        // Catching errors makes debugging more difficult, so we start with the
	        // OBSERVED_ERROR state before overwriting it with the real return value
	        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
	        // block, it means wrapper.initialize threw.
	        this.wrapperInitData[i] = OBSERVED_ERROR;
	        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
	      } finally {
	        if (this.wrapperInitData[i] === OBSERVED_ERROR) {
	          // The initializer for wrapper i threw an error; initialize the
	          // remaining wrappers but silence any exceptions from them to ensure
	          // that the first error is the one to bubble up.
	          try {
	            this.initializeAll(i + 1);
	          } catch (err) {}
	        }
	      }
	    }
	  },
	
	  /**
	   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
	   * them the respective return values of `this.transactionWrappers.init[i]`
	   * (`close`rs that correspond to initializers that failed will not be
	   * invoked).
	   */
	  closeAll: function (startIndex) {
	    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : _prodInvariant('28') : void 0;
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      var initData = this.wrapperInitData[i];
	      var errorThrown;
	      try {
	        // Catching errors makes debugging more difficult, so we start with
	        // errorThrown set to true before setting it to false after calling
	        // close -- if it's still set to true in the finally block, it means
	        // wrapper.close threw.
	        errorThrown = true;
	        if (initData !== OBSERVED_ERROR && wrapper.close) {
	          wrapper.close.call(this, initData);
	        }
	        errorThrown = false;
	      } finally {
	        if (errorThrown) {
	          // The closer for wrapper i threw an error; close the remaining
	          // wrappers but silence any exceptions from them to ensure that the
	          // first error is the one to bubble up.
	          try {
	            this.closeAll(i + 1);
	          } catch (e) {}
	        }
	      }
	    }
	    this.wrapperInitData.length = 0;
	  }
	};
	
	module.exports = TransactionImpl;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 32 */
/***/ function(module, exports) {

	/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * Based on the escape-html library, which is used under the MIT License below:
	 *
	 * Copyright (c) 2012-2013 TJ Holowaychuk
	 * Copyright (c) 2015 Andreas Lubbe
	 * Copyright (c) 2015 Tiancheng "Timothy" Gu
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining
	 * a copy of this software and associated documentation files (the
	 * 'Software'), to deal in the Software without restriction, including
	 * without limitation the rights to use, copy, modify, merge, publish,
	 * distribute, sublicense, and/or sell copies of the Software, and to
	 * permit persons to whom the Software is furnished to do so, subject to
	 * the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 *
	 */
	
	'use strict';
	
	// code copied and modified from escape-html
	/**
	 * Module variables.
	 * @private
	 */
	
	var matchHtmlRegExp = /["'&<>]/;
	
	/**
	 * Escape special characters in the given string of html.
	 *
	 * @param  {string} string The string to escape for inserting into HTML
	 * @return {string}
	 * @public
	 */
	
	function escapeHtml(string) {
	  var str = '' + string;
	  var match = matchHtmlRegExp.exec(str);
	
	  if (!match) {
	    return str;
	  }
	
	  var escape;
	  var html = '';
	  var index = 0;
	  var lastIndex = 0;
	
	  for (index = match.index; index < str.length; index++) {
	    switch (str.charCodeAt(index)) {
	      case 34:
	        // "
	        escape = '&quot;';
	        break;
	      case 38:
	        // &
	        escape = '&amp;';
	        break;
	      case 39:
	        // '
	        escape = '&#x27;'; // modified from escape-html; used to be '&#39'
	        break;
	      case 60:
	        // <
	        escape = '&lt;';
	        break;
	      case 62:
	        // >
	        escape = '&gt;';
	        break;
	      default:
	        continue;
	    }
	
	    if (lastIndex !== index) {
	      html += str.substring(lastIndex, index);
	    }
	
	    lastIndex = index + 1;
	    html += escape;
	  }
	
	  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
	}
	// end code copied and modified from escape-html
	
	
	/**
	 * Escapes text to prevent scripting attacks.
	 *
	 * @param {*} text Text value to escape.
	 * @return {string} An escaped string.
	 */
	function escapeTextContentForBrowser(text) {
	  if (typeof text === 'boolean' || typeof text === 'number') {
	    // this shortcircuit helps perf for types that we know will never have
	    // special characters, especially given that this function is used often
	    // for numeric dom ids.
	    return '' + text;
	  }
	  return escapeHtml(text);
	}
	
	module.exports = escapeTextContentForBrowser;

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(7);
	var DOMNamespaces = __webpack_require__(36);
	
	var WHITESPACE_TEST = /^[ \r\n\t\f]/;
	var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(43);
	
	// SVG temp container for IE lacking innerHTML
	var reusableSVGContainer;
	
	/**
	 * Set the innerHTML property of a node, ensuring that whitespace is preserved
	 * even in IE8.
	 *
	 * @param {DOMElement} node
	 * @param {string} html
	 * @internal
	 */
	var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
	  // IE does not have innerHTML for SVG nodes, so instead we inject the
	  // new markup in a temp node and then move the child nodes across into
	  // the target node
	  if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {
	    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
	    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
	    var svgNode = reusableSVGContainer.firstChild;
	    while (svgNode.firstChild) {
	      node.appendChild(svgNode.firstChild);
	    }
	  } else {
	    node.innerHTML = html;
	  }
	});
	
	if (ExecutionEnvironment.canUseDOM) {
	  // IE8: When updating a just created node with innerHTML only leading
	  // whitespace is removed. When updating an existing node with innerHTML
	  // whitespace in root TextNodes is also collapsed.
	  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html
	
	  // Feature detection; only IE8 is known to behave improperly like this.
	  var testElement = document.createElement('div');
	  testElement.innerHTML = ' ';
	  if (testElement.innerHTML === '') {
	    setInnerHTML = function (node, html) {
	      // Magic theory: IE8 supposedly differentiates between added and updated
	      // nodes when processing innerHTML, innerHTML on updated nodes suffers
	      // from worse whitespace behavior. Re-adding a node like this triggers
	      // the initial and more favorable whitespace behavior.
	      // TODO: What to do on a detached node?
	      if (node.parentNode) {
	        node.parentNode.replaceChild(node, node);
	      }
	
	      // We also implement a workaround for non-visible tags disappearing into
	      // thin air on IE8, this only happens if there is no visible text
	      // in-front of the non-visible tags. Piggyback on the whitespace fix
	      // and simply check if any non-visible tags appear in the source.
	      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
	        // Recover leading whitespace by temporarily prepending any character.
	        // \uFEFF has the potential advantage of being zero-width/invisible.
	        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
	        // in hopes that this is preserved even if "\uFEFF" is transformed to
	        // the actual Unicode character (by Babel, for example).
	        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
	        node.innerHTML = String.fromCharCode(0xFEFF) + html;
	
	        // deleteData leaves an empty `TextNode` which offsets the index of all
	        // children. Definitely want to avoid this.
	        var textNode = node.firstChild;
	        if (textNode.data.length === 1) {
	          node.removeChild(textNode);
	        } else {
	          textNode.deleteData(0, 1);
	        }
	      } else {
	        node.innerHTML = html;
	      }
	    };
	  }
	  testElement = null;
	}
	
	module.exports = setInnerHTML;

/***/ },
/* 34 */
6,
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMLazyTree = __webpack_require__(21);
	var Danger = __webpack_require__(104);
	var ReactDOMComponentTree = __webpack_require__(5);
	var ReactInstrumentation = __webpack_require__(9);
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(43);
	var setInnerHTML = __webpack_require__(33);
	var setTextContent = __webpack_require__(77);
	
	function getNodeAfter(parentNode, node) {
	  // Special case for text components, which return [open, close] comments
	  // from getHostNode.
	  if (Array.isArray(node)) {
	    node = node[1];
	  }
	  return node ? node.nextSibling : parentNode.firstChild;
	}
	
	/**
	 * Inserts `childNode` as a child of `parentNode` at the `index`.
	 *
	 * @param {DOMElement} parentNode Parent node in which to insert.
	 * @param {DOMElement} childNode Child node to insert.
	 * @param {number} index Index at which to insert the child.
	 * @internal
	 */
	var insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {
	  // We rely exclusively on `insertBefore(node, null)` instead of also using
	  // `appendChild(node)`. (Using `undefined` is not allowed by all browsers so
	  // we are careful to use `null`.)
	  parentNode.insertBefore(childNode, referenceNode);
	});
	
	function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
	  DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
	}
	
	function moveChild(parentNode, childNode, referenceNode) {
	  if (Array.isArray(childNode)) {
	    moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
	  } else {
	    insertChildAt(parentNode, childNode, referenceNode);
	  }
	}
	
	function removeChild(parentNode, childNode) {
	  if (Array.isArray(childNode)) {
	    var closingComment = childNode[1];
	    childNode = childNode[0];
	    removeDelimitedText(parentNode, childNode, closingComment);
	    parentNode.removeChild(closingComment);
	  }
	  parentNode.removeChild(childNode);
	}
	
	function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
	  var node = openingComment;
	  while (true) {
	    var nextNode = node.nextSibling;
	    insertChildAt(parentNode, node, referenceNode);
	    if (node === closingComment) {
	      break;
	    }
	    node = nextNode;
	  }
	}
	
	function removeDelimitedText(parentNode, startNode, closingComment) {
	  while (true) {
	    var node = startNode.nextSibling;
	    if (node === closingComment) {
	      // The closing comment is removed by ReactMultiChild.
	      break;
	    } else {
	      parentNode.removeChild(node);
	    }
	  }
	}
	
	function replaceDelimitedText(openingComment, closingComment, stringText) {
	  var parentNode = openingComment.parentNode;
	  var nodeAfterComment = openingComment.nextSibling;
	  if (nodeAfterComment === closingComment) {
	    // There are no text nodes between the opening and closing comments; insert
	    // a new one if stringText isn't empty.
	    if (stringText) {
	      insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
	    }
	  } else {
	    if (stringText) {
	      // Set the text content of the first node after the opening comment, and
	      // remove all following nodes up until the closing comment.
	      setTextContent(nodeAfterComment, stringText);
	      removeDelimitedText(parentNode, nodeAfterComment, closingComment);
	    } else {
	      removeDelimitedText(parentNode, openingComment, closingComment);
	    }
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onHostOperation({
	      instanceID: ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID,
	      type: 'replace text',
	      payload: stringText
	    });
	  }
	}
	
	var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
	if (process.env.NODE_ENV !== 'production') {
	  dangerouslyReplaceNodeWithMarkup = function (oldChild, markup, prevInstance) {
	    Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
	    if (prevInstance._debugID !== 0) {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: prevInstance._debugID,
	        type: 'replace with',
	        payload: markup.toString()
	      });
	    } else {
	      var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
	      if (nextInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onHostOperation({
	          instanceID: nextInstance._debugID,
	          type: 'mount',
	          payload: markup.toString()
	        });
	      }
	    }
	  };
	}
	
	/**
	 * Operations for updating with DOM children.
	 */
	var DOMChildrenOperations = {
	
	  dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,
	
	  replaceDelimitedText: replaceDelimitedText,
	
	  /**
	   * Updates a component's children by processing a series of updates. The
	   * update configurations are each expected to have a `parentNode` property.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @internal
	   */
	  processUpdates: function (parentNode, updates) {
	    if (process.env.NODE_ENV !== 'production') {
	      var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
	    }
	
	    for (var k = 0; k < updates.length; k++) {
	      var update = updates[k];
	      switch (update.type) {
	        case 'INSERT_MARKUP':
	          insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'insert child',
	              payload: { toIndex: update.toIndex, content: update.content.toString() }
	            });
	          }
	          break;
	        case 'MOVE_EXISTING':
	          moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'move child',
	              payload: { fromIndex: update.fromIndex, toIndex: update.toIndex }
	            });
	          }
	          break;
	        case 'SET_MARKUP':
	          setInnerHTML(parentNode, update.content);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'replace children',
	              payload: update.content.toString()
	            });
	          }
	          break;
	        case 'TEXT_CONTENT':
	          setTextContent(parentNode, update.content);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'replace text',
	              payload: update.content.toString()
	            });
	          }
	          break;
	        case 'REMOVE_NODE':
	          removeChild(parentNode, update.fromNode);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'remove child',
	              payload: { fromIndex: update.fromIndex }
	            });
	          }
	          break;
	      }
	    }
	  }
	
	};
	
	module.exports = DOMChildrenOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 36 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMNamespaces = {
	  html: 'http://www.w3.org/1999/xhtml',
	  mathml: 'http://www.w3.org/1998/Math/MathML',
	  svg: 'http://www.w3.org/2000/svg'
	};
	
	module.exports = DOMNamespaces;

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var ReactErrorUtils = __webpack_require__(41);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(4);
	
	/**
	 * Injected dependencies:
	 */
	
	/**
	 * - `ComponentTree`: [required] Module that can convert between React instances
	 *   and actual node references.
	 */
	var ComponentTree;
	var TreeTraversal;
	var injection = {
	  injectComponentTree: function (Injected) {
	    ComponentTree = Injected;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
	    }
	  },
	  injectTreeTraversal: function (Injected) {
	    TreeTraversal = Injected;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.isAncestor && Injected.getLowestCommonAncestor, 'EventPluginUtils.injection.injectTreeTraversal(...): Injected ' + 'module is missing isAncestor or getLowestCommonAncestor.') : void 0;
	    }
	  }
	};
	
	function isEndish(topLevelType) {
	  return topLevelType === 'topMouseUp' || topLevelType === 'topTouchEnd' || topLevelType === 'topTouchCancel';
	}
	
	function isMoveish(topLevelType) {
	  return topLevelType === 'topMouseMove' || topLevelType === 'topTouchMove';
	}
	function isStartish(topLevelType) {
	  return topLevelType === 'topMouseDown' || topLevelType === 'topTouchStart';
	}
	
	var validateEventDispatches;
	if (process.env.NODE_ENV !== 'production') {
	  validateEventDispatches = function (event) {
	    var dispatchListeners = event._dispatchListeners;
	    var dispatchInstances = event._dispatchInstances;
	
	    var listenersIsArr = Array.isArray(dispatchListeners);
	    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
	
	    var instancesIsArr = Array.isArray(dispatchInstances);
	    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;
	
	    process.env.NODE_ENV !== 'production' ? warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : void 0;
	  };
	}
	
	/**
	 * Dispatch the event to the listener.
	 * @param {SyntheticEvent} event SyntheticEvent to handle
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @param {function} listener Application-level callback
	 * @param {*} inst Internal component instance
	 */
	function executeDispatch(event, simulated, listener, inst) {
	  var type = event.type || 'unknown-event';
	  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
	  if (simulated) {
	    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
	  } else {
	    ReactErrorUtils.invokeGuardedCallback(type, listener, event);
	  }
	  event.currentTarget = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches.
	 */
	function executeDispatchesInOrder(event, simulated) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchInstances = event._dispatchInstances;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and Instances are two parallel arrays that are always in sync.
	      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
	    }
	  } else if (dispatchListeners) {
	    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
	  }
	  event._dispatchListeners = null;
	  event._dispatchInstances = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches, but stops
	 * at the first dispatch execution returning true, and returns that id.
	 *
	 * @return {?string} id of the first dispatch execution who's listener returns
	 * true, or null if no listener returned true.
	 */
	function executeDispatchesInOrderStopAtTrueImpl(event) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchInstances = event._dispatchInstances;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and Instances are two parallel arrays that are always in sync.
	      if (dispatchListeners[i](event, dispatchInstances[i])) {
	        return dispatchInstances[i];
	      }
	    }
	  } else if (dispatchListeners) {
	    if (dispatchListeners(event, dispatchInstances)) {
	      return dispatchInstances;
	    }
	  }
	  return null;
	}
	
	/**
	 * @see executeDispatchesInOrderStopAtTrueImpl
	 */
	function executeDispatchesInOrderStopAtTrue(event) {
	  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
	  event._dispatchInstances = null;
	  event._dispatchListeners = null;
	  return ret;
	}
	
	/**
	 * Execution of a "direct" dispatch - there must be at most one dispatch
	 * accumulated on the event or it is considered an error. It doesn't really make
	 * sense for an event with multiple dispatches (bubbled) to keep track of the
	 * return values at each dispatch execution, but it does tend to make sense when
	 * dealing with "direct" dispatches.
	 *
	 * @return {*} The return value of executing the single dispatch.
	 */
	function executeDirectDispatch(event) {
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  var dispatchListener = event._dispatchListeners;
	  var dispatchInstance = event._dispatchInstances;
	  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : _prodInvariant('103') : void 0;
	  event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
	  var res = dispatchListener ? dispatchListener(event) : null;
	  event.currentTarget = null;
	  event._dispatchListeners = null;
	  event._dispatchInstances = null;
	  return res;
	}
	
	/**
	 * @param {SyntheticEvent} event
	 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
	 */
	function hasDispatches(event) {
	  return !!event._dispatchListeners;
	}
	
	/**
	 * General utilities that are useful in creating custom Event Plugins.
	 */
	var EventPluginUtils = {
	  isEndish: isEndish,
	  isMoveish: isMoveish,
	  isStartish: isStartish,
	
	  executeDirectDispatch: executeDirectDispatch,
	  executeDispatchesInOrder: executeDispatchesInOrder,
	  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
	  hasDispatches: hasDispatches,
	
	  getInstanceFromNode: function (node) {
	    return ComponentTree.getInstanceFromNode(node);
	  },
	  getNodeFromInstance: function (node) {
	    return ComponentTree.getNodeFromInstance(node);
	  },
	  isAncestor: function (a, b) {
	    return TreeTraversal.isAncestor(a, b);
	  },
	  getLowestCommonAncestor: function (a, b) {
	    return TreeTraversal.getLowestCommonAncestor(a, b);
	  },
	  getParentInstance: function (inst) {
	    return TreeTraversal.getParentInstance(inst);
	  },
	  traverseTwoPhase: function (target, fn, arg) {
	    return TreeTraversal.traverseTwoPhase(target, fn, arg);
	  },
	  traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
	    return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
	  },
	
	  injection: injection
	};
	
	module.exports = EventPluginUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 38 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	/**
	 * Escape and wrap key so it is safe to use as a reactid
	 *
	 * @param {string} key to be escaped.
	 * @return {string} the escaped key.
	 */
	
	function escape(key) {
	  var escapeRegex = /[=:]/g;
	  var escaperLookup = {
	    '=': '=0',
	    ':': '=2'
	  };
	  var escapedString = ('' + key).replace(escapeRegex, function (match) {
	    return escaperLookup[match];
	  });
	
	  return '$' + escapedString;
	}
	
	/**
	 * Unescape and unwrap key for human-readable display
	 *
	 * @param {string} key to unescape.
	 * @return {string} the unescaped key.
	 */
	function unescape(key) {
	  var unescapeRegex = /(=0|=2)/g;
	  var unescaperLookup = {
	    '=0': '=',
	    '=2': ':'
	  };
	  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);
	
	  return ('' + keySubstring).replace(unescapeRegex, function (match) {
	    return unescaperLookup[match];
	  });
	}
	
	var KeyEscapeUtils = {
	  escape: escape,
	  unescape: unescape
	};
	
	module.exports = KeyEscapeUtils;

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var React = __webpack_require__(23);
	var ReactPropTypesSecret = __webpack_require__(69);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(4);
	
	var hasReadOnlyValue = {
	  'button': true,
	  'checkbox': true,
	  'image': true,
	  'hidden': true,
	  'radio': true,
	  'reset': true,
	  'submit': true
	};
	
	function _assertSingleLink(inputProps) {
	  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don\'t want to use valueLink and vice versa.') : _prodInvariant('87') : void 0;
	}
	function _assertValueLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don\'t want to use valueLink.') : _prodInvariant('88') : void 0;
	}
	
	function _assertCheckedLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don\'t want to use checkedLink') : _prodInvariant('89') : void 0;
	}
	
	var propTypes = {
	  value: function (props, propName, componentName) {
	    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  checked: function (props, propName, componentName) {
	    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  onChange: React.PropTypes.func
	};
	
	var loggedTypeFailures = {};
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Provide a linked `value` attribute for controlled forms. You should not use
	 * this outside of the ReactDOM controlled form components.
	 */
	var LinkedValueUtils = {
	  checkPropTypes: function (tagName, props, owner) {
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error = propTypes[propName](props, propName, tagName, 'prop', null, ReactPropTypesSecret);
	      }
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var addendum = getDeclarationErrorAddendum(owner);
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : void 0;
	      }
	    }
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current value of the input either from value prop or link.
	   */
	  getValue: function (inputProps) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.value;
	    }
	    return inputProps.value;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current checked status of the input either from checked prop
	   *             or link.
	   */
	  getChecked: function (inputProps) {
	    if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.value;
	    }
	    return inputProps.checked;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @param {SyntheticEvent} event change event to handle
	   */
	  executeOnChange: function (inputProps, event) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.requestChange(event.target.value);
	    } else if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.requestChange(event.target.checked);
	    } else if (inputProps.onChange) {
	      return inputProps.onChange.call(undefined, event);
	    }
	  }
	};
	
	module.exports = LinkedValueUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var invariant = __webpack_require__(2);
	
	var injected = false;
	
	var ReactComponentEnvironment = {
	
	  /**
	   * Optionally injectable hook for swapping out mount images in the middle of
	   * the tree.
	   */
	  replaceNodeWithMarkup: null,
	
	  /**
	   * Optionally injectable hook for processing a queue of child updates. Will
	   * later move into MultiChildComponents.
	   */
	  processChildrenUpdates: null,
	
	  injection: {
	    injectEnvironment: function (environment) {
	      !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : _prodInvariant('104') : void 0;
	      ReactComponentEnvironment.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
	      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
	      injected = true;
	    }
	  }
	
	};
	
	module.exports = ReactComponentEnvironment;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var caughtError = null;
	
	/**
	 * Call a function while guarding against errors that happens within it.
	 *
	 * @param {String} name of the guard to use for logging or debugging
	 * @param {Function} func The function to invoke
	 * @param {*} a First argument
	 * @param {*} b Second argument
	 */
	function invokeGuardedCallback(name, func, a) {
	  try {
	    func(a);
	  } catch (x) {
	    if (caughtError === null) {
	      caughtError = x;
	    }
	  }
	}
	
	var ReactErrorUtils = {
	  invokeGuardedCallback: invokeGuardedCallback,
	
	  /**
	   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
	   * handler are sure to be rethrown by rethrowCaughtError.
	   */
	  invokeGuardedCallbackWithCatch: invokeGuardedCallback,
	
	  /**
	   * During execution of guarded functions we will capture the first error which
	   * we will rethrow to be handled by the top level error handler.
	   */
	  rethrowCaughtError: function () {
	    if (caughtError) {
	      var error = caughtError;
	      caughtError = null;
	      throw error;
	    }
	  }
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  /**
	   * To help development we can get better devtools integration by simulating a
	   * real browser event.
	   */
	  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
	    var fakeNode = document.createElement('react');
	    ReactErrorUtils.invokeGuardedCallback = function (name, func, a) {
	      var boundFunc = func.bind(null, a);
	      var evtType = 'react-' + name;
	      fakeNode.addEventListener(evtType, boundFunc, false);
	      var evt = document.createEvent('Event');
	      // $FlowFixMe https://github.com/facebook/flow/issues/2336
	      evt.initEvent(evtType, false, false);
	      fakeNode.dispatchEvent(evt);
	      fakeNode.removeEventListener(evtType, boundFunc, false);
	    };
	  }
	}
	
	module.exports = ReactErrorUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var ReactCurrentOwner = __webpack_require__(11);
	var ReactInstanceMap = __webpack_require__(26);
	var ReactInstrumentation = __webpack_require__(9);
	var ReactUpdates = __webpack_require__(10);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(4);
	
	function enqueueUpdate(internalInstance) {
	  ReactUpdates.enqueueUpdate(internalInstance);
	}
	
	function formatUnexpectedArgument(arg) {
	  var type = typeof arg;
	  if (type !== 'object') {
	    return type;
	  }
	  var displayName = arg.constructor && arg.constructor.name || type;
	  var keys = Object.keys(arg);
	  if (keys.length > 0 && keys.length < 20) {
	    return displayName + ' (keys: ' + keys.join(', ') + ')';
	  }
	  return displayName;
	}
	
	function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
	  var internalInstance = ReactInstanceMap.get(publicInstance);
	  if (!internalInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var ctor = publicInstance.constructor;
	      // Only warn when we have a callerName. Otherwise we should be silent.
	      // We're probably calling from enqueueCallback. We don't want to warn
	      // there because we already warned for the corresponding lifecycle method.
	      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass') : void 0;
	    }
	    return null;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + 'within `render` or another component\'s constructor). Render methods ' + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;
	  }
	
	  return internalInstance;
	}
	
	/**
	 * ReactUpdateQueue allows for state updates to be scheduled into a later
	 * reconciliation step.
	 */
	var ReactUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var owner = ReactCurrentOwner.current;
	      if (owner !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
	        owner._warnedAboutRefsInRender = true;
	      }
	    }
	    var internalInstance = ReactInstanceMap.get(publicInstance);
	    if (internalInstance) {
	      // During componentWillMount and render this will still be null but after
	      // that will always render to something. At least for now. So we can use
	      // this hack.
	      return !!internalInstance._renderedComponent;
	    } else {
	      return false;
	    }
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @param {string} callerName Name of the calling function in the public API.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback, callerName) {
	    ReactUpdateQueue.validateCallback(callback, callerName);
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
	
	    // Previously we would throw an error if we didn't have an internal
	    // instance. Since we want to make it a no-op instead, we mirror the same
	    // behavior we have in other enqueue* methods.
	    // We also need to ignore callbacks in componentWillMount. See
	    // enqueueUpdates.
	    if (!internalInstance) {
	      return null;
	    }
	
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    // TODO: The callback here is ignored when setState is called from
	    // componentWillMount. Either fix it or disallow doing so completely in
	    // favor of getInitialState. Alternatively, we can disallow
	    // componentWillMount during server-side rendering.
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueCallbackInternal: function (internalInstance, callback) {
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingForceUpdate = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingStateQueue = [completeState];
	    internalInstance._pendingReplaceState = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onSetState();
	      process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;
	    }
	
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
	    queue.push(partialState);
	
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueElementInternal: function (internalInstance, nextElement, nextContext) {
	    internalInstance._pendingElement = nextElement;
	    // TODO: introduce _pendingContext instead of setting it directly.
	    internalInstance._context = nextContext;
	    enqueueUpdate(internalInstance);
	  },
	
	  validateCallback: function (callback, callerName) {
	    !(!callback || typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant('122', callerName, formatUnexpectedArgument(callback)) : void 0;
	  }
	
	};
	
	module.exports = ReactUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 43 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/* globals MSApp */
	
	'use strict';
	
	/**
	 * Create a function which has 'unsafe' privileges (required by windows8 apps)
	 */
	
	var createMicrosoftUnsafeLocalFunction = function (func) {
	  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
	    return function (arg0, arg1, arg2, arg3) {
	      MSApp.execUnsafeLocalFunction(function () {
	        return func(arg0, arg1, arg2, arg3);
	      });
	    };
	  } else {
	    return func;
	  }
	};
	
	module.exports = createMicrosoftUnsafeLocalFunction;

/***/ },
/* 44 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * `charCode` represents the actual "character code" and is safe to use with
	 * `String.fromCharCode`. As such, only keys that correspond to printable
	 * characters produce a valid `charCode`, the only exception to this is Enter.
	 * The Tab-key is considered non-printable and does not have a `charCode`,
	 * presumably because it does not produce a tab-character in browsers.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {number} Normalized `charCode` property.
	 */
	
	function getEventCharCode(nativeEvent) {
	  var charCode;
	  var keyCode = nativeEvent.keyCode;
	
	  if ('charCode' in nativeEvent) {
	    charCode = nativeEvent.charCode;
	
	    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
	    if (charCode === 0 && keyCode === 13) {
	      charCode = 13;
	    }
	  } else {
	    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
	    charCode = keyCode;
	  }
	
	  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
	  // Must not discard the (non-)printable Enter-key.
	  if (charCode >= 32 || charCode === 13) {
	    return charCode;
	  }
	
	  return 0;
	}
	
	module.exports = getEventCharCode;

/***/ },
/* 45 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Translation from modifier key to the associated property in the event.
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
	 */
	
	var modifierKeyToProp = {
	  'Alt': 'altKey',
	  'Control': 'ctrlKey',
	  'Meta': 'metaKey',
	  'Shift': 'shiftKey'
	};
	
	// IE8 does not implement getModifierState so we simply map it to the only
	// modifier keys exposed by the event itself, does not support Lock-keys.
	// Currently, all major browsers except Chrome seems to support Lock-keys.
	function modifierStateGetter(keyArg) {
	  var syntheticEvent = this;
	  var nativeEvent = syntheticEvent.nativeEvent;
	  if (nativeEvent.getModifierState) {
	    return nativeEvent.getModifierState(keyArg);
	  }
	  var keyProp = modifierKeyToProp[keyArg];
	  return keyProp ? !!nativeEvent[keyProp] : false;
	}
	
	function getEventModifierState(nativeEvent) {
	  return modifierStateGetter;
	}
	
	module.exports = getEventModifierState;

/***/ },
/* 46 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Gets the target node from a native browser event by accounting for
	 * inconsistencies in browser DOM APIs.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {DOMEventTarget} Target node.
	 */
	
	function getEventTarget(nativeEvent) {
	  var target = nativeEvent.target || nativeEvent.srcElement || window;
	
	  // Normalize SVG <use> element events #4963
	  if (target.correspondingUseElement) {
	    target = target.correspondingUseElement;
	  }
	
	  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
	  // @see http://www.quirksmode.org/js/events_properties.html
	  return target.nodeType === 3 ? target.parentNode : target;
	}
	
	module.exports = getEventTarget;

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(7);
	
	var useHasFeature;
	if (ExecutionEnvironment.canUseDOM) {
	  useHasFeature = document.implementation && document.implementation.hasFeature &&
	  // always returns true in newer browsers as per the standard.
	  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
	  document.implementation.hasFeature('', '') !== true;
	}
	
	/**
	 * Checks if an event is supported in the current execution environment.
	 *
	 * NOTE: This will not work correctly for non-generic events such as `change`,
	 * `reset`, `load`, `error`, and `select`.
	 *
	 * Borrows from Modernizr.
	 *
	 * @param {string} eventNameSuffix Event name, e.g. "click".
	 * @param {?boolean} capture Check if the capture phase is supported.
	 * @return {boolean} True if the event is supported.
	 * @internal
	 * @license Modernizr 3.0.0pre (Custom Build) | MIT
	 */
	function isEventSupported(eventNameSuffix, capture) {
	  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
	    return false;
	  }
	
	  var eventName = 'on' + eventNameSuffix;
	  var isSupported = eventName in document;
	
	  if (!isSupported) {
	    var element = document.createElement('div');
	    element.setAttribute(eventName, 'return;');
	    isSupported = typeof element[eventName] === 'function';
	  }
	
	  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
	    // This is the only way to test support for the `wheel` event in IE9+.
	    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
	  }
	
	  return isSupported;
	}
	
	module.exports = isEventSupported;

/***/ },
/* 48 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Given a `prevElement` and `nextElement`, determines if the existing
	 * instance should be updated as opposed to being destroyed or replaced by a new
	 * instance. Both arguments are elements. This ensures that this logic can
	 * operate on stateless trees without any backing instance.
	 *
	 * @param {?object} prevElement
	 * @param {?object} nextElement
	 * @return {boolean} True if the existing instance should be updated.
	 * @protected
	 */
	
	function shouldUpdateReactComponent(prevElement, nextElement) {
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	  if (prevEmpty || nextEmpty) {
	    return prevEmpty === nextEmpty;
	  }
	
	  var prevType = typeof prevElement;
	  var nextType = typeof nextElement;
	  if (prevType === 'string' || prevType === 'number') {
	    return nextType === 'string' || nextType === 'number';
	  } else {
	    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
	  }
	}
	
	module.exports = shouldUpdateReactComponent;

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var emptyFunction = __webpack_require__(15);
	var warning = __webpack_require__(4);
	
	var validateDOMNesting = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  // This validation code was written based on the HTML5 parsing spec:
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  //
	  // Note: this does not catch all invalid nesting, nor does it try to (as it's
	  // not clear what practical benefit doing so provides); instead, we warn only
	  // for cases where the parser will give a parse tree differing from what React
	  // intended. For example, <b><div></div></b> is invalid but we don't warn
	  // because it still parses correctly; we do warn for other cases like nested
	  // <p> tags where the beginning of the second element implicitly closes the
	  // first, causing a confusing mess.
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#special
	  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
	  // TODO: Distinguish by namespace here -- for <title>, including it here
	  // errs on the side of fewer warnings
	  'foreignObject', 'desc', 'title'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
	  var buttonScopeTags = inScopeTags.concat(['button']);
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
	  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];
	
	  var emptyAncestorInfo = {
	    current: null,
	
	    formTag: null,
	    aTagInScope: null,
	    buttonTagInScope: null,
	    nobrTagInScope: null,
	    pTagInButtonScope: null,
	
	    listItemTagAutoclosing: null,
	    dlItemTagAutoclosing: null
	  };
	
	  var updatedAncestorInfo = function (oldInfo, tag, instance) {
	    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
	    var info = { tag: tag, instance: instance };
	
	    if (inScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.aTagInScope = null;
	      ancestorInfo.buttonTagInScope = null;
	      ancestorInfo.nobrTagInScope = null;
	    }
	    if (buttonScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.pTagInButtonScope = null;
	    }
	
	    // See rules for 'li', 'dd', 'dt' start tags in
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
	      ancestorInfo.listItemTagAutoclosing = null;
	      ancestorInfo.dlItemTagAutoclosing = null;
	    }
	
	    ancestorInfo.current = info;
	
	    if (tag === 'form') {
	      ancestorInfo.formTag = info;
	    }
	    if (tag === 'a') {
	      ancestorInfo.aTagInScope = info;
	    }
	    if (tag === 'button') {
	      ancestorInfo.buttonTagInScope = info;
	    }
	    if (tag === 'nobr') {
	      ancestorInfo.nobrTagInScope = info;
	    }
	    if (tag === 'p') {
	      ancestorInfo.pTagInButtonScope = info;
	    }
	    if (tag === 'li') {
	      ancestorInfo.listItemTagAutoclosing = info;
	    }
	    if (tag === 'dd' || tag === 'dt') {
	      ancestorInfo.dlItemTagAutoclosing = info;
	    }
	
	    return ancestorInfo;
	  };
	
	  /**
	   * Returns whether
	   */
	  var isTagValidWithParent = function (tag, parentTag) {
	    // First, let's check if we're in an unusual parsing mode...
	    switch (parentTag) {
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
	      case 'select':
	        return tag === 'option' || tag === 'optgroup' || tag === '#text';
	      case 'optgroup':
	        return tag === 'option' || tag === '#text';
	      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
	      // but
	      case 'option':
	        return tag === '#text';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
	      // No special behavior since these rules fall back to "in body" mode for
	      // all except special table nodes which cause bad parsing behavior anyway.
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
	      case 'tr':
	        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
	      case 'tbody':
	      case 'thead':
	      case 'tfoot':
	        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
	      case 'colgroup':
	        return tag === 'col' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
	      case 'table':
	        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
	      case 'head':
	        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
	      case 'html':
	        return tag === 'head' || tag === 'body';
	      case '#document':
	        return tag === 'html';
	    }
	
	    // Probably in the "in body" parsing mode, so we outlaw only tag combos
	    // where the parsing rules cause implicit opens or closes to be added.
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    switch (tag) {
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';
	
	      case 'rp':
	      case 'rt':
	        return impliedEndTags.indexOf(parentTag) === -1;
	
	      case 'body':
	      case 'caption':
	      case 'col':
	      case 'colgroup':
	      case 'frame':
	      case 'head':
	      case 'html':
	      case 'tbody':
	      case 'td':
	      case 'tfoot':
	      case 'th':
	      case 'thead':
	      case 'tr':
	        // These tags are only valid with a few parents that have special child
	        // parsing rules -- if we're down here, then none of those matched and
	        // so we allow it only if we don't know what the parent is, as all other
	        // cases are invalid.
	        return parentTag == null;
	    }
	
	    return true;
	  };
	
	  /**
	   * Returns whether
	   */
	  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
	    switch (tag) {
	      case 'address':
	      case 'article':
	      case 'aside':
	      case 'blockquote':
	      case 'center':
	      case 'details':
	      case 'dialog':
	      case 'dir':
	      case 'div':
	      case 'dl':
	      case 'fieldset':
	      case 'figcaption':
	      case 'figure':
	      case 'footer':
	      case 'header':
	      case 'hgroup':
	      case 'main':
	      case 'menu':
	      case 'nav':
	      case 'ol':
	      case 'p':
	      case 'section':
	      case 'summary':
	      case 'ul':
	
	      case 'pre':
	      case 'listing':
	
	      case 'table':
	
	      case 'hr':
	
	      case 'xmp':
	
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return ancestorInfo.pTagInButtonScope;
	
	      case 'form':
	        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
	
	      case 'li':
	        return ancestorInfo.listItemTagAutoclosing;
	
	      case 'dd':
	      case 'dt':
	        return ancestorInfo.dlItemTagAutoclosing;
	
	      case 'button':
	        return ancestorInfo.buttonTagInScope;
	
	      case 'a':
	        // Spec says something about storing a list of markers, but it sounds
	        // equivalent to this check.
	        return ancestorInfo.aTagInScope;
	
	      case 'nobr':
	        return ancestorInfo.nobrTagInScope;
	    }
	
	    return null;
	  };
	
	  /**
	   * Given a ReactCompositeComponent instance, return a list of its recursive
	   * owners, starting at the root and ending with the instance itself.
	   */
	  var findOwnerStack = function (instance) {
	    if (!instance) {
	      return [];
	    }
	
	    var stack = [];
	    do {
	      stack.push(instance);
	    } while (instance = instance._currentElement._owner);
	    stack.reverse();
	    return stack;
	  };
	
	  var didWarn = {};
	
	  validateDOMNesting = function (childTag, childText, childInstance, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.current;
	    var parentTag = parentInfo && parentInfo.tag;
	
	    if (childText != null) {
	      process.env.NODE_ENV !== 'production' ? warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null') : void 0;
	      childTag = '#text';
	    }
	
	    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
	    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
	    var problematic = invalidParent || invalidAncestor;
	
	    if (problematic) {
	      var ancestorTag = problematic.tag;
	      var ancestorInstance = problematic.instance;
	
	      var childOwner = childInstance && childInstance._currentElement._owner;
	      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;
	
	      var childOwners = findOwnerStack(childOwner);
	      var ancestorOwners = findOwnerStack(ancestorOwner);
	
	      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
	      var i;
	
	      var deepestCommon = -1;
	      for (i = 0; i < minStackLen; i++) {
	        if (childOwners[i] === ancestorOwners[i]) {
	          deepestCommon = i;
	        } else {
	          break;
	        }
	      }
	
	      var UNKNOWN = '(unknown)';
	      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ownerInfo = [].concat(
	      // If the parent and child instances have a common owner ancestor, start
	      // with that -- otherwise we just start with the parent's owners.
	      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
	      // If we're warning about an invalid (non-parent) ancestry, add '...'
	      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');
	
	      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
	      if (didWarn[warnKey]) {
	        return;
	      }
	      didWarn[warnKey] = true;
	
	      var tagDisplayName = childTag;
	      var whitespaceInfo = '';
	      if (childTag === '#text') {
	        if (/\S/.test(childText)) {
	          tagDisplayName = 'Text nodes';
	        } else {
	          tagDisplayName = 'Whitespace text nodes';
	          whitespaceInfo = ' Make sure you don\'t have any extra whitespace between tags on ' + 'each line of your source code.';
	        }
	      } else {
	        tagDisplayName = '<' + childTag + '>';
	      }
	
	      if (invalidParent) {
	        var info = '';
	        if (ancestorTag === 'table' && childTag === 'tr') {
	          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
	        }
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s ' + 'See %s.%s', tagDisplayName, ancestorTag, whitespaceInfo, ownerInfo, info) : void 0;
	      } else {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
	      }
	    }
	  };
	
	  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;
	
	  // For testing
	  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.current;
	    var parentTag = parentInfo && parentInfo.tag;
	    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
	  };
	}
	
	module.exports = validateDOMNesting;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 50 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 * 
	 */
	
	/*eslint-disable no-self-compare */
	
	'use strict';
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	function is(x, y) {
	  // SameValue algorithm
	  if (x === y) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    // Added the nonzero y check to make Flow happy, but it is redundant
	    return x !== 0 || y !== 0 || 1 / x === 1 / y;
	  } else {
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	  }
	}
	
	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	function shallowEqual(objA, objB) {
	  if (is(objA, objB)) {
	    return true;
	  }
	
	  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
	    return false;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	module.exports = shallowEqual;

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(19);
	
	var ReactNoopUpdateQueue = __webpack_require__(52);
	
	var canDefineProperty = __webpack_require__(54);
	var emptyObject = __webpack_require__(57);
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(12);
	
	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactComponent(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	
	ReactComponent.prototype.isReactComponent = {};
	
	/**
	 * Sets a subset of the state. Always use this to mutate
	 * state. You should treat `this.state` as immutable.
	 *
	 * There is no guarantee that `this.state` will be immediately updated, so
	 * accessing `this.state` after calling this method may return the old value.
	 *
	 * There is no guarantee that calls to `setState` will run synchronously,
	 * as they may eventually be batched together.  You can provide an optional
	 * callback that will be executed when the call to setState is actually
	 * completed.
	 *
	 * When a function is provided to setState, it will be called at some point in
	 * the future (not synchronously). It will be called with the up to date
	 * component arguments (state, props, context). These values can be different
	 * from this.* because your function may be called after receiveProps but before
	 * shouldComponentUpdate, and this new state, props, and context will not yet be
	 * assigned to this.
	 *
	 * @param {object|function} partialState Next partial state or function to
	 *        produce next partial state to be merged with current state.
	 * @param {?function} callback Called after state is updated.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.setState = function (partialState, callback) {
	  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
	  this.updater.enqueueSetState(this, partialState);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback, 'setState');
	  }
	};
	
	/**
	 * Forces an update. This should only be invoked when it is known with
	 * certainty that we are **not** in a DOM transaction.
	 *
	 * You may want to call this when you know that some deeper aspect of the
	 * component's state has changed but `setState` was not called.
	 *
	 * This will not invoke `shouldComponentUpdate`, but it will invoke
	 * `componentWillUpdate` and `componentDidUpdate`.
	 *
	 * @param {?function} callback Called after update is complete.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.forceUpdate = function (callback) {
	  this.updater.enqueueForceUpdate(this);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback, 'forceUpdate');
	  }
	};
	
	/**
	 * Deprecated APIs. These APIs used to exist on classic React classes but since
	 * we would like to deprecate them, we're not going to move them over to this
	 * modern base class. Instead, we define a getter that warns if it's accessed.
	 */
	if (process.env.NODE_ENV !== 'production') {
	  var deprecatedAPIs = {
	    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
	    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
	  };
	  var defineDeprecationWarning = function (methodName, info) {
	    if (canDefineProperty) {
	      Object.defineProperty(ReactComponent.prototype, methodName, {
	        get: function () {
	          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : void 0;
	          return undefined;
	        }
	      });
	    }
	  };
	  for (var fnName in deprecatedAPIs) {
	    if (deprecatedAPIs.hasOwnProperty(fnName)) {
	      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
	    }
	  }
	}
	
	module.exports = ReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var warning = __webpack_require__(12);
	
	function warnNoop(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    var constructor = publicInstance.constructor;
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
	  }
	}
	
	/**
	 * This is the abstract API for an update queue.
	 */
	var ReactNoopUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    return false;
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback) {},
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    warnNoop(publicInstance, 'forceUpdate');
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState) {
	    warnNoop(publicInstance, 'replaceState');
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    warnNoop(publicInstance, 'setState');
	  }
	};
	
	module.exports = ReactNoopUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var ReactPropTypeLocationNames = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}
	
	module.exports = ReactPropTypeLocationNames;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var canDefineProperty = false;
	if (process.env.NODE_ENV !== 'production') {
	  try {
	    // $FlowFixMe https://github.com/facebook/flow/issues/285
	    Object.defineProperty({}, 'x', { get: function () {} });
	    canDefineProperty = true;
	  } catch (x) {
	    // IE will fail on defineProperty
	  }
	}
	
	module.exports = canDefineProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 55 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	/* global Symbol */
	
	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
	
	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}
	
	module.exports = getIteratorFn;

/***/ },
/* 56 */
15,
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyObject = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  Object.freeze(emptyObject);
	}
	
	module.exports = emptyObject;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 58 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * CSS properties which accept numbers but are not in units of "px".
	 */
	
	var isUnitlessNumber = {
	  animationIterationCount: true,
	  borderImageOutset: true,
	  borderImageSlice: true,
	  borderImageWidth: true,
	  boxFlex: true,
	  boxFlexGroup: true,
	  boxOrdinalGroup: true,
	  columnCount: true,
	  flex: true,
	  flexGrow: true,
	  flexPositive: true,
	  flexShrink: true,
	  flexNegative: true,
	  flexOrder: true,
	  gridRow: true,
	  gridColumn: true,
	  fontWeight: true,
	  lineClamp: true,
	  lineHeight: true,
	  opacity: true,
	  order: true,
	  orphans: true,
	  tabSize: true,
	  widows: true,
	  zIndex: true,
	  zoom: true,
	
	  // SVG-related properties
	  fillOpacity: true,
	  floodOpacity: true,
	  stopOpacity: true,
	  strokeDasharray: true,
	  strokeDashoffset: true,
	  strokeMiterlimit: true,
	  strokeOpacity: true,
	  strokeWidth: true
	};
	
	/**
	 * @param {string} prefix vendor-specific prefix, eg: Webkit
	 * @param {string} key style name, eg: transitionDuration
	 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
	 * WebkitTransitionDuration
	 */
	function prefixKey(prefix, key) {
	  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
	}
	
	/**
	 * Support style names that may come passed in prefixed by adding permutations
	 * of vendor prefixes.
	 */
	var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
	
	// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
	// infinite loop, because it iterates over the newly added props too.
	Object.keys(isUnitlessNumber).forEach(function (prop) {
	  prefixes.forEach(function (prefix) {
	    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
	  });
	});
	
	/**
	 * Most style properties can be unset by doing .style[prop] = '' but IE8
	 * doesn't like doing that with shorthand properties so for the properties that
	 * IE8 breaks on, which are listed here, we instead unset each of the
	 * individual properties. See http://bugs.jquery.com/ticket/12385.
	 * The 4-value 'clock' properties like margin, padding, border-width seem to
	 * behave without any problems. Curiously, list-style works too without any
	 * special prodding.
	 */
	var shorthandPropertyExpansions = {
	  background: {
	    backgroundAttachment: true,
	    backgroundColor: true,
	    backgroundImage: true,
	    backgroundPositionX: true,
	    backgroundPositionY: true,
	    backgroundRepeat: true
	  },
	  backgroundPosition: {
	    backgroundPositionX: true,
	    backgroundPositionY: true
	  },
	  border: {
	    borderWidth: true,
	    borderStyle: true,
	    borderColor: true
	  },
	  borderBottom: {
	    borderBottomWidth: true,
	    borderBottomStyle: true,
	    borderBottomColor: true
	  },
	  borderLeft: {
	    borderLeftWidth: true,
	    borderLeftStyle: true,
	    borderLeftColor: true
	  },
	  borderRight: {
	    borderRightWidth: true,
	    borderRightStyle: true,
	    borderRightColor: true
	  },
	  borderTop: {
	    borderTopWidth: true,
	    borderTopStyle: true,
	    borderTopColor: true
	  },
	  font: {
	    fontStyle: true,
	    fontVariant: true,
	    fontWeight: true,
	    fontSize: true,
	    lineHeight: true,
	    fontFamily: true
	  },
	  outline: {
	    outlineWidth: true,
	    outlineStyle: true,
	    outlineColor: true
	  }
	};
	
	var CSSProperty = {
	  isUnitlessNumber: isUnitlessNumber,
	  shorthandPropertyExpansions: shorthandPropertyExpansions
	};
	
	module.exports = CSSProperty;

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var PooledClass = __webpack_require__(17);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * A specialized pseudo-event module to help keep track of components waiting to
	 * be notified when their DOM representations are available for use.
	 *
	 * This implements `PooledClass`, so you should never need to instantiate this.
	 * Instead, use `CallbackQueue.getPooled()`.
	 *
	 * @class ReactMountReady
	 * @implements PooledClass
	 * @internal
	 */
	
	var CallbackQueue = function () {
	  function CallbackQueue(arg) {
	    _classCallCheck(this, CallbackQueue);
	
	    this._callbacks = null;
	    this._contexts = null;
	    this._arg = arg;
	  }
	
	  /**
	   * Enqueues a callback to be invoked when `notifyAll` is invoked.
	   *
	   * @param {function} callback Invoked when `notifyAll` is invoked.
	   * @param {?object} context Context to call `callback` with.
	   * @internal
	   */
	
	
	  CallbackQueue.prototype.enqueue = function enqueue(callback, context) {
	    this._callbacks = this._callbacks || [];
	    this._callbacks.push(callback);
	    this._contexts = this._contexts || [];
	    this._contexts.push(context);
	  };
	
	  /**
	   * Invokes all enqueued callbacks and clears the queue. This is invoked after
	   * the DOM representation of a component has been created or updated.
	   *
	   * @internal
	   */
	
	
	  CallbackQueue.prototype.notifyAll = function notifyAll() {
	    var callbacks = this._callbacks;
	    var contexts = this._contexts;
	    var arg = this._arg;
	    if (callbacks && contexts) {
	      !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : _prodInvariant('24') : void 0;
	      this._callbacks = null;
	      this._contexts = null;
	      for (var i = 0; i < callbacks.length; i++) {
	        callbacks[i].call(contexts[i], arg);
	      }
	      callbacks.length = 0;
	      contexts.length = 0;
	    }
	  };
	
	  CallbackQueue.prototype.checkpoint = function checkpoint() {
	    return this._callbacks ? this._callbacks.length : 0;
	  };
	
	  CallbackQueue.prototype.rollback = function rollback(len) {
	    if (this._callbacks && this._contexts) {
	      this._callbacks.length = len;
	      this._contexts.length = len;
	    }
	  };
	
	  /**
	   * Resets the internal queue.
	   *
	   * @internal
	   */
	
	
	  CallbackQueue.prototype.reset = function reset() {
	    this._callbacks = null;
	    this._contexts = null;
	  };
	
	  /**
	   * `PooledClass` looks for this.
	   */
	
	
	  CallbackQueue.prototype.destructor = function destructor() {
	    this.reset();
	  };
	
	  return CallbackQueue;
	}();
	
	module.exports = PooledClass.addPoolingTo(CallbackQueue);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(16);
	var ReactDOMComponentTree = __webpack_require__(5);
	var ReactInstrumentation = __webpack_require__(9);
	
	var quoteAttributeValueForBrowser = __webpack_require__(168);
	var warning = __webpack_require__(4);
	
	var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
	var illegalAttributeNameCache = {};
	var validatedAttributeNameCache = {};
	
	function isAttributeNameSafe(attributeName) {
	  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
	    return true;
	  }
	  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
	    return false;
	  }
	  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
	    validatedAttributeNameCache[attributeName] = true;
	    return true;
	  }
	  illegalAttributeNameCache[attributeName] = true;
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : void 0;
	  return false;
	}
	
	function shouldIgnoreValue(propertyInfo, value) {
	  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
	}
	
	/**
	 * Operations for dealing with DOM properties.
	 */
	var DOMPropertyOperations = {
	
	  /**
	   * Creates markup for the ID property.
	   *
	   * @param {string} id Unescaped ID.
	   * @return {string} Markup string.
	   */
	  createMarkupForID: function (id) {
	    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
	  },
	
	  setAttributeForID: function (node, id) {
	    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
	  },
	
	  createMarkupForRoot: function () {
	    return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
	  },
	
	  setAttributeForRoot: function (node) {
	    node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
	  },
	
	  /**
	   * Creates markup for a property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {?string} Markup string, or null if the property was invalid.
	   */
	  createMarkupForProperty: function (name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      if (shouldIgnoreValue(propertyInfo, value)) {
	        return '';
	      }
	      var attributeName = propertyInfo.attributeName;
	      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	        return attributeName + '=""';
	      }
	      return attributeName + '=' + quoteAttributeValueForBrowser(value);
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      if (value == null) {
	        return '';
	      }
	      return name + '=' + quoteAttributeValueForBrowser(value);
	    }
	    return null;
	  },
	
	  /**
	   * Creates markup for a custom property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {string} Markup string, or empty string if the property was invalid.
	   */
	  createMarkupForCustomAttribute: function (name, value) {
	    if (!isAttributeNameSafe(name) || value == null) {
	      return '';
	    }
	    return name + '=' + quoteAttributeValueForBrowser(value);
	  },
	
	  /**
	   * Sets the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   * @param {*} value
	   */
	  setValueForProperty: function (node, name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, value);
	      } else if (shouldIgnoreValue(propertyInfo, value)) {
	        this.deleteValueForProperty(node, name);
	        return;
	      } else if (propertyInfo.mustUseProperty) {
	        // Contrary to `setAttribute`, object properties are properly
	        // `toString`ed by IE8/9.
	        node[propertyInfo.propertyName] = value;
	      } else {
	        var attributeName = propertyInfo.attributeName;
	        var namespace = propertyInfo.attributeNamespace;
	        // `setAttribute` with objects becomes only `[object]` in IE8/9,
	        // ('' + value) makes it output the correct toString()-value.
	        if (namespace) {
	          node.setAttributeNS(namespace, attributeName, '' + value);
	        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	          node.setAttribute(attributeName, '');
	        } else {
	          node.setAttribute(attributeName, '' + value);
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      DOMPropertyOperations.setValueForAttribute(node, name, value);
	      return;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var payload = {};
	      payload[name] = value;
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'update attribute',
	        payload: payload
	      });
	    }
	  },
	
	  setValueForAttribute: function (node, name, value) {
	    if (!isAttributeNameSafe(name)) {
	      return;
	    }
	    if (value == null) {
	      node.removeAttribute(name);
	    } else {
	      node.setAttribute(name, '' + value);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var payload = {};
	      payload[name] = value;
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'update attribute',
	        payload: payload
	      });
	    }
	  },
	
	  /**
	   * Deletes an attributes from a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForAttribute: function (node, name) {
	    node.removeAttribute(name);
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'remove attribute',
	        payload: name
	      });
	    }
	  },
	
	  /**
	   * Deletes the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForProperty: function (node, name) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, undefined);
	      } else if (propertyInfo.mustUseProperty) {
	        var propName = propertyInfo.propertyName;
	        if (propertyInfo.hasBooleanValue) {
	          node[propName] = false;
	        } else {
	          node[propName] = '';
	        }
	      } else {
	        node.removeAttribute(propertyInfo.attributeName);
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      node.removeAttribute(name);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'remove attribute',
	        payload: name
	      });
	    }
	  }
	
	};
	
	module.exports = DOMPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 61 */
/***/ function(module, exports) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactDOMComponentFlags = {
	  hasCachedChildNodes: 1 << 0
	};
	
	module.exports = ReactDOMComponentFlags;

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var LinkedValueUtils = __webpack_require__(39);
	var ReactDOMComponentTree = __webpack_require__(5);
	var ReactUpdates = __webpack_require__(10);
	
	var warning = __webpack_require__(4);
	
	var didWarnValueLink = false;
	var didWarnValueDefaultValue = false;
	
	function updateOptionsIfPendingUpdateAndMounted() {
	  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
	    this._wrapperState.pendingUpdate = false;
	
	    var props = this._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);
	
	    if (value != null) {
	      updateOptions(this, Boolean(props.multiple), value);
	    }
	  }
	}
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	var valuePropNames = ['value', 'defaultValue'];
	
	/**
	 * Validation function for `value` and `defaultValue`.
	 * @private
	 */
	function checkSelectPropTypes(inst, props) {
	  var owner = inst._currentElement._owner;
	  LinkedValueUtils.checkPropTypes('select', props, owner);
	
	  if (props.valueLink !== undefined && !didWarnValueLink) {
	    process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead.') : void 0;
	    didWarnValueLink = true;
	  }
	
	  for (var i = 0; i < valuePropNames.length; i++) {
	    var propName = valuePropNames[i];
	    if (props[propName] == null) {
	      continue;
	    }
	    var isArray = Array.isArray(props[propName]);
	    if (props.multiple && !isArray) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
	    } else if (!props.multiple && isArray) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
	    }
	  }
	}
	
	/**
	 * @param {ReactDOMComponent} inst
	 * @param {boolean} multiple
	 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
	 * @private
	 */
	function updateOptions(inst, multiple, propValue) {
	  var selectedValue, i;
	  var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;
	
	  if (multiple) {
	    selectedValue = {};
	    for (i = 0; i < propValue.length; i++) {
	      selectedValue['' + propValue[i]] = true;
	    }
	    for (i = 0; i < options.length; i++) {
	      var selected = selectedValue.hasOwnProperty(options[i].value);
	      if (options[i].selected !== selected) {
	        options[i].selected = selected;
	      }
	    }
	  } else {
	    // Do not set `select.value` as exact behavior isn't consistent across all
	    // browsers for all cases.
	    selectedValue = '' + propValue;
	    for (i = 0; i < options.length; i++) {
	      if (options[i].value === selectedValue) {
	        options[i].selected = true;
	        return;
	      }
	    }
	    if (options.length) {
	      options[0].selected = true;
	    }
	  }
	}
	
	/**
	 * Implements a <select> host component that allows optionally setting the
	 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
	 * stringable. If `multiple` is true, the prop must be an array of stringables.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that change the
	 * selected option will trigger updates to the rendered options.
	 *
	 * If it is supplied (and not null/undefined), the rendered options will not
	 * update in response to user actions. Instead, the `value` prop must change in
	 * order for the rendered options to update.
	 *
	 * If `defaultValue` is provided, any options with the supplied values will be
	 * selected.
	 */
	var ReactDOMSelect = {
	  getHostProps: function (inst, props) {
	    return _assign({}, props, {
	      onChange: inst._wrapperState.onChange,
	      value: undefined
	    });
	  },
	
	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      checkSelectPropTypes(inst, props);
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    inst._wrapperState = {
	      pendingUpdate: false,
	      initialValue: value != null ? value : props.defaultValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst),
	      wasMultiple: Boolean(props.multiple)
	    };
	
	    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
	      didWarnValueDefaultValue = true;
	    }
	  },
	
	  getSelectValueContext: function (inst) {
	    // ReactDOMOption looks at this initial value so the initial generated
	    // markup has correct `selected` attributes
	    return inst._wrapperState.initialValue;
	  },
	
	  postUpdateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    // After the initial mount, we control selected-ness manually so don't pass
	    // this value down
	    inst._wrapperState.initialValue = undefined;
	
	    var wasMultiple = inst._wrapperState.wasMultiple;
	    inst._wrapperState.wasMultiple = Boolean(props.multiple);
	
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      inst._wrapperState.pendingUpdate = false;
	      updateOptions(inst, Boolean(props.multiple), value);
	    } else if (wasMultiple !== Boolean(props.multiple)) {
	      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
	      if (props.defaultValue != null) {
	        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
	      } else {
	        // Revert the select back to its default unselected state.
	        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
	      }
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  if (this._rootNodeID) {
	    this._wrapperState.pendingUpdate = true;
	  }
	  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMSelect;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 63 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyComponentFactory;
	
	var ReactEmptyComponentInjection = {
	  injectEmptyComponentFactory: function (factory) {
	    emptyComponentFactory = factory;
	  }
	};
	
	var ReactEmptyComponent = {
	  create: function (instantiate) {
	    return emptyComponentFactory(instantiate);
	  }
	};
	
	ReactEmptyComponent.injection = ReactEmptyComponentInjection;
	
	module.exports = ReactEmptyComponent;

/***/ },
/* 64 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var ReactFeatureFlags = {
	  // When true, call console.time() before and .timeEnd() after each top-level
	  // render (both initial renders and updates). Useful when looking at prod-mode
	  // timeline profiles in Chrome, for example.
	  logTopLevelRenders: false
	};
	
	module.exports = ReactFeatureFlags;

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3),
	    _assign = __webpack_require__(6);
	
	var invariant = __webpack_require__(2);
	
	var genericComponentClass = null;
	// This registry keeps track of wrapper classes around host tags.
	var tagToComponentClass = {};
	var textComponentClass = null;
	
	var ReactHostComponentInjection = {
	  // This accepts a class that receives the tag string. This is a catch all
	  // that can render any kind of tag.
	  injectGenericComponentClass: function (componentClass) {
	    genericComponentClass = componentClass;
	  },
	  // This accepts a text component class that takes the text string to be
	  // rendered as props.
	  injectTextComponentClass: function (componentClass) {
	    textComponentClass = componentClass;
	  },
	  // This accepts a keyed object with classes as values. Each key represents a
	  // tag. That particular tag will use this class instead of the generic one.
	  injectComponentClasses: function (componentClasses) {
	    _assign(tagToComponentClass, componentClasses);
	  }
	};
	
	/**
	 * Get a host internal component class for a specific tag.
	 *
	 * @param {ReactElement} element The element to create.
	 * @return {function} The internal class constructor function.
	 */
	function createInternalComponent(element) {
	  !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : _prodInvariant('111', element.type) : void 0;
	  return new genericComponentClass(element);
	}
	
	/**
	 * @param {ReactText} text
	 * @return {ReactComponent}
	 */
	function createInstanceForText(text) {
	  return new textComponentClass(text);
	}
	
	/**
	 * @param {ReactComponent} component
	 * @return {boolean}
	 */
	function isTextComponent(component) {
	  return component instanceof textComponentClass;
	}
	
	var ReactHostComponent = {
	  createInternalComponent: createInternalComponent,
	  createInstanceForText: createInstanceForText,
	  isTextComponent: isTextComponent,
	  injection: ReactHostComponentInjection
	};
	
	module.exports = ReactHostComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactDOMSelection = __webpack_require__(122);
	
	var containsNode = __webpack_require__(172);
	var focusNode = __webpack_require__(81);
	var getActiveElement = __webpack_require__(82);
	
	function isInDocument(node) {
	  return containsNode(document.documentElement, node);
	}
	
	/**
	 * @ReactInputSelection: React input selection module. Based on Selection.js,
	 * but modified to be suitable for react and has a couple of bug fixes (doesn't
	 * assume buttons have range selections allowed).
	 * Input selection module for React.
	 */
	var ReactInputSelection = {
	
	  hasSelectionCapabilities: function (elem) {
	    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
	  },
	
	  getSelectionInformation: function () {
	    var focusedElem = getActiveElement();
	    return {
	      focusedElem: focusedElem,
	      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
	    };
	  },
	
	  /**
	   * @restoreSelection: If any selection information was potentially lost,
	   * restore it. This is useful when performing operations that could remove dom
	   * nodes and place them back in, resulting in focus being lost.
	   */
	  restoreSelection: function (priorSelectionInformation) {
	    var curFocusedElem = getActiveElement();
	    var priorFocusedElem = priorSelectionInformation.focusedElem;
	    var priorSelectionRange = priorSelectionInformation.selectionRange;
	    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
	      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
	        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
	      }
	      focusNode(priorFocusedElem);
	    }
	  },
	
	  /**
	   * @getSelection: Gets the selection bounds of a focused textarea, input or
	   * contentEditable node.
	   * -@input: Look up selection bounds of this input
	   * -@return {start: selectionStart, end: selectionEnd}
	   */
	  getSelection: function (input) {
	    var selection;
	
	    if ('selectionStart' in input) {
	      // Modern browser with input or textarea.
	      selection = {
	        start: input.selectionStart,
	        end: input.selectionEnd
	      };
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      // IE8 input.
	      var range = document.selection.createRange();
	      // There can only be one selection per document in IE, so it must
	      // be in our element.
	      if (range.parentElement() === input) {
	        selection = {
	          start: -range.moveStart('character', -input.value.length),
	          end: -range.moveEnd('character', -input.value.length)
	        };
	      }
	    } else {
	      // Content editable or old IE textarea.
	      selection = ReactDOMSelection.getOffsets(input);
	    }
	
	    return selection || { start: 0, end: 0 };
	  },
	
	  /**
	   * @setSelection: Sets the selection bounds of a textarea or input and focuses
	   * the input.
	   * -@input     Set selection bounds of this input or textarea
	   * -@offsets   Object of same form that is returned from get*
	   */
	  setSelection: function (input, offsets) {
	    var start = offsets.start;
	    var end = offsets.end;
	    if (end === undefined) {
	      end = start;
	    }
	
	    if ('selectionStart' in input) {
	      input.selectionStart = start;
	      input.selectionEnd = Math.min(end, input.value.length);
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      var range = input.createTextRange();
	      range.collapse(true);
	      range.moveStart('character', start);
	      range.moveEnd('character', end - start);
	      range.select();
	    } else {
	      ReactDOMSelection.setOffsets(input, offsets);
	    }
	  }
	};
	
	module.exports = ReactInputSelection;

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var DOMLazyTree = __webpack_require__(21);
	var DOMProperty = __webpack_require__(16);
	var React = __webpack_require__(23);
	var ReactBrowserEventEmitter = __webpack_require__(29);
	var ReactCurrentOwner = __webpack_require__(11);
	var ReactDOMComponentTree = __webpack_require__(5);
	var ReactDOMContainerInfo = __webpack_require__(114);
	var ReactDOMFeatureFlags = __webpack_require__(116);
	var ReactFeatureFlags = __webpack_require__(64);
	var ReactInstanceMap = __webpack_require__(26);
	var ReactInstrumentation = __webpack_require__(9);
	var ReactMarkupChecksum = __webpack_require__(136);
	var ReactReconciler = __webpack_require__(22);
	var ReactUpdateQueue = __webpack_require__(42);
	var ReactUpdates = __webpack_require__(10);
	
	var emptyObject = __webpack_require__(80);
	var instantiateReactComponent = __webpack_require__(75);
	var invariant = __webpack_require__(2);
	var setInnerHTML = __webpack_require__(33);
	var shouldUpdateReactComponent = __webpack_require__(48);
	var warning = __webpack_require__(4);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;
	
	var ELEMENT_NODE_TYPE = 1;
	var DOC_NODE_TYPE = 9;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	var instancesByReactRootID = {};
	
	/**
	 * Finds the index of the first character
	 * that's not common between the two given strings.
	 *
	 * @return {number} the index of the character where the strings diverge
	 */
	function firstDifferenceIndex(string1, string2) {
	  var minLen = Math.min(string1.length, string2.length);
	  for (var i = 0; i < minLen; i++) {
	    if (string1.charAt(i) !== string2.charAt(i)) {
	      return i;
	    }
	  }
	  return string1.length === string2.length ? -1 : minLen;
	}
	
	/**
	 * @param {DOMElement|DOMDocument} container DOM element that may contain
	 * a React component
	 * @return {?*} DOM element that may have the reactRoot ID, or null.
	 */
	function getReactRootElementInContainer(container) {
	  if (!container) {
	    return null;
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    return container.documentElement;
	  } else {
	    return container.firstChild;
	  }
	}
	
	function internalGetID(node) {
	  // If node is something like a window, document, or text node, none of
	  // which support attributes or a .getAttribute method, gracefully return
	  // the empty string, as if the attribute were missing.
	  return node.getAttribute && node.getAttribute(ATTR_NAME) || '';
	}
	
	/**
	 * Mounts this component and inserts it into the DOM.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {ReactReconcileTransaction} transaction
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
	  var markerName;
	  if (ReactFeatureFlags.logTopLevelRenders) {
	    var wrappedElement = wrapperInstance._currentElement.props.child;
	    var type = wrappedElement.type;
	    markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
	    console.time(markerName);
	  }
	
	  var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0 /* parentDebugID */
	  );
	
	  if (markerName) {
	    console.timeEnd(markerName);
	  }
	
	  wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
	  ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
	}
	
	/**
	 * Batched mount.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
	  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* useCreateElement */
	  !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
	  transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
	  ReactUpdates.ReactReconcileTransaction.release(transaction);
	}
	
	/**
	 * Unmounts a component and removes it from the DOM.
	 *
	 * @param {ReactComponent} instance React component instance.
	 * @param {DOMElement} container DOM element to unmount from.
	 * @final
	 * @internal
	 * @see {ReactMount.unmountComponentAtNode}
	 */
	function unmountComponentFromNode(instance, container, safely) {
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onBeginFlush();
	  }
	  ReactReconciler.unmountComponent(instance, safely);
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onEndFlush();
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    container = container.documentElement;
	  }
	
	  // http://jsperf.com/emptying-a-node
	  while (container.lastChild) {
	    container.removeChild(container.lastChild);
	  }
	}
	
	/**
	 * True if the supplied DOM node has a direct React-rendered child that is
	 * not a React root element. Useful for warning in `render`,
	 * `unmountComponentAtNode`, etc.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM element contains a direct child that was
	 * rendered by React but is not a root element.
	 * @internal
	 */
	function hasNonRootReactChild(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  if (rootEl) {
	    var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
	    return !!(inst && inst._hostParent);
	  }
	}
	
	/**
	 * True if the supplied DOM node is a React DOM element and
	 * it has been rendered by another copy of React.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM has been rendered by another copy of React
	 * @internal
	 */
	function nodeIsRenderedByOtherInstance(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree.getInstanceFromNode(rootEl));
	}
	
	/**
	 * True if the supplied DOM node is a valid node element.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM is a valid DOM node.
	 * @internal
	 */
	function isValidContainer(node) {
	  return !!(node && (node.nodeType === ELEMENT_NODE_TYPE || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE));
	}
	
	/**
	 * True if the supplied DOM node is a valid React node element.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM is a valid React DOM node.
	 * @internal
	 */
	function isReactNode(node) {
	  return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME));
	}
	
	function getHostRootInstanceInContainer(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
	  return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;
	}
	
	function getTopLevelWrapperInContainer(container) {
	  var root = getHostRootInstanceInContainer(container);
	  return root ? root._hostContainerInfo._topLevelWrapper : null;
	}
	
	/**
	 * Temporary (?) hack so that we can store all top-level pending updates on
	 * composites instead of having to worry about different types of components
	 * here.
	 */
	var topLevelRootCounter = 1;
	var TopLevelWrapper = function () {
	  this.rootID = topLevelRootCounter++;
	};
	TopLevelWrapper.prototype.isReactComponent = {};
	if (process.env.NODE_ENV !== 'production') {
	  TopLevelWrapper.displayName = 'TopLevelWrapper';
	}
	TopLevelWrapper.prototype.render = function () {
	  return this.props.child;
	};
	TopLevelWrapper.isReactTopLevelWrapper = true;
	
	/**
	 * Mounting is the process of initializing a React component by creating its
	 * representative DOM elements and inserting them into a supplied `container`.
	 * Any prior content inside `container` is destroyed in the process.
	 *
	 *   ReactMount.render(
	 *     component,
	 *     document.getElementById('container')
	 *   );
	 *
	 *   <div id="container">                   <-- Supplied `container`.
	 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
	 *       // ...                                 component.
	 *     </div>
	 *   </div>
	 *
	 * Inside of `container`, the first element rendered is the "reactRoot".
	 */
	var ReactMount = {
	
	  TopLevelWrapper: TopLevelWrapper,
	
	  /**
	   * Used by devtools. The keys are not important.
	   */
	  _instancesByReactRootID: instancesByReactRootID,
	
	  /**
	   * This is a hook provided to support rendering React components while
	   * ensuring that the apparent scroll position of its `container` does not
	   * change.
	   *
	   * @param {DOMElement} container The `container` being rendered into.
	   * @param {function} renderCallback This must be called once to do the render.
	   */
	  scrollMonitor: function (container, renderCallback) {
	    renderCallback();
	  },
	
	  /**
	   * Take a component that's already mounted into the DOM and replace its props
	   * @param {ReactComponent} prevComponent component instance already in the DOM
	   * @param {ReactElement} nextElement component instance to render
	   * @param {DOMElement} container container to render into
	   * @param {?function} callback function triggered on completion
	   */
	  _updateRootComponent: function (prevComponent, nextElement, nextContext, container, callback) {
	    ReactMount.scrollMonitor(container, function () {
	      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
	      if (callback) {
	        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
	      }
	    });
	
	    return prevComponent;
	  },
	
	  /**
	   * Render a new component into the DOM. Hooked by hooks!
	   *
	   * @param {ReactElement} nextElement element to render
	   * @param {DOMElement} container container to render into
	   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
	   * @return {ReactComponent} nextComponent
	   */
	  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case.
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
	
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : _prodInvariant('37') : void 0;
	
	    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
	    var componentInstance = instantiateReactComponent(nextElement, false);
	
	    // The initial render is synchronous but any updates that happen during
	    // rendering, in componentWillMount or componentDidMount, will be batched
	    // according to the current batching strategy.
	
	    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);
	
	    var wrapperID = componentInstance._instance.rootID;
	    instancesByReactRootID[wrapperID] = componentInstance;
	
	    return componentInstance;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
	    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
	  },
	
	  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
	    !React.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' :
	    // Check if it quacks like an element
	    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;
	
	    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;
	
	    var nextWrappedElement = React.createElement(TopLevelWrapper, { child: nextElement });
	
	    var nextContext;
	    if (parentComponent) {
	      var parentInst = ReactInstanceMap.get(parentComponent);
	      nextContext = parentInst._processChildContext(parentInst._context);
	    } else {
	      nextContext = emptyObject;
	    }
	
	    var prevComponent = getTopLevelWrapperInContainer(container);
	
	    if (prevComponent) {
	      var prevWrappedElement = prevComponent._currentElement;
	      var prevElement = prevWrappedElement.props.child;
	      if (shouldUpdateReactComponent(prevElement, nextElement)) {
	        var publicInst = prevComponent._renderedComponent.getPublicInstance();
	        var updatedCallback = callback && function () {
	          callback.call(publicInst);
	        };
	        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
	        return publicInst;
	      } else {
	        ReactMount.unmountComponentAtNode(container);
	      }
	    }
	
	    var reactRootElement = getReactRootElementInContainer(container);
	    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
	    var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;
	
	      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
	        var rootElementSibling = reactRootElement;
	        while (rootElementSibling) {
	          if (internalGetID(rootElementSibling)) {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;
	            break;
	          }
	          rootElementSibling = rootElementSibling.nextSibling;
	        }
	      }
	    }
	
	    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
	    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();
	    if (callback) {
	      callback.call(component);
	    }
	    return component;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.render
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  render: function (nextElement, container, callback) {
	    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
	  },
	
	  /**
	   * Unmounts and destroys the React component rendered in the `container`.
	   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.unmountcomponentatnode
	   *
	   * @param {DOMElement} container DOM element containing a React component.
	   * @return {boolean} True if a component was found in and unmounted from
	   *                   `container`
	   */
	  unmountComponentAtNode: function (container) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case. (Strictly speaking, unmounting won't cause a
	    // render but we still don't expect to be in a render call here.)
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
	
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : _prodInvariant('40') : void 0;
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!nodeIsRenderedByOtherInstance(container), 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by another copy of React.') : void 0;
	    }
	
	    var prevComponent = getTopLevelWrapperInContainer(container);
	    if (!prevComponent) {
	      // Check if the node being unmounted was rendered by React, but isn't a
	      // root node.
	      var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	      // Check if the container itself is a React root node.
	      var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
	      }
	
	      return false;
	    }
	    delete instancesByReactRootID[prevComponent._instance.rootID];
	    ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
	    return true;
	  },
	
	  _mountImageIntoNode: function (markup, container, instance, shouldReuseMarkup, transaction) {
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : _prodInvariant('41') : void 0;
	
	    if (shouldReuseMarkup) {
	      var rootElement = getReactRootElementInContainer(container);
	      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
	        ReactDOMComponentTree.precacheNode(instance, rootElement);
	        return;
	      } else {
	        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	
	        var rootMarkup = rootElement.outerHTML;
	        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);
	
	        var normalizedMarkup = markup;
	        if (process.env.NODE_ENV !== 'production') {
	          // because rootMarkup is retrieved from the DOM, various normalizations
	          // will have occurred which will not be present in `markup`. Here,
	          // insert markup into a <div> or <iframe> depending on the container
	          // type to perform the same normalizations before comparing.
	          var normalizer;
	          if (container.nodeType === ELEMENT_NODE_TYPE) {
	            normalizer = document.createElement('div');
	            normalizer.innerHTML = markup;
	            normalizedMarkup = normalizer.innerHTML;
	          } else {
	            normalizer = document.createElement('iframe');
	            document.body.appendChild(normalizer);
	            normalizer.contentDocument.write(markup);
	            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
	            document.body.removeChild(normalizer);
	          }
	        }
	
	        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
	        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
	
	        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s', difference) : _prodInvariant('42', difference) : void 0;
	
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : void 0;
	        }
	      }
	    }
	
	    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but you didn\'t use server rendering. We can\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43') : void 0;
	
	    if (transaction.useCreateElement) {
	      while (container.lastChild) {
	        container.removeChild(container.lastChild);
	      }
	      DOMLazyTree.insertTreeBefore(container, markup, null);
	    } else {
	      setInnerHTML(container, markup);
	      ReactDOMComponentTree.precacheNode(instance, container.firstChild);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
	      if (hostNode._debugID !== 0) {
	        ReactInstrumentation.debugTool.onHostOperation({
	          instanceID: hostNode._debugID,
	          type: 'mount',
	          payload: markup.toString()
	        });
	      }
	    }
	  }
	};
	
	module.exports = ReactMount;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var React = __webpack_require__(23);
	
	var invariant = __webpack_require__(2);
	
	var ReactNodeTypes = {
	  HOST: 0,
	  COMPOSITE: 1,
	  EMPTY: 2,
	
	  getType: function (node) {
	    if (node === null || node === false) {
	      return ReactNodeTypes.EMPTY;
	    } else if (React.isValidElement(node)) {
	      if (typeof node.type === 'function') {
	        return ReactNodeTypes.COMPOSITE;
	      } else {
	        return ReactNodeTypes.HOST;
	      }
	    }
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unexpected node: %s', node) : _prodInvariant('26', node) : void 0;
	  }
	};
	
	module.exports = ReactNodeTypes;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 69 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
	
	module.exports = ReactPropTypesSecret;

/***/ },
/* 70 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ViewportMetrics = {
	
	  currentScrollLeft: 0,
	
	  currentScrollTop: 0,
	
	  refreshScrollValues: function (scrollPosition) {
	    ViewportMetrics.currentScrollLeft = scrollPosition.x;
	    ViewportMetrics.currentScrollTop = scrollPosition.y;
	  }
	
	};
	
	module.exports = ViewportMetrics;

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Accumulates items that must not be null or undefined into the first one. This
	 * is used to conserve memory by avoiding array allocations, and thus sacrifices
	 * API cleanness. Since `current` can be null before being passed in and not
	 * null after this function, make sure to assign it back to `current`:
	 *
	 * `a = accumulateInto(a, b);`
	 *
	 * This API should be sparingly used. Try `accumulate` for something cleaner.
	 *
	 * @return {*|array<*>} An accumulation of items.
	 */
	
	function accumulateInto(current, next) {
	  !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : _prodInvariant('30') : void 0;
	
	  if (current == null) {
	    return next;
	  }
	
	  // Both are not empty. Warning: Never call x.concat(y) when you are not
	  // certain that x is an Array (x could be a string with concat method).
	  if (Array.isArray(current)) {
	    if (Array.isArray(next)) {
	      current.push.apply(current, next);
	      return current;
	    }
	    current.push(next);
	    return current;
	  }
	
	  if (Array.isArray(next)) {
	    // A bit too dangerous to mutate `next`.
	    return [current].concat(next);
	  }
	
	  return [current, next];
	}
	
	module.exports = accumulateInto;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 72 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	/**
	 * @param {array} arr an "accumulation" of items which is either an Array or
	 * a single item. Useful when paired with the `accumulate` module. This is a
	 * simple utility that allows us to reason about a collection of items, but
	 * handling the case when there is exactly one item (and we do not need to
	 * allocate an array).
	 */
	
	function forEachAccumulated(arr, cb, scope) {
	  if (Array.isArray(arr)) {
	    arr.forEach(cb, scope);
	  } else if (arr) {
	    cb.call(scope, arr);
	  }
	}
	
	module.exports = forEachAccumulated;

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactNodeTypes = __webpack_require__(68);
	
	function getHostComponentFromComposite(inst) {
	  var type;
	
	  while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
	    inst = inst._renderedComponent;
	  }
	
	  if (type === ReactNodeTypes.HOST) {
	    return inst._renderedComponent;
	  } else if (type === ReactNodeTypes.EMPTY) {
	    return null;
	  }
	}
	
	module.exports = getHostComponentFromComposite;

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(7);
	
	var contentKey = null;
	
	/**
	 * Gets the key used to access text content on a DOM node.
	 *
	 * @return {?string} Key used to access text content.
	 * @internal
	 */
	function getTextContentAccessor() {
	  if (!contentKey && ExecutionEnvironment.canUseDOM) {
	    // Prefer textContent to innerText because many browsers support both but
	    // SVG <text> elements don't support innerText even when <div> does.
	    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
	  }
	  return contentKey;
	}
	
	module.exports = getTextContentAccessor;

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3),
	    _assign = __webpack_require__(6);
	
	var ReactCompositeComponent = __webpack_require__(111);
	var ReactEmptyComponent = __webpack_require__(63);
	var ReactHostComponent = __webpack_require__(65);
	
	var getNextDebugID = __webpack_require__(165);
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(4);
	
	// To avoid a cyclic dependency, we create the final class in this module
	var ReactCompositeComponentWrapper = function (element) {
	  this.construct(element);
	};
	_assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent, {
	  _instantiateReactComponent: instantiateReactComponent
	});
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Check if the type reference is a known internal type. I.e. not a user
	 * provided composite type.
	 *
	 * @param {function} type
	 * @return {boolean} Returns true if this is a valid internal type.
	 */
	function isInternalComponentType(type) {
	  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
	}
	
	/**
	 * Given a ReactNode, create an instance that will actually be mounted.
	 *
	 * @param {ReactNode} node
	 * @param {boolean} shouldHaveDebugID
	 * @return {object} A new instance of the element's constructor.
	 * @protected
	 */
	function instantiateReactComponent(node, shouldHaveDebugID) {
	  var instance;
	
	  if (node === null || node === false) {
	    instance = ReactEmptyComponent.create(instantiateReactComponent);
	  } else if (typeof node === 'object') {
	    var element = node;
	    !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : _prodInvariant('130', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : void 0;
	
	    // Special case string values
	    if (typeof element.type === 'string') {
	      instance = ReactHostComponent.createInternalComponent(element);
	    } else if (isInternalComponentType(element.type)) {
	      // This is temporarily available for custom components that are not string
	      // representations. I.e. ART. Once those are updated to use the string
	      // representation, we can drop this code path.
	      instance = new element.type(element);
	
	      // We renamed this. Allow the old name for compat. :(
	      if (!instance.getHostNode) {
	        instance.getHostNode = instance.getNativeNode;
	      }
	    } else {
	      instance = new ReactCompositeComponentWrapper(element);
	    }
	  } else if (typeof node === 'string' || typeof node === 'number') {
	    instance = ReactHostComponent.createInstanceForText(node);
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : _prodInvariant('131', typeof node) : void 0;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getHostNode === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : void 0;
	  }
	
	  // These two fields are used by the DOM and ART diffing algorithms
	  // respectively. Instead of using expandos on components, we should be
	  // storing the state needed by the diffing algorithms elsewhere.
	  instance._mountIndex = 0;
	  instance._mountImage = null;
	
	  if (process.env.NODE_ENV !== 'production') {
	    instance._debugID = shouldHaveDebugID ? getNextDebugID() : 0;
	  }
	
	  // Internal instances should fully constructed at this point, so they should
	  // not get any new fields added to them at this point.
	  if (process.env.NODE_ENV !== 'production') {
	    if (Object.preventExtensions) {
	      Object.preventExtensions(instance);
	    }
	  }
	
	  return instance;
	}
	
	module.exports = instantiateReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 76 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	/**
	 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
	 */
	
	var supportedInputTypes = {
	  'color': true,
	  'date': true,
	  'datetime': true,
	  'datetime-local': true,
	  'email': true,
	  'month': true,
	  'number': true,
	  'password': true,
	  'range': true,
	  'search': true,
	  'tel': true,
	  'text': true,
	  'time': true,
	  'url': true,
	  'week': true
	};
	
	function isTextInputElement(elem) {
	  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	
	  if (nodeName === 'input') {
	    return !!supportedInputTypes[elem.type];
	  }
	
	  if (nodeName === 'textarea') {
	    return true;
	  }
	
	  return false;
	}
	
	module.exports = isTextInputElement;

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(7);
	var escapeTextContentForBrowser = __webpack_require__(32);
	var setInnerHTML = __webpack_require__(33);
	
	/**
	 * Set the textContent property of a node, ensuring that whitespace is preserved
	 * even in IE8. innerText is a poor substitute for textContent and, among many
	 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
	 * as it should.
	 *
	 * @param {DOMElement} node
	 * @param {string} text
	 * @internal
	 */
	var setTextContent = function (node, text) {
	  if (text) {
	    var firstChild = node.firstChild;
	
	    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
	      firstChild.nodeValue = text;
	      return;
	    }
	  }
	  node.textContent = text;
	};
	
	if (ExecutionEnvironment.canUseDOM) {
	  if (!('textContent' in document.documentElement)) {
	    setTextContent = function (node, text) {
	      if (node.nodeType === 3) {
	        node.nodeValue = text;
	        return;
	      }
	      setInnerHTML(node, escapeTextContentForBrowser(text));
	    };
	  }
	}
	
	module.exports = setTextContent;

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var ReactCurrentOwner = __webpack_require__(11);
	var REACT_ELEMENT_TYPE = __webpack_require__(130);
	
	var getIteratorFn = __webpack_require__(164);
	var invariant = __webpack_require__(2);
	var KeyEscapeUtils = __webpack_require__(38);
	var warning = __webpack_require__(4);
	
	var SEPARATOR = '.';
	var SUBSEPARATOR = ':';
	
	/**
	 * This is inlined from ReactElement since this file is shared between
	 * isomorphic and renderers. We could extract this to a
	 *
	 */
	
	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */
	
	var didWarnAboutMaps = false;
	
	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  // Do some typechecking here since we call this blindly. We want to ensure
	  // that we don't block potential future ES APIs.
	  if (component && typeof component === 'object' && component.key != null) {
	    // Explicit key
	    return KeyEscapeUtils.escape(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}
	
	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children;
	
	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }
	
	  if (children === null || type === 'string' || type === 'number' ||
	  // The following is inlined from ReactElement. This means we can optimize
	  // some checks. React Fiber also inlines this logic for similar purposes.
	  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }
	
	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
	
	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          var mapsAsChildrenAddendum = '';
	          if (ReactCurrentOwner.current) {
	            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
	            if (mapsAsChildrenOwnerName) {
	              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
	            }
	          }
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (process.env.NODE_ENV !== 'production') {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
	    }
	  }
	
	  return subtreeCount;
	}
	
	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }
	
	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}
	
	module.exports = traverseAllChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * @typechecks
	 */
	
	var emptyFunction = __webpack_require__(15);
	
	/**
	 * Upstream version of event listener. Does not take into account specific
	 * nature of platform.
	 */
	var EventListener = {
	  /**
	   * Listen to DOM events during the bubble phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  listen: function listen(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, false);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, false);
	        }
	      };
	    } else if (target.attachEvent) {
	      target.attachEvent('on' + eventType, callback);
	      return {
	        remove: function remove() {
	          target.detachEvent('on' + eventType, callback);
	        }
	      };
	    }
	  },
	
	  /**
	   * Listen to DOM events during the capture phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  capture: function capture(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, true);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, true);
	        }
	      };
	    } else {
	      if (process.env.NODE_ENV !== 'production') {
	        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
	      }
	      return {
	        remove: emptyFunction
	      };
	    }
	  },
	
	  registerDefault: function registerDefault() {}
	};
	
	module.exports = EventListener;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 80 */
57,
/* 81 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * @param {DOMElement} node input/textarea to focus
	 */
	
	function focusNode(node) {
	  // IE8 can throw "Can't move focus to the control because it is invisible,
	  // not enabled, or of a type that does not accept the focus." for all kinds of
	  // reasons that are too expensive and fragile to test.
	  try {
	    node.focus();
	  } catch (e) {}
	}
	
	module.exports = focusNode;

/***/ },
/* 82 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/* eslint-disable fb-www/typeof-undefined */
	
	/**
	 * Same as document.activeElement but wraps in a try-catch block. In IE it is
	 * not safe to call document.activeElement if there is nothing focused.
	 *
	 * The activeElement will be null only if the document or document body is not
	 * yet defined.
	 */
	function getActiveElement() /*?DOMElement*/{
	  if (typeof document === 'undefined') {
	    return null;
	  }
	  try {
	    return document.activeElement || document.body;
	  } catch (e) {
	    return document.body;
	  }
	}
	
	module.exports = getActiveElement;

/***/ },
/* 83 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	
	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;
	
	module.exports = REACT_ELEMENT_TYPE;

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/**
	 * ReactElementValidator provides a wrapper around a element factory
	 * which validates the props passed to the element. This is intended to be
	 * used only in DEV and could be replaced by a static type checker for languages
	 * that support it.
	 */
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(11);
	var ReactComponentTreeHook = __webpack_require__(8);
	var ReactElement = __webpack_require__(18);
	
	var checkReactTypeSpec = __webpack_require__(192);
	
	var canDefineProperty = __webpack_require__(54);
	var getIteratorFn = __webpack_require__(55);
	var warning = __webpack_require__(12);
	
	function getDeclarationErrorAddendum() {
	  if (ReactCurrentOwner.current) {
	    var name = ReactCurrentOwner.current.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Warn if there's no key explicitly set on dynamic arrays of children or
	 * object keys are not valid. This allows us to keep track of children between
	 * updates.
	 */
	var ownerHasKeyUseWarning = {};
	
	function getCurrentComponentErrorInfo(parentType) {
	  var info = getDeclarationErrorAddendum();
	
	  if (!info) {
	    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
	    if (parentName) {
	      info = ' Check the top-level render call using <' + parentName + '>.';
	    }
	  }
	  return info;
	}
	
	/**
	 * Warn if the element doesn't have an explicit key assigned to it.
	 * This element is in an array. The array could grow and shrink or be
	 * reordered. All children that haven't already been validated are required to
	 * have a "key" property assigned to it. Error statuses are cached so a warning
	 * will only be shown once.
	 *
	 * @internal
	 * @param {ReactElement} element Element that requires a key.
	 * @param {*} parentType element's parent's type.
	 */
	function validateExplicitKey(element, parentType) {
	  if (!element._store || element._store.validated || element.key != null) {
	    return;
	  }
	  element._store.validated = true;
	
	  var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});
	
	  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
	  if (memoizer[currentComponentErrorInfo]) {
	    return;
	  }
	  memoizer[currentComponentErrorInfo] = true;
	
	  // Usually the current owner is the offender, but if it accepts children as a
	  // property, it may be the creator of the child that's responsible for
	  // assigning it a key.
	  var childOwner = '';
	  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
	    // Give the component that originally created this child.
	    childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
	  }
	
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
	}
	
	/**
	 * Ensure that every element either is passed in a static location, in an
	 * array with an explicit keys property defined, or in an object literal
	 * with valid key property.
	 *
	 * @internal
	 * @param {ReactNode} node Statically passed child of any type.
	 * @param {*} parentType node's parent's type.
	 */
	function validateChildKeys(node, parentType) {
	  if (typeof node !== 'object') {
	    return;
	  }
	  if (Array.isArray(node)) {
	    for (var i = 0; i < node.length; i++) {
	      var child = node[i];
	      if (ReactElement.isValidElement(child)) {
	        validateExplicitKey(child, parentType);
	      }
	    }
	  } else if (ReactElement.isValidElement(node)) {
	    // This element was passed in a valid location.
	    if (node._store) {
	      node._store.validated = true;
	    }
	  } else if (node) {
	    var iteratorFn = getIteratorFn(node);
	    // Entry iterators provide implicit keys.
	    if (iteratorFn) {
	      if (iteratorFn !== node.entries) {
	        var iterator = iteratorFn.call(node);
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (ReactElement.isValidElement(step.value)) {
	            validateExplicitKey(step.value, parentType);
	          }
	        }
	      }
	    }
	  }
	}
	
	/**
	 * Given an element, validate that its props follow the propTypes definition,
	 * provided by the type.
	 *
	 * @param {ReactElement} element
	 */
	function validatePropTypes(element) {
	  var componentClass = element.type;
	  if (typeof componentClass !== 'function') {
	    return;
	  }
	  var name = componentClass.displayName || componentClass.name;
	  if (componentClass.propTypes) {
	    checkReactTypeSpec(componentClass.propTypes, element.props, 'prop', name, element, null);
	  }
	  if (typeof componentClass.getDefaultProps === 'function') {
	    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
	  }
	}
	
	var ReactElementValidator = {
	
	  createElement: function (type, props, children) {
	    var validType = typeof type === 'string' || typeof type === 'function';
	    // We warn in this case but don't throw. We expect the element creation to
	    // succeed and there will likely be errors in render.
	    if (!validType) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : void 0;
	    }
	
	    var element = ReactElement.createElement.apply(this, arguments);
	
	    // The result can be nullish if a mock or a custom function is used.
	    // TODO: Drop this when these are no longer allowed as the type argument.
	    if (element == null) {
	      return element;
	    }
	
	    // Skip key warning if the type isn't valid since our key validation logic
	    // doesn't expect a non-string/function type and can throw confusing errors.
	    // We don't want exception behavior to differ between dev and prod.
	    // (Rendering will throw with a helpful message and as soon as the type is
	    // fixed, the key warnings will appear.)
	    if (validType) {
	      for (var i = 2; i < arguments.length; i++) {
	        validateChildKeys(arguments[i], type);
	      }
	    }
	
	    validatePropTypes(element);
	
	    return element;
	  },
	
	  createFactory: function (type) {
	    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
	    // Legacy hook TODO: Warn if this is accessed
	    validatedFactory.type = type;
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (canDefineProperty) {
	        Object.defineProperty(validatedFactory, 'type', {
	          enumerable: false,
	          get: function () {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : void 0;
	            Object.defineProperty(this, 'type', {
	              value: type
	            });
	            return type;
	          }
	        });
	      }
	    }
	
	    return validatedFactory;
	  },
	
	  cloneElement: function (element, props, children) {
	    var newElement = ReactElement.cloneElement.apply(this, arguments);
	    for (var i = 2; i < arguments.length; i++) {
	      validateChildKeys(arguments[i], newElement.type);
	    }
	    validatePropTypes(newElement);
	    return newElement;
	  }
	
	};
	
	module.exports = ReactElementValidator;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 85 */
69,
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(13);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _nav = __webpack_require__(92);
	
	var _nav2 = _interopRequireDefault(_nav);
	
	var _home = __webpack_require__(95);
	
	var _home2 = _interopRequireDefault(_home);
	
	var _about = __webpack_require__(93);
	
	var _about2 = _interopRequireDefault(_about);
	
	var _fruits = __webpack_require__(94);
	
	var _fruits2 = _interopRequireDefault(_fruits);
	
	var _register = __webpack_require__(96);
	
	var _register2 = _interopRequireDefault(_register);
	
	var _team = __webpack_require__(97);
	
	var _team2 = _interopRequireDefault(_team);
	
	var _pagePics = __webpack_require__(90);
	
	var _pagePics2 = _interopRequireDefault(_pagePics);
	
	var _fruits3 = __webpack_require__(89);
	
	var _fruits4 = _interopRequireDefault(_fruits3);
	
	var _team3 = __webpack_require__(91);
	
	var _team4 = _interopRequireDefault(_team3);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var App = function (_React$Component) {
	  _inherits(App, _React$Component);
	
	  function App(props) {
	    _classCallCheck(this, App);
	
	    var _this = _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).call(this, props));
	
	    _this.state = {
	      fruits: _this.props.fruits,
	      teamMems: _this.props.teamMems,
	      bkImg: _this.props.bkImg
	    };
	    return _this;
	  }
	
	  _createClass(App, [{
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement(
	        'div',
	        null,
	        _react2.default.createElement(_nav2.default, null),
	        _react2.default.createElement(_home2.default, { bkImg: this.state.bkImg }),
	        _react2.default.createElement(_about2.default, { bkImg: this.state.bkImg }),
	        _react2.default.createElement(_fruits2.default, { fruits: this.state.fruits }),
	        _react2.default.createElement(_register2.default, null),
	        _react2.default.createElement(_team2.default, { teamMems: this.state.teamMems })
	      );
	    }
	  }]);
	
	  return App;
	}(_react2.default.Component);
	
	exports.default = App;
	
	App.propTypes = {
	  fruits: _react2.default.PropTypes.array.isRequired,
	  teamMems: _react2.default.PropTypes.array.isRequired,
	  bkImg: _react2.default.PropTypes.array.isRequired
	};
	App.defaultProps = {
	  fruits: (0, _fruits4.default)(),
	  teamMems: (0, _team4.default)(),
	  bkImg: (0, _pagePics2.default)()
	};

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(13);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var FruitItems = function (_React$Component) {
	  _inherits(FruitItems, _React$Component);
	
	  function FruitItems() {
	    _classCallCheck(this, FruitItems);
	
	    return _possibleConstructorReturn(this, (FruitItems.__proto__ || Object.getPrototypeOf(FruitItems)).apply(this, arguments));
	  }
	
	  _createClass(FruitItems, [{
	    key: "render",
	    value: function render() {
	      var _props = this.props,
	          id = _props.id,
	          cname = _props.cname,
	          lname = _props.lname,
	          price = _props.price,
	          img = _props.img,
	          size = _props.size,
	          link = _props.link;
	
	      var myStyle1 = {
	        border: "1px double black",
	        borderRadius: 15,
	        marginLeft: 0,
	        marginRight: 0,
	        marginBottom: 2
	      };
	      var myStyle2 = {
	        color: "green"
	      };
	      return _react2.default.createElement(
	        "div",
	        { className: "col-lg-3 col-md-4 col-sm-6 text-center", style: myStyle1 },
	        _react2.default.createElement(
	          "h4",
	          null,
	          cname
	        ),
	        _react2.default.createElement(
	          "h5",
	          null,
	          _react2.default.createElement(
	            "em",
	            null,
	            lname
	          )
	        ),
	        _react2.default.createElement(
	          "h5",
	          null,
	          "Price:\xA0\xA0$",
	          price
	        ),
	        _react2.default.createElement(
	          "label",
	          { style: myStyle2 },
	          size,
	          _react2.default.createElement(
	            "a",
	            { href: link },
	            _react2.default.createElement("img", { src: img, height: "150px", className: "thumbnail center-block" })
	          )
	        )
	      );
	    }
	  }]);
	
	  return FruitItems;
	}(_react2.default.Component);
	
	exports.default = FruitItems;
	
	FruitItems.propTypes = {
	  id: _react2.default.PropTypes.number,
	  cname: _react2.default.PropTypes.string,
	  lname: _react2.default.PropTypes.string,
	  price: _react2.default.PropTypes.number,
	  img: _react2.default.PropTypes.node,
	  size: _react2.default.PropTypes.string,
	  link: _react2.default.PropTypes.node
	};
	FruitItems.defaultProps = {
	  id: 0,
	  cname: '',
	  lname: '',
	  price: 0,
	  img: '',
	  size: '',
	  link: ''
	};

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(13);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var TeamMems = function (_React$Component) {
	  _inherits(TeamMems, _React$Component);
	
	  function TeamMems() {
	    _classCallCheck(this, TeamMems);
	
	    return _possibleConstructorReturn(this, (TeamMems.__proto__ || Object.getPrototypeOf(TeamMems)).apply(this, arguments));
	  }
	
	  _createClass(TeamMems, [{
	    key: "render",
	    value: function render() {
	      var _props = this.props,
	          id = _props.id,
	          fname = _props.fname,
	          lname = _props.lname,
	          title = _props.title,
	          linkedin = _props.linkedin,
	          photo = _props.photo,
	          size = _props.size;
	
	      var myStyle1 = {
	        marginLeft: 0,
	        marginRight: 0,
	        marginBottom: 2
	      };
	      var myStyle2 = {
	        color: "magenta"
	      };
	      return _react2.default.createElement(
	        "div",
	        { className: "col-lg-3 col-md-6 col-sm-6 text-center", style: myStyle1 },
	        _react2.default.createElement("br", null),
	        _react2.default.createElement(
	          "label",
	          { style: myStyle2 },
	          size,
	          _react2.default.createElement(
	            "a",
	            { href: linkedin },
	            _react2.default.createElement("img", { src: photo, height: "200px", className: "thumbnail center-block" })
	          )
	        ),
	        _react2.default.createElement(
	          "h4",
	          null,
	          fname,
	          " ",
	          lname
	        ),
	        _react2.default.createElement(
	          "h5",
	          null,
	          _react2.default.createElement(
	            "em",
	            null,
	            title
	          )
	        ),
	        _react2.default.createElement("br", null)
	      );
	    }
	  }]);
	
	  return TeamMems;
	}(_react2.default.Component);
	
	exports.default = TeamMems;
	
	TeamMems.propTypes = {
	  id: _react2.default.PropTypes.number,
	  fname: _react2.default.PropTypes.string,
	  lname: _react2.default.PropTypes.string,
	  title: _react2.default.PropTypes.string,
	  linkedin: _react2.default.PropTypes.node,
	  photo: _react2.default.PropTypes.node,
	  size: _react2.default.PropTypes.string
	};
	TeamMems.defaultProps = {
	  id: 0,
	  fname: '',
	  lname: '',
	  title: '',
	  linkedin: '',
	  photo: '',
	  size: ''
	};

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  return [{
	    id: 1,
	    cname: "Apple",
	    lname: "Pyrus malus",
	    price: 5.31,
	    isChecked: false,
	    img: _apple2.default,
	    size: "8 Kbyte",
	    link: "https://en.wikipedia.org/wiki/Apple"
	  }, {
	    id: 2,
	    cname: "Banana",
	    lname: "Musa paradisicum",
	    price: 4.39,
	    isChecked: false,
	    img: _banana2.default,
	    size: "6 Kbyte",
	    link: "https://en.wikipedia.org/wiki/Banana"
	  }, {
	    id: 3,
	    cname: "Grapes",
	    lname: "Vitis vinifera",
	    price: 4.78,
	    isChecked: false,
	    img: _grapes2.default,
	    size: "5 Kbyte",
	    link: "https://en.wikipedia.org/wiki/Grape"
	  }, {
	    id: 4,
	    cname: "Lychee",
	    lname: "Litchi chinensis",
	    price: 6.12,
	    isChecked: false,
	    img: _lychee2.default,
	    size: "7 Kbyte",
	    link: "https://en.wikipedia.org/wiki/Lychee"
	  }, {
	    id: 5,
	    cname: "Mango",
	    lname: "Mangifera indica",
	    price: 6.32,
	    isChecked: false,
	    img: _mango2.default,
	    size: "7 Kbyte",
	    link: "https://en.wikipedia.org/wiki/Mango"
	  }, {
	    id: 6,
	    cname: "Orange",
	    lname: "Citrus aurantium",
	    price: 4.56,
	    isChecked: false,
	    img: _orange2.default,
	    size: "10 Kbyte",
	    link: "https://en.wikipedia.org/wiki/Orange_(fruit)"
	  }, {
	    id: 7,
	    cname: "Peach",
	    lname: "Prunus persica",
	    price: 4.97,
	    isChecked: false,
	    img: _peach2.default,
	    size: "7 Kbyte",
	    link: "https://en.wikipedia.org/wiki/Peach"
	  }, {
	    id: 8,
	    cname: "Pineapple",
	    lname: "Ananus sativus",
	    price: 4.97,
	    isChecked: false,
	    img: _pineapple2.default,
	    size: "8 Kbyte",
	    link: "https://en.wikipedia.org/wiki/Pineapple"
	  }, {
	    id: 9,
	    cname: "Pomegranate",
	    lname: "Punica granatum",
	    price: 3.97,
	    isChecked: false,
	    img: _pomegranate2.default,
	    size: "12 Kbyte",
	    link: "https://en.wikipedia.org/wiki/Pomegranate"
	  }, {
	    id: 10,
	    cname: "Raspberry",
	    lname: "Rubus idaeobatus",
	    price: 5.13,
	    isChecked: false,
	    img: _raspberry2.default,
	    size: "7 Kbyte",
	    link: "https://en.wikipedia.org/wiki/Raspberry"
	  }, {
	    id: 11,
	    cname: "Strawberry",
	    lname: "Fragaria ananassa",
	    price: 5.27,
	    isChecked: false,
	    img: _strawberry2.default,
	    size: "13 Kbyte",
	    link: "https://en.wikipedia.org/wiki/Strawberry"
	  }, {
	    id: 12,
	    cname: "Tomato",
	    lname: "Solanum lycopersicum",
	    price: 4.39,
	    isChecked: false,
	    img: _tomato2.default,
	    size: "7 Kbyte",
	    link: "https://en.wikipedia.org/wiki/Tomato"
	  }];
	};
	
	var _apple = __webpack_require__(195);
	
	var _apple2 = _interopRequireDefault(_apple);
	
	var _banana = __webpack_require__(196);
	
	var _banana2 = _interopRequireDefault(_banana);
	
	var _grapes = __webpack_require__(197);
	
	var _grapes2 = _interopRequireDefault(_grapes);
	
	var _lychee = __webpack_require__(198);
	
	var _lychee2 = _interopRequireDefault(_lychee);
	
	var _mango = __webpack_require__(199);
	
	var _mango2 = _interopRequireDefault(_mango);
	
	var _orange = __webpack_require__(200);
	
	var _orange2 = _interopRequireDefault(_orange);
	
	var _raspberry = __webpack_require__(204);
	
	var _raspberry2 = _interopRequireDefault(_raspberry);
	
	var _peach = __webpack_require__(201);
	
	var _peach2 = _interopRequireDefault(_peach);
	
	var _pineapple = __webpack_require__(202);
	
	var _pineapple2 = _interopRequireDefault(_pineapple);
	
	var _pomegranate = __webpack_require__(203);
	
	var _pomegranate2 = _interopRequireDefault(_pomegranate);
	
	var _tomato = __webpack_require__(206);
	
	var _tomato2 = _interopRequireDefault(_tomato);
	
	var _strawberry = __webpack_require__(205);
	
	var _strawberry2 = _interopRequireDefault(_strawberry);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	;

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  return [{
	    homeImg: _home2.default,
	    size: "272 Kbyte"
	  }, {
	    aboutImg: _about2.default,
	    size: "102 Kbyte"
	  }];
	};
	
	var _home = __webpack_require__(208);
	
	var _home2 = _interopRequireDefault(_home);
	
	var _about = __webpack_require__(207);
	
	var _about2 = _interopRequireDefault(_about);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	;

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  return [{
	    id: 1,
	    fname: "Rod",
	    lname: "Kay",
	    title: "Project Manager",
	    linkedin: "https://www.linkedin.com/in/rodk88",
	    photo: _somewhere2.default,
	    size: "10 Kbyte"
	  }, {
	    id: 2,
	    fname: "Rod",
	    lname: "Kay",
	    title: "Web Developer",
	    linkedin: "https://www.linkedin.com/in/rodk88",
	    photo: _somewhere2.default,
	    size: "10 Kbyte"
	  }, {
	    id: 3,
	    fname: "Rod",
	    lname: "Kay",
	    title: "Business Developer",
	    linkedin: "https://www.linkedin.com/in/rodk88",
	    photo: _somewhere2.default,
	    size: "10 Kbyte"
	  }, {
	    id: 4,
	    fname: "Rod",
	    lname: "Kay",
	    title: "Hardware Circuit Engineer",
	    linkedin: "https://www.linkedin.com/in/rodk88",
	    photo: _somewhere2.default,
	    size: "10 Kbyte"
	  }, {
	    id: 5,
	    fname: "Rod",
	    lname: "Kay",
	    title: "Assistant #1",
	    linkedin: "https://www.linkedin.com/in/rodk88",
	    photo: _somewhere2.default,
	    size: "10 Kbyte"
	  }, {
	    id: 6,
	    fname: "Rod",
	    lname: "Kay",
	    title: "Assistant #2",
	    linkedin: "https://www.linkedin.com/in/rodk88",
	    photo: _somewhere2.default,
	    size: "10 Kbyte"
	  }, {
	    id: 7,
	    fname: "Rod",
	    lname: "Kay",
	    title: "Assistant #3",
	    linkedin: "https://www.linkedin.com/in/rodk88",
	    photo: _somewhere2.default,
	    size: "10 Kbyte"
	  }, {
	    id: 8,
	    fname: "Rod",
	    lname: "Kay",
	    title: "Assistant #4",
	    linkedin: "https://www.linkedin.com/in/rodk88",
	    photo: _somewhere2.default,
	    size: "10 Kbyte"
	  }];
	};
	
	var _somewhere = __webpack_require__(209);
	
	var _somewhere2 = _interopRequireDefault(_somewhere);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	;

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(13);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var myStyle1 = {
	  color: "#fff"
	};
	var myStyle2 = {
	  marginRight: "15px"
	};
	
	var Nav = function (_React$Component) {
	  _inherits(Nav, _React$Component);
	
	  function Nav() {
	    _classCallCheck(this, Nav);
	
	    return _possibleConstructorReturn(this, (Nav.__proto__ || Object.getPrototypeOf(Nav)).apply(this, arguments));
	  }
	
	  _createClass(Nav, [{
	    key: "render",
	    value: function render() {
	      return _react2.default.createElement(
	        "nav",
	        { className: "navbar navbar-inverse navbar-fixed-top" },
	        _react2.default.createElement(
	          "div",
	          { className: "container-fluid" },
	          _react2.default.createElement(
	            "div",
	            { className: "navbar-header" },
	            _react2.default.createElement(
	              "button",
	              { type: "button", className: "navbar-toggle", "data-toggle": "collapse", "data-target": "#myNavbar" },
	              _react2.default.createElement(
	                "span",
	                { className: "", style: myStyle1 },
	                "MENU"
	              )
	            )
	          )
	        ),
	        _react2.default.createElement(
	          "div",
	          { className: "collapse navbar-collapse", id: "myNavbar" },
	          _react2.default.createElement(
	            "ul",
	            { className: "nav navbar-nav" },
	            _react2.default.createElement(
	              "li",
	              null,
	              _react2.default.createElement(
	                "a",
	                { href: "#home" },
	                "Home"
	              )
	            ),
	            _react2.default.createElement(
	              "li",
	              null,
	              _react2.default.createElement(
	                "a",
	                { href: "#about" },
	                "About"
	              )
	            ),
	            _react2.default.createElement(
	              "li",
	              null,
	              _react2.default.createElement(
	                "a",
	                { href: "#fruits" },
	                "Fruits"
	              )
	            ),
	            _react2.default.createElement(
	              "li",
	              null,
	              _react2.default.createElement(
	                "a",
	                { href: "#team" },
	                "Team"
	              )
	            )
	          ),
	          _react2.default.createElement(
	            "ul",
	            { className: "nav navbar-nav navbar-right", style: myStyle2 },
	            _react2.default.createElement(
	              "li",
	              null,
	              _react2.default.createElement(
	                "a",
	                { href: "#register" },
	                _react2.default.createElement("span", { className: "glyphicon glyphicon-user" }),
	                "\xA0Sign Up"
	              )
	            )
	          )
	        )
	      );
	    }
	  }]);
	
	  return Nav;
	}(_react2.default.Component);
	
	exports.default = Nav;

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(13);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var About = function (_React$Component) {
	  _inherits(About, _React$Component);
	
	  function About() {
	    _classCallCheck(this, About);
	
	    return _possibleConstructorReturn(this, (About.__proto__ || Object.getPrototypeOf(About)).apply(this, arguments));
	  }
	
	  _createClass(About, [{
	    key: "render",
	    value: function render() {
	      var myStyle1 = {
	        fontFamily: "Dosis",
	        paddingTop: "50px",
	        paddingBottom: "20px",
	        height: "100%",
	        color: "#000",
	        backgroundColor: "#cc0044"
	      };
	      var myStyle2 = {
	        marginRight: "20px",
	        marginBottom: "10px",
	        marginLeft: "15px"
	      };
	      var myStyle3 = {
	        color: "orange",
	        marginLeft: "-6px"
	      };
	      return _react2.default.createElement(
	        "div",
	        { id: "about", className: "container-fluid text-center", style: myStyle1 },
	        _react2.default.createElement(
	          "h3",
	          null,
	          '<',
	          _react2.default.createElement(
	            "em",
	            null,
	            " demo "
	          ),
	          '>',
	          "\xA0"
	        ),
	        _react2.default.createElement(
	          "h1",
	          null,
	          "`Pro-Seed` is a convenient place to buy your fruit seeds online! \xA0\xA0(Members only: \xA0\xA0Register below.)"
	        ),
	        _react2.default.createElement(
	          "p",
	          { className: "text-left", style: myStyle3 },
	          "\u2003\u2002",
	          this.props.bkImg[1].size
	        ),
	        _react2.default.createElement("img", { src: this.props.bkImg[1].aboutImg, width: "600px", className: "img-responsive pull-left gap-right", style: myStyle2 }),
	        _react2.default.createElement(
	          "p",
	          null,
	          "God yzal eht revo spmuj xof nworb kciuq eht.\xA0\xA0The quick brown fox jumps over the lazy dog. \xA0\xA0God yzal eht revo spmuj xof nworb kciuq eht.\xA0\xA0The quick brown fox jumps over the lazy dog.\xA0\xA0God yzal eht revo spmuj xof nworb kciuq eht.\xA0\xA0The quick brown fox jumps over the lazy dog.\xA0\xA0God yzal eht revo spmuj xof nworb kciuq eht.\xA0\xA0The quick brown fox jumps over the lazy dog.\xA0\xA0God yzal eht revo spmuj xof nworb kciuq eht.\xA0\xA0The quick brown fox jumps over the lazy dog.God yzal eht revo spmuj xof nworb kciuq eht.\xA0\xA0The quick brown fox jumps over the lazy dog. \xA0\xA0God yzal eht revo spmuj xof nworb kciuq eht.\xA0\xA0The quick brown fox jumps over the lazy dog.\xA0\xA0God yzal eht revo spmuj xof nworb kciuq eht.\xA0\xA0The quick brown fox jumps over the lazy dog.\xA0\xA0God yzal eht revo spmuj xof nworb kciuq eht.\xA0\xA0The quick brown fox jumps over the lazy dog.\xA0\xA0God yzal eht revo spmuj xof nworb kciuq eht.\xA0\xA0The quick brown fox jumps over the lazy dog.God yzal eht revo spmuj xof nworb kciuq eht.\xA0\xA0The quick brown fox jumps over the lazy dog. \xA0\xA0God yzal eht revo spmuj xof nworb kciuq eht.\xA0\xA0The quick brown fox jumps over the lazy dog.\xA0\xA0God yzal eht revo spmuj xof nworb kciuq eht.\xA0\xA0The quick brown fox jumps over the lazy dog.\xA0\xA0God yzal eht revo spmuj xof nworb kciuq eht.\xA0\xA0The quick brown fox jumps over the lazy dog.\xA0\xA0God yzal eht revo spmuj xof nworb kciuq eht.\xA0\xA0The quick brown fox jumps over the lazy dog.God yzal eht revo spmuj xof nworb kciuq eht.\xA0\xA0The quick brown fox jumps over the lazy dog. \xA0\xA0God yzal eht revo spmuj xof nworb kciuq eht.\xA0\xA0The quick brown fox jumps over the lazy dog.\xA0\xA0God yzal eht revo spmuj xof nworb kciuq eht.\xA0\xA0The quick brown fox jumps over the lazy dog.\xA0\xA0God yzal eht revo spmuj xof nworb kciuq eht.\xA0\xA0The quick brown fox jumps over the lazy dog.\xA0\xA0God yzal eht revo spmuj xof nworb kciuq eht.\xA0\xA0The quick brown fox jumps over the lazy dog."
	        )
	      );
	    }
	  }]);
	
	  return About;
	}(_react2.default.Component);
	
	exports.default = About;
	
	About.propTypes = {
	  bkImg: _react2.default.PropTypes.array.isRequired
	};
	About.defaultProps = {
	  bkImg: []
	};

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(13);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _fruitItems = __webpack_require__(87);
	
	var _fruitItems2 = _interopRequireDefault(_fruitItems);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Fruits = function (_React$Component) {
	  _inherits(Fruits, _React$Component);
	
	  function Fruits() {
	    _classCallCheck(this, Fruits);
	
	    return _possibleConstructorReturn(this, (Fruits.__proto__ || Object.getPrototypeOf(Fruits)).apply(this, arguments));
	  }
	
	  _createClass(Fruits, [{
	    key: 'render',
	    value: function render() {
	      var myStyle = {
	        fontFamily: "Dosis",
	        paddingTop: "50px",
	        paddingBottom: "20px",
	        height: "100%",
	        color: "#000",
	        backgroundColor: "#ffcc00"
	      };
	      var showFruits = this.props.fruits.map(function (fruit) {
	        return _react2.default.createElement(_fruitItems2.default, { key: fruit.id, id: fruit.id, cname: fruit.cname, lname: fruit.lname, price: fruit.price, img: fruit.img, size: fruit.size, link: fruit.link });
	      });
	      return _react2.default.createElement(
	        'div',
	        { id: 'fruits', className: 'container-fluid', style: myStyle },
	        _react2.default.createElement(
	          'div',
	          { className: 'row' },
	          _react2.default.createElement(
	            'div',
	            { className: 'col-lg-12' },
	            _react2.default.createElement(
	              'div',
	              { className: 'text-center' },
	              _react2.default.createElement(
	                'h3',
	                null,
	                '<',
	                _react2.default.createElement(
	                  'em',
	                  null,
	                  ' demo '
	                ),
	                '>',
	                '\xA0'
	              ),
	              _react2.default.createElement(
	                'h1',
	                null,
	                'Fruit Seeds List'
	              )
	            )
	          )
	        ),
	        _react2.default.createElement(
	          'div',
	          { className: 'row' },
	          showFruits
	        )
	      );
	    }
	  }]);
	
	  return Fruits;
	}(_react2.default.Component);
	
	exports.default = Fruits;
	
	Fruits.propTypes = {
	  fruits: _react2.default.PropTypes.array.isRequired
	};
	Fruits.defaultProps = {
	  fruits: []
	};

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(13);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Home = function (_React$Component) {
	  _inherits(Home, _React$Component);
	
	  function Home() {
	    _classCallCheck(this, Home);
	
	    return _possibleConstructorReturn(this, (Home.__proto__ || Object.getPrototypeOf(Home)).apply(this, arguments));
	  }
	
	  _createClass(Home, [{
	    key: "render",
	    value: function render() {
	      var myStyle1 = {
	        fontFamily: "Dosis",
	        paddingTop: "270px",
	        height: "700px",
	        color: "#fff",
	        backgroundImage: "url(" + this.props.bkImg[0].homeImg + ")",
	        backgroundSize: 'cover'
	      };
	      var myStyle2 = {
	        paddingTop: "240px",
	        color: "yellow"
	      };
	      return _react2.default.createElement(
	        "div",
	        { id: "home", className: "container-fluid text-center", style: myStyle1 },
	        _react2.default.createElement(
	          "h1",
	          null,
	          "Pro-Seed and Grow !"
	        ),
	        _react2.default.createElement(
	          "h2",
	          null,
	          '<',
	          _react2.default.createElement(
	            "em",
	            null,
	            " This is a demo site. "
	          ),
	          '>',
	          "\xA0"
	        ),
	        _react2.default.createElement(
	          "p",
	          null,
	          "God yzal eht revo spmuj xof nworb kciuq eht.\xA0\xA0The quick brown fox jumps over the lazy dog."
	        ),
	        _react2.default.createElement(
	          "div",
	          { style: myStyle2 },
	          _react2.default.createElement(
	            "p",
	            null,
	            this.props.bkImg[0].size
	          )
	        )
	      );
	    }
	  }]);
	
	  return Home;
	}(_react2.default.Component);
	
	exports.default = Home;
	
	Home.propTypes = {
	  bkImg: _react2.default.PropTypes.array.isRequired
	};
	Home.defaultProps = {
	  bkImg: []
	};

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(13);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Register = function (_React$Component) {
	  _inherits(Register, _React$Component);
	
	  function Register() {
	    _classCallCheck(this, Register);
	
	    return _possibleConstructorReturn(this, (Register.__proto__ || Object.getPrototypeOf(Register)).apply(this, arguments));
	  }
	
	  _createClass(Register, [{
	    key: "render",
	    value: function render() {
	      var myStyle1 = {
	        fontFamily: "Dosis",
	        paddingTop: "50px",
	        paddingBottom: "20px",
	        height: "100%",
	        color: "#000",
	        backgroundColor: "#009973"
	      };
	      var myStyle2 = {
	        color: "#fff",
	        textAlign: "center"
	      };
	      return _react2.default.createElement(
	        "div",
	        { id: "register", className: "container-fluid", style: myStyle1 },
	        _react2.default.createElement(
	          "div",
	          { className: "row" },
	          _react2.default.createElement(
	            "div",
	            { className: "col-lg-12" },
	            _react2.default.createElement(
	              "div",
	              { className: "text-center" },
	              _react2.default.createElement(
	                "h1",
	                null,
	                "Register for membership"
	              ),
	              _react2.default.createElement(
	                "h4",
	                { style: myStyle2 },
	                '<',
	                " Note: \xA0\xA0This signup form is not active. ",
	                '>'
	              )
	            )
	          )
	        ),
	        _react2.default.createElement(
	          "div",
	          { className: "row centered-form" },
	          _react2.default.createElement(
	            "div",
	            { className: " col-xs-6 col-xs-offset-3 col-sm-4 col-sm-offset-4 col-md-4 col-md-offset-4" },
	            _react2.default.createElement(
	              "form",
	              { className: "form-horizontal", action: "", method: "POST" },
	              _react2.default.createElement(
	                "fieldset",
	                null,
	                _react2.default.createElement(
	                  "div",
	                  { className: "control-group" },
	                  _react2.default.createElement(
	                    "label",
	                    { className: "control-label", htmlFor: "username" },
	                    "Username"
	                  ),
	                  _react2.default.createElement(
	                    "div",
	                    { className: "controls" },
	                    _react2.default.createElement("input", { type: "text", id: "username", name: "username", placeholder: "", className: "form-control input-lg" }),
	                    _react2.default.createElement(
	                      "p",
	                      { style: myStyle2, className: "help-block" },
	                      "Username can contain any letters or numbers, without spaces"
	                    )
	                  )
	                ),
	                _react2.default.createElement(
	                  "div",
	                  { className: "control-group" },
	                  _react2.default.createElement(
	                    "label",
	                    { className: "control-label", htmlFor: "email" },
	                    "E-mail"
	                  ),
	                  _react2.default.createElement(
	                    "div",
	                    { className: "controls" },
	                    _react2.default.createElement("input", { type: "email", id: "email", name: "email", placeholder: "", className: "form-control input-lg" }),
	                    _react2.default.createElement(
	                      "p",
	                      { style: myStyle2, className: "help-block" },
	                      "Please provide your E-mail"
	                    )
	                  )
	                ),
	                _react2.default.createElement(
	                  "div",
	                  { className: "control-group" },
	                  _react2.default.createElement(
	                    "label",
	                    { className: "control-label", htmlFor: "password" },
	                    "Password"
	                  ),
	                  _react2.default.createElement(
	                    "div",
	                    { className: "controls" },
	                    _react2.default.createElement("input", { type: "password", id: "password", name: "password", placeholder: "", className: "form-control input-lg" }),
	                    _react2.default.createElement(
	                      "p",
	                      { style: myStyle2, className: "help-block" },
	                      "Password should be at least 6 characters"
	                    )
	                  )
	                ),
	                _react2.default.createElement(
	                  "div",
	                  { className: "control-group" },
	                  _react2.default.createElement(
	                    "label",
	                    { className: "control-label", htmlFor: "password_confirm" },
	                    "Password (Confirm)"
	                  ),
	                  _react2.default.createElement(
	                    "div",
	                    { className: "controls" },
	                    _react2.default.createElement("input", { type: "password", id: "password_confirm", name: "password_confirm", placeholder: "", className: "form-control input-lg" }),
	                    _react2.default.createElement(
	                      "p",
	                      { style: myStyle2, className: "help-block" },
	                      "Please confirm password"
	                    )
	                  )
	                ),
	                _react2.default.createElement("br", null),
	                _react2.default.createElement(
	                  "div",
	                  { className: "control-group" },
	                  _react2.default.createElement(
	                    "div",
	                    { className: "controls" },
	                    _react2.default.createElement(
	                      "button",
	                      { className: "btn btn-primary btn-block" },
	                      _react2.default.createElement(
	                        "h4",
	                        null,
	                        "Submit"
	                      )
	                    )
	                  )
	                )
	              )
	            )
	          )
	        )
	      );
	    }
	  }]);
	
	  return Register;
	}(_react2.default.Component);
	
	exports.default = Register;

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(13);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _teamMems = __webpack_require__(88);
	
	var _teamMems2 = _interopRequireDefault(_teamMems);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Team = function (_React$Component) {
	  _inherits(Team, _React$Component);
	
	  function Team() {
	    _classCallCheck(this, Team);
	
	    return _possibleConstructorReturn(this, (Team.__proto__ || Object.getPrototypeOf(Team)).apply(this, arguments));
	  }
	
	  _createClass(Team, [{
	    key: 'render',
	    value: function render() {
	      var myStyle = {
	        fontFamily: "Dosis",
	        paddingTop: "50px",
	        paddingBottom: "50px",
	        height: "100%",
	        color: "#fff",
	        backgroundColor: "#505050"
	      };
	      var showTeamMembers = this.props.teamMems.map(function (teamMem) {
	        return _react2.default.createElement(_teamMems2.default, { key: teamMem.id, id: teamMem.id, fname: teamMem.fname, lname: teamMem.lname, title: teamMem.title, linkedin: teamMem.linkedin, photo: teamMem.photo, size: teamMem.size });
	      });
	      return _react2.default.createElement(
	        'div',
	        { id: 'team', className: 'container-fluid', style: myStyle },
	        _react2.default.createElement(
	          'div',
	          { className: 'row' },
	          _react2.default.createElement(
	            'div',
	            { className: 'col-lg-12' },
	            _react2.default.createElement(
	              'div',
	              { className: 'text-center' },
	              _react2.default.createElement(
	                'h3',
	                null,
	                '<',
	                _react2.default.createElement(
	                  'em',
	                  null,
	                  ' demo '
	                ),
	                '>',
	                '\xA0'
	              ),
	              _react2.default.createElement(
	                'h1',
	                null,
	                'Meet the Team'
	              ),
	              _react2.default.createElement('br', null),
	              _react2.default.createElement('br', null)
	            )
	          )
	        ),
	        _react2.default.createElement(
	          'div',
	          { className: 'row' },
	          showTeamMembers
	        ),
	        _react2.default.createElement('hr', null),
	        _react2.default.createElement(
	          'div',
	          { className: 'row' },
	          _react2.default.createElement(
	            'div',
	            { className: 'col-lg-12' },
	            _react2.default.createElement(
	              'div',
	              { className: 'text-center' },
	              _react2.default.createElement('br', null),
	              _react2.default.createElement(
	                'h3',
	                null,
	                '<',
	                _react2.default.createElement(
	                  'em',
	                  null,
	                  ' demo '
	                ),
	                '>',
	                '\xA0'
	              ),
	              _react2.default.createElement(
	                'h1',
	                null,
	                'Contact Info'
	              ),
	              _react2.default.createElement('br', null),
	              _react2.default.createElement(
	                'h3',
	                null,
	                'ProSeed Inc.'
	              ),
	              _react2.default.createElement(
	                'h4',
	                null,
	                '12-34 56th St. 78th Ave Flr 90 Ste 1234'
	              ),
	              _react2.default.createElement(
	                'h4',
	                null,
	                'New York, NY 56789'
	              ),
	              _react2.default.createElement(
	                'h4',
	                null,
	                'Tel: \xA0\xA0( 0123 ) 456-7890'
	              ),
	              _react2.default.createElement(
	                'h4',
	                null,
	                'EmaiL \xA0\xA0abc-123@proseed.com'
	              )
	            )
	          )
	        )
	      );
	    }
	  }]);
	
	  return Team;
	}(_react2.default.Component);
	
	exports.default = Team;
	
	Team.propTypes = {
	  teamMems: _react2.default.PropTypes.array.isRequired
	};
	Team.defaultProps = {
	  teamMems: []
	};

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(112);


/***/ },
/* 99 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ARIADOMPropertyConfig = {
	  Properties: {
	    // Global States and Properties
	    'aria-current': 0, // state
	    'aria-details': 0,
	    'aria-disabled': 0, // state
	    'aria-hidden': 0, // state
	    'aria-invalid': 0, // state
	    'aria-keyshortcuts': 0,
	    'aria-label': 0,
	    'aria-roledescription': 0,
	    // Widget Attributes
	    'aria-autocomplete': 0,
	    'aria-checked': 0,
	    'aria-expanded': 0,
	    'aria-haspopup': 0,
	    'aria-level': 0,
	    'aria-modal': 0,
	    'aria-multiline': 0,
	    'aria-multiselectable': 0,
	    'aria-orientation': 0,
	    'aria-placeholder': 0,
	    'aria-pressed': 0,
	    'aria-readonly': 0,
	    'aria-required': 0,
	    'aria-selected': 0,
	    'aria-sort': 0,
	    'aria-valuemax': 0,
	    'aria-valuemin': 0,
	    'aria-valuenow': 0,
	    'aria-valuetext': 0,
	    // Live Region Attributes
	    'aria-atomic': 0,
	    'aria-busy': 0,
	    'aria-live': 0,
	    'aria-relevant': 0,
	    // Drag-and-Drop Attributes
	    'aria-dropeffect': 0,
	    'aria-grabbed': 0,
	    // Relationship Attributes
	    'aria-activedescendant': 0,
	    'aria-colcount': 0,
	    'aria-colindex': 0,
	    'aria-colspan': 0,
	    'aria-controls': 0,
	    'aria-describedby': 0,
	    'aria-errormessage': 0,
	    'aria-flowto': 0,
	    'aria-labelledby': 0,
	    'aria-owns': 0,
	    'aria-posinset': 0,
	    'aria-rowcount': 0,
	    'aria-rowindex': 0,
	    'aria-rowspan': 0,
	    'aria-setsize': 0
	  },
	  DOMAttributeNames: {},
	  DOMPropertyNames: {}
	};
	
	module.exports = ARIADOMPropertyConfig;

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactDOMComponentTree = __webpack_require__(5);
	
	var focusNode = __webpack_require__(81);
	
	var AutoFocusUtils = {
	  focusDOMComponent: function () {
	    focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
	  }
	};
	
	module.exports = AutoFocusUtils;

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var EventPropagators = __webpack_require__(25);
	var ExecutionEnvironment = __webpack_require__(7);
	var FallbackCompositionState = __webpack_require__(107);
	var SyntheticCompositionEvent = __webpack_require__(150);
	var SyntheticInputEvent = __webpack_require__(153);
	
	var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
	var START_KEYCODE = 229;
	
	var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;
	
	var documentMode = null;
	if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
	  documentMode = document.documentMode;
	}
	
	// Webkit offers a very useful `textInput` event that can be used to
	// directly represent `beforeInput`. The IE `textinput` event is not as
	// useful, so we don't use it.
	var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();
	
	// In IE9+, we have access to composition events, but the data supplied
	// by the native compositionend event may be incorrect. Japanese ideographic
	// spaces, for instance (\u3000) are not recorded correctly.
	var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
	
	/**
	 * Opera <= 12 includes TextEvent in window, but does not fire
	 * text input events. Rely on keypress instead.
	 */
	function isPresto() {
	  var opera = window.opera;
	  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
	}
	
	var SPACEBAR_CODE = 32;
	var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
	
	// Events and their corresponding property names.
	var eventTypes = {
	  beforeInput: {
	    phasedRegistrationNames: {
	      bubbled: 'onBeforeInput',
	      captured: 'onBeforeInputCapture'
	    },
	    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']
	  },
	  compositionEnd: {
	    phasedRegistrationNames: {
	      bubbled: 'onCompositionEnd',
	      captured: 'onCompositionEndCapture'
	    },
	    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
	  },
	  compositionStart: {
	    phasedRegistrationNames: {
	      bubbled: 'onCompositionStart',
	      captured: 'onCompositionStartCapture'
	    },
	    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
	  },
	  compositionUpdate: {
	    phasedRegistrationNames: {
	      bubbled: 'onCompositionUpdate',
	      captured: 'onCompositionUpdateCapture'
	    },
	    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
	  }
	};
	
	// Track whether we've ever handled a keypress on the space key.
	var hasSpaceKeypress = false;
	
	/**
	 * Return whether a native keypress event is assumed to be a command.
	 * This is required because Firefox fires `keypress` events for key commands
	 * (cut, copy, select-all, etc.) even though no character is inserted.
	 */
	function isKeypressCommand(nativeEvent) {
	  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
	  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
	  !(nativeEvent.ctrlKey && nativeEvent.altKey);
	}
	
	/**
	 * Translate native top level events into event types.
	 *
	 * @param {string} topLevelType
	 * @return {object}
	 */
	function getCompositionEventType(topLevelType) {
	  switch (topLevelType) {
	    case 'topCompositionStart':
	      return eventTypes.compositionStart;
	    case 'topCompositionEnd':
	      return eventTypes.compositionEnd;
	    case 'topCompositionUpdate':
	      return eventTypes.compositionUpdate;
	  }
	}
	
	/**
	 * Does our fallback best-guess model think this event signifies that
	 * composition has begun?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionStart(topLevelType, nativeEvent) {
	  return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;
	}
	
	/**
	 * Does our fallback mode think that this event is the end of composition?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionEnd(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case 'topKeyUp':
	      // Command keys insert or clear IME input.
	      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
	    case 'topKeyDown':
	      // Expect IME keyCode on each keydown. If we get any other
	      // code we must have exited earlier.
	      return nativeEvent.keyCode !== START_KEYCODE;
	    case 'topKeyPress':
	    case 'topMouseDown':
	    case 'topBlur':
	      // Events are not possible without cancelling IME.
	      return true;
	    default:
	      return false;
	  }
	}
	
	/**
	 * Google Input Tools provides composition data via a CustomEvent,
	 * with the `data` property populated in the `detail` object. If this
	 * is available on the event object, use it. If not, this is a plain
	 * composition event and we have nothing special to extract.
	 *
	 * @param {object} nativeEvent
	 * @return {?string}
	 */
	function getDataFromCustomEvent(nativeEvent) {
	  var detail = nativeEvent.detail;
	  if (typeof detail === 'object' && 'data' in detail) {
	    return detail.data;
	  }
	  return null;
	}
	
	// Track the current IME composition fallback object, if any.
	var currentComposition = null;
	
	/**
	 * @return {?object} A SyntheticCompositionEvent.
	 */
	function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var eventType;
	  var fallbackData;
	
	  if (canUseCompositionEvent) {
	    eventType = getCompositionEventType(topLevelType);
	  } else if (!currentComposition) {
	    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
	      eventType = eventTypes.compositionStart;
	    }
	  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	    eventType = eventTypes.compositionEnd;
	  }
	
	  if (!eventType) {
	    return null;
	  }
	
	  if (useFallbackCompositionData) {
	    // The current composition is stored statically and must not be
	    // overwritten while composition continues.
	    if (!currentComposition && eventType === eventTypes.compositionStart) {
	      currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
	    } else if (eventType === eventTypes.compositionEnd) {
	      if (currentComposition) {
	        fallbackData = currentComposition.getData();
	      }
	    }
	  }
	
	  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);
	
	  if (fallbackData) {
	    // Inject data generated from fallback path into the synthetic event.
	    // This matches the property of native CompositionEventInterface.
	    event.data = fallbackData;
	  } else {
	    var customData = getDataFromCustomEvent(nativeEvent);
	    if (customData !== null) {
	      event.data = customData;
	    }
	  }
	
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The string corresponding to this `beforeInput` event.
	 */
	function getNativeBeforeInputChars(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case 'topCompositionEnd':
	      return getDataFromCustomEvent(nativeEvent);
	    case 'topKeyPress':
	      /**
	       * If native `textInput` events are available, our goal is to make
	       * use of them. However, there is a special case: the spacebar key.
	       * In Webkit, preventing default on a spacebar `textInput` event
	       * cancels character insertion, but it *also* causes the browser
	       * to fall back to its default spacebar behavior of scrolling the
	       * page.
	       *
	       * Tracking at:
	       * https://code.google.com/p/chromium/issues/detail?id=355103
	       *
	       * To avoid this issue, use the keypress event as if no `textInput`
	       * event is available.
	       */
	      var which = nativeEvent.which;
	      if (which !== SPACEBAR_CODE) {
	        return null;
	      }
	
	      hasSpaceKeypress = true;
	      return SPACEBAR_CHAR;
	
	    case 'topTextInput':
	      // Record the characters to be added to the DOM.
	      var chars = nativeEvent.data;
	
	      // If it's a spacebar character, assume that we have already handled
	      // it at the keypress level and bail immediately. Android Chrome
	      // doesn't give us keycodes, so we need to blacklist it.
	      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
	        return null;
	      }
	
	      return chars;
	
	    default:
	      // For other native event types, do nothing.
	      return null;
	  }
	}
	
	/**
	 * For browsers that do not provide the `textInput` event, extract the
	 * appropriate string to use for SyntheticInputEvent.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The fallback string for this `beforeInput` event.
	 */
	function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
	  // If we are currently composing (IME) and using a fallback to do so,
	  // try to extract the composed characters from the fallback object.
	  // If composition event is available, we extract a string only at
	  // compositionevent, otherwise extract it at fallback events.
	  if (currentComposition) {
	    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	      var chars = currentComposition.getData();
	      FallbackCompositionState.release(currentComposition);
	      currentComposition = null;
	      return chars;
	    }
	    return null;
	  }
	
	  switch (topLevelType) {
	    case 'topPaste':
	      // If a paste event occurs after a keypress, throw out the input
	      // chars. Paste events should not lead to BeforeInput events.
	      return null;
	    case 'topKeyPress':
	      /**
	       * As of v27, Firefox may fire keypress events even when no character
	       * will be inserted. A few possibilities:
	       *
	       * - `which` is `0`. Arrow keys, Esc key, etc.
	       *
	       * - `which` is the pressed key code, but no char is available.
	       *   Ex: 'AltGr + d` in Polish. There is no modified character for
	       *   this key combination and no character is inserted into the
	       *   document, but FF fires the keypress for char code `100` anyway.
	       *   No `input` event will occur.
	       *
	       * - `which` is the pressed key code, but a command combination is
	       *   being used. Ex: `Cmd+C`. No character is inserted, and no
	       *   `input` event will occur.
	       */
	      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
	        return String.fromCharCode(nativeEvent.which);
	      }
	      return null;
	    case 'topCompositionEnd':
	      return useFallbackCompositionData ? null : nativeEvent.data;
	    default:
	      return null;
	  }
	}
	
	/**
	 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
	 * `textInput` or fallback behavior.
	 *
	 * @return {?object} A SyntheticInputEvent.
	 */
	function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var chars;
	
	  if (canUseTextInputEvent) {
	    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
	  } else {
	    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
	  }
	
	  // If no characters are being inserted, no BeforeInput event should
	  // be fired.
	  if (!chars) {
	    return null;
	  }
	
	  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);
	
	  event.data = chars;
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * Create an `onBeforeInput` event to match
	 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
	 *
	 * This event plugin is based on the native `textInput` event
	 * available in Chrome, Safari, Opera, and IE. This event fires after
	 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
	 *
	 * `beforeInput` is spec'd but not implemented in any browsers, and
	 * the `input` event does not provide any useful information about what has
	 * actually been added, contrary to the spec. Thus, `textInput` is the best
	 * available event to identify the characters that have actually been inserted
	 * into the target node.
	 *
	 * This plugin is also responsible for emitting `composition` events, thus
	 * allowing us to share composition fallback code for both `beforeInput` and
	 * `composition` event types.
	 */
	var BeforeInputEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
	  }
	};
	
	module.exports = BeforeInputEventPlugin;

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(58);
	var ExecutionEnvironment = __webpack_require__(7);
	var ReactInstrumentation = __webpack_require__(9);
	
	var camelizeStyleName = __webpack_require__(171);
	var dangerousStyleValue = __webpack_require__(160);
	var hyphenateStyleName = __webpack_require__(178);
	var memoizeStringOnly = __webpack_require__(181);
	var warning = __webpack_require__(4);
	
	var processStyleName = memoizeStringOnly(function (styleName) {
	  return hyphenateStyleName(styleName);
	});
	
	var hasShorthandPropertyBug = false;
	var styleFloatAccessor = 'cssFloat';
	if (ExecutionEnvironment.canUseDOM) {
	  var tempStyle = document.createElement('div').style;
	  try {
	    // IE8 throws "Invalid argument." if resetting shorthand style properties.
	    tempStyle.font = '';
	  } catch (e) {
	    hasShorthandPropertyBug = true;
	  }
	  // IE8 only supports accessing cssFloat (standard) as styleFloat
	  if (document.documentElement.style.cssFloat === undefined) {
	    styleFloatAccessor = 'styleFloat';
	  }
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  // 'msTransform' is correct, but the other prefixes should be capitalized
	  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
	
	  // style values shouldn't contain a semicolon
	  var badStyleValueWithSemicolonPattern = /;\s*$/;
	
	  var warnedStyleNames = {};
	  var warnedStyleValues = {};
	  var warnedForNaNValue = false;
	
	  var warnHyphenatedStyleName = function (name, owner) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner)) : void 0;
	  };
	
	  var warnBadVendoredStyleName = function (name, owner) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
	  };
	
	  var warnStyleValueWithSemicolon = function (name, value, owner) {
	    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
	      return;
	    }
	
	    warnedStyleValues[value] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon.%s ' + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, '')) : void 0;
	  };
	
	  var warnStyleValueIsNaN = function (name, value, owner) {
	    if (warnedForNaNValue) {
	      return;
	    }
	
	    warnedForNaNValue = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner)) : void 0;
	  };
	
	  var checkRenderMessage = function (owner) {
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' Check the render method of `' + name + '`.';
	      }
	    }
	    return '';
	  };
	
	  /**
	   * @param {string} name
	   * @param {*} value
	   * @param {ReactDOMComponent} component
	   */
	  var warnValidStyle = function (name, value, component) {
	    var owner;
	    if (component) {
	      owner = component._currentElement._owner;
	    }
	    if (name.indexOf('-') > -1) {
	      warnHyphenatedStyleName(name, owner);
	    } else if (badVendoredStyleNamePattern.test(name)) {
	      warnBadVendoredStyleName(name, owner);
	    } else if (badStyleValueWithSemicolonPattern.test(value)) {
	      warnStyleValueWithSemicolon(name, value, owner);
	    }
	
	    if (typeof value === 'number' && isNaN(value)) {
	      warnStyleValueIsNaN(name, value, owner);
	    }
	  };
	}
	
	/**
	 * Operations for dealing with CSS properties.
	 */
	var CSSPropertyOperations = {
	
	  /**
	   * Serializes a mapping of style properties for use as inline styles:
	   *
	   *   > createMarkupForStyles({width: '200px', height: 0})
	   *   "width:200px;height:0;"
	   *
	   * Undefined values are ignored so that declarative programming is easier.
	   * The result should be HTML-escaped before insertion into the DOM.
	   *
	   * @param {object} styles
	   * @param {ReactDOMComponent} component
	   * @return {?string}
	   */
	  createMarkupForStyles: function (styles, component) {
	    var serialized = '';
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var styleValue = styles[styleName];
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styleValue, component);
	      }
	      if (styleValue != null) {
	        serialized += processStyleName(styleName) + ':';
	        serialized += dangerousStyleValue(styleName, styleValue, component) + ';';
	      }
	    }
	    return serialized || null;
	  },
	
	  /**
	   * Sets the value for multiple styles on a node.  If a value is specified as
	   * '' (empty string), the corresponding style property will be unset.
	   *
	   * @param {DOMElement} node
	   * @param {object} styles
	   * @param {ReactDOMComponent} component
	   */
	  setValueForStyles: function (node, styles, component) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: component._debugID,
	        type: 'update styles',
	        payload: styles
	      });
	    }
	
	    var style = node.style;
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styles[styleName], component);
	      }
	      var styleValue = dangerousStyleValue(styleName, styles[styleName], component);
	      if (styleName === 'float' || styleName === 'cssFloat') {
	        styleName = styleFloatAccessor;
	      }
	      if (styleValue) {
	        style[styleName] = styleValue;
	      } else {
	        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
	        if (expansion) {
	          // Shorthand property that IE8 won't like unsetting, so unset each
	          // component to placate it
	          for (var individualStyleName in expansion) {
	            style[individualStyleName] = '';
	          }
	        } else {
	          style[styleName] = '';
	        }
	      }
	    }
	  }
	
	};
	
	module.exports = CSSPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(24);
	var EventPropagators = __webpack_require__(25);
	var ExecutionEnvironment = __webpack_require__(7);
	var ReactDOMComponentTree = __webpack_require__(5);
	var ReactUpdates = __webpack_require__(10);
	var SyntheticEvent = __webpack_require__(14);
	
	var getEventTarget = __webpack_require__(46);
	var isEventSupported = __webpack_require__(47);
	var isTextInputElement = __webpack_require__(76);
	
	var eventTypes = {
	  change: {
	    phasedRegistrationNames: {
	      bubbled: 'onChange',
	      captured: 'onChangeCapture'
	    },
	    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']
	  }
	};
	
	/**
	 * For IE shims
	 */
	var activeElement = null;
	var activeElementInst = null;
	var activeElementValue = null;
	var activeElementValueProp = null;
	
	/**
	 * SECTION: handle `change` event
	 */
	function shouldUseChangeEvent(elem) {
	  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
	}
	
	var doesChangeEventBubble = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // See `handleChange` comment below
	  doesChangeEventBubble = isEventSupported('change') && (!document.documentMode || document.documentMode > 8);
	}
	
	function manualDispatchChangeEvent(nativeEvent) {
	  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	
	  // If change and propertychange bubbled, we'd just bind to it like all the
	  // other events and have it go through ReactBrowserEventEmitter. Since it
	  // doesn't, we manually listen for the events and so we have to enqueue and
	  // process the abstract event manually.
	  //
	  // Batching is necessary here in order to ensure that all event handlers run
	  // before the next rerender (including event handlers attached to ancestor
	  // elements instead of directly on the input). Without this, controlled
	  // components don't work properly in conjunction with event bubbling because
	  // the component is rerendered and the value reverted before all the event
	  // handlers can run. See https://github.com/facebook/react/issues/708.
	  ReactUpdates.batchedUpdates(runEventInBatch, event);
	}
	
	function runEventInBatch(event) {
	  EventPluginHub.enqueueEvents(event);
	  EventPluginHub.processEventQueue(false);
	}
	
	function startWatchingForChangeEventIE8(target, targetInst) {
	  activeElement = target;
	  activeElementInst = targetInst;
	  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
	}
	
	function stopWatchingForChangeEventIE8() {
	  if (!activeElement) {
	    return;
	  }
	  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
	  activeElement = null;
	  activeElementInst = null;
	}
	
	function getTargetInstForChangeEvent(topLevelType, targetInst) {
	  if (topLevelType === 'topChange') {
	    return targetInst;
	  }
	}
	function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
	  if (topLevelType === 'topFocus') {
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForChangeEventIE8();
	    startWatchingForChangeEventIE8(target, targetInst);
	  } else if (topLevelType === 'topBlur') {
	    stopWatchingForChangeEventIE8();
	  }
	}
	
	/**
	 * SECTION: handle `input` event
	 */
	var isInputEventSupported = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // IE9 claims to support the input event but fails to trigger it when
	  // deleting text, so we ignore its input events.
	  // IE10+ fire input events to often, such when a placeholder
	  // changes or when an input with a placeholder is focused.
	  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 11);
	}
	
	/**
	 * (For IE <=11) Replacement getter/setter for the `value` property that gets
	 * set on the active element.
	 */
	var newValueProp = {
	  get: function () {
	    return activeElementValueProp.get.call(this);
	  },
	  set: function (val) {
	    // Cast to a string so we can do equality checks.
	    activeElementValue = '' + val;
	    activeElementValueProp.set.call(this, val);
	  }
	};
	
	/**
	 * (For IE <=11) Starts tracking propertychange events on the passed-in element
	 * and override the value property so that we can distinguish user events from
	 * value changes in JS.
	 */
	function startWatchingForValueChange(target, targetInst) {
	  activeElement = target;
	  activeElementInst = targetInst;
	  activeElementValue = target.value;
	  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');
	
	  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
	  // on DOM elements
	  Object.defineProperty(activeElement, 'value', newValueProp);
	  if (activeElement.attachEvent) {
	    activeElement.attachEvent('onpropertychange', handlePropertyChange);
	  } else {
	    activeElement.addEventListener('propertychange', handlePropertyChange, false);
	  }
	}
	
	/**
	 * (For IE <=11) Removes the event listeners from the currently-tracked element,
	 * if any exists.
	 */
	function stopWatchingForValueChange() {
	  if (!activeElement) {
	    return;
	  }
	
	  // delete restores the original property definition
	  delete activeElement.value;
	
	  if (activeElement.detachEvent) {
	    activeElement.detachEvent('onpropertychange', handlePropertyChange);
	  } else {
	    activeElement.removeEventListener('propertychange', handlePropertyChange, false);
	  }
	
	  activeElement = null;
	  activeElementInst = null;
	  activeElementValue = null;
	  activeElementValueProp = null;
	}
	
	/**
	 * (For IE <=11) Handles a propertychange event, sending a `change` event if
	 * the value of the active element has changed.
	 */
	function handlePropertyChange(nativeEvent) {
	  if (nativeEvent.propertyName !== 'value') {
	    return;
	  }
	  var value = nativeEvent.srcElement.value;
	  if (value === activeElementValue) {
	    return;
	  }
	  activeElementValue = value;
	
	  manualDispatchChangeEvent(nativeEvent);
	}
	
	/**
	 * If a `change` event should be fired, returns the target's ID.
	 */
	function getTargetInstForInputEvent(topLevelType, targetInst) {
	  if (topLevelType === 'topInput') {
	    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
	    // what we want so fall through here and trigger an abstract event
	    return targetInst;
	  }
	}
	
	function handleEventsForInputEventIE(topLevelType, target, targetInst) {
	  if (topLevelType === 'topFocus') {
	    // In IE8, we can capture almost all .value changes by adding a
	    // propertychange handler and looking for events with propertyName
	    // equal to 'value'
	    // In IE9-11, propertychange fires for most input events but is buggy and
	    // doesn't fire when text is deleted, but conveniently, selectionchange
	    // appears to fire in all of the remaining cases so we catch those and
	    // forward the event if the value has changed
	    // In either case, we don't want to call the event handler if the value
	    // is changed from JS so we redefine a setter for `.value` that updates
	    // our activeElementValue variable, allowing us to ignore those changes
	    //
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForValueChange();
	    startWatchingForValueChange(target, targetInst);
	  } else if (topLevelType === 'topBlur') {
	    stopWatchingForValueChange();
	  }
	}
	
	// For IE8 and IE9.
	function getTargetInstForInputEventIE(topLevelType, targetInst) {
	  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {
	    // On the selectionchange event, the target is just document which isn't
	    // helpful for us so just check activeElement instead.
	    //
	    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
	    // propertychange on the first input event after setting `value` from a
	    // script and fires only keydown, keypress, keyup. Catching keyup usually
	    // gets it and catching keydown lets us fire an event for the first
	    // keystroke if user does a key repeat (it'll be a little delayed: right
	    // before the second keystroke). Other input methods (e.g., paste) seem to
	    // fire selectionchange normally.
	    if (activeElement && activeElement.value !== activeElementValue) {
	      activeElementValue = activeElement.value;
	      return activeElementInst;
	    }
	  }
	}
	
	/**
	 * SECTION: handle `click` event
	 */
	function shouldUseClickEvent(elem) {
	  // Use the `click` event to detect changes to checkbox and radio inputs.
	  // This approach works across all browsers, whereas `change` does not fire
	  // until `blur` in IE8.
	  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
	}
	
	function getTargetInstForClickEvent(topLevelType, targetInst) {
	  if (topLevelType === 'topClick') {
	    return targetInst;
	  }
	}
	
	/**
	 * This plugin creates an `onChange` event that normalizes change events
	 * across form elements. This event fires at a time when it's possible to
	 * change the element's value without seeing a flicker.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - select
	 */
	var ChangeEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
	
	    var getTargetInstFunc, handleEventFunc;
	    if (shouldUseChangeEvent(targetNode)) {
	      if (doesChangeEventBubble) {
	        getTargetInstFunc = getTargetInstForChangeEvent;
	      } else {
	        handleEventFunc = handleEventsForChangeEventIE8;
	      }
	    } else if (isTextInputElement(targetNode)) {
	      if (isInputEventSupported) {
	        getTargetInstFunc = getTargetInstForInputEvent;
	      } else {
	        getTargetInstFunc = getTargetInstForInputEventIE;
	        handleEventFunc = handleEventsForInputEventIE;
	      }
	    } else if (shouldUseClickEvent(targetNode)) {
	      getTargetInstFunc = getTargetInstForClickEvent;
	    }
	
	    if (getTargetInstFunc) {
	      var inst = getTargetInstFunc(topLevelType, targetInst);
	      if (inst) {
	        var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, nativeEventTarget);
	        event.type = 'change';
	        EventPropagators.accumulateTwoPhaseDispatches(event);
	        return event;
	      }
	    }
	
	    if (handleEventFunc) {
	      handleEventFunc(topLevelType, targetNode, targetInst);
	    }
	  }
	
	};
	
	module.exports = ChangeEventPlugin;

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var DOMLazyTree = __webpack_require__(21);
	var ExecutionEnvironment = __webpack_require__(7);
	
	var createNodesFromMarkup = __webpack_require__(174);
	var emptyFunction = __webpack_require__(15);
	var invariant = __webpack_require__(2);
	
	var Danger = {
	
	  /**
	   * Replaces a node with a string of markup at its current position within its
	   * parent. The markup must render into a single root node.
	   *
	   * @param {DOMElement} oldChild Child node to replace.
	   * @param {string} markup Markup to render in place of the child node.
	   * @internal
	   */
	  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
	    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('56') : void 0;
	    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : _prodInvariant('57') : void 0;
	    !(oldChild.nodeName !== 'HTML') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See ReactDOMServer.renderToString().') : _prodInvariant('58') : void 0;
	
	    if (typeof markup === 'string') {
	      var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
	      oldChild.parentNode.replaceChild(newChild, oldChild);
	    } else {
	      DOMLazyTree.replaceChildWithTree(oldChild, markup);
	    }
	  }
	
	};
	
	module.exports = Danger;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 105 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Module that is injectable into `EventPluginHub`, that specifies a
	 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
	 * plugins, without having to package every one of them. This is better than
	 * having plugins be ordered in the same order that they are injected because
	 * that ordering would be influenced by the packaging order.
	 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
	 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
	 */
	
	var DefaultEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];
	
	module.exports = DefaultEventPluginOrder;

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var EventPropagators = __webpack_require__(25);
	var ReactDOMComponentTree = __webpack_require__(5);
	var SyntheticMouseEvent = __webpack_require__(30);
	
	var eventTypes = {
	  mouseEnter: {
	    registrationName: 'onMouseEnter',
	    dependencies: ['topMouseOut', 'topMouseOver']
	  },
	  mouseLeave: {
	    registrationName: 'onMouseLeave',
	    dependencies: ['topMouseOut', 'topMouseOver']
	  }
	};
	
	var EnterLeaveEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * For almost every interaction we care about, there will be both a top-level
	   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
	   * we do not extract duplicate events. However, moving the mouse into the
	   * browser from outside will not fire a `mouseout` event. In this case, we use
	   * the `mouseover` top-level event.
	   */
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
	      return null;
	    }
	    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {
	      // Must not be a mouse in or mouse out - ignoring.
	      return null;
	    }
	
	    var win;
	    if (nativeEventTarget.window === nativeEventTarget) {
	      // `nativeEventTarget` is probably a window object.
	      win = nativeEventTarget;
	    } else {
	      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	      var doc = nativeEventTarget.ownerDocument;
	      if (doc) {
	        win = doc.defaultView || doc.parentWindow;
	      } else {
	        win = window;
	      }
	    }
	
	    var from;
	    var to;
	    if (topLevelType === 'topMouseOut') {
	      from = targetInst;
	      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
	      to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
	    } else {
	      // Moving to a node from outside the window.
	      from = null;
	      to = targetInst;
	    }
	
	    if (from === to) {
	      // Nothing pertains to our managed components.
	      return null;
	    }
	
	    var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
	    var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);
	
	    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
	    leave.type = 'mouseleave';
	    leave.target = fromNode;
	    leave.relatedTarget = toNode;
	
	    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
	    enter.type = 'mouseenter';
	    enter.target = toNode;
	    enter.relatedTarget = fromNode;
	
	    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);
	
	    return [leave, enter];
	  }
	
	};
	
	module.exports = EnterLeaveEventPlugin;

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var PooledClass = __webpack_require__(17);
	
	var getTextContentAccessor = __webpack_require__(74);
	
	/**
	 * This helper class stores information about text content of a target node,
	 * allowing comparison of content before and after a given event.
	 *
	 * Identify the node where selection currently begins, then observe
	 * both its text content and its current position in the DOM. Since the
	 * browser may natively replace the target node during composition, we can
	 * use its position to find its replacement.
	 *
	 * @param {DOMEventTarget} root
	 */
	function FallbackCompositionState(root) {
	  this._root = root;
	  this._startText = this.getText();
	  this._fallbackText = null;
	}
	
	_assign(FallbackCompositionState.prototype, {
	  destructor: function () {
	    this._root = null;
	    this._startText = null;
	    this._fallbackText = null;
	  },
	
	  /**
	   * Get current text of input.
	   *
	   * @return {string}
	   */
	  getText: function () {
	    if ('value' in this._root) {
	      return this._root.value;
	    }
	    return this._root[getTextContentAccessor()];
	  },
	
	  /**
	   * Determine the differing substring between the initially stored
	   * text content and the current content.
	   *
	   * @return {string}
	   */
	  getData: function () {
	    if (this._fallbackText) {
	      return this._fallbackText;
	    }
	
	    var start;
	    var startValue = this._startText;
	    var startLength = startValue.length;
	    var end;
	    var endValue = this.getText();
	    var endLength = endValue.length;
	
	    for (start = 0; start < startLength; start++) {
	      if (startValue[start] !== endValue[start]) {
	        break;
	      }
	    }
	
	    var minEnd = startLength - start;
	    for (end = 1; end <= minEnd; end++) {
	      if (startValue[startLength - end] !== endValue[endLength - end]) {
	        break;
	      }
	    }
	
	    var sliceTail = end > 1 ? 1 - end : undefined;
	    this._fallbackText = endValue.slice(start, sliceTail);
	    return this._fallbackText;
	  }
	});
	
	PooledClass.addPoolingTo(FallbackCompositionState);
	
	module.exports = FallbackCompositionState;

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(16);
	
	var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
	var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
	var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
	var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
	var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
	
	var HTMLDOMPropertyConfig = {
	  isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$')),
	  Properties: {
	    /**
	     * Standard Properties
	     */
	    accept: 0,
	    acceptCharset: 0,
	    accessKey: 0,
	    action: 0,
	    allowFullScreen: HAS_BOOLEAN_VALUE,
	    allowTransparency: 0,
	    alt: 0,
	    // specifies target context for links with `preload` type
	    as: 0,
	    async: HAS_BOOLEAN_VALUE,
	    autoComplete: 0,
	    // autoFocus is polyfilled/normalized by AutoFocusUtils
	    // autoFocus: HAS_BOOLEAN_VALUE,
	    autoPlay: HAS_BOOLEAN_VALUE,
	    capture: HAS_BOOLEAN_VALUE,
	    cellPadding: 0,
	    cellSpacing: 0,
	    charSet: 0,
	    challenge: 0,
	    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    cite: 0,
	    classID: 0,
	    className: 0,
	    cols: HAS_POSITIVE_NUMERIC_VALUE,
	    colSpan: 0,
	    content: 0,
	    contentEditable: 0,
	    contextMenu: 0,
	    controls: HAS_BOOLEAN_VALUE,
	    coords: 0,
	    crossOrigin: 0,
	    data: 0, // For `<object />` acts as `src`.
	    dateTime: 0,
	    'default': HAS_BOOLEAN_VALUE,
	    defer: HAS_BOOLEAN_VALUE,
	    dir: 0,
	    disabled: HAS_BOOLEAN_VALUE,
	    download: HAS_OVERLOADED_BOOLEAN_VALUE,
	    draggable: 0,
	    encType: 0,
	    form: 0,
	    formAction: 0,
	    formEncType: 0,
	    formMethod: 0,
	    formNoValidate: HAS_BOOLEAN_VALUE,
	    formTarget: 0,
	    frameBorder: 0,
	    headers: 0,
	    height: 0,
	    hidden: HAS_BOOLEAN_VALUE,
	    high: 0,
	    href: 0,
	    hrefLang: 0,
	    htmlFor: 0,
	    httpEquiv: 0,
	    icon: 0,
	    id: 0,
	    inputMode: 0,
	    integrity: 0,
	    is: 0,
	    keyParams: 0,
	    keyType: 0,
	    kind: 0,
	    label: 0,
	    lang: 0,
	    list: 0,
	    loop: HAS_BOOLEAN_VALUE,
	    low: 0,
	    manifest: 0,
	    marginHeight: 0,
	    marginWidth: 0,
	    max: 0,
	    maxLength: 0,
	    media: 0,
	    mediaGroup: 0,
	    method: 0,
	    min: 0,
	    minLength: 0,
	    // Caution; `option.selected` is not updated if `select.multiple` is
	    // disabled with `removeAttribute`.
	    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    name: 0,
	    nonce: 0,
	    noValidate: HAS_BOOLEAN_VALUE,
	    open: HAS_BOOLEAN_VALUE,
	    optimum: 0,
	    pattern: 0,
	    placeholder: 0,
	    playsInline: HAS_BOOLEAN_VALUE,
	    poster: 0,
	    preload: 0,
	    profile: 0,
	    radioGroup: 0,
	    readOnly: HAS_BOOLEAN_VALUE,
	    referrerPolicy: 0,
	    rel: 0,
	    required: HAS_BOOLEAN_VALUE,
	    reversed: HAS_BOOLEAN_VALUE,
	    role: 0,
	    rows: HAS_POSITIVE_NUMERIC_VALUE,
	    rowSpan: HAS_NUMERIC_VALUE,
	    sandbox: 0,
	    scope: 0,
	    scoped: HAS_BOOLEAN_VALUE,
	    scrolling: 0,
	    seamless: HAS_BOOLEAN_VALUE,
	    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    shape: 0,
	    size: HAS_POSITIVE_NUMERIC_VALUE,
	    sizes: 0,
	    span: HAS_POSITIVE_NUMERIC_VALUE,
	    spellCheck: 0,
	    src: 0,
	    srcDoc: 0,
	    srcLang: 0,
	    srcSet: 0,
	    start: HAS_NUMERIC_VALUE,
	    step: 0,
	    style: 0,
	    summary: 0,
	    tabIndex: 0,
	    target: 0,
	    title: 0,
	    // Setting .type throws on non-<input> tags
	    type: 0,
	    useMap: 0,
	    value: 0,
	    width: 0,
	    wmode: 0,
	    wrap: 0,
	
	    /**
	     * RDFa Properties
	     */
	    about: 0,
	    datatype: 0,
	    inlist: 0,
	    prefix: 0,
	    // property is also supported for OpenGraph in meta tags.
	    property: 0,
	    resource: 0,
	    'typeof': 0,
	    vocab: 0,
	
	    /**
	     * Non-standard Properties
	     */
	    // autoCapitalize and autoCorrect are supported in Mobile Safari for
	    // keyboard hints.
	    autoCapitalize: 0,
	    autoCorrect: 0,
	    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
	    autoSave: 0,
	    // color is for Safari mask-icon link
	    color: 0,
	    // itemProp, itemScope, itemType are for
	    // Microdata support. See http://schema.org/docs/gs.html
	    itemProp: 0,
	    itemScope: HAS_BOOLEAN_VALUE,
	    itemType: 0,
	    // itemID and itemRef are for Microdata support as well but
	    // only specified in the WHATWG spec document. See
	    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
	    itemID: 0,
	    itemRef: 0,
	    // results show looking glass icon and recent searches on input
	    // search fields in WebKit/Blink
	    results: 0,
	    // IE-only attribute that specifies security restrictions on an iframe
	    // as an alternative to the sandbox attribute on IE<10
	    security: 0,
	    // IE-only attribute that controls focus behavior
	    unselectable: 0
	  },
	  DOMAttributeNames: {
	    acceptCharset: 'accept-charset',
	    className: 'class',
	    htmlFor: 'for',
	    httpEquiv: 'http-equiv'
	  },
	  DOMPropertyNames: {}
	};
	
	module.exports = HTMLDOMPropertyConfig;

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactReconciler = __webpack_require__(22);
	
	var instantiateReactComponent = __webpack_require__(75);
	var KeyEscapeUtils = __webpack_require__(38);
	var shouldUpdateReactComponent = __webpack_require__(48);
	var traverseAllChildren = __webpack_require__(78);
	var warning = __webpack_require__(4);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(8);
	}
	
	function instantiateChild(childInstances, child, name, selfDebugID) {
	  // We found a component instance.
	  var keyUnique = childInstances[name] === undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    if (!ReactComponentTreeHook) {
	      ReactComponentTreeHook = __webpack_require__(8);
	    }
	    if (!keyUnique) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
	    }
	  }
	  if (child != null && keyUnique) {
	    childInstances[name] = instantiateReactComponent(child, true);
	  }
	}
	
	/**
	 * ReactChildReconciler provides helpers for initializing or updating a set of
	 * children. Its output is suitable for passing it onto ReactMultiChild which
	 * does diffed reordering and insertion.
	 */
	var ReactChildReconciler = {
	  /**
	   * Generates a "mount image" for each of the supplied children. In the case
	   * of `ReactDOMComponent`, a mount image is a string of markup.
	   *
	   * @param {?object} nestedChildNodes Nested child maps.
	   * @return {?object} A set of child instances.
	   * @internal
	   */
	  instantiateChildren: function (nestedChildNodes, transaction, context, selfDebugID // 0 in production and for roots
	  ) {
	    if (nestedChildNodes == null) {
	      return null;
	    }
	    var childInstances = {};
	
	    if (process.env.NODE_ENV !== 'production') {
	      traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {
	        return instantiateChild(childInsts, child, name, selfDebugID);
	      }, childInstances);
	    } else {
	      traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
	    }
	    return childInstances;
	  },
	
	  /**
	   * Updates the rendered children and returns a new set of children.
	   *
	   * @param {?object} prevChildren Previously initialized set of children.
	   * @param {?object} nextChildren Flat child element maps.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @return {?object} A new set of child instances.
	   * @internal
	   */
	  updateChildren: function (prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID // 0 in production and for roots
	  ) {
	    // We currently don't have a way to track moves here but if we use iterators
	    // instead of for..in we can zip the iterators and check if an item has
	    // moved.
	    // TODO: If nothing has changed, return the prevChildren object so that we
	    // can quickly bailout if nothing has changed.
	    if (!nextChildren && !prevChildren) {
	      return;
	    }
	    var name;
	    var prevChild;
	    for (name in nextChildren) {
	      if (!nextChildren.hasOwnProperty(name)) {
	        continue;
	      }
	      prevChild = prevChildren && prevChildren[name];
	      var prevElement = prevChild && prevChild._currentElement;
	      var nextElement = nextChildren[name];
	      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
	        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
	        nextChildren[name] = prevChild;
	      } else {
	        if (prevChild) {
	          removedNodes[name] = ReactReconciler.getHostNode(prevChild);
	          ReactReconciler.unmountComponent(prevChild, false);
	        }
	        // The child must be instantiated before it's mounted.
	        var nextChildInstance = instantiateReactComponent(nextElement, true);
	        nextChildren[name] = nextChildInstance;
	        // Creating mount image now ensures refs are resolved in right order
	        // (see https://github.com/facebook/react/pull/7101 for explanation).
	        var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);
	        mountImages.push(nextChildMountImage);
	      }
	    }
	    // Unmount children that are no longer present.
	    for (name in prevChildren) {
	      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	        prevChild = prevChildren[name];
	        removedNodes[name] = ReactReconciler.getHostNode(prevChild);
	        ReactReconciler.unmountComponent(prevChild, false);
	      }
	    }
	  },
	
	  /**
	   * Unmounts all rendered children. This should be used to clean up children
	   * when this component is unmounted.
	   *
	   * @param {?object} renderedChildren Previously initialized set of children.
	   * @internal
	   */
	  unmountChildren: function (renderedChildren, safely) {
	    for (var name in renderedChildren) {
	      if (renderedChildren.hasOwnProperty(name)) {
	        var renderedChild = renderedChildren[name];
	        ReactReconciler.unmountComponent(renderedChild, safely);
	      }
	    }
	  }
	
	};
	
	module.exports = ReactChildReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(35);
	var ReactDOMIDOperations = __webpack_require__(117);
	
	/**
	 * Abstracts away all functionality of the reconciler that requires knowledge of
	 * the browser context. TODO: These callers should be refactored to avoid the
	 * need for this injection.
	 */
	var ReactComponentBrowserEnvironment = {
	
	  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
	
	  replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup
	
	};
	
	module.exports = ReactComponentBrowserEnvironment;

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3),
	    _assign = __webpack_require__(6);
	
	var React = __webpack_require__(23);
	var ReactComponentEnvironment = __webpack_require__(40);
	var ReactCurrentOwner = __webpack_require__(11);
	var ReactErrorUtils = __webpack_require__(41);
	var ReactInstanceMap = __webpack_require__(26);
	var ReactInstrumentation = __webpack_require__(9);
	var ReactNodeTypes = __webpack_require__(68);
	var ReactReconciler = __webpack_require__(22);
	
	if (process.env.NODE_ENV !== 'production') {
	  var checkReactTypeSpec = __webpack_require__(159);
	}
	
	var emptyObject = __webpack_require__(80);
	var invariant = __webpack_require__(2);
	var shallowEqual = __webpack_require__(50);
	var shouldUpdateReactComponent = __webpack_require__(48);
	var warning = __webpack_require__(4);
	
	var CompositeTypes = {
	  ImpureClass: 0,
	  PureClass: 1,
	  StatelessFunctional: 2
	};
	
	function StatelessComponent(Component) {}
	StatelessComponent.prototype.render = function () {
	  var Component = ReactInstanceMap.get(this)._currentElement.type;
	  var element = Component(this.props, this.context, this.updater);
	  warnIfInvalidElement(Component, element);
	  return element;
	};
	
	function warnIfInvalidElement(Component, element) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(element === null || element === false || React.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;
	  }
	}
	
	function shouldConstruct(Component) {
	  return !!(Component.prototype && Component.prototype.isReactComponent);
	}
	
	function isPureComponent(Component) {
	  return !!(Component.prototype && Component.prototype.isPureReactComponent);
	}
	
	// Separated into a function to contain deoptimizations caused by try/finally.
	function measureLifeCyclePerf(fn, debugID, timerType) {
	  if (debugID === 0) {
	    // Top-level wrappers (see ReactMount) and empty components (see
	    // ReactDOMEmptyComponent) are invisible to hooks and devtools.
	    // Both are implementation details that should go away in the future.
	    return fn();
	  }
	
	  ReactInstrumentation.debugTool.onBeginLifeCycleTimer(debugID, timerType);
	  try {
	    return fn();
	  } finally {
	    ReactInstrumentation.debugTool.onEndLifeCycleTimer(debugID, timerType);
	  }
	}
	
	/**
	 * ------------------ The Life-Cycle of a Composite Component ------------------
	 *
	 * - constructor: Initialization of state. The instance is now retained.
	 *   - componentWillMount
	 *   - render
	 *   - [children's constructors]
	 *     - [children's componentWillMount and render]
	 *     - [children's componentDidMount]
	 *     - componentDidMount
	 *
	 *       Update Phases:
	 *       - componentWillReceiveProps (only called if parent updated)
	 *       - shouldComponentUpdate
	 *         - componentWillUpdate
	 *           - render
	 *           - [children's constructors or receive props phases]
	 *         - componentDidUpdate
	 *
	 *     - componentWillUnmount
	 *     - [children's componentWillUnmount]
	 *   - [children destroyed]
	 * - (destroyed): The instance is now blank, released by React and ready for GC.
	 *
	 * -----------------------------------------------------------------------------
	 */
	
	/**
	 * An incrementing ID assigned to each component when it is mounted. This is
	 * used to enforce the order in which `ReactUpdates` updates dirty components.
	 *
	 * @private
	 */
	var nextMountID = 1;
	
	/**
	 * @lends {ReactCompositeComponent.prototype}
	 */
	var ReactCompositeComponent = {
	
	  /**
	   * Base constructor for all composite component.
	   *
	   * @param {ReactElement} element
	   * @final
	   * @internal
	   */
	  construct: function (element) {
	    this._currentElement = element;
	    this._rootNodeID = 0;
	    this._compositeType = null;
	    this._instance = null;
	    this._hostParent = null;
	    this._hostContainerInfo = null;
	
	    // See ReactUpdateQueue
	    this._updateBatchNumber = null;
	    this._pendingElement = null;
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    this._renderedNodeType = null;
	    this._renderedComponent = null;
	    this._context = null;
	    this._mountOrder = 0;
	    this._topLevelWrapper = null;
	
	    // See ReactUpdates and ReactUpdateQueue.
	    this._pendingCallbacks = null;
	
	    // ComponentWillUnmount shall only be called once
	    this._calledComponentWillUnmount = false;
	
	    if (process.env.NODE_ENV !== 'production') {
	      this._warnedAboutRefsInRender = false;
	    }
	  },
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?object} hostParent
	   * @param {?object} hostContainerInfo
	   * @param {?object} context
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    var _this = this;
	
	    this._context = context;
	    this._mountOrder = nextMountID++;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var publicProps = this._currentElement.props;
	    var publicContext = this._processContext(context);
	
	    var Component = this._currentElement.type;
	
	    var updateQueue = transaction.getUpdateQueue();
	
	    // Initialize the public class
	    var doConstruct = shouldConstruct(Component);
	    var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
	    var renderedElement;
	
	    // Support functional components
	    if (!doConstruct && (inst == null || inst.render == null)) {
	      renderedElement = inst;
	      warnIfInvalidElement(Component, renderedElement);
	      !(inst === null || inst === false || React.isValidElement(inst)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component.displayName || Component.name || 'Component') : void 0;
	      inst = new StatelessComponent(Component);
	      this._compositeType = CompositeTypes.StatelessFunctional;
	    } else {
	      if (isPureComponent(Component)) {
	        this._compositeType = CompositeTypes.PureClass;
	      } else {
	        this._compositeType = CompositeTypes.ImpureClass;
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This will throw later in _renderValidatedComponent, but add an early
	      // warning now to help debugging
	      if (inst.render == null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;
	      }
	
	      var propsMutated = inst.props !== publicProps;
	      var componentName = Component.displayName || Component.name || 'Component';
	
	      process.env.NODE_ENV !== 'production' ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + 'up the same props that your component\'s constructor was passed.', componentName, componentName) : void 0;
	    }
	
	    // These should be set up in the constructor, but as a convenience for
	    // simpler class abstractions, we set them up after the fact.
	    inst.props = publicProps;
	    inst.context = publicContext;
	    inst.refs = emptyObject;
	    inst.updater = updateQueue;
	
	    this._instance = inst;
	
	    // Store a reference from the instance back to the internal representation
	    ReactInstanceMap.set(inst, this);
	
	    if (process.env.NODE_ENV !== 'production') {
	      // Since plain JS classes are defined without any special initialization
	      // logic, we can not catch common errors early. Therefore, we have to
	      // catch them here, at initialization time, instead.
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;
	    }
	
	    var initialState = inst.state;
	    if (initialState === undefined) {
	      inst.state = initialState = null;
	    }
	    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : _prodInvariant('106', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    var markup;
	    if (inst.unstable_handleError) {
	      markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    } else {
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    }
	
	    if (inst.componentDidMount) {
	      if (process.env.NODE_ENV !== 'production') {
	        transaction.getReactMountReady().enqueue(function () {
	          measureLifeCyclePerf(function () {
	            return inst.componentDidMount();
	          }, _this._debugID, 'componentDidMount');
	        });
	      } else {
	        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
	      }
	    }
	
	    return markup;
	  },
	
	  _constructComponent: function (doConstruct, publicProps, publicContext, updateQueue) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactCurrentOwner.current = this;
	      try {
	        return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
	      } finally {
	        ReactCurrentOwner.current = null;
	      }
	    } else {
	      return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
	    }
	  },
	
	  _constructComponentWithoutOwner: function (doConstruct, publicProps, publicContext, updateQueue) {
	    var Component = this._currentElement.type;
	
	    if (doConstruct) {
	      if (process.env.NODE_ENV !== 'production') {
	        return measureLifeCyclePerf(function () {
	          return new Component(publicProps, publicContext, updateQueue);
	        }, this._debugID, 'ctor');
	      } else {
	        return new Component(publicProps, publicContext, updateQueue);
	      }
	    }
	
	    // This can still be an instance in case of factory components
	    // but we'll count this as time spent rendering as the more common case.
	    if (process.env.NODE_ENV !== 'production') {
	      return measureLifeCyclePerf(function () {
	        return Component(publicProps, publicContext, updateQueue);
	      }, this._debugID, 'render');
	    } else {
	      return Component(publicProps, publicContext, updateQueue);
	    }
	  },
	
	  performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
	    var markup;
	    var checkpoint = transaction.checkpoint();
	    try {
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    } catch (e) {
	      // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
	      transaction.rollback(checkpoint);
	      this._instance.unstable_handleError(e);
	      if (this._pendingStateQueue) {
	        this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
	      }
	      checkpoint = transaction.checkpoint();
	
	      this._renderedComponent.unmountComponent(true);
	      transaction.rollback(checkpoint);
	
	      // Try again - we've informed the component about the error, so they can render an error message this time.
	      // If this throws again, the error will bubble up (and can be caught by a higher error boundary).
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    }
	    return markup;
	  },
	
	  performInitialMount: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
	    var inst = this._instance;
	
	    var debugID = 0;
	    if (process.env.NODE_ENV !== 'production') {
	      debugID = this._debugID;
	    }
	
	    if (inst.componentWillMount) {
	      if (process.env.NODE_ENV !== 'production') {
	        measureLifeCyclePerf(function () {
	          return inst.componentWillMount();
	        }, debugID, 'componentWillMount');
	      } else {
	        inst.componentWillMount();
	      }
	      // When mounting, calls to `setState` by `componentWillMount` will set
	      // `this._pendingStateQueue` without triggering a re-render.
	      if (this._pendingStateQueue) {
	        inst.state = this._processPendingState(inst.props, inst.context);
	      }
	    }
	
	    // If not a stateless component, we now render
	    if (renderedElement === undefined) {
	      renderedElement = this._renderValidatedComponent();
	    }
	
	    var nodeType = ReactNodeTypes.getType(renderedElement);
	    this._renderedNodeType = nodeType;
	    var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
	    );
	    this._renderedComponent = child;
	
	    var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), debugID);
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (debugID !== 0) {
	        var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
	        ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
	      }
	    }
	
	    return markup;
	  },
	
	  getHostNode: function () {
	    return ReactReconciler.getHostNode(this._renderedComponent);
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function (safely) {
	    if (!this._renderedComponent) {
	      return;
	    }
	
	    var inst = this._instance;
	
	    if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
	      inst._calledComponentWillUnmount = true;
	
	      if (safely) {
	        var name = this.getName() + '.componentWillUnmount()';
	        ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          measureLifeCyclePerf(function () {
	            return inst.componentWillUnmount();
	          }, this._debugID, 'componentWillUnmount');
	        } else {
	          inst.componentWillUnmount();
	        }
	      }
	    }
	
	    if (this._renderedComponent) {
	      ReactReconciler.unmountComponent(this._renderedComponent, safely);
	      this._renderedNodeType = null;
	      this._renderedComponent = null;
	      this._instance = null;
	    }
	
	    // Reset pending fields
	    // Even if this component is scheduled for another update in ReactUpdates,
	    // it would still be ignored because these fields are reset.
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	    this._pendingCallbacks = null;
	    this._pendingElement = null;
	
	    // These fields do not really need to be reset since this object is no
	    // longer accessible.
	    this._context = null;
	    this._rootNodeID = 0;
	    this._topLevelWrapper = null;
	
	    // Delete the reference from the instance to this internal representation
	    // which allow the internals to be properly cleaned up even if the user
	    // leaks a reference to the public instance.
	    ReactInstanceMap.remove(inst);
	
	    // Some existing components rely on inst.props even after they've been
	    // destroyed (in event handlers).
	    // TODO: inst.props = null;
	    // TODO: inst.state = null;
	    // TODO: inst.context = null;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _maskContext: function (context) {
	    var Component = this._currentElement.type;
	    var contextTypes = Component.contextTypes;
	    if (!contextTypes) {
	      return emptyObject;
	    }
	    var maskedContext = {};
	    for (var contextName in contextTypes) {
	      maskedContext[contextName] = context[contextName];
	    }
	    return maskedContext;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`, and asserts that they are valid.
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _processContext: function (context) {
	    var maskedContext = this._maskContext(context);
	    if (process.env.NODE_ENV !== 'production') {
	      var Component = this._currentElement.type;
	      if (Component.contextTypes) {
	        this._checkContextTypes(Component.contextTypes, maskedContext, 'context');
	      }
	    }
	    return maskedContext;
	  },
	
	  /**
	   * @param {object} currentContext
	   * @return {object}
	   * @private
	   */
	  _processChildContext: function (currentContext) {
	    var Component = this._currentElement.type;
	    var inst = this._instance;
	    var childContext;
	
	    if (inst.getChildContext) {
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onBeginProcessingChildContext();
	        try {
	          childContext = inst.getChildContext();
	        } finally {
	          ReactInstrumentation.debugTool.onEndProcessingChildContext();
	        }
	      } else {
	        childContext = inst.getChildContext();
	      }
	    }
	
	    if (childContext) {
	      !(typeof Component.childContextTypes === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant('107', this.getName() || 'ReactCompositeComponent') : void 0;
	      if (process.env.NODE_ENV !== 'production') {
	        this._checkContextTypes(Component.childContextTypes, childContext, 'childContext');
	      }
	      for (var name in childContext) {
	        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant('108', this.getName() || 'ReactCompositeComponent', name) : void 0;
	      }
	      return _assign({}, currentContext, childContext);
	    }
	    return currentContext;
	  },
	
	  /**
	   * Assert that the context types are valid
	   *
	   * @param {object} typeSpecs Map of context field to a ReactPropType
	   * @param {object} values Runtime values that need to be type-checked
	   * @param {string} location e.g. "prop", "context", "child context"
	   * @private
	   */
	  _checkContextTypes: function (typeSpecs, values, location) {
	    if (process.env.NODE_ENV !== 'production') {
	      checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);
	    }
	  },
	
	  receiveComponent: function (nextElement, transaction, nextContext) {
	    var prevElement = this._currentElement;
	    var prevContext = this._context;
	
	    this._pendingElement = null;
	
	    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
	  },
	
	  /**
	   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
	   * is set, update the component.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (transaction) {
	    if (this._pendingElement != null) {
	      ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
	    } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
	      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
	    } else {
	      this._updateBatchNumber = null;
	    }
	  },
	
	  /**
	   * Perform an update to a mounted component. The componentWillReceiveProps and
	   * shouldComponentUpdate methods are called, then (assuming the update isn't
	   * skipped) the remaining update lifecycle methods are called and the DOM
	   * representation is updated.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevParentElement
	   * @param {ReactElement} nextParentElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
	    var inst = this._instance;
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant('136', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    var willReceive = false;
	    var nextContext;
	
	    // Determine if the context has changed or not
	    if (this._context === nextUnmaskedContext) {
	      nextContext = inst.context;
	    } else {
	      nextContext = this._processContext(nextUnmaskedContext);
	      willReceive = true;
	    }
	
	    var prevProps = prevParentElement.props;
	    var nextProps = nextParentElement.props;
	
	    // Not a simple state update but a props update
	    if (prevParentElement !== nextParentElement) {
	      willReceive = true;
	    }
	
	    // An update here will schedule an update but immediately set
	    // _pendingStateQueue which will ensure that any state updates gets
	    // immediately reconciled instead of waiting for the next batch.
	    if (willReceive && inst.componentWillReceiveProps) {
	      if (process.env.NODE_ENV !== 'production') {
	        measureLifeCyclePerf(function () {
	          return inst.componentWillReceiveProps(nextProps, nextContext);
	        }, this._debugID, 'componentWillReceiveProps');
	      } else {
	        inst.componentWillReceiveProps(nextProps, nextContext);
	      }
	    }
	
	    var nextState = this._processPendingState(nextProps, nextContext);
	    var shouldUpdate = true;
	
	    if (!this._pendingForceUpdate) {
	      if (inst.shouldComponentUpdate) {
	        if (process.env.NODE_ENV !== 'production') {
	          shouldUpdate = measureLifeCyclePerf(function () {
	            return inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	          }, this._debugID, 'shouldComponentUpdate');
	        } else {
	          shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	        }
	      } else {
	        if (this._compositeType === CompositeTypes.PureClass) {
	          shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
	        }
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;
	    }
	
	    this._updateBatchNumber = null;
	    if (shouldUpdate) {
	      this._pendingForceUpdate = false;
	      // Will set `this.props`, `this.state` and `this.context`.
	      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
	    } else {
	      // If it's determined that a component should not update, we still want
	      // to set props and state but we shortcut the rest of the update.
	      this._currentElement = nextParentElement;
	      this._context = nextUnmaskedContext;
	      inst.props = nextProps;
	      inst.state = nextState;
	      inst.context = nextContext;
	    }
	  },
	
	  _processPendingState: function (props, context) {
	    var inst = this._instance;
	    var queue = this._pendingStateQueue;
	    var replace = this._pendingReplaceState;
	    this._pendingReplaceState = false;
	    this._pendingStateQueue = null;
	
	    if (!queue) {
	      return inst.state;
	    }
	
	    if (replace && queue.length === 1) {
	      return queue[0];
	    }
	
	    var nextState = _assign({}, replace ? queue[0] : inst.state);
	    for (var i = replace ? 1 : 0; i < queue.length; i++) {
	      var partial = queue[i];
	      _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
	    }
	
	    return nextState;
	  },
	
	  /**
	   * Merges new props and state, notifies delegate methods of update and
	   * performs update.
	   *
	   * @param {ReactElement} nextElement Next element
	   * @param {object} nextProps Next public object to set as properties.
	   * @param {?object} nextState Next object to set as state.
	   * @param {?object} nextContext Next public object to set as context.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?object} unmaskedContext
	   * @private
	   */
	  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
	    var _this2 = this;
	
	    var inst = this._instance;
	
	    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
	    var prevProps;
	    var prevState;
	    var prevContext;
	    if (hasComponentDidUpdate) {
	      prevProps = inst.props;
	      prevState = inst.state;
	      prevContext = inst.context;
	    }
	
	    if (inst.componentWillUpdate) {
	      if (process.env.NODE_ENV !== 'production') {
	        measureLifeCyclePerf(function () {
	          return inst.componentWillUpdate(nextProps, nextState, nextContext);
	        }, this._debugID, 'componentWillUpdate');
	      } else {
	        inst.componentWillUpdate(nextProps, nextState, nextContext);
	      }
	    }
	
	    this._currentElement = nextElement;
	    this._context = unmaskedContext;
	    inst.props = nextProps;
	    inst.state = nextState;
	    inst.context = nextContext;
	
	    this._updateRenderedComponent(transaction, unmaskedContext);
	
	    if (hasComponentDidUpdate) {
	      if (process.env.NODE_ENV !== 'production') {
	        transaction.getReactMountReady().enqueue(function () {
	          measureLifeCyclePerf(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), _this2._debugID, 'componentDidUpdate');
	        });
	      } else {
	        transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
	      }
	    }
	  },
	
	  /**
	   * Call the component's `render` method and update the DOM accordingly.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  _updateRenderedComponent: function (transaction, context) {
	    var prevComponentInstance = this._renderedComponent;
	    var prevRenderedElement = prevComponentInstance._currentElement;
	    var nextRenderedElement = this._renderValidatedComponent();
	
	    var debugID = 0;
	    if (process.env.NODE_ENV !== 'production') {
	      debugID = this._debugID;
	    }
	
	    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
	      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
	    } else {
	      var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
	      ReactReconciler.unmountComponent(prevComponentInstance, false);
	
	      var nodeType = ReactNodeTypes.getType(nextRenderedElement);
	      this._renderedNodeType = nodeType;
	      var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
	      );
	      this._renderedComponent = child;
	
	      var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), debugID);
	
	      if (process.env.NODE_ENV !== 'production') {
	        if (debugID !== 0) {
	          var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
	          ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
	        }
	      }
	
	      this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
	    }
	  },
	
	  /**
	   * Overridden in shallow rendering.
	   *
	   * @protected
	   */
	  _replaceNodeWithMarkup: function (oldHostNode, nextMarkup, prevInstance) {
	    ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
	  },
	
	  /**
	   * @protected
	   */
	  _renderValidatedComponentWithoutOwnerOrContext: function () {
	    var inst = this._instance;
	    var renderedElement;
	
	    if (process.env.NODE_ENV !== 'production') {
	      renderedElement = measureLifeCyclePerf(function () {
	        return inst.render();
	      }, this._debugID, 'render');
	    } else {
	      renderedElement = inst.render();
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // We allow auto-mocks to proceed as if they're returning null.
	      if (renderedElement === undefined && inst.render._isMockFunction) {
	        // This is probably bad practice. Consider warning here and
	        // deprecating this convenience.
	        renderedElement = null;
	      }
	    }
	
	    return renderedElement;
	  },
	
	  /**
	   * @private
	   */
	  _renderValidatedComponent: function () {
	    var renderedElement;
	    if (process.env.NODE_ENV !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {
	      ReactCurrentOwner.current = this;
	      try {
	        renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
	      } finally {
	        ReactCurrentOwner.current = null;
	      }
	    } else {
	      renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
	    }
	    !(
	    // TODO: An `isValidNode` function would probably be more appropriate
	    renderedElement === null || renderedElement === false || React.isValidElement(renderedElement)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant('109', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    return renderedElement;
	  },
	
	  /**
	   * Lazily allocates the refs object and stores `component` as `ref`.
	   *
	   * @param {string} ref Reference name.
	   * @param {component} component Component to store as `ref`.
	   * @final
	   * @private
	   */
	  attachRef: function (ref, component) {
	    var inst = this.getPublicInstance();
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : _prodInvariant('110') : void 0;
	    var publicComponentInstance = component.getPublicInstance();
	    if (process.env.NODE_ENV !== 'production') {
	      var componentName = component && component.getName ? component.getName() : 'a component';
	      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null || component._compositeType !== CompositeTypes.StatelessFunctional, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
	    }
	    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
	    refs[ref] = publicComponentInstance;
	  },
	
	  /**
	   * Detaches a reference name.
	   *
	   * @param {string} ref Name to dereference.
	   * @final
	   * @private
	   */
	  detachRef: function (ref) {
	    var refs = this.getPublicInstance().refs;
	    delete refs[ref];
	  },
	
	  /**
	   * Get a text description of the component that can be used to identify it
	   * in error messages.
	   * @return {string} The name or null.
	   * @internal
	   */
	  getName: function () {
	    var type = this._currentElement.type;
	    var constructor = this._instance && this._instance.constructor;
	    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
	  },
	
	  /**
	   * Get the publicly accessible representation of this component - i.e. what
	   * is exposed by refs and returned by render. Can be null for stateless
	   * components.
	   *
	   * @return {ReactComponent} the public component instance.
	   * @internal
	   */
	  getPublicInstance: function () {
	    var inst = this._instance;
	    if (this._compositeType === CompositeTypes.StatelessFunctional) {
	      return null;
	    }
	    return inst;
	  },
	
	  // Stub
	  _instantiateReactComponent: null
	
	};
	
	module.exports = ReactCompositeComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/
	
	'use strict';
	
	var ReactDOMComponentTree = __webpack_require__(5);
	var ReactDefaultInjection = __webpack_require__(129);
	var ReactMount = __webpack_require__(67);
	var ReactReconciler = __webpack_require__(22);
	var ReactUpdates = __webpack_require__(10);
	var ReactVersion = __webpack_require__(144);
	
	var findDOMNode = __webpack_require__(161);
	var getHostComponentFromComposite = __webpack_require__(73);
	var renderSubtreeIntoContainer = __webpack_require__(169);
	var warning = __webpack_require__(4);
	
	ReactDefaultInjection.inject();
	
	var ReactDOM = {
	  findDOMNode: findDOMNode,
	  render: ReactMount.render,
	  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
	  version: ReactVersion,
	
	  /* eslint-disable camelcase */
	  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
	  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
	};
	
	// Inject the runtime into a devtools global hook regardless of browser.
	// Allows for debugging when the hook is injected on the page.
	if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
	  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
	    ComponentTree: {
	      getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
	      getNodeFromInstance: function (inst) {
	        // inst is an internal instance (but could be a composite)
	        if (inst._renderedComponent) {
	          inst = getHostComponentFromComposite(inst);
	        }
	        if (inst) {
	          return ReactDOMComponentTree.getNodeFromInstance(inst);
	        } else {
	          return null;
	        }
	      }
	    },
	    Mount: ReactMount,
	    Reconciler: ReactReconciler
	  });
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var ExecutionEnvironment = __webpack_require__(7);
	  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
	
	    // First check if devtools is not installed
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
	      // If we're in Chrome or Firefox, provide a download link if not installed.
	      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
	        // Firefox does not have the issue with devtools loaded over file://
	        var showFileUrlMessage = window.location.protocol.indexOf('http') === -1 && navigator.userAgent.indexOf('Firefox') === -1;
	        console.debug('Download the React DevTools ' + (showFileUrlMessage ? 'and use an HTTP server (instead of a file: URL) ' : '') + 'for a better development experience: ' + 'https://fb.me/react-devtools');
	      }
	    }
	
	    var testFunc = function testFn() {};
	    process.env.NODE_ENV !== 'production' ? warning((testFunc.name || testFunc.toString()).indexOf('testFn') !== -1, 'It looks like you\'re using a minified copy of the development build ' + 'of React. When deploying React apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See https://fb.me/react-minification for more details.') : void 0;
	
	    // If we're in IE8, check to see if we are in compatibility mode and provide
	    // information on preventing compatibility mode
	    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;
	
	    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : void 0;
	
	    var expectedFeatures = [
	    // shims
	    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.trim];
	
	    for (var i = 0; i < expectedFeatures.length; i++) {
	      if (!expectedFeatures[i]) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'One or more ES5 shims expected by React are not available: ' + 'https://fb.me/react-warning-polyfills') : void 0;
	        break;
	      }
	    }
	  }
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactInstrumentation = __webpack_require__(9);
	  var ReactDOMUnknownPropertyHook = __webpack_require__(126);
	  var ReactDOMNullInputValuePropHook = __webpack_require__(120);
	  var ReactDOMInvalidARIAHook = __webpack_require__(119);
	
	  ReactInstrumentation.debugTool.addHook(ReactDOMUnknownPropertyHook);
	  ReactInstrumentation.debugTool.addHook(ReactDOMNullInputValuePropHook);
	  ReactInstrumentation.debugTool.addHook(ReactDOMInvalidARIAHook);
	}
	
	module.exports = ReactDOM;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/* global hasOwnProperty:true */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3),
	    _assign = __webpack_require__(6);
	
	var AutoFocusUtils = __webpack_require__(100);
	var CSSPropertyOperations = __webpack_require__(102);
	var DOMLazyTree = __webpack_require__(21);
	var DOMNamespaces = __webpack_require__(36);
	var DOMProperty = __webpack_require__(16);
	var DOMPropertyOperations = __webpack_require__(60);
	var EventPluginHub = __webpack_require__(24);
	var EventPluginRegistry = __webpack_require__(28);
	var ReactBrowserEventEmitter = __webpack_require__(29);
	var ReactDOMComponentFlags = __webpack_require__(61);
	var ReactDOMComponentTree = __webpack_require__(5);
	var ReactDOMInput = __webpack_require__(118);
	var ReactDOMOption = __webpack_require__(121);
	var ReactDOMSelect = __webpack_require__(62);
	var ReactDOMTextarea = __webpack_require__(124);
	var ReactInstrumentation = __webpack_require__(9);
	var ReactMultiChild = __webpack_require__(137);
	var ReactServerRenderingTransaction = __webpack_require__(142);
	
	var emptyFunction = __webpack_require__(15);
	var escapeTextContentForBrowser = __webpack_require__(32);
	var invariant = __webpack_require__(2);
	var isEventSupported = __webpack_require__(47);
	var shallowEqual = __webpack_require__(50);
	var validateDOMNesting = __webpack_require__(49);
	var warning = __webpack_require__(4);
	
	var Flags = ReactDOMComponentFlags;
	var deleteListener = EventPluginHub.deleteListener;
	var getNode = ReactDOMComponentTree.getNodeFromInstance;
	var listenTo = ReactBrowserEventEmitter.listenTo;
	var registrationNameModules = EventPluginRegistry.registrationNameModules;
	
	// For quickly matching children type, to test if can be treated as content.
	var CONTENT_TYPES = { 'string': true, 'number': true };
	
	var STYLE = 'style';
	var HTML = '__html';
	var RESERVED_PROPS = {
	  children: null,
	  dangerouslySetInnerHTML: null,
	  suppressContentEditableWarning: null
	};
	
	// Node type for document fragments (Node.DOCUMENT_FRAGMENT_NODE).
	var DOC_FRAGMENT_TYPE = 11;
	
	function getDeclarationErrorAddendum(internalInstance) {
	  if (internalInstance) {
	    var owner = internalInstance._currentElement._owner || null;
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' This DOM node was rendered by `' + name + '`.';
	      }
	    }
	  }
	  return '';
	}
	
	function friendlyStringify(obj) {
	  if (typeof obj === 'object') {
	    if (Array.isArray(obj)) {
	      return '[' + obj.map(friendlyStringify).join(', ') + ']';
	    } else {
	      var pairs = [];
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) {
	          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
	          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
	        }
	      }
	      return '{' + pairs.join(', ') + '}';
	    }
	  } else if (typeof obj === 'string') {
	    return JSON.stringify(obj);
	  } else if (typeof obj === 'function') {
	    return '[function object]';
	  }
	  // Differs from JSON.stringify in that undefined because undefined and that
	  // inf and nan don't become null
	  return String(obj);
	}
	
	var styleMutationWarning = {};
	
	function checkAndWarnForMutatedStyle(style1, style2, component) {
	  if (style1 == null || style2 == null) {
	    return;
	  }
	  if (shallowEqual(style1, style2)) {
	    return;
	  }
	
	  var componentName = component._tag;
	  var owner = component._currentElement._owner;
	  var ownerName;
	  if (owner) {
	    ownerName = owner.getName();
	  }
	
	  var hash = ownerName + '|' + componentName;
	
	  if (styleMutationWarning.hasOwnProperty(hash)) {
	    return;
	  }
	
	  styleMutationWarning[hash] = true;
	
	  process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : void 0;
	}
	
	/**
	 * @param {object} component
	 * @param {?object} props
	 */
	function assertValidProps(component, props) {
	  if (!props) {
	    return;
	  }
	  // Note the use of `==` which checks for null or undefined.
	  if (voidElementTags[component._tag]) {
	    !(props.children == null && props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : _prodInvariant('137', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : void 0;
	  }
	  if (props.dangerouslySetInnerHTML != null) {
	    !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : _prodInvariant('60') : void 0;
	    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : _prodInvariant('61') : void 0;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(props.onFocusIn == null && props.onFocusOut == null, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.') : void 0;
	  }
	  !(props.style == null || typeof props.style === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getDeclarationErrorAddendum(component)) : _prodInvariant('62', getDeclarationErrorAddendum(component)) : void 0;
	}
	
	function enqueuePutListener(inst, registrationName, listener, transaction) {
	  if (transaction instanceof ReactServerRenderingTransaction) {
	    return;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    // IE8 has no API for event capturing and the `onScroll` event doesn't
	    // bubble.
	    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : void 0;
	  }
	  var containerInfo = inst._hostContainerInfo;
	  var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
	  var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
	  listenTo(registrationName, doc);
	  transaction.getReactMountReady().enqueue(putListener, {
	    inst: inst,
	    registrationName: registrationName,
	    listener: listener
	  });
	}
	
	function putListener() {
	  var listenerToPut = this;
	  EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
	}
	
	function inputPostMount() {
	  var inst = this;
	  ReactDOMInput.postMountWrapper(inst);
	}
	
	function textareaPostMount() {
	  var inst = this;
	  ReactDOMTextarea.postMountWrapper(inst);
	}
	
	function optionPostMount() {
	  var inst = this;
	  ReactDOMOption.postMountWrapper(inst);
	}
	
	var setAndValidateContentChildDev = emptyFunction;
	if (process.env.NODE_ENV !== 'production') {
	  setAndValidateContentChildDev = function (content) {
	    var hasExistingContent = this._contentDebugID != null;
	    var debugID = this._debugID;
	    // This ID represents the inlined child that has no backing instance:
	    var contentDebugID = -debugID;
	
	    if (content == null) {
	      if (hasExistingContent) {
	        ReactInstrumentation.debugTool.onUnmountComponent(this._contentDebugID);
	      }
	      this._contentDebugID = null;
	      return;
	    }
	
	    validateDOMNesting(null, String(content), this, this._ancestorInfo);
	    this._contentDebugID = contentDebugID;
	    if (hasExistingContent) {
	      ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
	      ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
	    } else {
	      ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
	      ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
	      ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
	    }
	  };
	}
	
	// There are so many media events, it makes sense to just
	// maintain a list rather than create a `trapBubbledEvent` for each
	var mediaEvents = {
	  topAbort: 'abort',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTimeUpdate: 'timeupdate',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting'
	};
	
	function trapBubbledEventsLocal() {
	  var inst = this;
	  // If a component renders to null or if another component fatals and causes
	  // the state of the tree to be corrupted, `node` here can be null.
	  !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : _prodInvariant('63') : void 0;
	  var node = getNode(inst);
	  !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : _prodInvariant('64') : void 0;
	
	  switch (inst._tag) {
	    case 'iframe':
	    case 'object':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
	      break;
	    case 'video':
	    case 'audio':
	
	      inst._wrapperState.listeners = [];
	      // Create listener for each media event
	      for (var event in mediaEvents) {
	        if (mediaEvents.hasOwnProperty(event)) {
	          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(event, mediaEvents[event], node));
	        }
	      }
	      break;
	    case 'source':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node)];
	      break;
	    case 'img':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node), ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
	      break;
	    case 'form':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topReset', 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent('topSubmit', 'submit', node)];
	      break;
	    case 'input':
	    case 'select':
	    case 'textarea':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topInvalid', 'invalid', node)];
	      break;
	  }
	}
	
	function postUpdateSelectWrapper() {
	  ReactDOMSelect.postUpdateWrapper(this);
	}
	
	// For HTML, certain tags should omit their close tag. We keep a whitelist for
	// those special-case tags.
	
	var omittedCloseTags = {
	  'area': true,
	  'base': true,
	  'br': true,
	  'col': true,
	  'embed': true,
	  'hr': true,
	  'img': true,
	  'input': true,
	  'keygen': true,
	  'link': true,
	  'meta': true,
	  'param': true,
	  'source': true,
	  'track': true,
	  'wbr': true
	};
	
	var newlineEatingTags = {
	  'listing': true,
	  'pre': true,
	  'textarea': true
	};
	
	// For HTML, certain tags cannot have children. This has the same purpose as
	// `omittedCloseTags` except that `menuitem` should still have its closing tag.
	
	var voidElementTags = _assign({
	  'menuitem': true
	}, omittedCloseTags);
	
	// We accept any tag to be rendered but since this gets injected into arbitrary
	// HTML, we want to make sure that it's a safe tag.
	// http://www.w3.org/TR/REC-xml/#NT-Name
	
	var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
	var validatedTagCache = {};
	var hasOwnProperty = {}.hasOwnProperty;
	
	function validateDangerousTag(tag) {
	  if (!hasOwnProperty.call(validatedTagCache, tag)) {
	    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : _prodInvariant('65', tag) : void 0;
	    validatedTagCache[tag] = true;
	  }
	}
	
	function isCustomComponent(tagName, props) {
	  return tagName.indexOf('-') >= 0 || props.is != null;
	}
	
	var globalIdCounter = 1;
	
	/**
	 * Creates a new React class that is idempotent and capable of containing other
	 * React components. It accepts event listeners and DOM properties that are
	 * valid according to `DOMProperty`.
	 *
	 *  - Event listeners: `onClick`, `onMouseDown`, etc.
	 *  - DOM properties: `className`, `name`, `title`, etc.
	 *
	 * The `style` property functions differently from the DOM API. It accepts an
	 * object mapping of style properties to values.
	 *
	 * @constructor ReactDOMComponent
	 * @extends ReactMultiChild
	 */
	function ReactDOMComponent(element) {
	  var tag = element.type;
	  validateDangerousTag(tag);
	  this._currentElement = element;
	  this._tag = tag.toLowerCase();
	  this._namespaceURI = null;
	  this._renderedChildren = null;
	  this._previousStyle = null;
	  this._previousStyleCopy = null;
	  this._hostNode = null;
	  this._hostParent = null;
	  this._rootNodeID = 0;
	  this._domID = 0;
	  this._hostContainerInfo = null;
	  this._wrapperState = null;
	  this._topLevelWrapper = null;
	  this._flags = 0;
	  if (process.env.NODE_ENV !== 'production') {
	    this._ancestorInfo = null;
	    setAndValidateContentChildDev.call(this, null);
	  }
	}
	
	ReactDOMComponent.displayName = 'ReactDOMComponent';
	
	ReactDOMComponent.Mixin = {
	
	  /**
	   * Generates root tag markup then recurses. This method has side effects and
	   * is not idempotent.
	   *
	   * @internal
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?ReactDOMComponent} the parent component instance
	   * @param {?object} info about the host container
	   * @param {object} context
	   * @return {string} The computed markup.
	   */
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    this._rootNodeID = globalIdCounter++;
	    this._domID = hostContainerInfo._idCounter++;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var props = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'audio':
	      case 'form':
	      case 'iframe':
	      case 'img':
	      case 'link':
	      case 'object':
	      case 'source':
	      case 'video':
	        this._wrapperState = {
	          listeners: null
	        };
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'input':
	        ReactDOMInput.mountWrapper(this, props, hostParent);
	        props = ReactDOMInput.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'option':
	        ReactDOMOption.mountWrapper(this, props, hostParent);
	        props = ReactDOMOption.getHostProps(this, props);
	        break;
	      case 'select':
	        ReactDOMSelect.mountWrapper(this, props, hostParent);
	        props = ReactDOMSelect.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.mountWrapper(this, props, hostParent);
	        props = ReactDOMTextarea.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	    }
	
	    assertValidProps(this, props);
	
	    // We create tags in the namespace of their parent container, except HTML
	    // tags get no namespace.
	    var namespaceURI;
	    var parentTag;
	    if (hostParent != null) {
	      namespaceURI = hostParent._namespaceURI;
	      parentTag = hostParent._tag;
	    } else if (hostContainerInfo._tag) {
	      namespaceURI = hostContainerInfo._namespaceURI;
	      parentTag = hostContainerInfo._tag;
	    }
	    if (namespaceURI == null || namespaceURI === DOMNamespaces.svg && parentTag === 'foreignobject') {
	      namespaceURI = DOMNamespaces.html;
	    }
	    if (namespaceURI === DOMNamespaces.html) {
	      if (this._tag === 'svg') {
	        namespaceURI = DOMNamespaces.svg;
	      } else if (this._tag === 'math') {
	        namespaceURI = DOMNamespaces.mathml;
	      }
	    }
	    this._namespaceURI = namespaceURI;
	
	    if (process.env.NODE_ENV !== 'production') {
	      var parentInfo;
	      if (hostParent != null) {
	        parentInfo = hostParent._ancestorInfo;
	      } else if (hostContainerInfo._tag) {
	        parentInfo = hostContainerInfo._ancestorInfo;
	      }
	      if (parentInfo) {
	        // parentInfo should always be present except for the top-level
	        // component when server rendering
	        validateDOMNesting(this._tag, null, this, parentInfo);
	      }
	      this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
	    }
	
	    var mountImage;
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var el;
	      if (namespaceURI === DOMNamespaces.html) {
	        if (this._tag === 'script') {
	          // Create the script via .innerHTML so its "parser-inserted" flag is
	          // set to true and it does not execute
	          var div = ownerDocument.createElement('div');
	          var type = this._currentElement.type;
	          div.innerHTML = '<' + type + '></' + type + '>';
	          el = div.removeChild(div.firstChild);
	        } else if (props.is) {
	          el = ownerDocument.createElement(this._currentElement.type, props.is);
	        } else {
	          // Separate else branch instead of using `props.is || undefined` above becuase of a Firefox bug.
	          // See discussion in https://github.com/facebook/react/pull/6896
	          // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
	          el = ownerDocument.createElement(this._currentElement.type);
	        }
	      } else {
	        el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
	      }
	      ReactDOMComponentTree.precacheNode(this, el);
	      this._flags |= Flags.hasCachedChildNodes;
	      if (!this._hostParent) {
	        DOMPropertyOperations.setAttributeForRoot(el);
	      }
	      this._updateDOMProperties(null, props, transaction);
	      var lazyTree = DOMLazyTree(el);
	      this._createInitialChildren(transaction, props, context, lazyTree);
	      mountImage = lazyTree;
	    } else {
	      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
	      var tagContent = this._createContentMarkup(transaction, props, context);
	      if (!tagContent && omittedCloseTags[this._tag]) {
	        mountImage = tagOpen + '/>';
	      } else {
	        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
	      }
	    }
	
	    switch (this._tag) {
	      case 'input':
	        transaction.getReactMountReady().enqueue(inputPostMount, this);
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'textarea':
	        transaction.getReactMountReady().enqueue(textareaPostMount, this);
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'select':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'button':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'option':
	        transaction.getReactMountReady().enqueue(optionPostMount, this);
	        break;
	    }
	
	    return mountImage;
	  },
	
	  /**
	   * Creates markup for the open tag and all attributes.
	   *
	   * This method has side effects because events get registered.
	   *
	   * Iterating over object properties is faster than iterating over arrays.
	   * @see http://jsperf.com/obj-vs-arr-iteration
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @return {string} Markup of opening tag.
	   */
	  _createOpenTagMarkupAndPutListeners: function (transaction, props) {
	    var ret = '<' + this._currentElement.type;
	
	    for (var propKey in props) {
	      if (!props.hasOwnProperty(propKey)) {
	        continue;
	      }
	      var propValue = props[propKey];
	      if (propValue == null) {
	        continue;
	      }
	      if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (propValue) {
	          enqueuePutListener(this, propKey, propValue, transaction);
	        }
	      } else {
	        if (propKey === STYLE) {
	          if (propValue) {
	            if (process.env.NODE_ENV !== 'production') {
	              // See `_updateDOMProperties`. style block
	              this._previousStyle = propValue;
	            }
	            propValue = this._previousStyleCopy = _assign({}, props.style);
	          }
	          propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
	        }
	        var markup = null;
	        if (this._tag != null && isCustomComponent(this._tag, props)) {
	          if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
	          }
	        } else {
	          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
	        }
	        if (markup) {
	          ret += ' ' + markup;
	        }
	      }
	    }
	
	    // For static pages, no need to put React ID and checksum. Saves lots of
	    // bytes.
	    if (transaction.renderToStaticMarkup) {
	      return ret;
	    }
	
	    if (!this._hostParent) {
	      ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
	    }
	    ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
	    return ret;
	  },
	
	  /**
	   * Creates markup for the content between the tags.
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @param {object} context
	   * @return {string} Content markup.
	   */
	  _createContentMarkup: function (transaction, props, context) {
	    var ret = '';
	
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        ret = innerHTML.__html;
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        ret = escapeTextContentForBrowser(contentToUse);
	        if (process.env.NODE_ENV !== 'production') {
	          setAndValidateContentChildDev.call(this, contentToUse);
	        }
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        ret = mountImages.join('');
	      }
	    }
	    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
	      // text/html ignores the first character in these tags if it's a newline
	      // Prefer to break application/xml over text/html (for now) by adding
	      // a newline specifically to get eaten by the parser. (Alternately for
	      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
	      // \r is normalized out by HTMLTextAreaElement#value.)
	      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
	      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
	      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
	      // See: Parsing of "textarea" "listing" and "pre" elements
	      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
	      return '\n' + ret;
	    } else {
	      return ret;
	    }
	  },
	
	  _createInitialChildren: function (transaction, props, context, lazyTree) {
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        if (process.env.NODE_ENV !== 'production') {
	          setAndValidateContentChildDev.call(this, contentToUse);
	        }
	        DOMLazyTree.queueText(lazyTree, contentToUse);
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        for (var i = 0; i < mountImages.length; i++) {
	          DOMLazyTree.queueChild(lazyTree, mountImages[i]);
	        }
	      }
	    }
	  },
	
	  /**
	   * Receives a next element and updates the component.
	   *
	   * @internal
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   */
	  receiveComponent: function (nextElement, transaction, context) {
	    var prevElement = this._currentElement;
	    this._currentElement = nextElement;
	    this.updateComponent(transaction, prevElement, nextElement, context);
	  },
	
	  /**
	   * Updates a DOM component after it has already been allocated and
	   * attached to the DOM. Reconciles the root DOM node, then recurses.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevElement
	   * @param {ReactElement} nextElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevElement, nextElement, context) {
	    var lastProps = prevElement.props;
	    var nextProps = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'input':
	        lastProps = ReactDOMInput.getHostProps(this, lastProps);
	        nextProps = ReactDOMInput.getHostProps(this, nextProps);
	        break;
	      case 'option':
	        lastProps = ReactDOMOption.getHostProps(this, lastProps);
	        nextProps = ReactDOMOption.getHostProps(this, nextProps);
	        break;
	      case 'select':
	        lastProps = ReactDOMSelect.getHostProps(this, lastProps);
	        nextProps = ReactDOMSelect.getHostProps(this, nextProps);
	        break;
	      case 'textarea':
	        lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
	        nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
	        break;
	    }
	
	    assertValidProps(this, nextProps);
	    this._updateDOMProperties(lastProps, nextProps, transaction);
	    this._updateDOMChildren(lastProps, nextProps, transaction, context);
	
	    switch (this._tag) {
	      case 'input':
	        // Update the wrapper around inputs *after* updating props. This has to
	        // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
	        // raise warnings and prevent the new value from being assigned.
	        ReactDOMInput.updateWrapper(this);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.updateWrapper(this);
	        break;
	      case 'select':
	        // <select> value update needs to occur after <option> children
	        // reconciliation
	        transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
	        break;
	    }
	  },
	
	  /**
	   * Reconciles the properties by detecting differences in property values and
	   * updating the DOM as necessary. This function is probably the single most
	   * critical path for performance optimization.
	   *
	   * TODO: Benchmark whether checking for changed values in memory actually
	   *       improves performance (especially statically positioned elements).
	   * TODO: Benchmark the effects of putting this at the top since 99% of props
	   *       do not change for a given reconciliation.
	   * TODO: Benchmark areas that can be improved with caching.
	   *
	   * @private
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {?DOMElement} node
	   */
	  _updateDOMProperties: function (lastProps, nextProps, transaction) {
	    var propKey;
	    var styleName;
	    var styleUpdates;
	    for (propKey in lastProps) {
	      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        var lastStyle = this._previousStyleCopy;
	        for (styleName in lastStyle) {
	          if (lastStyle.hasOwnProperty(styleName)) {
	            styleUpdates = styleUpdates || {};
	            styleUpdates[styleName] = '';
	          }
	        }
	        this._previousStyleCopy = null;
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (lastProps[propKey]) {
	          // Only call deleteListener if there was a listener previously or
	          // else willDeleteListener gets called when there wasn't actually a
	          // listener (e.g., onClick={null})
	          deleteListener(this, propKey);
	        }
	      } else if (isCustomComponent(this._tag, lastProps)) {
	        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	          DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
	      }
	    }
	    for (propKey in nextProps) {
	      var nextProp = nextProps[propKey];
	      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
	      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        if (nextProp) {
	          if (process.env.NODE_ENV !== 'production') {
	            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
	            this._previousStyle = nextProp;
	          }
	          nextProp = this._previousStyleCopy = _assign({}, nextProp);
	        } else {
	          this._previousStyleCopy = null;
	        }
	        if (lastProp) {
	          // Unset styles on `lastProp` but not on `nextProp`.
	          for (styleName in lastProp) {
	            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = '';
	            }
	          }
	          // Update styles that changed since `lastProp`.
	          for (styleName in nextProp) {
	            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = nextProp[styleName];
	            }
	          }
	        } else {
	          // Relies on `updateStylesByID` not mutating `styleUpdates`.
	          styleUpdates = nextProp;
	        }
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (nextProp) {
	          enqueuePutListener(this, propKey, nextProp, transaction);
	        } else if (lastProp) {
	          deleteListener(this, propKey);
	        }
	      } else if (isCustomComponent(this._tag, nextProps)) {
	        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	          DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        var node = getNode(this);
	        // If we're updating to null or undefined, we should remove the property
	        // from the DOM node instead of inadvertently setting to a string. This
	        // brings us in line with the same behavior we have on initial render.
	        if (nextProp != null) {
	          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
	        } else {
	          DOMPropertyOperations.deleteValueForProperty(node, propKey);
	        }
	      }
	    }
	    if (styleUpdates) {
	      CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
	    }
	  },
	
	  /**
	   * Reconciles the children with the various properties that affect the
	   * children content.
	   *
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   */
	  _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
	    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
	    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;
	
	    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
	    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
	
	    // Note the use of `!=` which checks for null or undefined.
	    var lastChildren = lastContent != null ? null : lastProps.children;
	    var nextChildren = nextContent != null ? null : nextProps.children;
	
	    // If we're switching from children to content/html or vice versa, remove
	    // the old content
	    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
	    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
	    if (lastChildren != null && nextChildren == null) {
	      this.updateChildren(null, transaction, context);
	    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
	      this.updateTextContent('');
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
	      }
	    }
	
	    if (nextContent != null) {
	      if (lastContent !== nextContent) {
	        this.updateTextContent('' + nextContent);
	        if (process.env.NODE_ENV !== 'production') {
	          setAndValidateContentChildDev.call(this, nextContent);
	        }
	      }
	    } else if (nextHtml != null) {
	      if (lastHtml !== nextHtml) {
	        this.updateMarkup('' + nextHtml);
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
	      }
	    } else if (nextChildren != null) {
	      if (process.env.NODE_ENV !== 'production') {
	        setAndValidateContentChildDev.call(this, null);
	      }
	
	      this.updateChildren(nextChildren, transaction, context);
	    }
	  },
	
	  getHostNode: function () {
	    return getNode(this);
	  },
	
	  /**
	   * Destroys all event registrations for this instance. Does not remove from
	   * the DOM. That must be done by the parent.
	   *
	   * @internal
	   */
	  unmountComponent: function (safely) {
	    switch (this._tag) {
	      case 'audio':
	      case 'form':
	      case 'iframe':
	      case 'img':
	      case 'link':
	      case 'object':
	      case 'source':
	      case 'video':
	        var listeners = this._wrapperState.listeners;
	        if (listeners) {
	          for (var i = 0; i < listeners.length; i++) {
	            listeners[i].remove();
	          }
	        }
	        break;
	      case 'html':
	      case 'head':
	      case 'body':
	        /**
	         * Components like <html> <head> and <body> can't be removed or added
	         * easily in a cross-browser way, however it's valuable to be able to
	         * take advantage of React's reconciliation for styling and <title>
	         * management. So we just document it and throw in dangerous cases.
	         */
	         true ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.', this._tag) : _prodInvariant('66', this._tag) : void 0;
	        break;
	    }
	
	    this.unmountChildren(safely);
	    ReactDOMComponentTree.uncacheNode(this);
	    EventPluginHub.deleteAllListeners(this);
	    this._rootNodeID = 0;
	    this._domID = 0;
	    this._wrapperState = null;
	
	    if (process.env.NODE_ENV !== 'production') {
	      setAndValidateContentChildDev.call(this, null);
	    }
	  },
	
	  getPublicInstance: function () {
	    return getNode(this);
	  }
	
	};
	
	_assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);
	
	module.exports = ReactDOMComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var validateDOMNesting = __webpack_require__(49);
	
	var DOC_NODE_TYPE = 9;
	
	function ReactDOMContainerInfo(topLevelWrapper, node) {
	  var info = {
	    _topLevelWrapper: topLevelWrapper,
	    _idCounter: 1,
	    _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,
	    _node: node,
	    _tag: node ? node.nodeName.toLowerCase() : null,
	    _namespaceURI: node ? node.namespaceURI : null
	  };
	  if (process.env.NODE_ENV !== 'production') {
	    info._ancestorInfo = node ? validateDOMNesting.updatedAncestorInfo(null, info._tag, null) : null;
	  }
	  return info;
	}
	
	module.exports = ReactDOMContainerInfo;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var DOMLazyTree = __webpack_require__(21);
	var ReactDOMComponentTree = __webpack_require__(5);
	
	var ReactDOMEmptyComponent = function (instantiate) {
	  // ReactCompositeComponent uses this:
	  this._currentElement = null;
	  // ReactDOMComponentTree uses these:
	  this._hostNode = null;
	  this._hostParent = null;
	  this._hostContainerInfo = null;
	  this._domID = 0;
	};
	_assign(ReactDOMEmptyComponent.prototype, {
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    var domID = hostContainerInfo._idCounter++;
	    this._domID = domID;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var nodeValue = ' react-empty: ' + this._domID + ' ';
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var node = ownerDocument.createComment(nodeValue);
	      ReactDOMComponentTree.precacheNode(this, node);
	      return DOMLazyTree(node);
	    } else {
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd insert a comment node, but since this is a situation
	        // where React won't take over (static pages), we can simply return
	        // nothing.
	        return '';
	      }
	      return '<!--' + nodeValue + '-->';
	    }
	  },
	  receiveComponent: function () {},
	  getHostNode: function () {
	    return ReactDOMComponentTree.getNodeFromInstance(this);
	  },
	  unmountComponent: function () {
	    ReactDOMComponentTree.uncacheNode(this);
	  }
	});
	
	module.exports = ReactDOMEmptyComponent;

/***/ },
/* 116 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactDOMFeatureFlags = {
	  useCreateElement: true,
	  useFiber: false
	};
	
	module.exports = ReactDOMFeatureFlags;

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(35);
	var ReactDOMComponentTree = __webpack_require__(5);
	
	/**
	 * Operations used to process updates to DOM nodes.
	 */
	var ReactDOMIDOperations = {
	
	  /**
	   * Updates a component's children by processing a series of updates.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @internal
	   */
	  dangerouslyProcessChildrenUpdates: function (parentInst, updates) {
	    var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
	    DOMChildrenOperations.processUpdates(node, updates);
	  }
	};
	
	module.exports = ReactDOMIDOperations;

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3),
	    _assign = __webpack_require__(6);
	
	var DOMPropertyOperations = __webpack_require__(60);
	var LinkedValueUtils = __webpack_require__(39);
	var ReactDOMComponentTree = __webpack_require__(5);
	var ReactUpdates = __webpack_require__(10);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(4);
	
	var didWarnValueLink = false;
	var didWarnCheckedLink = false;
	var didWarnValueDefaultValue = false;
	var didWarnCheckedDefaultChecked = false;
	var didWarnControlledToUncontrolled = false;
	var didWarnUncontrolledToControlled = false;
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMInput.updateWrapper(this);
	  }
	}
	
	function isControlled(props) {
	  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
	  return usesChecked ? props.checked != null : props.value != null;
	}
	
	/**
	 * Implements an <input> host component that allows setting these optional
	 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
	 *
	 * If `checked` or `value` are not supplied (or null/undefined), user actions
	 * that affect the checked state or value will trigger updates to the element.
	 *
	 * If they are supplied (and not null/undefined), the rendered element will not
	 * trigger updates to the element. Instead, the props must change in order for
	 * the rendered element to be updated.
	 *
	 * The rendered element will be initialized as unchecked (or `defaultChecked`)
	 * with an empty value (or `defaultValue`).
	 *
	 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
	 */
	var ReactDOMInput = {
	  getHostProps: function (inst, props) {
	    var value = LinkedValueUtils.getValue(props);
	    var checked = LinkedValueUtils.getChecked(props);
	
	    var hostProps = _assign({
	      // Make sure we set .type before any other properties (setting .value
	      // before .type means .value is lost in IE11 and below)
	      type: undefined,
	      // Make sure we set .step before .value (setting .value before .step
	      // means .value is rounded on mount, based upon step precision)
	      step: undefined,
	      // Make sure we set .min & .max before .value (to ensure proper order
	      // in corner cases such as min or max deriving from value, e.g. Issue #7170)
	      min: undefined,
	      max: undefined
	    }, props, {
	      defaultChecked: undefined,
	      defaultValue: undefined,
	      value: value != null ? value : inst._wrapperState.initialValue,
	      checked: checked != null ? checked : inst._wrapperState.initialChecked,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return hostProps;
	  },
	
	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
	
	      var owner = inst._currentElement._owner;
	
	      if (props.valueLink !== undefined && !didWarnValueLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnValueLink = true;
	      }
	      if (props.checkedLink !== undefined && !didWarnCheckedLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnCheckedLink = true;
	      }
	      if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnCheckedDefaultChecked = true;
	      }
	      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnValueDefaultValue = true;
	      }
	    }
	
	    var defaultValue = props.defaultValue;
	    inst._wrapperState = {
	      initialChecked: props.checked != null ? props.checked : props.defaultChecked,
	      initialValue: props.value != null ? props.value : defaultValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst)
	    };
	
	    if (process.env.NODE_ENV !== 'production') {
	      inst._wrapperState.controlled = isControlled(props);
	    }
	  },
	
	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    if (process.env.NODE_ENV !== 'production') {
	      var controlled = isControlled(props);
	      var owner = inst._currentElement._owner;
	
	      if (!inst._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnUncontrolledToControlled = true;
	      }
	      if (inst._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnControlledToUncontrolled = true;
	      }
	    }
	
	    // TODO: Shouldn't this be getChecked(props)?
	    var checked = props.checked;
	    if (checked != null) {
	      DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
	    }
	
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      var newValue = '' + value;
	
	      // To avoid side effects (such as losing text selection), only set value if changed
	      if (newValue !== node.value) {
	        node.value = newValue;
	      }
	    } else {
	      if (props.value == null && props.defaultValue != null) {
	        node.defaultValue = '' + props.defaultValue;
	      }
	      if (props.checked == null && props.defaultChecked != null) {
	        node.defaultChecked = !!props.defaultChecked;
	      }
	    }
	  },
	
	  postMountWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    // This is in postMount because we need access to the DOM node, which is not
	    // available until after the component has mounted.
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	
	    // Detach value from defaultValue. We won't do anything if we're working on
	    // submit or reset inputs as those values & defaultValues are linked. They
	    // are not resetable nodes so this operation doesn't matter and actually
	    // removes browser-default values (eg "Submit Query") when no value is
	    // provided.
	
	    switch (props.type) {
	      case 'submit':
	      case 'reset':
	        break;
	      case 'color':
	      case 'date':
	      case 'datetime':
	      case 'datetime-local':
	      case 'month':
	      case 'time':
	      case 'week':
	        // This fixes the no-show issue on iOS Safari and Android Chrome:
	        // https://github.com/facebook/react/issues/7233
	        node.value = '';
	        node.value = node.defaultValue;
	        break;
	      default:
	        node.value = node.value;
	        break;
	    }
	
	    // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
	    // this is needed to work around a chrome bug where setting defaultChecked
	    // will sometimes influence the value of checked (even after detachment).
	    // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
	    // We need to temporarily unset name to avoid disrupting radio button groups.
	    var name = node.name;
	    if (name !== '') {
	      node.name = '';
	    }
	    node.defaultChecked = !node.defaultChecked;
	    node.defaultChecked = !node.defaultChecked;
	    if (name !== '') {
	      node.name = name;
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  // Here we use asap to wait until all updates have propagated, which
	  // is important when using controlled components within layers:
	  // https://github.com/facebook/react/issues/1698
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	
	  var name = props.name;
	  if (props.type === 'radio' && name != null) {
	    var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
	    var queryRoot = rootNode;
	
	    while (queryRoot.parentNode) {
	      queryRoot = queryRoot.parentNode;
	    }
	
	    // If `rootNode.form` was non-null, then we could try `form.elements`,
	    // but that sometimes behaves strangely in IE8. We could also try using
	    // `form.getElementsByName`, but that will only return direct children
	    // and won't include inputs that use the HTML5 `form=` attribute. Since
	    // the input might not even be in a form, let's just use the global
	    // `querySelectorAll` to ensure we don't miss anything.
	    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
	
	    for (var i = 0; i < group.length; i++) {
	      var otherNode = group[i];
	      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
	        continue;
	      }
	      // This will throw if radio buttons rendered by different copies of React
	      // and the same name are rendered into the same form (same as #1939).
	      // That's probably okay; we don't support it just as we don't support
	      // mixing React radio buttons with non-React ones.
	      var otherInstance = ReactDOMComponentTree.getInstanceFromNode(otherNode);
	      !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : _prodInvariant('90') : void 0;
	      // If this is a controlled radio button group, forcing the input that
	      // was previously checked to update will cause it to be come re-checked
	      // as appropriate.
	      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
	    }
	  }
	
	  return returnValue;
	}
	
	module.exports = ReactDOMInput;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(16);
	var ReactComponentTreeHook = __webpack_require__(8);
	
	var warning = __webpack_require__(4);
	
	var warnedProperties = {};
	var rARIA = new RegExp('^(aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
	
	function validateProperty(tagName, name, debugID) {
	  if (warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	    return true;
	  }
	
	  if (rARIA.test(name)) {
	    var lowerCasedName = name.toLowerCase();
	    var standardName = DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
	
	    // If this is an aria-* attribute, but is not listed in the known DOM
	    // DOM properties, then it is an invalid aria-* attribute.
	    if (standardName == null) {
	      warnedProperties[name] = true;
	      return false;
	    }
	    // aria-* attributes should be lowercase; suggest the lowercase version.
	    if (name !== standardName) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown ARIA attribute %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      warnedProperties[name] = true;
	      return true;
	    }
	  }
	
	  return true;
	}
	
	function warnInvalidARIAProps(debugID, element) {
	  var invalidProps = [];
	
	  for (var key in element.props) {
	    var isValid = validateProperty(element.type, key, debugID);
	    if (!isValid) {
	      invalidProps.push(key);
	    }
	  }
	
	  var unknownPropString = invalidProps.map(function (prop) {
	    return '`' + prop + '`';
	  }).join(', ');
	
	  if (invalidProps.length === 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  } else if (invalidProps.length > 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  }
	}
	
	function handleElement(debugID, element) {
	  if (element == null || typeof element.type !== 'string') {
	    return;
	  }
	  if (element.type.indexOf('-') >= 0 || element.props.is) {
	    return;
	  }
	
	  warnInvalidARIAProps(debugID, element);
	}
	
	var ReactDOMInvalidARIAHook = {
	  onBeforeMountComponent: function (debugID, element) {
	    if (process.env.NODE_ENV !== 'production') {
	      handleElement(debugID, element);
	    }
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    if (process.env.NODE_ENV !== 'production') {
	      handleElement(debugID, element);
	    }
	  }
	};
	
	module.exports = ReactDOMInvalidARIAHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactComponentTreeHook = __webpack_require__(8);
	
	var warning = __webpack_require__(4);
	
	var didWarnValueNull = false;
	
	function handleElement(debugID, element) {
	  if (element == null) {
	    return;
	  }
	  if (element.type !== 'input' && element.type !== 'textarea' && element.type !== 'select') {
	    return;
	  }
	  if (element.props != null && element.props.value === null && !didWarnValueNull) {
	    process.env.NODE_ENV !== 'production' ? warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	
	    didWarnValueNull = true;
	  }
	}
	
	var ReactDOMNullInputValuePropHook = {
	  onBeforeMountComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  }
	};
	
	module.exports = ReactDOMNullInputValuePropHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var React = __webpack_require__(23);
	var ReactDOMComponentTree = __webpack_require__(5);
	var ReactDOMSelect = __webpack_require__(62);
	
	var warning = __webpack_require__(4);
	var didWarnInvalidOptionChildren = false;
	
	function flattenChildren(children) {
	  var content = '';
	
	  // Flatten children and warn if they aren't strings or numbers;
	  // invalid types are ignored.
	  React.Children.forEach(children, function (child) {
	    if (child == null) {
	      return;
	    }
	    if (typeof child === 'string' || typeof child === 'number') {
	      content += child;
	    } else if (!didWarnInvalidOptionChildren) {
	      didWarnInvalidOptionChildren = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : void 0;
	    }
	  });
	
	  return content;
	}
	
	/**
	 * Implements an <option> host component that warns when `selected` is set.
	 */
	var ReactDOMOption = {
	  mountWrapper: function (inst, props, hostParent) {
	    // TODO (yungsters): Remove support for `selected` in <option>.
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : void 0;
	    }
	
	    // Look up whether this option is 'selected'
	    var selectValue = null;
	    if (hostParent != null) {
	      var selectParent = hostParent;
	
	      if (selectParent._tag === 'optgroup') {
	        selectParent = selectParent._hostParent;
	      }
	
	      if (selectParent != null && selectParent._tag === 'select') {
	        selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
	      }
	    }
	
	    // If the value is null (e.g., no specified value or after initial mount)
	    // or missing (e.g., for <datalist>), we don't change props.selected
	    var selected = null;
	    if (selectValue != null) {
	      var value;
	      if (props.value != null) {
	        value = props.value + '';
	      } else {
	        value = flattenChildren(props.children);
	      }
	      selected = false;
	      if (Array.isArray(selectValue)) {
	        // multiple
	        for (var i = 0; i < selectValue.length; i++) {
	          if ('' + selectValue[i] === value) {
	            selected = true;
	            break;
	          }
	        }
	      } else {
	        selected = '' + selectValue === value;
	      }
	    }
	
	    inst._wrapperState = { selected: selected };
	  },
	
	  postMountWrapper: function (inst) {
	    // value="" should make a value attribute (#6219)
	    var props = inst._currentElement.props;
	    if (props.value != null) {
	      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	      node.setAttribute('value', props.value);
	    }
	  },
	
	  getHostProps: function (inst, props) {
	    var hostProps = _assign({ selected: undefined, children: undefined }, props);
	
	    // Read state only from initial mount because <select> updates value
	    // manually; we need the initial state only for server rendering
	    if (inst._wrapperState.selected != null) {
	      hostProps.selected = inst._wrapperState.selected;
	    }
	
	    var content = flattenChildren(props.children);
	
	    if (content) {
	      hostProps.children = content;
	    }
	
	    return hostProps;
	  }
	
	};
	
	module.exports = ReactDOMOption;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(7);
	
	var getNodeForCharacterOffset = __webpack_require__(166);
	var getTextContentAccessor = __webpack_require__(74);
	
	/**
	 * While `isCollapsed` is available on the Selection object and `collapsed`
	 * is available on the Range object, IE11 sometimes gets them wrong.
	 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
	 */
	function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
	  return anchorNode === focusNode && anchorOffset === focusOffset;
	}
	
	/**
	 * Get the appropriate anchor and focus node/offset pairs for IE.
	 *
	 * The catch here is that IE's selection API doesn't provide information
	 * about whether the selection is forward or backward, so we have to
	 * behave as though it's always forward.
	 *
	 * IE text differs from modern selection in that it behaves as though
	 * block elements end with a new line. This means character offsets will
	 * differ between the two APIs.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getIEOffsets(node) {
	  var selection = document.selection;
	  var selectedRange = selection.createRange();
	  var selectedLength = selectedRange.text.length;
	
	  // Duplicate selection so we can move range without breaking user selection.
	  var fromStart = selectedRange.duplicate();
	  fromStart.moveToElementText(node);
	  fromStart.setEndPoint('EndToStart', selectedRange);
	
	  var startOffset = fromStart.text.length;
	  var endOffset = startOffset + selectedLength;
	
	  return {
	    start: startOffset,
	    end: endOffset
	  };
	}
	
	/**
	 * @param {DOMElement} node
	 * @return {?object}
	 */
	function getModernOffsets(node) {
	  var selection = window.getSelection && window.getSelection();
	
	  if (!selection || selection.rangeCount === 0) {
	    return null;
	  }
	
	  var anchorNode = selection.anchorNode;
	  var anchorOffset = selection.anchorOffset;
	  var focusNode = selection.focusNode;
	  var focusOffset = selection.focusOffset;
	
	  var currentRange = selection.getRangeAt(0);
	
	  // In Firefox, range.startContainer and range.endContainer can be "anonymous
	  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
	  // divs do not seem to expose properties, triggering a "Permission denied
	  // error" if any of its properties are accessed. The only seemingly possible
	  // way to avoid erroring is to access a property that typically works for
	  // non-anonymous divs and catch any error that may otherwise arise. See
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
	  try {
	    /* eslint-disable no-unused-expressions */
	    currentRange.startContainer.nodeType;
	    currentRange.endContainer.nodeType;
	    /* eslint-enable no-unused-expressions */
	  } catch (e) {
	    return null;
	  }
	
	  // If the node and offset values are the same, the selection is collapsed.
	  // `Selection.isCollapsed` is available natively, but IE sometimes gets
	  // this value wrong.
	  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
	
	  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
	
	  var tempRange = currentRange.cloneRange();
	  tempRange.selectNodeContents(node);
	  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
	
	  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
	
	  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
	  var end = start + rangeLength;
	
	  // Detect whether the selection is backward.
	  var detectionRange = document.createRange();
	  detectionRange.setStart(anchorNode, anchorOffset);
	  detectionRange.setEnd(focusNode, focusOffset);
	  var isBackward = detectionRange.collapsed;
	
	  return {
	    start: isBackward ? end : start,
	    end: isBackward ? start : end
	  };
	}
	
	/**
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setIEOffsets(node, offsets) {
	  var range = document.selection.createRange().duplicate();
	  var start, end;
	
	  if (offsets.end === undefined) {
	    start = offsets.start;
	    end = start;
	  } else if (offsets.start > offsets.end) {
	    start = offsets.end;
	    end = offsets.start;
	  } else {
	    start = offsets.start;
	    end = offsets.end;
	  }
	
	  range.moveToElementText(node);
	  range.moveStart('character', start);
	  range.setEndPoint('EndToStart', range);
	  range.moveEnd('character', end - start);
	  range.select();
	}
	
	/**
	 * In modern non-IE browsers, we can support both forward and backward
	 * selections.
	 *
	 * Note: IE10+ supports the Selection object, but it does not support
	 * the `extend` method, which means that even in modern IE, it's not possible
	 * to programmatically create a backward selection. Thus, for all IE
	 * versions, we use the old IE API to create our selections.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setModernOffsets(node, offsets) {
	  if (!window.getSelection) {
	    return;
	  }
	
	  var selection = window.getSelection();
	  var length = node[getTextContentAccessor()].length;
	  var start = Math.min(offsets.start, length);
	  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);
	
	  // IE 11 uses modern selection, but doesn't support the extend method.
	  // Flip backward selections, so we can set with a single range.
	  if (!selection.extend && start > end) {
	    var temp = end;
	    end = start;
	    start = temp;
	  }
	
	  var startMarker = getNodeForCharacterOffset(node, start);
	  var endMarker = getNodeForCharacterOffset(node, end);
	
	  if (startMarker && endMarker) {
	    var range = document.createRange();
	    range.setStart(startMarker.node, startMarker.offset);
	    selection.removeAllRanges();
	
	    if (start > end) {
	      selection.addRange(range);
	      selection.extend(endMarker.node, endMarker.offset);
	    } else {
	      range.setEnd(endMarker.node, endMarker.offset);
	      selection.addRange(range);
	    }
	  }
	}
	
	var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);
	
	var ReactDOMSelection = {
	  /**
	   * @param {DOMElement} node
	   */
	  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
	
	  /**
	   * @param {DOMElement|DOMTextNode} node
	   * @param {object} offsets
	   */
	  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
	};
	
	module.exports = ReactDOMSelection;

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3),
	    _assign = __webpack_require__(6);
	
	var DOMChildrenOperations = __webpack_require__(35);
	var DOMLazyTree = __webpack_require__(21);
	var ReactDOMComponentTree = __webpack_require__(5);
	
	var escapeTextContentForBrowser = __webpack_require__(32);
	var invariant = __webpack_require__(2);
	var validateDOMNesting = __webpack_require__(49);
	
	/**
	 * Text nodes violate a couple assumptions that React makes about components:
	 *
	 *  - When mounting text into the DOM, adjacent text nodes are merged.
	 *  - Text nodes cannot be assigned a React root ID.
	 *
	 * This component is used to wrap strings between comment nodes so that they
	 * can undergo the same reconciliation that is applied to elements.
	 *
	 * TODO: Investigate representing React components in the DOM with text nodes.
	 *
	 * @class ReactDOMTextComponent
	 * @extends ReactComponent
	 * @internal
	 */
	var ReactDOMTextComponent = function (text) {
	  // TODO: This is really a ReactText (ReactNode), not a ReactElement
	  this._currentElement = text;
	  this._stringText = '' + text;
	  // ReactDOMComponentTree uses these:
	  this._hostNode = null;
	  this._hostParent = null;
	
	  // Properties
	  this._domID = 0;
	  this._mountIndex = 0;
	  this._closingComment = null;
	  this._commentNodes = null;
	};
	
	_assign(ReactDOMTextComponent.prototype, {
	
	  /**
	   * Creates the markup for this text node. This node is not intended to have
	   * any features besides containing text content.
	   *
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {string} Markup for this text node.
	   * @internal
	   */
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    if (process.env.NODE_ENV !== 'production') {
	      var parentInfo;
	      if (hostParent != null) {
	        parentInfo = hostParent._ancestorInfo;
	      } else if (hostContainerInfo != null) {
	        parentInfo = hostContainerInfo._ancestorInfo;
	      }
	      if (parentInfo) {
	        // parentInfo should always be present except for the top-level
	        // component when server rendering
	        validateDOMNesting(null, this._stringText, this, parentInfo);
	      }
	    }
	
	    var domID = hostContainerInfo._idCounter++;
	    var openingValue = ' react-text: ' + domID + ' ';
	    var closingValue = ' /react-text ';
	    this._domID = domID;
	    this._hostParent = hostParent;
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var openingComment = ownerDocument.createComment(openingValue);
	      var closingComment = ownerDocument.createComment(closingValue);
	      var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
	      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
	      if (this._stringText) {
	        DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
	      }
	      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
	      ReactDOMComponentTree.precacheNode(this, openingComment);
	      this._closingComment = closingComment;
	      return lazyTree;
	    } else {
	      var escapedText = escapeTextContentForBrowser(this._stringText);
	
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd wrap this between comment nodes for the reasons stated
	        // above, but since this is a situation where React won't take over
	        // (static pages), we can simply return the text as it is.
	        return escapedText;
	      }
	
	      return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
	    }
	  },
	
	  /**
	   * Updates this component by updating the text content.
	   *
	   * @param {ReactText} nextText The next text content
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  receiveComponent: function (nextText, transaction) {
	    if (nextText !== this._currentElement) {
	      this._currentElement = nextText;
	      var nextStringText = '' + nextText;
	      if (nextStringText !== this._stringText) {
	        // TODO: Save this as pending props and use performUpdateIfNecessary
	        // and/or updateComponent to do the actual update for consistency with
	        // other component types?
	        this._stringText = nextStringText;
	        var commentNodes = this.getHostNode();
	        DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
	      }
	    }
	  },
	
	  getHostNode: function () {
	    var hostNode = this._commentNodes;
	    if (hostNode) {
	      return hostNode;
	    }
	    if (!this._closingComment) {
	      var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
	      var node = openingComment.nextSibling;
	      while (true) {
	        !(node != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Missing closing comment for text component %s', this._domID) : _prodInvariant('67', this._domID) : void 0;
	        if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
	          this._closingComment = node;
	          break;
	        }
	        node = node.nextSibling;
	      }
	    }
	    hostNode = [this._hostNode, this._closingComment];
	    this._commentNodes = hostNode;
	    return hostNode;
	  },
	
	  unmountComponent: function () {
	    this._closingComment = null;
	    this._commentNodes = null;
	    ReactDOMComponentTree.uncacheNode(this);
	  }
	
	});
	
	module.exports = ReactDOMTextComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3),
	    _assign = __webpack_require__(6);
	
	var LinkedValueUtils = __webpack_require__(39);
	var ReactDOMComponentTree = __webpack_require__(5);
	var ReactUpdates = __webpack_require__(10);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(4);
	
	var didWarnValueLink = false;
	var didWarnValDefaultVal = false;
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMTextarea.updateWrapper(this);
	  }
	}
	
	/**
	 * Implements a <textarea> host component that allows setting `value`, and
	 * `defaultValue`. This differs from the traditional DOM API because value is
	 * usually set as PCDATA children.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that affect the
	 * value will trigger updates to the element.
	 *
	 * If `value` is supplied (and not null/undefined), the rendered element will
	 * not trigger updates to the element. Instead, the `value` prop must change in
	 * order for the rendered element to be updated.
	 *
	 * The rendered element will be initialized with an empty value, the prop
	 * `defaultValue` if specified, or the children content (deprecated).
	 */
	var ReactDOMTextarea = {
	  getHostProps: function (inst, props) {
	    !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : _prodInvariant('91') : void 0;
	
	    // Always set children to the same thing. In IE9, the selection range will
	    // get reset if `textContent` is mutated.  We could add a check in setTextContent
	    // to only set the value if/when the value differs from the node value (which would
	    // completely solve this IE9 bug), but Sebastian+Ben seemed to like this solution.
	    // The value can be a boolean or object so that's why it's forced to be a string.
	    var hostProps = _assign({}, props, {
	      value: undefined,
	      defaultValue: undefined,
	      children: '' + inst._wrapperState.initialValue,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return hostProps;
	  },
	
	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
	      if (props.valueLink !== undefined && !didWarnValueLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnValueLink = true;
	      }
	      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
	        didWarnValDefaultVal = true;
	      }
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    var initialValue = value;
	
	    // Only bother fetching default value if we're going to use it
	    if (value == null) {
	      var defaultValue = props.defaultValue;
	      // TODO (yungsters): Remove support for children content in <textarea>.
	      var children = props.children;
	      if (children != null) {
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : void 0;
	        }
	        !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : _prodInvariant('92') : void 0;
	        if (Array.isArray(children)) {
	          !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : _prodInvariant('93') : void 0;
	          children = children[0];
	        }
	
	        defaultValue = '' + children;
	      }
	      if (defaultValue == null) {
	        defaultValue = '';
	      }
	      initialValue = defaultValue;
	    }
	
	    inst._wrapperState = {
	      initialValue: '' + initialValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst)
	    };
	  },
	
	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      var newValue = '' + value;
	
	      // To avoid side effects (such as losing text selection), only set value if changed
	      if (newValue !== node.value) {
	        node.value = newValue;
	      }
	      if (props.defaultValue == null) {
	        node.defaultValue = newValue;
	      }
	    }
	    if (props.defaultValue != null) {
	      node.defaultValue = props.defaultValue;
	    }
	  },
	
	  postMountWrapper: function (inst) {
	    // This is in postMount because we need access to the DOM node, which is not
	    // available until after the component has mounted.
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	
	    // Warning: node.value may be the empty string at this point (IE11) if placeholder is set.
	    node.value = node.textContent; // Detach value from defaultValue
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMTextarea;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Return the lowest common ancestor of A and B, or null if they are in
	 * different trees.
	 */
	function getLowestCommonAncestor(instA, instB) {
	  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	
	  var depthA = 0;
	  for (var tempA = instA; tempA; tempA = tempA._hostParent) {
	    depthA++;
	  }
	  var depthB = 0;
	  for (var tempB = instB; tempB; tempB = tempB._hostParent) {
	    depthB++;
	  }
	
	  // If A is deeper, crawl up.
	  while (depthA - depthB > 0) {
	    instA = instA._hostParent;
	    depthA--;
	  }
	
	  // If B is deeper, crawl up.
	  while (depthB - depthA > 0) {
	    instB = instB._hostParent;
	    depthB--;
	  }
	
	  // Walk in lockstep until we find a match.
	  var depth = depthA;
	  while (depth--) {
	    if (instA === instB) {
	      return instA;
	    }
	    instA = instA._hostParent;
	    instB = instB._hostParent;
	  }
	  return null;
	}
	
	/**
	 * Return if A is an ancestor of B.
	 */
	function isAncestor(instA, instB) {
	  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
	  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
	
	  while (instB) {
	    if (instB === instA) {
	      return true;
	    }
	    instB = instB._hostParent;
	  }
	  return false;
	}
	
	/**
	 * Return the parent instance of the passed-in instance.
	 */
	function getParentInstance(inst) {
	  !('_hostNode' in inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;
	
	  return inst._hostParent;
	}
	
	/**
	 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
	 */
	function traverseTwoPhase(inst, fn, arg) {
	  var path = [];
	  while (inst) {
	    path.push(inst);
	    inst = inst._hostParent;
	  }
	  var i;
	  for (i = path.length; i-- > 0;) {
	    fn(path[i], 'captured', arg);
	  }
	  for (i = 0; i < path.length; i++) {
	    fn(path[i], 'bubbled', arg);
	  }
	}
	
	/**
	 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
	 * should would receive a `mouseEnter` or `mouseLeave` event.
	 *
	 * Does not invoke the callback on the nearest common ancestor because nothing
	 * "entered" or "left" that element.
	 */
	function traverseEnterLeave(from, to, fn, argFrom, argTo) {
	  var common = from && to ? getLowestCommonAncestor(from, to) : null;
	  var pathFrom = [];
	  while (from && from !== common) {
	    pathFrom.push(from);
	    from = from._hostParent;
	  }
	  var pathTo = [];
	  while (to && to !== common) {
	    pathTo.push(to);
	    to = to._hostParent;
	  }
	  var i;
	  for (i = 0; i < pathFrom.length; i++) {
	    fn(pathFrom[i], 'bubbled', argFrom);
	  }
	  for (i = pathTo.length; i-- > 0;) {
	    fn(pathTo[i], 'captured', argTo);
	  }
	}
	
	module.exports = {
	  isAncestor: isAncestor,
	  getLowestCommonAncestor: getLowestCommonAncestor,
	  getParentInstance: getParentInstance,
	  traverseTwoPhase: traverseTwoPhase,
	  traverseEnterLeave: traverseEnterLeave
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(16);
	var EventPluginRegistry = __webpack_require__(28);
	var ReactComponentTreeHook = __webpack_require__(8);
	
	var warning = __webpack_require__(4);
	
	if (process.env.NODE_ENV !== 'production') {
	  var reactProps = {
	    children: true,
	    dangerouslySetInnerHTML: true,
	    key: true,
	    ref: true,
	
	    autoFocus: true,
	    defaultValue: true,
	    valueLink: true,
	    defaultChecked: true,
	    checkedLink: true,
	    innerHTML: true,
	    suppressContentEditableWarning: true,
	    onFocusIn: true,
	    onFocusOut: true
	  };
	  var warnedProperties = {};
	
	  var validateProperty = function (tagName, name, debugID) {
	    if (DOMProperty.properties.hasOwnProperty(name) || DOMProperty.isCustomAttribute(name)) {
	      return true;
	    }
	    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	      return true;
	    }
	    if (EventPluginRegistry.registrationNameModules.hasOwnProperty(name)) {
	      return true;
	    }
	    warnedProperties[name] = true;
	    var lowerCasedName = name.toLowerCase();
	
	    // data-* attributes should be lowercase; suggest the lowercase version
	    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
	
	    var registrationName = EventPluginRegistry.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry.possibleRegistrationNames[lowerCasedName] : null;
	
	    if (standardName != null) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown DOM property %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      return true;
	    } else if (registrationName != null) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown event handler property %s. Did you mean `%s`?%s', name, registrationName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      return true;
	    } else {
	      // We were unable to guess which prop the user intended.
	      // It is likely that the user was just blindly spreading/forwarding props
	      // Components should be careful to only render valid props/attributes.
	      // Warning will be invoked in warnUnknownProperties to allow grouping.
	      return false;
	    }
	  };
	}
	
	var warnUnknownProperties = function (debugID, element) {
	  var unknownProps = [];
	  for (var key in element.props) {
	    var isValid = validateProperty(element.type, key, debugID);
	    if (!isValid) {
	      unknownProps.push(key);
	    }
	  }
	
	  var unknownPropString = unknownProps.map(function (prop) {
	    return '`' + prop + '`';
	  }).join(', ');
	
	  if (unknownProps.length === 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown prop %s on <%s> tag. Remove this prop from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  } else if (unknownProps.length > 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown props %s on <%s> tag. Remove these props from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  }
	};
	
	function handleElement(debugID, element) {
	  if (element == null || typeof element.type !== 'string') {
	    return;
	  }
	  if (element.type.indexOf('-') >= 0 || element.props.is) {
	    return;
	  }
	  warnUnknownProperties(debugID, element);
	}
	
	var ReactDOMUnknownPropertyHook = {
	  onBeforeMountComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  }
	};
	
	module.exports = ReactDOMUnknownPropertyHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var ReactInvalidSetStateWarningHook = __webpack_require__(135);
	var ReactHostOperationHistoryHook = __webpack_require__(133);
	var ReactComponentTreeHook = __webpack_require__(8);
	var ExecutionEnvironment = __webpack_require__(7);
	
	var performanceNow = __webpack_require__(183);
	var warning = __webpack_require__(4);
	
	var hooks = [];
	var didHookThrowForEvent = {};
	
	function callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {
	  try {
	    fn.call(context, arg1, arg2, arg3, arg4, arg5);
	  } catch (e) {
	    process.env.NODE_ENV !== 'production' ? warning(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\n' + e.stack) : void 0;
	    didHookThrowForEvent[event] = true;
	  }
	}
	
	function emitEvent(event, arg1, arg2, arg3, arg4, arg5) {
	  for (var i = 0; i < hooks.length; i++) {
	    var hook = hooks[i];
	    var fn = hook[event];
	    if (fn) {
	      callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);
	    }
	  }
	}
	
	var isProfiling = false;
	var flushHistory = [];
	var lifeCycleTimerStack = [];
	var currentFlushNesting = 0;
	var currentFlushMeasurements = [];
	var currentFlushStartTime = 0;
	var currentTimerDebugID = null;
	var currentTimerStartTime = 0;
	var currentTimerNestedFlushDuration = 0;
	var currentTimerType = null;
	
	var lifeCycleTimerHasWarned = false;
	
	function clearHistory() {
	  ReactComponentTreeHook.purgeUnmountedComponents();
	  ReactHostOperationHistoryHook.clearHistory();
	}
	
	function getTreeSnapshot(registeredIDs) {
	  return registeredIDs.reduce(function (tree, id) {
	    var ownerID = ReactComponentTreeHook.getOwnerID(id);
	    var parentID = ReactComponentTreeHook.getParentID(id);
	    tree[id] = {
	      displayName: ReactComponentTreeHook.getDisplayName(id),
	      text: ReactComponentTreeHook.getText(id),
	      updateCount: ReactComponentTreeHook.getUpdateCount(id),
	      childIDs: ReactComponentTreeHook.getChildIDs(id),
	      // Text nodes don't have owners but this is close enough.
	      ownerID: ownerID || parentID && ReactComponentTreeHook.getOwnerID(parentID) || 0,
	      parentID: parentID
	    };
	    return tree;
	  }, {});
	}
	
	function resetMeasurements() {
	  var previousStartTime = currentFlushStartTime;
	  var previousMeasurements = currentFlushMeasurements;
	  var previousOperations = ReactHostOperationHistoryHook.getHistory();
	
	  if (currentFlushNesting === 0) {
	    currentFlushStartTime = 0;
	    currentFlushMeasurements = [];
	    clearHistory();
	    return;
	  }
	
	  if (previousMeasurements.length || previousOperations.length) {
	    var registeredIDs = ReactComponentTreeHook.getRegisteredIDs();
	    flushHistory.push({
	      duration: performanceNow() - previousStartTime,
	      measurements: previousMeasurements || [],
	      operations: previousOperations || [],
	      treeSnapshot: getTreeSnapshot(registeredIDs)
	    });
	  }
	
	  clearHistory();
	  currentFlushStartTime = performanceNow();
	  currentFlushMeasurements = [];
	}
	
	function checkDebugID(debugID) {
	  var allowRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	
	  if (allowRoot && debugID === 0) {
	    return;
	  }
	  if (!debugID) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDebugTool: debugID may not be empty.') : void 0;
	  }
	}
	
	function beginLifeCycleTimer(debugID, timerType) {
	  if (currentFlushNesting === 0) {
	    return;
	  }
	  if (currentTimerType && !lifeCycleTimerHasWarned) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
	    lifeCycleTimerHasWarned = true;
	  }
	  currentTimerStartTime = performanceNow();
	  currentTimerNestedFlushDuration = 0;
	  currentTimerDebugID = debugID;
	  currentTimerType = timerType;
	}
	
	function endLifeCycleTimer(debugID, timerType) {
	  if (currentFlushNesting === 0) {
	    return;
	  }
	  if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
	    lifeCycleTimerHasWarned = true;
	  }
	  if (isProfiling) {
	    currentFlushMeasurements.push({
	      timerType: timerType,
	      instanceID: debugID,
	      duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration
	    });
	  }
	  currentTimerStartTime = 0;
	  currentTimerNestedFlushDuration = 0;
	  currentTimerDebugID = null;
	  currentTimerType = null;
	}
	
	function pauseCurrentLifeCycleTimer() {
	  var currentTimer = {
	    startTime: currentTimerStartTime,
	    nestedFlushStartTime: performanceNow(),
	    debugID: currentTimerDebugID,
	    timerType: currentTimerType
	  };
	  lifeCycleTimerStack.push(currentTimer);
	  currentTimerStartTime = 0;
	  currentTimerNestedFlushDuration = 0;
	  currentTimerDebugID = null;
	  currentTimerType = null;
	}
	
	function resumeCurrentLifeCycleTimer() {
	  var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop(),
	      startTime = _lifeCycleTimerStack$.startTime,
	      nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime,
	      debugID = _lifeCycleTimerStack$.debugID,
	      timerType = _lifeCycleTimerStack$.timerType;
	
	  var nestedFlushDuration = performanceNow() - nestedFlushStartTime;
	  currentTimerStartTime = startTime;
	  currentTimerNestedFlushDuration += nestedFlushDuration;
	  currentTimerDebugID = debugID;
	  currentTimerType = timerType;
	}
	
	var lastMarkTimeStamp = 0;
	var canUsePerformanceMeasure =
	// $FlowFixMe https://github.com/facebook/flow/issues/2345
	typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';
	
	function shouldMark(debugID) {
	  if (!isProfiling || !canUsePerformanceMeasure) {
	    return false;
	  }
	  var element = ReactComponentTreeHook.getElement(debugID);
	  if (element == null || typeof element !== 'object') {
	    return false;
	  }
	  var isHostElement = typeof element.type === 'string';
	  if (isHostElement) {
	    return false;
	  }
	  return true;
	}
	
	function markBegin(debugID, markType) {
	  if (!shouldMark(debugID)) {
	    return;
	  }
	
	  var markName = debugID + '::' + markType;
	  lastMarkTimeStamp = performanceNow();
	  performance.mark(markName);
	}
	
	function markEnd(debugID, markType) {
	  if (!shouldMark(debugID)) {
	    return;
	  }
	
	  var markName = debugID + '::' + markType;
	  var displayName = ReactComponentTreeHook.getDisplayName(debugID) || 'Unknown';
	
	  // Chrome has an issue of dropping markers recorded too fast:
	  // https://bugs.chromium.org/p/chromium/issues/detail?id=640652
	  // To work around this, we will not report very small measurements.
	  // I determined the magic number by tweaking it back and forth.
	  // 0.05ms was enough to prevent the issue, but I set it to 0.1ms to be safe.
	  // When the bug is fixed, we can `measure()` unconditionally if we want to.
	  var timeStamp = performanceNow();
	  if (timeStamp - lastMarkTimeStamp > 0.1) {
	    var measurementName = displayName + ' [' + markType + ']';
	    performance.measure(measurementName, markName);
	  }
	
	  performance.clearMarks(markName);
	  performance.clearMeasures(measurementName);
	}
	
	var ReactDebugTool = {
	  addHook: function (hook) {
	    hooks.push(hook);
	  },
	  removeHook: function (hook) {
	    for (var i = 0; i < hooks.length; i++) {
	      if (hooks[i] === hook) {
	        hooks.splice(i, 1);
	        i--;
	      }
	    }
	  },
	  isProfiling: function () {
	    return isProfiling;
	  },
	  beginProfiling: function () {
	    if (isProfiling) {
	      return;
	    }
	
	    isProfiling = true;
	    flushHistory.length = 0;
	    resetMeasurements();
	    ReactDebugTool.addHook(ReactHostOperationHistoryHook);
	  },
	  endProfiling: function () {
	    if (!isProfiling) {
	      return;
	    }
	
	    isProfiling = false;
	    resetMeasurements();
	    ReactDebugTool.removeHook(ReactHostOperationHistoryHook);
	  },
	  getFlushHistory: function () {
	    return flushHistory;
	  },
	  onBeginFlush: function () {
	    currentFlushNesting++;
	    resetMeasurements();
	    pauseCurrentLifeCycleTimer();
	    emitEvent('onBeginFlush');
	  },
	  onEndFlush: function () {
	    resetMeasurements();
	    currentFlushNesting--;
	    resumeCurrentLifeCycleTimer();
	    emitEvent('onEndFlush');
	  },
	  onBeginLifeCycleTimer: function (debugID, timerType) {
	    checkDebugID(debugID);
	    emitEvent('onBeginLifeCycleTimer', debugID, timerType);
	    markBegin(debugID, timerType);
	    beginLifeCycleTimer(debugID, timerType);
	  },
	  onEndLifeCycleTimer: function (debugID, timerType) {
	    checkDebugID(debugID);
	    endLifeCycleTimer(debugID, timerType);
	    markEnd(debugID, timerType);
	    emitEvent('onEndLifeCycleTimer', debugID, timerType);
	  },
	  onBeginProcessingChildContext: function () {
	    emitEvent('onBeginProcessingChildContext');
	  },
	  onEndProcessingChildContext: function () {
	    emitEvent('onEndProcessingChildContext');
	  },
	  onHostOperation: function (operation) {
	    checkDebugID(operation.instanceID);
	    emitEvent('onHostOperation', operation);
	  },
	  onSetState: function () {
	    emitEvent('onSetState');
	  },
	  onSetChildren: function (debugID, childDebugIDs) {
	    checkDebugID(debugID);
	    childDebugIDs.forEach(checkDebugID);
	    emitEvent('onSetChildren', debugID, childDebugIDs);
	  },
	  onBeforeMountComponent: function (debugID, element, parentDebugID) {
	    checkDebugID(debugID);
	    checkDebugID(parentDebugID, true);
	    emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);
	    markBegin(debugID, 'mount');
	  },
	  onMountComponent: function (debugID) {
	    checkDebugID(debugID);
	    markEnd(debugID, 'mount');
	    emitEvent('onMountComponent', debugID);
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    checkDebugID(debugID);
	    emitEvent('onBeforeUpdateComponent', debugID, element);
	    markBegin(debugID, 'update');
	  },
	  onUpdateComponent: function (debugID) {
	    checkDebugID(debugID);
	    markEnd(debugID, 'update');
	    emitEvent('onUpdateComponent', debugID);
	  },
	  onBeforeUnmountComponent: function (debugID) {
	    checkDebugID(debugID);
	    emitEvent('onBeforeUnmountComponent', debugID);
	    markBegin(debugID, 'unmount');
	  },
	  onUnmountComponent: function (debugID) {
	    checkDebugID(debugID);
	    markEnd(debugID, 'unmount');
	    emitEvent('onUnmountComponent', debugID);
	  },
	  onTestEvent: function () {
	    emitEvent('onTestEvent');
	  }
	};
	
	// TODO remove these when RN/www gets updated
	ReactDebugTool.addDevtool = ReactDebugTool.addHook;
	ReactDebugTool.removeDevtool = ReactDebugTool.removeHook;
	
	ReactDebugTool.addHook(ReactInvalidSetStateWarningHook);
	ReactDebugTool.addHook(ReactComponentTreeHook);
	var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
	if (/[?&]react_perf\b/.test(url)) {
	  ReactDebugTool.beginProfiling();
	}
	
	module.exports = ReactDebugTool;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var ReactUpdates = __webpack_require__(10);
	var Transaction = __webpack_require__(31);
	
	var emptyFunction = __webpack_require__(15);
	
	var RESET_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: function () {
	    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
	  }
	};
	
	var FLUSH_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
	};
	
	var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
	
	function ReactDefaultBatchingStrategyTransaction() {
	  this.reinitializeTransaction();
	}
	
	_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  }
	});
	
	var transaction = new ReactDefaultBatchingStrategyTransaction();
	
	var ReactDefaultBatchingStrategy = {
	  isBatchingUpdates: false,
	
	  /**
	   * Call the provided function in a context within which calls to `setState`
	   * and friends are batched such that components aren't updated unnecessarily.
	   */
	  batchedUpdates: function (callback, a, b, c, d, e) {
	    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
	
	    ReactDefaultBatchingStrategy.isBatchingUpdates = true;
	
	    // The code is written this way to avoid extra allocations
	    if (alreadyBatchingUpdates) {
	      return callback(a, b, c, d, e);
	    } else {
	      return transaction.perform(callback, null, a, b, c, d, e);
	    }
	  }
	};
	
	module.exports = ReactDefaultBatchingStrategy;

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ARIADOMPropertyConfig = __webpack_require__(99);
	var BeforeInputEventPlugin = __webpack_require__(101);
	var ChangeEventPlugin = __webpack_require__(103);
	var DefaultEventPluginOrder = __webpack_require__(105);
	var EnterLeaveEventPlugin = __webpack_require__(106);
	var HTMLDOMPropertyConfig = __webpack_require__(108);
	var ReactComponentBrowserEnvironment = __webpack_require__(110);
	var ReactDOMComponent = __webpack_require__(113);
	var ReactDOMComponentTree = __webpack_require__(5);
	var ReactDOMEmptyComponent = __webpack_require__(115);
	var ReactDOMTreeTraversal = __webpack_require__(125);
	var ReactDOMTextComponent = __webpack_require__(123);
	var ReactDefaultBatchingStrategy = __webpack_require__(128);
	var ReactEventListener = __webpack_require__(132);
	var ReactInjection = __webpack_require__(134);
	var ReactReconcileTransaction = __webpack_require__(140);
	var SVGDOMPropertyConfig = __webpack_require__(145);
	var SelectEventPlugin = __webpack_require__(146);
	var SimpleEventPlugin = __webpack_require__(147);
	
	var alreadyInjected = false;
	
	function inject() {
	  if (alreadyInjected) {
	    // TODO: This is currently true because these injections are shared between
	    // the client and the server package. They should be built independently
	    // and not share any injection state. Then this problem will be solved.
	    return;
	  }
	  alreadyInjected = true;
	
	  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
	
	  /**
	   * Inject modules for resolving DOM hierarchy and plugin ordering.
	   */
	  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
	  ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
	  ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);
	
	  /**
	   * Some important event plugins included by default (without having to require
	   * them).
	   */
	  ReactInjection.EventPluginHub.injectEventPluginsByName({
	    SimpleEventPlugin: SimpleEventPlugin,
	    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
	    ChangeEventPlugin: ChangeEventPlugin,
	    SelectEventPlugin: SelectEventPlugin,
	    BeforeInputEventPlugin: BeforeInputEventPlugin
	  });
	
	  ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);
	
	  ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);
	
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(ARIADOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
	
	  ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
	    return new ReactDOMEmptyComponent(instantiate);
	  });
	
	  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
	  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	
	  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
	}
	
	module.exports = {
	  inject: inject
	};

/***/ },
/* 130 */
83,
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(24);
	
	function runEventQueueInBatch(events) {
	  EventPluginHub.enqueueEvents(events);
	  EventPluginHub.processEventQueue(false);
	}
	
	var ReactEventEmitterMixin = {
	
	  /**
	   * Streams a fired top-level event to `EventPluginHub` where plugins have the
	   * opportunity to create `ReactEvent`s to be dispatched.
	   */
	  handleTopLevel: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	    runEventQueueInBatch(events);
	  }
	};
	
	module.exports = ReactEventEmitterMixin;

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var EventListener = __webpack_require__(79);
	var ExecutionEnvironment = __webpack_require__(7);
	var PooledClass = __webpack_require__(17);
	var ReactDOMComponentTree = __webpack_require__(5);
	var ReactUpdates = __webpack_require__(10);
	
	var getEventTarget = __webpack_require__(46);
	var getUnboundedScrollPosition = __webpack_require__(176);
	
	/**
	 * Find the deepest React component completely containing the root of the
	 * passed-in instance (for use when entire React trees are nested within each
	 * other). If React trees are not nested, returns null.
	 */
	function findParent(inst) {
	  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
	  // traversal, but caching is difficult to do correctly without using a
	  // mutation observer to listen for all DOM changes.
	  while (inst._hostParent) {
	    inst = inst._hostParent;
	  }
	  var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
	  var container = rootNode.parentNode;
	  return ReactDOMComponentTree.getClosestInstanceFromNode(container);
	}
	
	// Used to store ancestor hierarchy in top level callback
	function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
	  this.topLevelType = topLevelType;
	  this.nativeEvent = nativeEvent;
	  this.ancestors = [];
	}
	_assign(TopLevelCallbackBookKeeping.prototype, {
	  destructor: function () {
	    this.topLevelType = null;
	    this.nativeEvent = null;
	    this.ancestors.length = 0;
	  }
	});
	PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
	
	function handleTopLevelImpl(bookKeeping) {
	  var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
	  var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);
	
	  // Loop through the hierarchy, in case there's any nested components.
	  // It's important that we build the array of ancestors before calling any
	  // event handlers, because event handlers can modify the DOM, leading to
	  // inconsistencies with ReactMount's node cache. See #1105.
	  var ancestor = targetInst;
	  do {
	    bookKeeping.ancestors.push(ancestor);
	    ancestor = ancestor && findParent(ancestor);
	  } while (ancestor);
	
	  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
	    targetInst = bookKeeping.ancestors[i];
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}
	
	function scrollValueMonitor(cb) {
	  var scrollPosition = getUnboundedScrollPosition(window);
	  cb(scrollPosition);
	}
	
	var ReactEventListener = {
	  _enabled: true,
	  _handleTopLevel: null,
	
	  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
	
	  setHandleTopLevel: function (handleTopLevel) {
	    ReactEventListener._handleTopLevel = handleTopLevel;
	  },
	
	  setEnabled: function (enabled) {
	    ReactEventListener._enabled = !!enabled;
	  },
	
	  isEnabled: function () {
	    return ReactEventListener._enabled;
	  },
	
	  /**
	   * Traps top-level events by using event bubbling.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} element Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapBubbledEvent: function (topLevelType, handlerBaseName, element) {
	    if (!element) {
	      return null;
	    }
	    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  /**
	   * Traps a top-level event by using event capturing.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} element Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapCapturedEvent: function (topLevelType, handlerBaseName, element) {
	    if (!element) {
	      return null;
	    }
	    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  monitorScrollValue: function (refresh) {
	    var callback = scrollValueMonitor.bind(null, refresh);
	    EventListener.listen(window, 'scroll', callback);
	  },
	
	  dispatchEvent: function (topLevelType, nativeEvent) {
	    if (!ReactEventListener._enabled) {
	      return;
	    }
	
	    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
	    try {
	      // Event queue being processed in the same cycle allows
	      // `preventDefault`.
	      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
	    } finally {
	      TopLevelCallbackBookKeeping.release(bookKeeping);
	    }
	  }
	};
	
	module.exports = ReactEventListener;

/***/ },
/* 133 */
/***/ function(module, exports) {

	/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var history = [];
	
	var ReactHostOperationHistoryHook = {
	  onHostOperation: function (operation) {
	    history.push(operation);
	  },
	  clearHistory: function () {
	    if (ReactHostOperationHistoryHook._preventClearing) {
	      // Should only be used for tests.
	      return;
	    }
	
	    history = [];
	  },
	  getHistory: function () {
	    return history;
	  }
	};
	
	module.exports = ReactHostOperationHistoryHook;

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(16);
	var EventPluginHub = __webpack_require__(24);
	var EventPluginUtils = __webpack_require__(37);
	var ReactComponentEnvironment = __webpack_require__(40);
	var ReactEmptyComponent = __webpack_require__(63);
	var ReactBrowserEventEmitter = __webpack_require__(29);
	var ReactHostComponent = __webpack_require__(65);
	var ReactUpdates = __webpack_require__(10);
	
	var ReactInjection = {
	  Component: ReactComponentEnvironment.injection,
	  DOMProperty: DOMProperty.injection,
	  EmptyComponent: ReactEmptyComponent.injection,
	  EventPluginHub: EventPluginHub.injection,
	  EventPluginUtils: EventPluginUtils.injection,
	  EventEmitter: ReactBrowserEventEmitter.injection,
	  HostComponent: ReactHostComponent.injection,
	  Updates: ReactUpdates.injection
	};
	
	module.exports = ReactInjection;

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var warning = __webpack_require__(4);
	
	if (process.env.NODE_ENV !== 'production') {
	  var processingChildContext = false;
	
	  var warnInvalidSetState = function () {
	    process.env.NODE_ENV !== 'production' ? warning(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()') : void 0;
	  };
	}
	
	var ReactInvalidSetStateWarningHook = {
	  onBeginProcessingChildContext: function () {
	    processingChildContext = true;
	  },
	  onEndProcessingChildContext: function () {
	    processingChildContext = false;
	  },
	  onSetState: function () {
	    warnInvalidSetState();
	  }
	};
	
	module.exports = ReactInvalidSetStateWarningHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var adler32 = __webpack_require__(158);
	
	var TAG_END = /\/?>/;
	var COMMENT_START = /^<\!\-\-/;
	
	var ReactMarkupChecksum = {
	  CHECKSUM_ATTR_NAME: 'data-react-checksum',
	
	  /**
	   * @param {string} markup Markup string
	   * @return {string} Markup string with checksum attribute attached
	   */
	  addChecksumToMarkup: function (markup) {
	    var checksum = adler32(markup);
	
	    // Add checksum (handle both parent tags, comments and self-closing tags)
	    if (COMMENT_START.test(markup)) {
	      return markup;
	    } else {
	      return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
	    }
	  },
	
	  /**
	   * @param {string} markup to use
	   * @param {DOMElement} element root React element
	   * @returns {boolean} whether or not the markup is the same
	   */
	  canReuseMarkup: function (markup, element) {
	    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
	    var markupChecksum = adler32(markup);
	    return markupChecksum === existingChecksum;
	  }
	};
	
	module.exports = ReactMarkupChecksum;

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var ReactComponentEnvironment = __webpack_require__(40);
	var ReactInstanceMap = __webpack_require__(26);
	var ReactInstrumentation = __webpack_require__(9);
	
	var ReactCurrentOwner = __webpack_require__(11);
	var ReactReconciler = __webpack_require__(22);
	var ReactChildReconciler = __webpack_require__(109);
	
	var emptyFunction = __webpack_require__(15);
	var flattenChildren = __webpack_require__(162);
	var invariant = __webpack_require__(2);
	
	/**
	 * Make an update for markup to be rendered and inserted at a supplied index.
	 *
	 * @param {string} markup Markup that renders into an element.
	 * @param {number} toIndex Destination index.
	 * @private
	 */
	function makeInsertMarkup(markup, afterNode, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'INSERT_MARKUP',
	    content: markup,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: toIndex,
	    afterNode: afterNode
	  };
	}
	
	/**
	 * Make an update for moving an existing element to another index.
	 *
	 * @param {number} fromIndex Source index of the existing element.
	 * @param {number} toIndex Destination index of the element.
	 * @private
	 */
	function makeMove(child, afterNode, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'MOVE_EXISTING',
	    content: null,
	    fromIndex: child._mountIndex,
	    fromNode: ReactReconciler.getHostNode(child),
	    toIndex: toIndex,
	    afterNode: afterNode
	  };
	}
	
	/**
	 * Make an update for removing an element at an index.
	 *
	 * @param {number} fromIndex Index of the element to remove.
	 * @private
	 */
	function makeRemove(child, node) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'REMOVE_NODE',
	    content: null,
	    fromIndex: child._mountIndex,
	    fromNode: node,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Make an update for setting the markup of a node.
	 *
	 * @param {string} markup Markup that renders into an element.
	 * @private
	 */
	function makeSetMarkup(markup) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'SET_MARKUP',
	    content: markup,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Make an update for setting the text content.
	 *
	 * @param {string} textContent Text content to set.
	 * @private
	 */
	function makeTextContent(textContent) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'TEXT_CONTENT',
	    content: textContent,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Push an update, if any, onto the queue. Creates a new queue if none is
	 * passed and always returns the queue. Mutative.
	 */
	function enqueue(queue, update) {
	  if (update) {
	    queue = queue || [];
	    queue.push(update);
	  }
	  return queue;
	}
	
	/**
	 * Processes any enqueued updates.
	 *
	 * @private
	 */
	function processQueue(inst, updateQueue) {
	  ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
	}
	
	var setChildrenForInstrumentation = emptyFunction;
	if (process.env.NODE_ENV !== 'production') {
	  var getDebugID = function (inst) {
	    if (!inst._debugID) {
	      // Check for ART-like instances. TODO: This is silly/gross.
	      var internal;
	      if (internal = ReactInstanceMap.get(inst)) {
	        inst = internal;
	      }
	    }
	    return inst._debugID;
	  };
	  setChildrenForInstrumentation = function (children) {
	    var debugID = getDebugID(this);
	    // TODO: React Native empty components are also multichild.
	    // This means they still get into this method but don't have _debugID.
	    if (debugID !== 0) {
	      ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {
	        return children[key]._debugID;
	      }) : []);
	    }
	  };
	}
	
	/**
	 * ReactMultiChild are capable of reconciling multiple children.
	 *
	 * @class ReactMultiChild
	 * @internal
	 */
	var ReactMultiChild = {
	
	  /**
	   * Provides common functionality for components that must reconcile multiple
	   * children. This is used by `ReactDOMComponent` to mount, update, and
	   * unmount child components.
	   *
	   * @lends {ReactMultiChild.prototype}
	   */
	  Mixin: {
	
	    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
	      if (process.env.NODE_ENV !== 'production') {
	        var selfDebugID = getDebugID(this);
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	        }
	      }
	      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	    },
	
	    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
	      var nextChildren;
	      var selfDebugID = 0;
	      if (process.env.NODE_ENV !== 'production') {
	        selfDebugID = getDebugID(this);
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	          ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
	          return nextChildren;
	        }
	      }
	      nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
	      ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
	      return nextChildren;
	    },
	
	    /**
	     * Generates a "mount image" for each of the supplied children. In the case
	     * of `ReactDOMComponent`, a mount image is a string of markup.
	     *
	     * @param {?object} nestedChildren Nested child maps.
	     * @return {array} An array of mounted representations.
	     * @internal
	     */
	    mountChildren: function (nestedChildren, transaction, context) {
	      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
	      this._renderedChildren = children;
	
	      var mountImages = [];
	      var index = 0;
	      for (var name in children) {
	        if (children.hasOwnProperty(name)) {
	          var child = children[name];
	          var selfDebugID = 0;
	          if (process.env.NODE_ENV !== 'production') {
	            selfDebugID = getDebugID(this);
	          }
	          var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
	          child._mountIndex = index++;
	          mountImages.push(mountImage);
	        }
	      }
	
	      if (process.env.NODE_ENV !== 'production') {
	        setChildrenForInstrumentation.call(this, children);
	      }
	
	      return mountImages;
	    },
	
	    /**
	     * Replaces any rendered children with a text content string.
	     *
	     * @param {string} nextContent String of content.
	     * @internal
	     */
	    updateTextContent: function (nextContent) {
	      var prevChildren = this._renderedChildren;
	      // Remove any rendered children.
	      ReactChildReconciler.unmountChildren(prevChildren, false);
	      for (var name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name)) {
	           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
	        }
	      }
	      // Set new text content.
	      var updates = [makeTextContent(nextContent)];
	      processQueue(this, updates);
	    },
	
	    /**
	     * Replaces any rendered children with a markup string.
	     *
	     * @param {string} nextMarkup String of markup.
	     * @internal
	     */
	    updateMarkup: function (nextMarkup) {
	      var prevChildren = this._renderedChildren;
	      // Remove any rendered children.
	      ReactChildReconciler.unmountChildren(prevChildren, false);
	      for (var name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name)) {
	           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
	        }
	      }
	      var updates = [makeSetMarkup(nextMarkup)];
	      processQueue(this, updates);
	    },
	
	    /**
	     * Updates the rendered children with new children.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     */
	    updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      // Hook used by React ART
	      this._updateChildren(nextNestedChildrenElements, transaction, context);
	    },
	
	    /**
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @final
	     * @protected
	     */
	    _updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      var prevChildren = this._renderedChildren;
	      var removedNodes = {};
	      var mountImages = [];
	      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);
	      if (!nextChildren && !prevChildren) {
	        return;
	      }
	      var updates = null;
	      var name;
	      // `nextIndex` will increment for each child in `nextChildren`, but
	      // `lastIndex` will be the last index visited in `prevChildren`.
	      var nextIndex = 0;
	      var lastIndex = 0;
	      // `nextMountIndex` will increment for each newly mounted child.
	      var nextMountIndex = 0;
	      var lastPlacedNode = null;
	      for (name in nextChildren) {
	        if (!nextChildren.hasOwnProperty(name)) {
	          continue;
	        }
	        var prevChild = prevChildren && prevChildren[name];
	        var nextChild = nextChildren[name];
	        if (prevChild === nextChild) {
	          updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
	          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	          prevChild._mountIndex = nextIndex;
	        } else {
	          if (prevChild) {
	            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
	            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	            // The `removedNodes` loop below will actually remove the child.
	          }
	          // The child must be instantiated before it's mounted.
	          updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));
	          nextMountIndex++;
	        }
	        nextIndex++;
	        lastPlacedNode = ReactReconciler.getHostNode(nextChild);
	      }
	      // Remove children that are no longer present.
	      for (name in removedNodes) {
	        if (removedNodes.hasOwnProperty(name)) {
	          updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
	        }
	      }
	      if (updates) {
	        processQueue(this, updates);
	      }
	      this._renderedChildren = nextChildren;
	
	      if (process.env.NODE_ENV !== 'production') {
	        setChildrenForInstrumentation.call(this, nextChildren);
	      }
	    },
	
	    /**
	     * Unmounts all rendered children. This should be used to clean up children
	     * when this component is unmounted. It does not actually perform any
	     * backend operations.
	     *
	     * @internal
	     */
	    unmountChildren: function (safely) {
	      var renderedChildren = this._renderedChildren;
	      ReactChildReconciler.unmountChildren(renderedChildren, safely);
	      this._renderedChildren = null;
	    },
	
	    /**
	     * Moves a child component to the supplied index.
	     *
	     * @param {ReactComponent} child Component to move.
	     * @param {number} toIndex Destination index of the element.
	     * @param {number} lastIndex Last index visited of the siblings of `child`.
	     * @protected
	     */
	    moveChild: function (child, afterNode, toIndex, lastIndex) {
	      // If the index of `child` is less than `lastIndex`, then it needs to
	      // be moved. Otherwise, we do not need to move it because a child will be
	      // inserted or moved before `child`.
	      if (child._mountIndex < lastIndex) {
	        return makeMove(child, afterNode, toIndex);
	      }
	    },
	
	    /**
	     * Creates a child component.
	     *
	     * @param {ReactComponent} child Component to create.
	     * @param {string} mountImage Markup to insert.
	     * @protected
	     */
	    createChild: function (child, afterNode, mountImage) {
	      return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
	    },
	
	    /**
	     * Removes a child component.
	     *
	     * @param {ReactComponent} child Child to remove.
	     * @protected
	     */
	    removeChild: function (child, node) {
	      return makeRemove(child, node);
	    },
	
	    /**
	     * Mounts a child with the supplied name.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to mount.
	     * @param {string} name Name of the child.
	     * @param {number} index Index at which to insert the child.
	     * @param {ReactReconcileTransaction} transaction
	     * @private
	     */
	    _mountChildAtIndex: function (child, mountImage, afterNode, index, transaction, context) {
	      child._mountIndex = index;
	      return this.createChild(child, afterNode, mountImage);
	    },
	
	    /**
	     * Unmounts a rendered child.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to unmount.
	     * @private
	     */
	    _unmountChild: function (child, node) {
	      var update = this.removeChild(child, node);
	      child._mountIndex = null;
	      return update;
	    }
	
	  }
	
	};
	
	module.exports = ReactMultiChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid owner.
	 * @final
	 */
	function isValidOwner(object) {
	  return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
	}
	
	/**
	 * ReactOwners are capable of storing references to owned components.
	 *
	 * All components are capable of //being// referenced by owner components, but
	 * only ReactOwner components are capable of //referencing// owned components.
	 * The named reference is known as a "ref".
	 *
	 * Refs are available when mounted and updated during reconciliation.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return (
	 *         <div onClick={this.handleClick}>
	 *           <CustomComponent ref="custom" />
	 *         </div>
	 *       );
	 *     },
	 *     handleClick: function() {
	 *       this.refs.custom.handleClick();
	 *     },
	 *     componentDidMount: function() {
	 *       this.refs.custom.initialize();
	 *     }
	 *   });
	 *
	 * Refs should rarely be used. When refs are used, they should only be done to
	 * control data that is not handled by React's data flow.
	 *
	 * @class ReactOwner
	 */
	var ReactOwner = {
	  /**
	   * Adds a component by ref to an owner component.
	   *
	   * @param {ReactComponent} component Component to reference.
	   * @param {string} ref Name by which to refer to the component.
	   * @param {ReactOwner} owner Component on which to record the ref.
	   * @final
	   * @internal
	   */
	  addComponentAsRefTo: function (component, ref, owner) {
	    !isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('119') : void 0;
	    owner.attachRef(ref, component);
	  },
	
	  /**
	   * Removes a component by ref from an owner component.
	   *
	   * @param {ReactComponent} component Component to dereference.
	   * @param {string} ref Name of the ref to remove.
	   * @param {ReactOwner} owner Component on which the ref is recorded.
	   * @final
	   * @internal
	   */
	  removeComponentAsRefFrom: function (component, ref, owner) {
	    !isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('120') : void 0;
	    var ownerPublicInstance = owner.getPublicInstance();
	    // Check that `component`'s owner is still alive and that `component` is still the current ref
	    // because we do not want to detach the ref if another component stole it.
	    if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
	      owner.detachRef(ref);
	    }
	  }
	
	};
	
	module.exports = ReactOwner;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 139 */
53,
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var CallbackQueue = __webpack_require__(59);
	var PooledClass = __webpack_require__(17);
	var ReactBrowserEventEmitter = __webpack_require__(29);
	var ReactInputSelection = __webpack_require__(66);
	var ReactInstrumentation = __webpack_require__(9);
	var Transaction = __webpack_require__(31);
	var ReactUpdateQueue = __webpack_require__(42);
	
	/**
	 * Ensures that, when possible, the selection range (currently selected text
	 * input) is not disturbed by performing the transaction.
	 */
	var SELECTION_RESTORATION = {
	  /**
	   * @return {Selection} Selection information.
	   */
	  initialize: ReactInputSelection.getSelectionInformation,
	  /**
	   * @param {Selection} sel Selection information returned from `initialize`.
	   */
	  close: ReactInputSelection.restoreSelection
	};
	
	/**
	 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
	 * high level DOM manipulations (like temporarily removing a text input from the
	 * DOM).
	 */
	var EVENT_SUPPRESSION = {
	  /**
	   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
	   * the reconciliation.
	   */
	  initialize: function () {
	    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
	    ReactBrowserEventEmitter.setEnabled(false);
	    return currentlyEnabled;
	  },
	
	  /**
	   * @param {boolean} previouslyEnabled Enabled status of
	   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
	   *   restores the previous value.
	   */
	  close: function (previouslyEnabled) {
	    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
	  }
	};
	
	/**
	 * Provides a queue for collecting `componentDidMount` and
	 * `componentDidUpdate` callbacks during the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function () {
	    this.reactMountReady.reset();
	  },
	
	  /**
	   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
	   */
	  close: function () {
	    this.reactMountReady.notifyAll();
	  }
	};
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];
	
	if (process.env.NODE_ENV !== 'production') {
	  TRANSACTION_WRAPPERS.push({
	    initialize: ReactInstrumentation.debugTool.onBeginFlush,
	    close: ReactInstrumentation.debugTool.onEndFlush
	  });
	}
	
	/**
	 * Currently:
	 * - The order that these are listed in the transaction is critical:
	 * - Suppresses events.
	 * - Restores selection range.
	 *
	 * Future:
	 * - Restore document/overflow scroll positions that were unintentionally
	 *   modified via DOM insertions above the top viewport boundary.
	 * - Implement/integrate with customized constraint based layout system and keep
	 *   track of which dimensions must be remeasured.
	 *
	 * @class ReactReconcileTransaction
	 */
	function ReactReconcileTransaction(useCreateElement) {
	  this.reinitializeTransaction();
	  // Only server-side rendering really needs this option (see
	  // `ReactServerRendering`), but server-side uses
	  // `ReactServerRenderingTransaction` instead. This option is here so that it's
	  // accessible and defaults to false when `ReactDOMComponent` and
	  // `ReactDOMTextComponent` checks it in `mountComponent`.`
	  this.renderToStaticMarkup = false;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = useCreateElement;
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array<object>} List of operation wrap procedures.
	   *   TODO: convert to array<TransactionWrapper>
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return this.reactMountReady;
	  },
	
	  /**
	   * @return {object} The queue to collect React async events.
	   */
	  getUpdateQueue: function () {
	    return ReactUpdateQueue;
	  },
	
	  /**
	   * Save current transaction state -- if the return value from this method is
	   * passed to `rollback`, the transaction will be reset to that state.
	   */
	  checkpoint: function () {
	    // reactMountReady is the our only stateful wrapper
	    return this.reactMountReady.checkpoint();
	  },
	
	  rollback: function (checkpoint) {
	    this.reactMountReady.rollback(checkpoint);
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};
	
	_assign(ReactReconcileTransaction.prototype, Transaction, Mixin);
	
	PooledClass.addPoolingTo(ReactReconcileTransaction);
	
	module.exports = ReactReconcileTransaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var ReactOwner = __webpack_require__(138);
	
	var ReactRef = {};
	
	function attachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(component.getPublicInstance());
	  } else {
	    // Legacy ref
	    ReactOwner.addComponentAsRefTo(component, ref, owner);
	  }
	}
	
	function detachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(null);
	  } else {
	    // Legacy ref
	    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
	  }
	}
	
	ReactRef.attachRefs = function (instance, element) {
	  if (element === null || typeof element !== 'object') {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    attachRef(ref, instance, element._owner);
	  }
	};
	
	ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
	  // If either the owner or a `ref` has changed, make sure the newest owner
	  // has stored a reference to `this`, and the previous owner (if different)
	  // has forgotten the reference to `this`. We use the element instead
	  // of the public this.props because the post processing cannot determine
	  // a ref. The ref conceptually lives on the element.
	
	  // TODO: Should this even be possible? The owner cannot change because
	  // it's forbidden by shouldUpdateReactComponent. The ref can change
	  // if you swap the keys of but not the refs. Reconsider where this check
	  // is made. It probably belongs where the key checking and
	  // instantiateReactComponent is done.
	
	  var prevRef = null;
	  var prevOwner = null;
	  if (prevElement !== null && typeof prevElement === 'object') {
	    prevRef = prevElement.ref;
	    prevOwner = prevElement._owner;
	  }
	
	  var nextRef = null;
	  var nextOwner = null;
	  if (nextElement !== null && typeof nextElement === 'object') {
	    nextRef = nextElement.ref;
	    nextOwner = nextElement._owner;
	  }
	
	  return prevRef !== nextRef ||
	  // If owner changes but we have an unchanged function ref, don't update refs
	  typeof nextRef === 'string' && nextOwner !== prevOwner;
	};
	
	ReactRef.detachRefs = function (instance, element) {
	  if (element === null || typeof element !== 'object') {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    detachRef(ref, instance, element._owner);
	  }
	};
	
	module.exports = ReactRef;

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var PooledClass = __webpack_require__(17);
	var Transaction = __webpack_require__(31);
	var ReactInstrumentation = __webpack_require__(9);
	var ReactServerUpdateQueue = __webpack_require__(143);
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [];
	
	if (process.env.NODE_ENV !== 'production') {
	  TRANSACTION_WRAPPERS.push({
	    initialize: ReactInstrumentation.debugTool.onBeginFlush,
	    close: ReactInstrumentation.debugTool.onEndFlush
	  });
	}
	
	var noopCallbackQueue = {
	  enqueue: function () {}
	};
	
	/**
	 * @class ReactServerRenderingTransaction
	 * @param {boolean} renderToStaticMarkup
	 */
	function ReactServerRenderingTransaction(renderToStaticMarkup) {
	  this.reinitializeTransaction();
	  this.renderToStaticMarkup = renderToStaticMarkup;
	  this.useCreateElement = false;
	  this.updateQueue = new ReactServerUpdateQueue(this);
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array} Empty list of operation wrap procedures.
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return noopCallbackQueue;
	  },
	
	  /**
	   * @return {object} The queue to collect React async events.
	   */
	  getUpdateQueue: function () {
	    return this.updateQueue;
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {},
	
	  checkpoint: function () {},
	
	  rollback: function () {}
	};
	
	_assign(ReactServerRenderingTransaction.prototype, Transaction, Mixin);
	
	PooledClass.addPoolingTo(ReactServerRenderingTransaction);
	
	module.exports = ReactServerRenderingTransaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var ReactUpdateQueue = __webpack_require__(42);
	
	var warning = __webpack_require__(4);
	
	function warnNoop(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    var constructor = publicInstance.constructor;
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
	  }
	}
	
	/**
	 * This is the update queue used for server rendering.
	 * It delegates to ReactUpdateQueue while server rendering is in progress and
	 * switches to ReactNoopUpdateQueue after the transaction has completed.
	 * @class ReactServerUpdateQueue
	 * @param {Transaction} transaction
	 */
	
	var ReactServerUpdateQueue = function () {
	  function ReactServerUpdateQueue(transaction) {
	    _classCallCheck(this, ReactServerUpdateQueue);
	
	    this.transaction = transaction;
	  }
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	
	
	  ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {
	    return false;
	  };
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	
	
	  ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
	    }
	  };
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	
	
	  ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueForceUpdate(publicInstance);
	    } else {
	      warnNoop(publicInstance, 'forceUpdate');
	    }
	  };
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object|function} completeState Next state.
	   * @internal
	   */
	
	
	  ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
	    } else {
	      warnNoop(publicInstance, 'replaceState');
	    }
	  };
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object|function} partialState Next partial state to be merged with state.
	   * @internal
	   */
	
	
	  ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
	    } else {
	      warnNoop(publicInstance, 'setState');
	    }
	  };
	
	  return ReactServerUpdateQueue;
	}();
	
	module.exports = ReactServerUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 144 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	module.exports = '15.4.0';

/***/ },
/* 145 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var NS = {
	  xlink: 'http://www.w3.org/1999/xlink',
	  xml: 'http://www.w3.org/XML/1998/namespace'
	};
	
	// We use attributes for everything SVG so let's avoid some duplication and run
	// code instead.
	// The following are all specified in the HTML config already so we exclude here.
	// - class (as className)
	// - color
	// - height
	// - id
	// - lang
	// - max
	// - media
	// - method
	// - min
	// - name
	// - style
	// - target
	// - type
	// - width
	var ATTRS = {
	  accentHeight: 'accent-height',
	  accumulate: 0,
	  additive: 0,
	  alignmentBaseline: 'alignment-baseline',
	  allowReorder: 'allowReorder',
	  alphabetic: 0,
	  amplitude: 0,
	  arabicForm: 'arabic-form',
	  ascent: 0,
	  attributeName: 'attributeName',
	  attributeType: 'attributeType',
	  autoReverse: 'autoReverse',
	  azimuth: 0,
	  baseFrequency: 'baseFrequency',
	  baseProfile: 'baseProfile',
	  baselineShift: 'baseline-shift',
	  bbox: 0,
	  begin: 0,
	  bias: 0,
	  by: 0,
	  calcMode: 'calcMode',
	  capHeight: 'cap-height',
	  clip: 0,
	  clipPath: 'clip-path',
	  clipRule: 'clip-rule',
	  clipPathUnits: 'clipPathUnits',
	  colorInterpolation: 'color-interpolation',
	  colorInterpolationFilters: 'color-interpolation-filters',
	  colorProfile: 'color-profile',
	  colorRendering: 'color-rendering',
	  contentScriptType: 'contentScriptType',
	  contentStyleType: 'contentStyleType',
	  cursor: 0,
	  cx: 0,
	  cy: 0,
	  d: 0,
	  decelerate: 0,
	  descent: 0,
	  diffuseConstant: 'diffuseConstant',
	  direction: 0,
	  display: 0,
	  divisor: 0,
	  dominantBaseline: 'dominant-baseline',
	  dur: 0,
	  dx: 0,
	  dy: 0,
	  edgeMode: 'edgeMode',
	  elevation: 0,
	  enableBackground: 'enable-background',
	  end: 0,
	  exponent: 0,
	  externalResourcesRequired: 'externalResourcesRequired',
	  fill: 0,
	  fillOpacity: 'fill-opacity',
	  fillRule: 'fill-rule',
	  filter: 0,
	  filterRes: 'filterRes',
	  filterUnits: 'filterUnits',
	  floodColor: 'flood-color',
	  floodOpacity: 'flood-opacity',
	  focusable: 0,
	  fontFamily: 'font-family',
	  fontSize: 'font-size',
	  fontSizeAdjust: 'font-size-adjust',
	  fontStretch: 'font-stretch',
	  fontStyle: 'font-style',
	  fontVariant: 'font-variant',
	  fontWeight: 'font-weight',
	  format: 0,
	  from: 0,
	  fx: 0,
	  fy: 0,
	  g1: 0,
	  g2: 0,
	  glyphName: 'glyph-name',
	  glyphOrientationHorizontal: 'glyph-orientation-horizontal',
	  glyphOrientationVertical: 'glyph-orientation-vertical',
	  glyphRef: 'glyphRef',
	  gradientTransform: 'gradientTransform',
	  gradientUnits: 'gradientUnits',
	  hanging: 0,
	  horizAdvX: 'horiz-adv-x',
	  horizOriginX: 'horiz-origin-x',
	  ideographic: 0,
	  imageRendering: 'image-rendering',
	  'in': 0,
	  in2: 0,
	  intercept: 0,
	  k: 0,
	  k1: 0,
	  k2: 0,
	  k3: 0,
	  k4: 0,
	  kernelMatrix: 'kernelMatrix',
	  kernelUnitLength: 'kernelUnitLength',
	  kerning: 0,
	  keyPoints: 'keyPoints',
	  keySplines: 'keySplines',
	  keyTimes: 'keyTimes',
	  lengthAdjust: 'lengthAdjust',
	  letterSpacing: 'letter-spacing',
	  lightingColor: 'lighting-color',
	  limitingConeAngle: 'limitingConeAngle',
	  local: 0,
	  markerEnd: 'marker-end',
	  markerMid: 'marker-mid',
	  markerStart: 'marker-start',
	  markerHeight: 'markerHeight',
	  markerUnits: 'markerUnits',
	  markerWidth: 'markerWidth',
	  mask: 0,
	  maskContentUnits: 'maskContentUnits',
	  maskUnits: 'maskUnits',
	  mathematical: 0,
	  mode: 0,
	  numOctaves: 'numOctaves',
	  offset: 0,
	  opacity: 0,
	  operator: 0,
	  order: 0,
	  orient: 0,
	  orientation: 0,
	  origin: 0,
	  overflow: 0,
	  overlinePosition: 'overline-position',
	  overlineThickness: 'overline-thickness',
	  paintOrder: 'paint-order',
	  panose1: 'panose-1',
	  pathLength: 'pathLength',
	  patternContentUnits: 'patternContentUnits',
	  patternTransform: 'patternTransform',
	  patternUnits: 'patternUnits',
	  pointerEvents: 'pointer-events',
	  points: 0,
	  pointsAtX: 'pointsAtX',
	  pointsAtY: 'pointsAtY',
	  pointsAtZ: 'pointsAtZ',
	  preserveAlpha: 'preserveAlpha',
	  preserveAspectRatio: 'preserveAspectRatio',
	  primitiveUnits: 'primitiveUnits',
	  r: 0,
	  radius: 0,
	  refX: 'refX',
	  refY: 'refY',
	  renderingIntent: 'rendering-intent',
	  repeatCount: 'repeatCount',
	  repeatDur: 'repeatDur',
	  requiredExtensions: 'requiredExtensions',
	  requiredFeatures: 'requiredFeatures',
	  restart: 0,
	  result: 0,
	  rotate: 0,
	  rx: 0,
	  ry: 0,
	  scale: 0,
	  seed: 0,
	  shapeRendering: 'shape-rendering',
	  slope: 0,
	  spacing: 0,
	  specularConstant: 'specularConstant',
	  specularExponent: 'specularExponent',
	  speed: 0,
	  spreadMethod: 'spreadMethod',
	  startOffset: 'startOffset',
	  stdDeviation: 'stdDeviation',
	  stemh: 0,
	  stemv: 0,
	  stitchTiles: 'stitchTiles',
	  stopColor: 'stop-color',
	  stopOpacity: 'stop-opacity',
	  strikethroughPosition: 'strikethrough-position',
	  strikethroughThickness: 'strikethrough-thickness',
	  string: 0,
	  stroke: 0,
	  strokeDasharray: 'stroke-dasharray',
	  strokeDashoffset: 'stroke-dashoffset',
	  strokeLinecap: 'stroke-linecap',
	  strokeLinejoin: 'stroke-linejoin',
	  strokeMiterlimit: 'stroke-miterlimit',
	  strokeOpacity: 'stroke-opacity',
	  strokeWidth: 'stroke-width',
	  surfaceScale: 'surfaceScale',
	  systemLanguage: 'systemLanguage',
	  tableValues: 'tableValues',
	  targetX: 'targetX',
	  targetY: 'targetY',
	  textAnchor: 'text-anchor',
	  textDecoration: 'text-decoration',
	  textRendering: 'text-rendering',
	  textLength: 'textLength',
	  to: 0,
	  transform: 0,
	  u1: 0,
	  u2: 0,
	  underlinePosition: 'underline-position',
	  underlineThickness: 'underline-thickness',
	  unicode: 0,
	  unicodeBidi: 'unicode-bidi',
	  unicodeRange: 'unicode-range',
	  unitsPerEm: 'units-per-em',
	  vAlphabetic: 'v-alphabetic',
	  vHanging: 'v-hanging',
	  vIdeographic: 'v-ideographic',
	  vMathematical: 'v-mathematical',
	  values: 0,
	  vectorEffect: 'vector-effect',
	  version: 0,
	  vertAdvY: 'vert-adv-y',
	  vertOriginX: 'vert-origin-x',
	  vertOriginY: 'vert-origin-y',
	  viewBox: 'viewBox',
	  viewTarget: 'viewTarget',
	  visibility: 0,
	  widths: 0,
	  wordSpacing: 'word-spacing',
	  writingMode: 'writing-mode',
	  x: 0,
	  xHeight: 'x-height',
	  x1: 0,
	  x2: 0,
	  xChannelSelector: 'xChannelSelector',
	  xlinkActuate: 'xlink:actuate',
	  xlinkArcrole: 'xlink:arcrole',
	  xlinkHref: 'xlink:href',
	  xlinkRole: 'xlink:role',
	  xlinkShow: 'xlink:show',
	  xlinkTitle: 'xlink:title',
	  xlinkType: 'xlink:type',
	  xmlBase: 'xml:base',
	  xmlns: 0,
	  xmlnsXlink: 'xmlns:xlink',
	  xmlLang: 'xml:lang',
	  xmlSpace: 'xml:space',
	  y: 0,
	  y1: 0,
	  y2: 0,
	  yChannelSelector: 'yChannelSelector',
	  z: 0,
	  zoomAndPan: 'zoomAndPan'
	};
	
	var SVGDOMPropertyConfig = {
	  Properties: {},
	  DOMAttributeNamespaces: {
	    xlinkActuate: NS.xlink,
	    xlinkArcrole: NS.xlink,
	    xlinkHref: NS.xlink,
	    xlinkRole: NS.xlink,
	    xlinkShow: NS.xlink,
	    xlinkTitle: NS.xlink,
	    xlinkType: NS.xlink,
	    xmlBase: NS.xml,
	    xmlLang: NS.xml,
	    xmlSpace: NS.xml
	  },
	  DOMAttributeNames: {}
	};
	
	Object.keys(ATTRS).forEach(function (key) {
	  SVGDOMPropertyConfig.Properties[key] = 0;
	  if (ATTRS[key]) {
	    SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
	  }
	});
	
	module.exports = SVGDOMPropertyConfig;

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var EventPropagators = __webpack_require__(25);
	var ExecutionEnvironment = __webpack_require__(7);
	var ReactDOMComponentTree = __webpack_require__(5);
	var ReactInputSelection = __webpack_require__(66);
	var SyntheticEvent = __webpack_require__(14);
	
	var getActiveElement = __webpack_require__(82);
	var isTextInputElement = __webpack_require__(76);
	var shallowEqual = __webpack_require__(50);
	
	var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;
	
	var eventTypes = {
	  select: {
	    phasedRegistrationNames: {
	      bubbled: 'onSelect',
	      captured: 'onSelectCapture'
	    },
	    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']
	  }
	};
	
	var activeElement = null;
	var activeElementInst = null;
	var lastSelection = null;
	var mouseDown = false;
	
	// Track whether a listener exists for this plugin. If none exist, we do
	// not extract events. See #3639.
	var hasListener = false;
	
	/**
	 * Get an object which is a unique representation of the current selection.
	 *
	 * The return value will not be consistent across nodes or browsers, but
	 * two identical selections on the same node will return identical objects.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getSelection(node) {
	  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
	    return {
	      start: node.selectionStart,
	      end: node.selectionEnd
	    };
	  } else if (window.getSelection) {
	    var selection = window.getSelection();
	    return {
	      anchorNode: selection.anchorNode,
	      anchorOffset: selection.anchorOffset,
	      focusNode: selection.focusNode,
	      focusOffset: selection.focusOffset
	    };
	  } else if (document.selection) {
	    var range = document.selection.createRange();
	    return {
	      parentElement: range.parentElement(),
	      text: range.text,
	      top: range.boundingTop,
	      left: range.boundingLeft
	    };
	  }
	}
	
	/**
	 * Poll selection to see whether it's changed.
	 *
	 * @param {object} nativeEvent
	 * @return {?SyntheticEvent}
	 */
	function constructSelectEvent(nativeEvent, nativeEventTarget) {
	  // Ensure we have the right element, and that the user is not dragging a
	  // selection (this matches native `select` event behavior). In HTML5, select
	  // fires only on input and textarea thus if there's no focused element we
	  // won't dispatch.
	  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
	    return null;
	  }
	
	  // Only fire when selection has actually changed.
	  var currentSelection = getSelection(activeElement);
	  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
	    lastSelection = currentSelection;
	
	    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);
	
	    syntheticEvent.type = 'select';
	    syntheticEvent.target = activeElement;
	
	    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
	
	    return syntheticEvent;
	  }
	
	  return null;
	}
	
	/**
	 * This plugin creates an `onSelect` event that normalizes select events
	 * across form elements.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - contentEditable
	 *
	 * This differs from native browser implementations in the following ways:
	 * - Fires on contentEditable fields as well as inputs.
	 * - Fires for collapsed selection.
	 * - Fires after user input.
	 */
	var SelectEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    if (!hasListener) {
	      return null;
	    }
	
	    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
	
	    switch (topLevelType) {
	      // Track the input node that has focus.
	      case 'topFocus':
	        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
	          activeElement = targetNode;
	          activeElementInst = targetInst;
	          lastSelection = null;
	        }
	        break;
	      case 'topBlur':
	        activeElement = null;
	        activeElementInst = null;
	        lastSelection = null;
	        break;
	
	      // Don't fire the event while the user is dragging. This matches the
	      // semantics of the native select event.
	      case 'topMouseDown':
	        mouseDown = true;
	        break;
	      case 'topContextMenu':
	      case 'topMouseUp':
	        mouseDown = false;
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	
	      // Chrome and IE fire non-standard event when selection is changed (and
	      // sometimes when it hasn't). IE's event fires out of order with respect
	      // to key and input events on deletion, so we discard it.
	      //
	      // Firefox doesn't support selectionchange, so check selection status
	      // after each key entry. The selection changes after keydown and before
	      // keyup, but we check on keydown as well in the case of holding down a
	      // key, when multiple keydown events are fired but only one keyup is.
	      // This is also our approach for IE handling, for the reason above.
	      case 'topSelectionChange':
	        if (skipSelectionChangeEvent) {
	          break;
	        }
	      // falls through
	      case 'topKeyDown':
	      case 'topKeyUp':
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	    }
	
	    return null;
	  },
	
	  didPutListener: function (inst, registrationName, listener) {
	    if (registrationName === 'onSelect') {
	      hasListener = true;
	    }
	  }
	};
	
	module.exports = SelectEventPlugin;

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var EventListener = __webpack_require__(79);
	var EventPropagators = __webpack_require__(25);
	var ReactDOMComponentTree = __webpack_require__(5);
	var SyntheticAnimationEvent = __webpack_require__(148);
	var SyntheticClipboardEvent = __webpack_require__(149);
	var SyntheticEvent = __webpack_require__(14);
	var SyntheticFocusEvent = __webpack_require__(152);
	var SyntheticKeyboardEvent = __webpack_require__(154);
	var SyntheticMouseEvent = __webpack_require__(30);
	var SyntheticDragEvent = __webpack_require__(151);
	var SyntheticTouchEvent = __webpack_require__(155);
	var SyntheticTransitionEvent = __webpack_require__(156);
	var SyntheticUIEvent = __webpack_require__(27);
	var SyntheticWheelEvent = __webpack_require__(157);
	
	var emptyFunction = __webpack_require__(15);
	var getEventCharCode = __webpack_require__(44);
	var invariant = __webpack_require__(2);
	
	/**
	 * Turns
	 * ['abort', ...]
	 * into
	 * eventTypes = {
	 *   'abort': {
	 *     phasedRegistrationNames: {
	 *       bubbled: 'onAbort',
	 *       captured: 'onAbortCapture',
	 *     },
	 *     dependencies: ['topAbort'],
	 *   },
	 *   ...
	 * };
	 * topLevelEventsToDispatchConfig = {
	 *   'topAbort': { sameConfig }
	 * };
	 */
	var eventTypes = {};
	var topLevelEventsToDispatchConfig = {};
	['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'canPlay', 'canPlayThrough', 'click', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {
	  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
	  var onEvent = 'on' + capitalizedEvent;
	  var topEvent = 'top' + capitalizedEvent;
	
	  var type = {
	    phasedRegistrationNames: {
	      bubbled: onEvent,
	      captured: onEvent + 'Capture'
	    },
	    dependencies: [topEvent]
	  };
	  eventTypes[event] = type;
	  topLevelEventsToDispatchConfig[topEvent] = type;
	});
	
	var onClickListeners = {};
	
	function getDictionaryKey(inst) {
	  // Prevents V8 performance issue:
	  // https://github.com/facebook/react/pull/7232
	  return '.' + inst._rootNodeID;
	}
	
	function isInteractive(tag) {
	  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
	}
	
	function shouldPreventMouseEvent(inst) {
	  if (inst) {
	    var disabled = inst._currentElement && inst._currentElement.props.disabled;
	
	    if (disabled) {
	      return isInteractive(inst._tag);
	    }
	  }
	
	  return false;
	}
	
	var SimpleEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
	    if (!dispatchConfig) {
	      return null;
	    }
	    var EventConstructor;
	    switch (topLevelType) {
	      case 'topAbort':
	      case 'topCanPlay':
	      case 'topCanPlayThrough':
	      case 'topDurationChange':
	      case 'topEmptied':
	      case 'topEncrypted':
	      case 'topEnded':
	      case 'topError':
	      case 'topInput':
	      case 'topInvalid':
	      case 'topLoad':
	      case 'topLoadedData':
	      case 'topLoadedMetadata':
	      case 'topLoadStart':
	      case 'topPause':
	      case 'topPlay':
	      case 'topPlaying':
	      case 'topProgress':
	      case 'topRateChange':
	      case 'topReset':
	      case 'topSeeked':
	      case 'topSeeking':
	      case 'topStalled':
	      case 'topSubmit':
	      case 'topSuspend':
	      case 'topTimeUpdate':
	      case 'topVolumeChange':
	      case 'topWaiting':
	        // HTML Events
	        // @see http://www.w3.org/TR/html5/index.html#events-0
	        EventConstructor = SyntheticEvent;
	        break;
	      case 'topKeyPress':
	        // Firefox creates a keypress event for function keys too. This removes
	        // the unwanted keypress events. Enter is however both printable and
	        // non-printable. One would expect Tab to be as well (but it isn't).
	        if (getEventCharCode(nativeEvent) === 0) {
	          return null;
	        }
	      /* falls through */
	      case 'topKeyDown':
	      case 'topKeyUp':
	        EventConstructor = SyntheticKeyboardEvent;
	        break;
	      case 'topBlur':
	      case 'topFocus':
	        EventConstructor = SyntheticFocusEvent;
	        break;
	      case 'topClick':
	        // Firefox creates a click event on right mouse clicks. This removes the
	        // unwanted click events.
	        if (nativeEvent.button === 2) {
	          return null;
	        }
	      /* falls through */
	      case 'topDoubleClick':
	      case 'topMouseDown':
	      case 'topMouseMove':
	      case 'topMouseUp':
	        // Disabled elements should not respond to mouse events
	        if (shouldPreventMouseEvent(targetInst)) {
	          return null;
	        }
	      /* falls through */
	      case 'topMouseOut':
	      case 'topMouseOver':
	      case 'topContextMenu':
	        EventConstructor = SyntheticMouseEvent;
	        break;
	      case 'topDrag':
	      case 'topDragEnd':
	      case 'topDragEnter':
	      case 'topDragExit':
	      case 'topDragLeave':
	      case 'topDragOver':
	      case 'topDragStart':
	      case 'topDrop':
	        EventConstructor = SyntheticDragEvent;
	        break;
	      case 'topTouchCancel':
	      case 'topTouchEnd':
	      case 'topTouchMove':
	      case 'topTouchStart':
	        EventConstructor = SyntheticTouchEvent;
	        break;
	      case 'topAnimationEnd':
	      case 'topAnimationIteration':
	      case 'topAnimationStart':
	        EventConstructor = SyntheticAnimationEvent;
	        break;
	      case 'topTransitionEnd':
	        EventConstructor = SyntheticTransitionEvent;
	        break;
	      case 'topScroll':
	        EventConstructor = SyntheticUIEvent;
	        break;
	      case 'topWheel':
	        EventConstructor = SyntheticWheelEvent;
	        break;
	      case 'topCopy':
	      case 'topCut':
	      case 'topPaste':
	        EventConstructor = SyntheticClipboardEvent;
	        break;
	    }
	    !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : _prodInvariant('86', topLevelType) : void 0;
	    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
	    EventPropagators.accumulateTwoPhaseDispatches(event);
	    return event;
	  },
	
	  didPutListener: function (inst, registrationName, listener) {
	    // Mobile Safari does not fire properly bubble click events on
	    // non-interactive elements, which means delegated click listeners do not
	    // fire. The workaround for this bug involves attaching an empty click
	    // listener on the target node.
	    // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
	      var key = getDictionaryKey(inst);
	      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	      if (!onClickListeners[key]) {
	        onClickListeners[key] = EventListener.listen(node, 'click', emptyFunction);
	      }
	    }
	  },
	
	  willDeleteListener: function (inst, registrationName) {
	    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
	      var key = getDictionaryKey(inst);
	      onClickListeners[key].remove();
	      delete onClickListeners[key];
	    }
	  }
	
	};
	
	module.exports = SimpleEventPlugin;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(14);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
	 */
	var AnimationEventInterface = {
	  animationName: null,
	  elapsedTime: null,
	  pseudoElement: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);
	
	module.exports = SyntheticAnimationEvent;

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(14);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/clipboard-apis/
	 */
	var ClipboardEventInterface = {
	  clipboardData: function (event) {
	    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
	
	module.exports = SyntheticClipboardEvent;

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(14);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
	 */
	var CompositionEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
	
	module.exports = SyntheticCompositionEvent;

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(30);
	
	/**
	 * @interface DragEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var DragEventInterface = {
	  dataTransfer: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
	
	module.exports = SyntheticDragEvent;

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(27);
	
	/**
	 * @interface FocusEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var FocusEventInterface = {
	  relatedTarget: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
	
	module.exports = SyntheticFocusEvent;

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(14);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
	 *      /#events-inputevents
	 */
	var InputEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
	
	module.exports = SyntheticInputEvent;

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(27);
	
	var getEventCharCode = __webpack_require__(44);
	var getEventKey = __webpack_require__(163);
	var getEventModifierState = __webpack_require__(45);
	
	/**
	 * @interface KeyboardEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var KeyboardEventInterface = {
	  key: getEventKey,
	  location: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  repeat: null,
	  locale: null,
	  getModifierState: getEventModifierState,
	  // Legacy Interface
	  charCode: function (event) {
	    // `charCode` is the result of a KeyPress event and represents the value of
	    // the actual printable character.
	
	    // KeyPress is deprecated, but its replacement is not yet final and not
	    // implemented in any major browser. Only KeyPress has charCode.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    return 0;
	  },
	  keyCode: function (event) {
	    // `keyCode` is the result of a KeyDown/Up event and represents the value of
	    // physical keyboard key.
	
	    // The actual meaning of the value depends on the users' keyboard layout
	    // which cannot be detected. Assuming that it is a US keyboard layout
	    // provides a surprisingly accurate mapping for US and European users.
	    // Due to this, it is left to the user to implement at this time.
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  },
	  which: function (event) {
	    // `which` is an alias for either `keyCode` or `charCode` depending on the
	    // type of the event.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
	
	module.exports = SyntheticKeyboardEvent;

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(27);
	
	var getEventModifierState = __webpack_require__(45);
	
	/**
	 * @interface TouchEvent
	 * @see http://www.w3.org/TR/touch-events/
	 */
	var TouchEventInterface = {
	  touches: null,
	  targetTouches: null,
	  changedTouches: null,
	  altKey: null,
	  metaKey: null,
	  ctrlKey: null,
	  shiftKey: null,
	  getModifierState: getEventModifierState
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
	
	module.exports = SyntheticTouchEvent;

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(14);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
	 */
	var TransitionEventInterface = {
	  propertyName: null,
	  elapsedTime: null,
	  pseudoElement: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);
	
	module.exports = SyntheticTransitionEvent;

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(30);
	
	/**
	 * @interface WheelEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var WheelEventInterface = {
	  deltaX: function (event) {
	    return 'deltaX' in event ? event.deltaX :
	    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
	    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
	  },
	  deltaY: function (event) {
	    return 'deltaY' in event ? event.deltaY :
	    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
	    'wheelDeltaY' in event ? -event.wheelDeltaY :
	    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
	    'wheelDelta' in event ? -event.wheelDelta : 0;
	  },
	  deltaZ: null,
	
	  // Browsers without "deltaMode" is reporting in raw wheel delta where one
	  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
	  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
	  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
	  deltaMode: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticMouseEvent}
	 */
	function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
	
	module.exports = SyntheticWheelEvent;

/***/ },
/* 158 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var MOD = 65521;
	
	// adler32 is not cryptographically strong, and is only used to sanity check that
	// markup generated on the server matches the markup generated on the client.
	// This implementation (a modified version of the SheetJS version) has been optimized
	// for our use case, at the expense of conforming to the adler32 specification
	// for non-ascii inputs.
	function adler32(data) {
	  var a = 1;
	  var b = 0;
	  var i = 0;
	  var l = data.length;
	  var m = l & ~0x3;
	  while (i < m) {
	    var n = Math.min(i + 4096, m);
	    for (; i < n; i += 4) {
	      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
	    }
	    a %= MOD;
	    b %= MOD;
	  }
	  for (; i < l; i++) {
	    b += a += data.charCodeAt(i);
	  }
	  a %= MOD;
	  b %= MOD;
	  return a | b << 16;
	}
	
	module.exports = adler32;

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var ReactPropTypeLocationNames = __webpack_require__(139);
	var ReactPropTypesSecret = __webpack_require__(69);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(4);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(8);
	}
	
	var loggedTypeFailures = {};
	
	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?object} element The React element that is being type-checked
	 * @param {?number} debugID The React component instance that is being type-checked
	 * @private
	 */
	function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
	  for (var typeSpecName in typeSpecs) {
	    if (typeSpecs.hasOwnProperty(typeSpecName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
	        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	      } catch (ex) {
	        error = ex;
	      }
	      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var componentStackInfo = '';
	
	        if (process.env.NODE_ENV !== 'production') {
	          if (!ReactComponentTreeHook) {
	            ReactComponentTreeHook = __webpack_require__(8);
	          }
	          if (debugID !== null) {
	            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
	          } else if (element !== null) {
	            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
	          }
	        }
	
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
	      }
	    }
	  }
	}
	
	module.exports = checkReactTypeSpec;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(58);
	var warning = __webpack_require__(4);
	
	var isUnitlessNumber = CSSProperty.isUnitlessNumber;
	var styleWarnings = {};
	
	/**
	 * Convert a value into the proper css writable value. The style name `name`
	 * should be logical (no hyphens), as specified
	 * in `CSSProperty.isUnitlessNumber`.
	 *
	 * @param {string} name CSS property name such as `topMargin`.
	 * @param {*} value CSS property value such as `10px`.
	 * @param {ReactDOMComponent} component
	 * @return {string} Normalized style value with dimensions applied.
	 */
	function dangerousStyleValue(name, value, component) {
	  // Note that we've removed escapeTextForBrowser() calls here since the
	  // whole string will be escaped when the attribute is injected into
	  // the markup. If you provide unsafe user data here they can inject
	  // arbitrary CSS which may be problematic (I couldn't repro this):
	  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
	  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
	  // This is not an XSS hole but instead a potential CSS injection issue
	  // which has lead to a greater discussion about how we're going to
	  // trust URLs moving forward. See #2115901
	
	  var isEmpty = value == null || typeof value === 'boolean' || value === '';
	  if (isEmpty) {
	    return '';
	  }
	
	  var isNonNumeric = isNaN(value);
	  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
	    return '' + value; // cast to string
	  }
	
	  if (typeof value === 'string') {
	    if (process.env.NODE_ENV !== 'production') {
	      // Allow '0' to pass through without warning. 0 is already special and
	      // doesn't require units, so we don't need to warn about it.
	      if (component && value !== '0') {
	        var owner = component._currentElement._owner;
	        var ownerName = owner ? owner.getName() : null;
	        if (ownerName && !styleWarnings[ownerName]) {
	          styleWarnings[ownerName] = {};
	        }
	        var warned = false;
	        if (ownerName) {
	          var warnings = styleWarnings[ownerName];
	          warned = warnings[name];
	          if (!warned) {
	            warnings[name] = true;
	          }
	        }
	        if (!warned) {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value) : void 0;
	        }
	      }
	    }
	    value = value.trim();
	  }
	  return value + 'px';
	}
	
	module.exports = dangerousStyleValue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(3);
	
	var ReactCurrentOwner = __webpack_require__(11);
	var ReactDOMComponentTree = __webpack_require__(5);
	var ReactInstanceMap = __webpack_require__(26);
	
	var getHostComponentFromComposite = __webpack_require__(73);
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(4);
	
	/**
	 * Returns the DOM node rendered by this element.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.finddomnode
	 *
	 * @param {ReactComponent|DOMElement} componentOrElement
	 * @return {?DOMElement} The root node of this element.
	 */
	function findDOMNode(componentOrElement) {
	  if (process.env.NODE_ENV !== 'production') {
	    var owner = ReactCurrentOwner.current;
	    if (owner !== null) {
	      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
	      owner._warnedAboutRefsInRender = true;
	    }
	  }
	  if (componentOrElement == null) {
	    return null;
	  }
	  if (componentOrElement.nodeType === 1) {
	    return componentOrElement;
	  }
	
	  var inst = ReactInstanceMap.get(componentOrElement);
	  if (inst) {
	    inst = getHostComponentFromComposite(inst);
	    return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
	  }
	
	  if (typeof componentOrElement.render === 'function') {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : _prodInvariant('44') : void 0;
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : _prodInvariant('45', Object.keys(componentOrElement)) : void 0;
	  }
	}
	
	module.exports = findDOMNode;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var KeyEscapeUtils = __webpack_require__(38);
	var traverseAllChildren = __webpack_require__(78);
	var warning = __webpack_require__(4);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(8);
	}
	
	/**
	 * @param {function} traverseContext Context passed through traversal.
	 * @param {?ReactComponent} child React child component.
	 * @param {!string} name String name of key path to child.
	 * @param {number=} selfDebugID Optional debugID of the current internal instance.
	 */
	function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
	  // We found a component instance.
	  if (traverseContext && typeof traverseContext === 'object') {
	    var result = traverseContext;
	    var keyUnique = result[name] === undefined;
	    if (process.env.NODE_ENV !== 'production') {
	      if (!ReactComponentTreeHook) {
	        ReactComponentTreeHook = __webpack_require__(8);
	      }
	      if (!keyUnique) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
	      }
	    }
	    if (keyUnique && child != null) {
	      result[name] = child;
	    }
	  }
	}
	
	/**
	 * Flattens children that are typically specified as `props.children`. Any null
	 * children will not be included in the resulting object.
	 * @return {!object} flattened children keyed by name.
	 */
	function flattenChildren(children, selfDebugID) {
	  if (children == null) {
	    return children;
	  }
	  var result = {};
	
	  if (process.env.NODE_ENV !== 'production') {
	    traverseAllChildren(children, function (traverseContext, child, name) {
	      return flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID);
	    }, result);
	  } else {
	    traverseAllChildren(children, flattenSingleChildIntoContext, result);
	  }
	  return result;
	}
	
	module.exports = flattenChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var getEventCharCode = __webpack_require__(44);
	
	/**
	 * Normalization of deprecated HTML5 `key` values
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var normalizeKey = {
	  'Esc': 'Escape',
	  'Spacebar': ' ',
	  'Left': 'ArrowLeft',
	  'Up': 'ArrowUp',
	  'Right': 'ArrowRight',
	  'Down': 'ArrowDown',
	  'Del': 'Delete',
	  'Win': 'OS',
	  'Menu': 'ContextMenu',
	  'Apps': 'ContextMenu',
	  'Scroll': 'ScrollLock',
	  'MozPrintableKey': 'Unidentified'
	};
	
	/**
	 * Translation from legacy `keyCode` to HTML5 `key`
	 * Only special keys supported, all others depend on keyboard layout or browser
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var translateToKey = {
	  8: 'Backspace',
	  9: 'Tab',
	  12: 'Clear',
	  13: 'Enter',
	  16: 'Shift',
	  17: 'Control',
	  18: 'Alt',
	  19: 'Pause',
	  20: 'CapsLock',
	  27: 'Escape',
	  32: ' ',
	  33: 'PageUp',
	  34: 'PageDown',
	  35: 'End',
	  36: 'Home',
	  37: 'ArrowLeft',
	  38: 'ArrowUp',
	  39: 'ArrowRight',
	  40: 'ArrowDown',
	  45: 'Insert',
	  46: 'Delete',
	  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
	  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
	  144: 'NumLock',
	  145: 'ScrollLock',
	  224: 'Meta'
	};
	
	/**
	 * @param {object} nativeEvent Native browser event.
	 * @return {string} Normalized `key` property.
	 */
	function getEventKey(nativeEvent) {
	  if (nativeEvent.key) {
	    // Normalize inconsistent values reported by browsers due to
	    // implementations of a working draft specification.
	
	    // FireFox implements `key` but returns `MozPrintableKey` for all
	    // printable characters (normalized to `Unidentified`), ignore it.
	    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
	    if (key !== 'Unidentified') {
	      return key;
	    }
	  }
	
	  // Browser does not implement `key`, polyfill as much of it as we can.
	  if (nativeEvent.type === 'keypress') {
	    var charCode = getEventCharCode(nativeEvent);
	
	    // The enter-key is technically both printable and non-printable and can
	    // thus be captured by `keypress`, no other non-printable key should.
	    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
	  }
	  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
	    // While user keyboard layout determines the actual meaning of each
	    // `keyCode` value, almost all function keys have a universal value.
	    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
	  }
	  return '';
	}
	
	module.exports = getEventKey;

/***/ },
/* 164 */
55,
/* 165 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var nextDebugID = 1;
	
	function getNextDebugID() {
	  return nextDebugID++;
	}
	
	module.exports = getNextDebugID;

/***/ },
/* 166 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Given any node return the first leaf node without children.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {DOMElement|DOMTextNode}
	 */
	
	function getLeafNode(node) {
	  while (node && node.firstChild) {
	    node = node.firstChild;
	  }
	  return node;
	}
	
	/**
	 * Get the next sibling within a container. This will walk up the
	 * DOM if a node's siblings have been exhausted.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {?DOMElement|DOMTextNode}
	 */
	function getSiblingNode(node) {
	  while (node) {
	    if (node.nextSibling) {
	      return node.nextSibling;
	    }
	    node = node.parentNode;
	  }
	}
	
	/**
	 * Get object describing the nodes which contain characters at offset.
	 *
	 * @param {DOMElement|DOMTextNode} root
	 * @param {number} offset
	 * @return {?object}
	 */
	function getNodeForCharacterOffset(root, offset) {
	  var node = getLeafNode(root);
	  var nodeStart = 0;
	  var nodeEnd = 0;
	
	  while (node) {
	    if (node.nodeType === 3) {
	      nodeEnd = nodeStart + node.textContent.length;
	
	      if (nodeStart <= offset && nodeEnd >= offset) {
	        return {
	          node: node,
	          offset: offset - nodeStart
	        };
	      }
	
	      nodeStart = nodeEnd;
	    }
	
	    node = getLeafNode(getSiblingNode(node));
	  }
	}
	
	module.exports = getNodeForCharacterOffset;

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(7);
	
	/**
	 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
	 *
	 * @param {string} styleProp
	 * @param {string} eventName
	 * @returns {object}
	 */
	function makePrefixMap(styleProp, eventName) {
	  var prefixes = {};
	
	  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
	  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
	  prefixes['Moz' + styleProp] = 'moz' + eventName;
	  prefixes['ms' + styleProp] = 'MS' + eventName;
	  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();
	
	  return prefixes;
	}
	
	/**
	 * A list of event names to a configurable list of vendor prefixes.
	 */
	var vendorPrefixes = {
	  animationend: makePrefixMap('Animation', 'AnimationEnd'),
	  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
	  animationstart: makePrefixMap('Animation', 'AnimationStart'),
	  transitionend: makePrefixMap('Transition', 'TransitionEnd')
	};
	
	/**
	 * Event names that have already been detected and prefixed (if applicable).
	 */
	var prefixedEventNames = {};
	
	/**
	 * Element to check for prefixes on.
	 */
	var style = {};
	
	/**
	 * Bootstrap if a DOM exists.
	 */
	if (ExecutionEnvironment.canUseDOM) {
	  style = document.createElement('div').style;
	
	  // On some platforms, in particular some releases of Android 4.x,
	  // the un-prefixed "animation" and "transition" properties are defined on the
	  // style object but the events that fire will still be prefixed, so we need
	  // to check if the un-prefixed events are usable, and if not remove them from the map.
	  if (!('AnimationEvent' in window)) {
	    delete vendorPrefixes.animationend.animation;
	    delete vendorPrefixes.animationiteration.animation;
	    delete vendorPrefixes.animationstart.animation;
	  }
	
	  // Same as above
	  if (!('TransitionEvent' in window)) {
	    delete vendorPrefixes.transitionend.transition;
	  }
	}
	
	/**
	 * Attempts to determine the correct vendor prefixed event name.
	 *
	 * @param {string} eventName
	 * @returns {string}
	 */
	function getVendorPrefixedEventName(eventName) {
	  if (prefixedEventNames[eventName]) {
	    return prefixedEventNames[eventName];
	  } else if (!vendorPrefixes[eventName]) {
	    return eventName;
	  }
	
	  var prefixMap = vendorPrefixes[eventName];
	
	  for (var styleProp in prefixMap) {
	    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
	      return prefixedEventNames[eventName] = prefixMap[styleProp];
	    }
	  }
	
	  return '';
	}
	
	module.exports = getVendorPrefixedEventName;

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var escapeTextContentForBrowser = __webpack_require__(32);
	
	/**
	 * Escapes attribute value to prevent scripting attacks.
	 *
	 * @param {*} value Value to escape.
	 * @return {string} An escaped string.
	 */
	function quoteAttributeValueForBrowser(value) {
	  return '"' + escapeTextContentForBrowser(value) + '"';
	}
	
	module.exports = quoteAttributeValueForBrowser;

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactMount = __webpack_require__(67);
	
	module.exports = ReactMount.renderSubtreeIntoContainer;

/***/ },
/* 170 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var _hyphenPattern = /-(.)/g;
	
	/**
	 * Camelcases a hyphenated string, for example:
	 *
	 *   > camelize('background-color')
	 *   < "backgroundColor"
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelize(string) {
	  return string.replace(_hyphenPattern, function (_, character) {
	    return character.toUpperCase();
	  });
	}
	
	module.exports = camelize;

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var camelize = __webpack_require__(170);
	
	var msPattern = /^-ms-/;
	
	/**
	 * Camelcases a hyphenated CSS property name, for example:
	 *
	 *   > camelizeStyleName('background-color')
	 *   < "backgroundColor"
	 *   > camelizeStyleName('-moz-transition')
	 *   < "MozTransition"
	 *   > camelizeStyleName('-ms-transition')
	 *   < "msTransition"
	 *
	 * As Andi Smith suggests
	 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
	 * is converted to lowercase `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelizeStyleName(string) {
	  return camelize(string.replace(msPattern, 'ms-'));
	}
	
	module.exports = camelizeStyleName;

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	var isTextNode = __webpack_require__(180);
	
	/*eslint-disable no-bitwise */
	
	/**
	 * Checks if a given DOM node contains or is another DOM node.
	 */
	function containsNode(outerNode, innerNode) {
	  if (!outerNode || !innerNode) {
	    return false;
	  } else if (outerNode === innerNode) {
	    return true;
	  } else if (isTextNode(outerNode)) {
	    return false;
	  } else if (isTextNode(innerNode)) {
	    return containsNode(outerNode, innerNode.parentNode);
	  } else if ('contains' in outerNode) {
	    return outerNode.contains(innerNode);
	  } else if (outerNode.compareDocumentPosition) {
	    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
	  } else {
	    return false;
	  }
	}
	
	module.exports = containsNode;

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Convert array-like objects to arrays.
	 *
	 * This API assumes the caller knows the contents of the data type. For less
	 * well defined inputs use createArrayFromMixed.
	 *
	 * @param {object|function|filelist} obj
	 * @return {array}
	 */
	function toArray(obj) {
	  var length = obj.length;
	
	  // Some browsers builtin objects can report typeof 'function' (e.g. NodeList
	  // in old versions of Safari).
	  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : void 0;
	
	  !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : void 0;
	
	  !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : void 0;
	
	  !(typeof obj.callee !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : invariant(false) : void 0;
	
	  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
	  // without method will throw during the slice call and skip straight to the
	  // fallback.
	  if (obj.hasOwnProperty) {
	    try {
	      return Array.prototype.slice.call(obj);
	    } catch (e) {
	      // IE < 9 does not support Array#slice on collections objects
	    }
	  }
	
	  // Fall back to copying key by key. This assumes all keys have a value,
	  // so will not preserve sparsely populated inputs.
	  var ret = Array(length);
	  for (var ii = 0; ii < length; ii++) {
	    ret[ii] = obj[ii];
	  }
	  return ret;
	}
	
	/**
	 * Perform a heuristic test to determine if an object is "array-like".
	 *
	 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
	 *   Joshu replied: "Mu."
	 *
	 * This function determines if its argument has "array nature": it returns
	 * true if the argument is an actual array, an `arguments' object, or an
	 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
	 *
	 * It will return false for other array-like objects like Filelist.
	 *
	 * @param {*} obj
	 * @return {boolean}
	 */
	function hasArrayNature(obj) {
	  return (
	    // not null/false
	    !!obj && (
	    // arrays are objects, NodeLists are functions in Safari
	    typeof obj == 'object' || typeof obj == 'function') &&
	    // quacks like an array
	    'length' in obj &&
	    // not window
	    !('setInterval' in obj) &&
	    // no DOM node should be considered an array-like
	    // a 'select' element has 'length' and 'item' properties on IE8
	    typeof obj.nodeType != 'number' && (
	    // a real array
	    Array.isArray(obj) ||
	    // arguments
	    'callee' in obj ||
	    // HTMLCollection/NodeList
	    'item' in obj)
	  );
	}
	
	/**
	 * Ensure that the argument is an array by wrapping it in an array if it is not.
	 * Creates a copy of the argument if it is already an array.
	 *
	 * This is mostly useful idiomatically:
	 *
	 *   var createArrayFromMixed = require('createArrayFromMixed');
	 *
	 *   function takesOneOrMoreThings(things) {
	 *     things = createArrayFromMixed(things);
	 *     ...
	 *   }
	 *
	 * This allows you to treat `things' as an array, but accept scalars in the API.
	 *
	 * If you need to convert an array-like object, like `arguments`, into an array
	 * use toArray instead.
	 *
	 * @param {*} obj
	 * @return {array}
	 */
	function createArrayFromMixed(obj) {
	  if (!hasArrayNature(obj)) {
	    return [obj];
	  } else if (Array.isArray(obj)) {
	    return obj.slice();
	  } else {
	    return toArray(obj);
	  }
	}
	
	module.exports = createArrayFromMixed;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/*eslint-disable fb-www/unsafe-html*/
	
	var ExecutionEnvironment = __webpack_require__(7);
	
	var createArrayFromMixed = __webpack_require__(173);
	var getMarkupWrap = __webpack_require__(175);
	var invariant = __webpack_require__(2);
	
	/**
	 * Dummy container used to render all markup.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Pattern used by `getNodeName`.
	 */
	var nodeNamePattern = /^\s*<(\w+)/;
	
	/**
	 * Extracts the `nodeName` of the first element in a string of markup.
	 *
	 * @param {string} markup String of markup.
	 * @return {?string} Node name of the supplied markup.
	 */
	function getNodeName(markup) {
	  var nodeNameMatch = markup.match(nodeNamePattern);
	  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
	}
	
	/**
	 * Creates an array containing the nodes rendered from the supplied markup. The
	 * optionally supplied `handleScript` function will be invoked once for each
	 * <script> element that is rendered. If no `handleScript` function is supplied,
	 * an exception is thrown if any <script> elements are rendered.
	 *
	 * @param {string} markup A string of valid HTML markup.
	 * @param {?function} handleScript Invoked once for each rendered <script>.
	 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
	 */
	function createNodesFromMarkup(markup, handleScript) {
	  var node = dummyNode;
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : void 0;
	  var nodeName = getNodeName(markup);
	
	  var wrap = nodeName && getMarkupWrap(nodeName);
	  if (wrap) {
	    node.innerHTML = wrap[1] + markup + wrap[2];
	
	    var wrapDepth = wrap[0];
	    while (wrapDepth--) {
	      node = node.lastChild;
	    }
	  } else {
	    node.innerHTML = markup;
	  }
	
	  var scripts = node.getElementsByTagName('script');
	  if (scripts.length) {
	    !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : void 0;
	    createArrayFromMixed(scripts).forEach(handleScript);
	  }
	
	  var nodes = Array.from(node.childNodes);
	  while (node.lastChild) {
	    node.removeChild(node.lastChild);
	  }
	  return nodes;
	}
	
	module.exports = createNodesFromMarkup;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/*eslint-disable fb-www/unsafe-html */
	
	var ExecutionEnvironment = __webpack_require__(7);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Dummy container used to detect which wraps are necessary.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Some browsers cannot use `innerHTML` to render certain elements standalone,
	 * so we wrap them, render the wrapped nodes, then extract the desired node.
	 *
	 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
	 */
	
	var shouldWrap = {};
	
	var selectWrap = [1, '<select multiple="true">', '</select>'];
	var tableWrap = [1, '<table>', '</table>'];
	var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
	
	var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];
	
	var markupWrap = {
	  '*': [1, '?<div>', '</div>'],
	
	  'area': [1, '<map>', '</map>'],
	  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
	  'legend': [1, '<fieldset>', '</fieldset>'],
	  'param': [1, '<object>', '</object>'],
	  'tr': [2, '<table><tbody>', '</tbody></table>'],
	
	  'optgroup': selectWrap,
	  'option': selectWrap,
	
	  'caption': tableWrap,
	  'colgroup': tableWrap,
	  'tbody': tableWrap,
	  'tfoot': tableWrap,
	  'thead': tableWrap,
	
	  'td': trWrap,
	  'th': trWrap
	};
	
	// Initialize the SVG elements since we know they'll always need to be wrapped
	// consistently. If they are created inside a <div> they will be initialized in
	// the wrong namespace (and will not display).
	var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
	svgElements.forEach(function (nodeName) {
	  markupWrap[nodeName] = svgWrap;
	  shouldWrap[nodeName] = true;
	});
	
	/**
	 * Gets the markup wrap configuration for the supplied `nodeName`.
	 *
	 * NOTE: This lazily detects which wraps are necessary for the current browser.
	 *
	 * @param {string} nodeName Lowercase `nodeName`.
	 * @return {?array} Markup wrap configuration, if applicable.
	 */
	function getMarkupWrap(nodeName) {
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : void 0;
	  if (!markupWrap.hasOwnProperty(nodeName)) {
	    nodeName = '*';
	  }
	  if (!shouldWrap.hasOwnProperty(nodeName)) {
	    if (nodeName === '*') {
	      dummyNode.innerHTML = '<link />';
	    } else {
	      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
	    }
	    shouldWrap[nodeName] = !dummyNode.firstChild;
	  }
	  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
	}
	
	module.exports = getMarkupWrap;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 176 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	/**
	 * Gets the scroll position of the supplied element or window.
	 *
	 * The return values are unbounded, unlike `getScrollPosition`. This means they
	 * may be negative or exceed the element boundaries (which is possible using
	 * inertial scrolling).
	 *
	 * @param {DOMWindow|DOMElement} scrollable
	 * @return {object} Map with `x` and `y` keys.
	 */
	
	function getUnboundedScrollPosition(scrollable) {
	  if (scrollable === window) {
	    return {
	      x: window.pageXOffset || document.documentElement.scrollLeft,
	      y: window.pageYOffset || document.documentElement.scrollTop
	    };
	  }
	  return {
	    x: scrollable.scrollLeft,
	    y: scrollable.scrollTop
	  };
	}
	
	module.exports = getUnboundedScrollPosition;

/***/ },
/* 177 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var _uppercasePattern = /([A-Z])/g;
	
	/**
	 * Hyphenates a camelcased string, for example:
	 *
	 *   > hyphenate('backgroundColor')
	 *   < "background-color"
	 *
	 * For CSS style names, use `hyphenateStyleName` instead which works properly
	 * with all vendor prefixes, including `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenate(string) {
	  return string.replace(_uppercasePattern, '-$1').toLowerCase();
	}
	
	module.exports = hyphenate;

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var hyphenate = __webpack_require__(177);
	
	var msPattern = /^ms-/;
	
	/**
	 * Hyphenates a camelcased CSS property name, for example:
	 *
	 *   > hyphenateStyleName('backgroundColor')
	 *   < "background-color"
	 *   > hyphenateStyleName('MozTransition')
	 *   < "-moz-transition"
	 *   > hyphenateStyleName('msTransition')
	 *   < "-ms-transition"
	 *
	 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	 * is converted to `-ms-`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenateStyleName(string) {
	  return hyphenate(string).replace(msPattern, '-ms-');
	}
	
	module.exports = hyphenateStyleName;

/***/ },
/* 179 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM node.
	 */
	function isNode(object) {
	  return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
	}
	
	module.exports = isNode;

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var isNode = __webpack_require__(179);
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM text node.
	 */
	function isTextNode(object) {
	  return isNode(object) && object.nodeType == 3;
	}
	
	module.exports = isTextNode;

/***/ },
/* 181 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Memoizes the return value of a function that accepts one string argument.
	 */
	
	function memoizeStringOnly(callback) {
	  var cache = {};
	  return function (string) {
	    if (!cache.hasOwnProperty(string)) {
	      cache[string] = callback.call(this, string);
	    }
	    return cache[string];
	  };
	}
	
	module.exports = memoizeStringOnly;

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(7);
	
	var performance;
	
	if (ExecutionEnvironment.canUseDOM) {
	  performance = window.performance || window.msPerformance || window.webkitPerformance;
	}
	
	module.exports = performance || {};

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var performance = __webpack_require__(182);
	
	var performanceNow;
	
	/**
	 * Detect if we can use `window.performance.now()` and gracefully fallback to
	 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
	 * because of Facebook's testing infrastructure.
	 */
	if (performance.now) {
	  performanceNow = function performanceNow() {
	    return performance.now();
	  };
	} else {
	  performanceNow = function performanceNow() {
	    return Date.now();
	  };
	}
	
	module.exports = performanceNow;

/***/ },
/* 184 */
38,
/* 185 */
[210, 19, 20],
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(185);
	var ReactElement = __webpack_require__(18);
	
	var emptyFunction = __webpack_require__(56);
	var traverseAllChildren = __webpack_require__(194);
	
	var twoArgumentPooler = PooledClass.twoArgumentPooler;
	var fourArgumentPooler = PooledClass.fourArgumentPooler;
	
	var userProvidedKeyEscapeRegex = /\/+/g;
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * traversal. Allows avoiding binding callbacks.
	 *
	 * @constructor ForEachBookKeeping
	 * @param {!function} forEachFunction Function to perform traversal with.
	 * @param {?*} forEachContext Context to perform context with.
	 */
	function ForEachBookKeeping(forEachFunction, forEachContext) {
	  this.func = forEachFunction;
	  this.context = forEachContext;
	  this.count = 0;
	}
	ForEachBookKeeping.prototype.destructor = function () {
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
	
	function forEachSingleChild(bookKeeping, child, name) {
	  var func = bookKeeping.func,
	      context = bookKeeping.context;
	
	  func.call(context, child, bookKeeping.count++);
	}
	
	/**
	 * Iterates through children that are typically specified as `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.foreach
	 *
	 * The provided forEachFunc(child, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} forEachFunc
	 * @param {*} forEachContext Context for forEachContext.
	 */
	function forEachChildren(children, forEachFunc, forEachContext) {
	  if (children == null) {
	    return children;
	  }
	  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
	  traverseAllChildren(children, forEachSingleChild, traverseContext);
	  ForEachBookKeeping.release(traverseContext);
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * mapping. Allows avoiding binding callbacks.
	 *
	 * @constructor MapBookKeeping
	 * @param {!*} mapResult Object containing the ordered map of results.
	 * @param {!function} mapFunction Function to perform mapping with.
	 * @param {?*} mapContext Context to perform mapping with.
	 */
	function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
	  this.result = mapResult;
	  this.keyPrefix = keyPrefix;
	  this.func = mapFunction;
	  this.context = mapContext;
	  this.count = 0;
	}
	MapBookKeeping.prototype.destructor = function () {
	  this.result = null;
	  this.keyPrefix = null;
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);
	
	function mapSingleChildIntoContext(bookKeeping, child, childKey) {
	  var result = bookKeeping.result,
	      keyPrefix = bookKeeping.keyPrefix,
	      func = bookKeeping.func,
	      context = bookKeeping.context;
	
	
	  var mappedChild = func.call(context, child, bookKeeping.count++);
	  if (Array.isArray(mappedChild)) {
	    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
	  } else if (mappedChild != null) {
	    if (ReactElement.isValidElement(mappedChild)) {
	      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
	      // Keep both the (mapped) and old keys if they differ, just as
	      // traverseAllChildren used to do for objects as children
	      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
	    }
	    result.push(mappedChild);
	  }
	}
	
	function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
	  var escapedPrefix = '';
	  if (prefix != null) {
	    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
	  }
	  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
	  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
	  MapBookKeeping.release(traverseContext);
	}
	
	/**
	 * Maps children that are typically specified as `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.map
	 *
	 * The provided mapFunction(child, key, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} func The map function.
	 * @param {*} context Context for mapFunction.
	 * @return {object} Object containing the ordered map of results.
	 */
	function mapChildren(children, func, context) {
	  if (children == null) {
	    return children;
	  }
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
	  return result;
	}
	
	function forEachSingleChildDummy(traverseContext, child, name) {
	  return null;
	}
	
	/**
	 * Count the number of children that are typically specified as
	 * `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.count
	 *
	 * @param {?*} children Children tree container.
	 * @return {number} The number of children.
	 */
	function countChildren(children, context) {
	  return traverseAllChildren(children, forEachSingleChildDummy, null);
	}
	
	/**
	 * Flatten a children object (typically specified as `props.children`) and
	 * return an array with appropriately re-keyed children.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.toarray
	 */
	function toArray(children) {
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
	  return result;
	}
	
	var ReactChildren = {
	  forEach: forEachChildren,
	  map: mapChildren,
	  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
	  count: countChildren,
	  toArray: toArray
	};
	
	module.exports = ReactChildren;

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(19),
	    _assign = __webpack_require__(34);
	
	var ReactComponent = __webpack_require__(51);
	var ReactElement = __webpack_require__(18);
	var ReactPropTypeLocationNames = __webpack_require__(53);
	var ReactNoopUpdateQueue = __webpack_require__(52);
	
	var emptyObject = __webpack_require__(57);
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(12);
	
	var MIXINS_KEY = 'mixins';
	
	// Helper function to allow the creation of anonymous functions which do not
	// have .name set to the name of the variable being assigned to.
	function identity(fn) {
	  return fn;
	}
	
	/**
	 * Policies that describe methods in `ReactClassInterface`.
	 */
	
	
	var injectedMixins = [];
	
	/**
	 * Composite components are higher-level components that compose other composite
	 * or host components.
	 *
	 * To create a new type of `ReactClass`, pass a specification of
	 * your new class to `React.createClass`. The only requirement of your class
	 * specification is that you implement a `render` method.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return <div>Hello World</div>;
	 *     }
	 *   });
	 *
	 * The class specification supports a specific protocol of methods that have
	 * special meaning (e.g. `render`). See `ReactClassInterface` for
	 * more the comprehensive protocol. Any other properties and methods in the
	 * class specification will be available on the prototype.
	 *
	 * @interface ReactClassInterface
	 * @internal
	 */
	var ReactClassInterface = {
	
	  /**
	   * An array of Mixin objects to include when defining your component.
	   *
	   * @type {array}
	   * @optional
	   */
	  mixins: 'DEFINE_MANY',
	
	  /**
	   * An object containing properties and methods that should be defined on
	   * the component's constructor instead of its prototype (static methods).
	   *
	   * @type {object}
	   * @optional
	   */
	  statics: 'DEFINE_MANY',
	
	  /**
	   * Definition of prop types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  propTypes: 'DEFINE_MANY',
	
	  /**
	   * Definition of context types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  contextTypes: 'DEFINE_MANY',
	
	  /**
	   * Definition of context types this component sets for its children.
	   *
	   * @type {object}
	   * @optional
	   */
	  childContextTypes: 'DEFINE_MANY',
	
	  // ==== Definition methods ====
	
	  /**
	   * Invoked when the component is mounted. Values in the mapping will be set on
	   * `this.props` if that prop is not specified (i.e. using an `in` check).
	   *
	   * This method is invoked before `getInitialState` and therefore cannot rely
	   * on `this.state` or use `this.setState`.
	   *
	   * @return {object}
	   * @optional
	   */
	  getDefaultProps: 'DEFINE_MANY_MERGED',
	
	  /**
	   * Invoked once before the component is mounted. The return value will be used
	   * as the initial value of `this.state`.
	   *
	   *   getInitialState: function() {
	   *     return {
	   *       isOn: false,
	   *       fooBaz: new BazFoo()
	   *     }
	   *   }
	   *
	   * @return {object}
	   * @optional
	   */
	  getInitialState: 'DEFINE_MANY_MERGED',
	
	  /**
	   * @return {object}
	   * @optional
	   */
	  getChildContext: 'DEFINE_MANY_MERGED',
	
	  /**
	   * Uses props from `this.props` and state from `this.state` to render the
	   * structure of the component.
	   *
	   * No guarantees are made about when or how often this method is invoked, so
	   * it must not have side effects.
	   *
	   *   render: function() {
	   *     var name = this.props.name;
	   *     return <div>Hello, {name}!</div>;
	   *   }
	   *
	   * @return {ReactComponent}
	   * @nosideeffects
	   * @required
	   */
	  render: 'DEFINE_ONCE',
	
	  // ==== Delegate methods ====
	
	  /**
	   * Invoked when the component is initially created and about to be mounted.
	   * This may have side effects, but any external subscriptions or data created
	   * by this method must be cleaned up in `componentWillUnmount`.
	   *
	   * @optional
	   */
	  componentWillMount: 'DEFINE_MANY',
	
	  /**
	   * Invoked when the component has been mounted and has a DOM representation.
	   * However, there is no guarantee that the DOM node is in the document.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been mounted (initialized and rendered) for the first time.
	   *
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidMount: 'DEFINE_MANY',
	
	  /**
	   * Invoked before the component receives new props.
	   *
	   * Use this as an opportunity to react to a prop transition by updating the
	   * state using `this.setState`. Current props are accessed via `this.props`.
	   *
	   *   componentWillReceiveProps: function(nextProps, nextContext) {
	   *     this.setState({
	   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
	   *     });
	   *   }
	   *
	   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
	   * transition may cause a state change, but the opposite is not true. If you
	   * need it, you are probably looking for `componentWillUpdate`.
	   *
	   * @param {object} nextProps
	   * @optional
	   */
	  componentWillReceiveProps: 'DEFINE_MANY',
	
	  /**
	   * Invoked while deciding if the component should be updated as a result of
	   * receiving new props, state and/or context.
	   *
	   * Use this as an opportunity to `return false` when you're certain that the
	   * transition to the new props/state/context will not require a component
	   * update.
	   *
	   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
	   *     return !equal(nextProps, this.props) ||
	   *       !equal(nextState, this.state) ||
	   *       !equal(nextContext, this.context);
	   *   }
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @return {boolean} True if the component should update.
	   * @optional
	   */
	  shouldComponentUpdate: 'DEFINE_ONCE',
	
	  /**
	   * Invoked when the component is about to update due to a transition from
	   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
	   * and `nextContext`.
	   *
	   * Use this as an opportunity to perform preparation before an update occurs.
	   *
	   * NOTE: You **cannot** use `this.setState()` in this method.
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @param {ReactReconcileTransaction} transaction
	   * @optional
	   */
	  componentWillUpdate: 'DEFINE_MANY',
	
	  /**
	   * Invoked when the component's DOM representation has been updated.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been updated.
	   *
	   * @param {object} prevProps
	   * @param {?object} prevState
	   * @param {?object} prevContext
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidUpdate: 'DEFINE_MANY',
	
	  /**
	   * Invoked when the component is about to be removed from its parent and have
	   * its DOM representation destroyed.
	   *
	   * Use this as an opportunity to deallocate any external resources.
	   *
	   * NOTE: There is no `componentDidUnmount` since your component will have been
	   * destroyed by that point.
	   *
	   * @optional
	   */
	  componentWillUnmount: 'DEFINE_MANY',
	
	  // ==== Advanced methods ====
	
	  /**
	   * Updates the component's currently mounted DOM representation.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   * @overridable
	   */
	  updateComponent: 'OVERRIDE_BASE'
	
	};
	
	/**
	 * Mapping from class specification keys to special processing functions.
	 *
	 * Although these are declared like instance properties in the specification
	 * when defining classes using `React.createClass`, they are actually static
	 * and are accessible on the constructor instead of the prototype. Despite
	 * being static, they must be defined outside of the "statics" key under
	 * which all other static methods are defined.
	 */
	var RESERVED_SPEC_KEYS = {
	  displayName: function (Constructor, displayName) {
	    Constructor.displayName = displayName;
	  },
	  mixins: function (Constructor, mixins) {
	    if (mixins) {
	      for (var i = 0; i < mixins.length; i++) {
	        mixSpecIntoComponent(Constructor, mixins[i]);
	      }
	    }
	  },
	  childContextTypes: function (Constructor, childContextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, childContextTypes, 'childContext');
	    }
	    Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);
	  },
	  contextTypes: function (Constructor, contextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, contextTypes, 'context');
	    }
	    Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);
	  },
	  /**
	   * Special case getDefaultProps which should move into statics but requires
	   * automatic merging.
	   */
	  getDefaultProps: function (Constructor, getDefaultProps) {
	    if (Constructor.getDefaultProps) {
	      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
	    } else {
	      Constructor.getDefaultProps = getDefaultProps;
	    }
	  },
	  propTypes: function (Constructor, propTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, propTypes, 'prop');
	    }
	    Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
	  },
	  statics: function (Constructor, statics) {
	    mixStaticSpecIntoComponent(Constructor, statics);
	  },
	  autobind: function () {} };
	
	function validateTypeDef(Constructor, typeDef, location) {
	  for (var propName in typeDef) {
	    if (typeDef.hasOwnProperty(propName)) {
	      // use a warning instead of an invariant so components
	      // don't show up in prod but only in __DEV__
	      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : void 0;
	    }
	  }
	}
	
	function validateMethodOverride(isAlreadyDefined, name) {
	  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
	
	  // Disallow overriding of base class methods unless explicitly allowed.
	  if (ReactClassMixin.hasOwnProperty(name)) {
	    !(specPolicy === 'OVERRIDE_BASE') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.', name) : _prodInvariant('73', name) : void 0;
	  }
	
	  // Disallow defining methods more than once unless explicitly allowed.
	  if (isAlreadyDefined) {
	    !(specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('74', name) : void 0;
	  }
	}
	
	/**
	 * Mixin helper which handles policy validation and reserved
	 * specification keys when building React classes.
	 */
	function mixSpecIntoComponent(Constructor, spec) {
	  if (!spec) {
	    if (process.env.NODE_ENV !== 'production') {
	      var typeofSpec = typeof spec;
	      var isMixinValid = typeofSpec === 'object' && spec !== null;
	
	      process.env.NODE_ENV !== 'production' ? warning(isMixinValid, '%s: You\'re attempting to include a mixin that is either null ' + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec) : void 0;
	    }
	
	    return;
	  }
	
	  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component class or function as a mixin. Instead, just use a regular object.') : _prodInvariant('75') : void 0;
	  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component as a mixin. Instead, just use a regular object.') : _prodInvariant('76') : void 0;
	
	  var proto = Constructor.prototype;
	  var autoBindPairs = proto.__reactAutoBindPairs;
	
	  // By handling mixins before any other properties, we ensure the same
	  // chaining order is applied to methods with DEFINE_MANY policy, whether
	  // mixins are listed before or after these methods in the spec.
	  if (spec.hasOwnProperty(MIXINS_KEY)) {
	    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
	  }
	
	  for (var name in spec) {
	    if (!spec.hasOwnProperty(name)) {
	      continue;
	    }
	
	    if (name === MIXINS_KEY) {
	      // We have already handled mixins in a special case above.
	      continue;
	    }
	
	    var property = spec[name];
	    var isAlreadyDefined = proto.hasOwnProperty(name);
	    validateMethodOverride(isAlreadyDefined, name);
	
	    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
	      RESERVED_SPEC_KEYS[name](Constructor, property);
	    } else {
	      // Setup methods on prototype:
	      // The following member methods should not be automatically bound:
	      // 1. Expected ReactClass methods (in the "interface").
	      // 2. Overridden methods (that were mixed in).
	      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
	      var isFunction = typeof property === 'function';
	      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;
	
	      if (shouldAutoBind) {
	        autoBindPairs.push(name, property);
	        proto[name] = property;
	      } else {
	        if (isAlreadyDefined) {
	          var specPolicy = ReactClassInterface[name];
	
	          // These cases should already be caught by validateMethodOverride.
	          !(isReactClassMethod && (specPolicy === 'DEFINE_MANY_MERGED' || specPolicy === 'DEFINE_MANY')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.', specPolicy, name) : _prodInvariant('77', specPolicy, name) : void 0;
	
	          // For methods which are defined more than once, call the existing
	          // methods before calling the new property, merging if appropriate.
	          if (specPolicy === 'DEFINE_MANY_MERGED') {
	            proto[name] = createMergedResultFunction(proto[name], property);
	          } else if (specPolicy === 'DEFINE_MANY') {
	            proto[name] = createChainedFunction(proto[name], property);
	          }
	        } else {
	          proto[name] = property;
	          if (process.env.NODE_ENV !== 'production') {
	            // Add verbose displayName to the function, which helps when looking
	            // at profiling tools.
	            if (typeof property === 'function' && spec.displayName) {
	              proto[name].displayName = spec.displayName + '_' + name;
	            }
	          }
	        }
	      }
	    }
	  }
	}
	
	function mixStaticSpecIntoComponent(Constructor, statics) {
	  if (!statics) {
	    return;
	  }
	  for (var name in statics) {
	    var property = statics[name];
	    if (!statics.hasOwnProperty(name)) {
	      continue;
	    }
	
	    var isReserved = name in RESERVED_SPEC_KEYS;
	    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.', name) : _prodInvariant('78', name) : void 0;
	
	    var isInherited = name in Constructor;
	    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('79', name) : void 0;
	    Constructor[name] = property;
	  }
	}
	
	/**
	 * Merge two objects, but throw if both contain the same key.
	 *
	 * @param {object} one The first object, which is mutated.
	 * @param {object} two The second object
	 * @return {object} one after it has been mutated to contain everything in two.
	 */
	function mergeIntoWithNoDuplicateKeys(one, two) {
	  !(one && two && typeof one === 'object' && typeof two === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : _prodInvariant('80') : void 0;
	
	  for (var key in two) {
	    if (two.hasOwnProperty(key)) {
	      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.', key) : _prodInvariant('81', key) : void 0;
	      one[key] = two[key];
	    }
	  }
	  return one;
	}
	
	/**
	 * Creates a function that invokes two functions and merges their return values.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createMergedResultFunction(one, two) {
	  return function mergedResult() {
	    var a = one.apply(this, arguments);
	    var b = two.apply(this, arguments);
	    if (a == null) {
	      return b;
	    } else if (b == null) {
	      return a;
	    }
	    var c = {};
	    mergeIntoWithNoDuplicateKeys(c, a);
	    mergeIntoWithNoDuplicateKeys(c, b);
	    return c;
	  };
	}
	
	/**
	 * Creates a function that invokes two functions and ignores their return vales.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createChainedFunction(one, two) {
	  return function chainedFunction() {
	    one.apply(this, arguments);
	    two.apply(this, arguments);
	  };
	}
	
	/**
	 * Binds a method to the component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 * @param {function} method Method to be bound.
	 * @return {function} The bound method.
	 */
	function bindAutoBindMethod(component, method) {
	  var boundMethod = method.bind(component);
	  if (process.env.NODE_ENV !== 'production') {
	    boundMethod.__reactBoundContext = component;
	    boundMethod.__reactBoundMethod = method;
	    boundMethod.__reactBoundArguments = null;
	    var componentName = component.constructor.displayName;
	    var _bind = boundMethod.bind;
	    boundMethod.bind = function (newThis) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      // User is trying to bind() an autobound method; we effectively will
	      // ignore the value of "this" that the user is trying to use, so
	      // let's warn.
	      if (newThis !== component && newThis !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : void 0;
	      } else if (!args.length) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : void 0;
	        return boundMethod;
	      }
	      var reboundMethod = _bind.apply(boundMethod, arguments);
	      reboundMethod.__reactBoundContext = component;
	      reboundMethod.__reactBoundMethod = method;
	      reboundMethod.__reactBoundArguments = args;
	      return reboundMethod;
	    };
	  }
	  return boundMethod;
	}
	
	/**
	 * Binds all auto-bound methods in a component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 */
	function bindAutoBindMethods(component) {
	  var pairs = component.__reactAutoBindPairs;
	  for (var i = 0; i < pairs.length; i += 2) {
	    var autoBindKey = pairs[i];
	    var method = pairs[i + 1];
	    component[autoBindKey] = bindAutoBindMethod(component, method);
	  }
	}
	
	/**
	 * Add more to the ReactClass base class. These are all legacy features and
	 * therefore not already part of the modern ReactComponent.
	 */
	var ReactClassMixin = {
	
	  /**
	   * TODO: This will be deprecated because state should always keep a consistent
	   * type signature and the only use case for this, is to avoid that.
	   */
	  replaceState: function (newState, callback) {
	    this.updater.enqueueReplaceState(this, newState);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback, 'replaceState');
	    }
	  },
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function () {
	    return this.updater.isMounted(this);
	  }
	};
	
	var ReactClassComponent = function () {};
	_assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
	
	/**
	 * Module for creating composite components.
	 *
	 * @class ReactClass
	 */
	var ReactClass = {
	
	  /**
	   * Creates a composite component class given a class specification.
	   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
	   *
	   * @param {object} spec Class specification (which must define `render`).
	   * @return {function} Component constructor function.
	   * @public
	   */
	  createClass: function (spec) {
	    // To keep our warnings more understandable, we'll use a little hack here to
	    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
	    // unnecessarily identify a class without displayName as 'Constructor'.
	    var Constructor = identity(function (props, context, updater) {
	      // This constructor gets overridden by mocks. The argument is used
	      // by mocks to assert on what gets mounted.
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : void 0;
	      }
	
	      // Wire up auto-binding
	      if (this.__reactAutoBindPairs.length) {
	        bindAutoBindMethods(this);
	      }
	
	      this.props = props;
	      this.context = context;
	      this.refs = emptyObject;
	      this.updater = updater || ReactNoopUpdateQueue;
	
	      this.state = null;
	
	      // ReactClasses doesn't have constructors. Instead, they use the
	      // getInitialState and componentWillMount methods for initialization.
	
	      var initialState = this.getInitialState ? this.getInitialState() : null;
	      if (process.env.NODE_ENV !== 'production') {
	        // We allow auto-mocks to proceed as if they're returning null.
	        if (initialState === undefined && this.getInitialState._isMockFunction) {
	          // This is probably bad practice. Consider warning here and
	          // deprecating this convenience.
	          initialState = null;
	        }
	      }
	      !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : _prodInvariant('82', Constructor.displayName || 'ReactCompositeComponent') : void 0;
	
	      this.state = initialState;
	    });
	    Constructor.prototype = new ReactClassComponent();
	    Constructor.prototype.constructor = Constructor;
	    Constructor.prototype.__reactAutoBindPairs = [];
	
	    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
	
	    mixSpecIntoComponent(Constructor, spec);
	
	    // Initialize the defaultProps property after all mixins have been merged.
	    if (Constructor.getDefaultProps) {
	      Constructor.defaultProps = Constructor.getDefaultProps();
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This is a tag to indicate that the use of these method names is ok,
	      // since it's used with createClass. If it's not, then it's likely a
	      // mistake so we'll warn you to use the static property, property
	      // initializer or constructor respectively.
	      if (Constructor.getDefaultProps) {
	        Constructor.getDefaultProps.isReactClassApproved = {};
	      }
	      if (Constructor.prototype.getInitialState) {
	        Constructor.prototype.getInitialState.isReactClassApproved = {};
	      }
	    }
	
	    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : _prodInvariant('83') : void 0;
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : void 0;
	    }
	
	    // Reduce time spent doing lookups by setting these on the prototype.
	    for (var methodName in ReactClassInterface) {
	      if (!Constructor.prototype[methodName]) {
	        Constructor.prototype[methodName] = null;
	      }
	    }
	
	    return Constructor;
	  },
	
	  injection: {
	    injectMixin: function (mixin) {
	      injectedMixins.push(mixin);
	    }
	  }
	
	};
	
	module.exports = ReactClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(18);
	
	/**
	 * Create a factory that creates HTML tag elements.
	 *
	 * @private
	 */
	var createDOMFactory = ReactElement.createFactory;
	if (process.env.NODE_ENV !== 'production') {
	  var ReactElementValidator = __webpack_require__(84);
	  createDOMFactory = ReactElementValidator.createFactory;
	}
	
	/**
	 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
	 * This is also accessible via `React.DOM`.
	 *
	 * @public
	 */
	var ReactDOMFactories = {
	  a: createDOMFactory('a'),
	  abbr: createDOMFactory('abbr'),
	  address: createDOMFactory('address'),
	  area: createDOMFactory('area'),
	  article: createDOMFactory('article'),
	  aside: createDOMFactory('aside'),
	  audio: createDOMFactory('audio'),
	  b: createDOMFactory('b'),
	  base: createDOMFactory('base'),
	  bdi: createDOMFactory('bdi'),
	  bdo: createDOMFactory('bdo'),
	  big: createDOMFactory('big'),
	  blockquote: createDOMFactory('blockquote'),
	  body: createDOMFactory('body'),
	  br: createDOMFactory('br'),
	  button: createDOMFactory('button'),
	  canvas: createDOMFactory('canvas'),
	  caption: createDOMFactory('caption'),
	  cite: createDOMFactory('cite'),
	  code: createDOMFactory('code'),
	  col: createDOMFactory('col'),
	  colgroup: createDOMFactory('colgroup'),
	  data: createDOMFactory('data'),
	  datalist: createDOMFactory('datalist'),
	  dd: createDOMFactory('dd'),
	  del: createDOMFactory('del'),
	  details: createDOMFactory('details'),
	  dfn: createDOMFactory('dfn'),
	  dialog: createDOMFactory('dialog'),
	  div: createDOMFactory('div'),
	  dl: createDOMFactory('dl'),
	  dt: createDOMFactory('dt'),
	  em: createDOMFactory('em'),
	  embed: createDOMFactory('embed'),
	  fieldset: createDOMFactory('fieldset'),
	  figcaption: createDOMFactory('figcaption'),
	  figure: createDOMFactory('figure'),
	  footer: createDOMFactory('footer'),
	  form: createDOMFactory('form'),
	  h1: createDOMFactory('h1'),
	  h2: createDOMFactory('h2'),
	  h3: createDOMFactory('h3'),
	  h4: createDOMFactory('h4'),
	  h5: createDOMFactory('h5'),
	  h6: createDOMFactory('h6'),
	  head: createDOMFactory('head'),
	  header: createDOMFactory('header'),
	  hgroup: createDOMFactory('hgroup'),
	  hr: createDOMFactory('hr'),
	  html: createDOMFactory('html'),
	  i: createDOMFactory('i'),
	  iframe: createDOMFactory('iframe'),
	  img: createDOMFactory('img'),
	  input: createDOMFactory('input'),
	  ins: createDOMFactory('ins'),
	  kbd: createDOMFactory('kbd'),
	  keygen: createDOMFactory('keygen'),
	  label: createDOMFactory('label'),
	  legend: createDOMFactory('legend'),
	  li: createDOMFactory('li'),
	  link: createDOMFactory('link'),
	  main: createDOMFactory('main'),
	  map: createDOMFactory('map'),
	  mark: createDOMFactory('mark'),
	  menu: createDOMFactory('menu'),
	  menuitem: createDOMFactory('menuitem'),
	  meta: createDOMFactory('meta'),
	  meter: createDOMFactory('meter'),
	  nav: createDOMFactory('nav'),
	  noscript: createDOMFactory('noscript'),
	  object: createDOMFactory('object'),
	  ol: createDOMFactory('ol'),
	  optgroup: createDOMFactory('optgroup'),
	  option: createDOMFactory('option'),
	  output: createDOMFactory('output'),
	  p: createDOMFactory('p'),
	  param: createDOMFactory('param'),
	  picture: createDOMFactory('picture'),
	  pre: createDOMFactory('pre'),
	  progress: createDOMFactory('progress'),
	  q: createDOMFactory('q'),
	  rp: createDOMFactory('rp'),
	  rt: createDOMFactory('rt'),
	  ruby: createDOMFactory('ruby'),
	  s: createDOMFactory('s'),
	  samp: createDOMFactory('samp'),
	  script: createDOMFactory('script'),
	  section: createDOMFactory('section'),
	  select: createDOMFactory('select'),
	  small: createDOMFactory('small'),
	  source: createDOMFactory('source'),
	  span: createDOMFactory('span'),
	  strong: createDOMFactory('strong'),
	  style: createDOMFactory('style'),
	  sub: createDOMFactory('sub'),
	  summary: createDOMFactory('summary'),
	  sup: createDOMFactory('sup'),
	  table: createDOMFactory('table'),
	  tbody: createDOMFactory('tbody'),
	  td: createDOMFactory('td'),
	  textarea: createDOMFactory('textarea'),
	  tfoot: createDOMFactory('tfoot'),
	  th: createDOMFactory('th'),
	  thead: createDOMFactory('thead'),
	  time: createDOMFactory('time'),
	  title: createDOMFactory('title'),
	  tr: createDOMFactory('tr'),
	  track: createDOMFactory('track'),
	  u: createDOMFactory('u'),
	  ul: createDOMFactory('ul'),
	  'var': createDOMFactory('var'),
	  video: createDOMFactory('video'),
	  wbr: createDOMFactory('wbr'),
	
	  // SVG
	  circle: createDOMFactory('circle'),
	  clipPath: createDOMFactory('clipPath'),
	  defs: createDOMFactory('defs'),
	  ellipse: createDOMFactory('ellipse'),
	  g: createDOMFactory('g'),
	  image: createDOMFactory('image'),
	  line: createDOMFactory('line'),
	  linearGradient: createDOMFactory('linearGradient'),
	  mask: createDOMFactory('mask'),
	  path: createDOMFactory('path'),
	  pattern: createDOMFactory('pattern'),
	  polygon: createDOMFactory('polygon'),
	  polyline: createDOMFactory('polyline'),
	  radialGradient: createDOMFactory('radialGradient'),
	  rect: createDOMFactory('rect'),
	  stop: createDOMFactory('stop'),
	  svg: createDOMFactory('svg'),
	  text: createDOMFactory('text'),
	  tspan: createDOMFactory('tspan')
	};
	
	module.exports = ReactDOMFactories;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(18);
	var ReactPropTypeLocationNames = __webpack_require__(53);
	var ReactPropTypesSecret = __webpack_require__(85);
	
	var emptyFunction = __webpack_require__(56);
	var getIteratorFn = __webpack_require__(55);
	var warning = __webpack_require__(12);
	
	/**
	 * Collection of methods that allow declaration and validation of props that are
	 * supplied to React components. Example usage:
	 *
	 *   var Props = require('ReactPropTypes');
	 *   var MyArticle = React.createClass({
	 *     propTypes: {
	 *       // An optional string prop named "description".
	 *       description: Props.string,
	 *
	 *       // A required enum prop named "category".
	 *       category: Props.oneOf(['News','Photos']).isRequired,
	 *
	 *       // A prop named "dialog" that requires an instance of Dialog.
	 *       dialog: Props.instanceOf(Dialog).isRequired
	 *     },
	 *     render: function() { ... }
	 *   });
	 *
	 * A more formal specification of how these methods are used:
	 *
	 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	 *   decl := ReactPropTypes.{type}(.isRequired)?
	 *
	 * Each and every declaration produces a function with the same signature. This
	 * allows the creation of custom validation functions. For example:
	 *
	 *  var MyLink = React.createClass({
	 *    propTypes: {
	 *      // An optional string or URI prop named "href".
	 *      href: function(props, propName, componentName) {
	 *        var propValue = props[propName];
	 *        if (propValue != null && typeof propValue !== 'string' &&
	 *            !(propValue instanceof URI)) {
	 *          return new Error(
	 *            'Expected a string or an URI for ' + propName + ' in ' +
	 *            componentName
	 *          );
	 *        }
	 *      }
	 *    },
	 *    render: function() {...}
	 *  });
	 *
	 * @internal
	 */
	
	var ANONYMOUS = '<<anonymous>>';
	
	var ReactPropTypes = {
	  array: createPrimitiveTypeChecker('array'),
	  bool: createPrimitiveTypeChecker('boolean'),
	  func: createPrimitiveTypeChecker('function'),
	  number: createPrimitiveTypeChecker('number'),
	  object: createPrimitiveTypeChecker('object'),
	  string: createPrimitiveTypeChecker('string'),
	  symbol: createPrimitiveTypeChecker('symbol'),
	
	  any: createAnyTypeChecker(),
	  arrayOf: createArrayOfTypeChecker,
	  element: createElementTypeChecker(),
	  instanceOf: createInstanceTypeChecker,
	  node: createNodeChecker(),
	  objectOf: createObjectOfTypeChecker,
	  oneOf: createEnumTypeChecker,
	  oneOfType: createUnionTypeChecker,
	  shape: createShapeTypeChecker
	};
	
	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	/*eslint-disable no-self-compare*/
	function is(x, y) {
	  // SameValue algorithm
	  if (x === y) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    return x !== 0 || 1 / x === 1 / y;
	  } else {
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	  }
	}
	/*eslint-enable no-self-compare*/
	
	/**
	 * We use an Error-like object for backward compatibility as people may call
	 * PropTypes directly and inspect their output. However we don't use real
	 * Errors anymore. We don't inspect their stack anyway, and creating them
	 * is prohibitively expensive if they are created too often, such as what
	 * happens in oneOfType() for any type before the one that matched.
	 */
	function PropTypeError(message) {
	  this.message = message;
	  this.stack = '';
	}
	// Make `instanceof Error` still work for returned errors.
	PropTypeError.prototype = Error.prototype;
	
	function createChainableTypeChecker(validate) {
	  if (process.env.NODE_ENV !== 'production') {
	    var manualPropTypeCallCache = {};
	  }
	  function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	    componentName = componentName || ANONYMOUS;
	    propFullName = propFullName || propName;
	    if (process.env.NODE_ENV !== 'production') {
	      if (secret !== ReactPropTypesSecret && typeof console !== 'undefined') {
	        var cacheKey = componentName + ':' + propName;
	        if (!manualPropTypeCallCache[cacheKey]) {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will not work in production with the next major version. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName) : void 0;
	          manualPropTypeCallCache[cacheKey] = true;
	        }
	      }
	    }
	    if (props[propName] == null) {
	      var locationName = ReactPropTypeLocationNames[location];
	      if (isRequired) {
	        if (props[propName] === null) {
	          return new PropTypeError('The ' + locationName + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
	        }
	        return new PropTypeError('The ' + locationName + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
	      }
	      return null;
	    } else {
	      return validate(props, propName, componentName, location, propFullName);
	    }
	  }
	
	  var chainedCheckType = checkType.bind(null, false);
	  chainedCheckType.isRequired = checkType.bind(null, true);
	
	  return chainedCheckType;
	}
	
	function createPrimitiveTypeChecker(expectedType) {
	  function validate(props, propName, componentName, location, propFullName, secret) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== expectedType) {
	      var locationName = ReactPropTypeLocationNames[location];
	      // `propValue` being instance of, say, date/regexp, pass the 'object'
	      // check, but we can offer a more precise error message here rather than
	      // 'of type `object`'.
	      var preciseType = getPreciseType(propValue);
	
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createAnyTypeChecker() {
	  return createChainableTypeChecker(emptyFunction.thatReturns(null));
	}
	
	function createArrayOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (typeof typeChecker !== 'function') {
	      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	    }
	    var propValue = props[propName];
	    if (!Array.isArray(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	    }
	    for (var i = 0; i < propValue.length; i++) {
	      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
	      if (error instanceof Error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createElementTypeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    if (!ReactElement.isValidElement(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createInstanceTypeChecker(expectedClass) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!(props[propName] instanceof expectedClass)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var expectedClassName = expectedClass.name || ANONYMOUS;
	      var actualClassName = getClassName(props[propName]);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createEnumTypeChecker(expectedValues) {
	  if (!Array.isArray(expectedValues)) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
	    return emptyFunction.thatReturnsNull;
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    for (var i = 0; i < expectedValues.length; i++) {
	      if (is(propValue, expectedValues[i])) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    var valuesString = JSON.stringify(expectedValues);
	    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createObjectOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (typeof typeChecker !== 'function') {
	      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	    }
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	    }
	    for (var key in propValue) {
	      if (propValue.hasOwnProperty(key)) {
	        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createUnionTypeChecker(arrayOfTypeCheckers) {
	  if (!Array.isArray(arrayOfTypeCheckers)) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
	    return emptyFunction.thatReturnsNull;
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createNodeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!isNode(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createShapeTypeChecker(shapeTypes) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	    }
	    for (var key in shapeTypes) {
	      var checker = shapeTypes[key];
	      if (!checker) {
	        continue;
	      }
	      var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	      if (error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function isNode(propValue) {
	  switch (typeof propValue) {
	    case 'number':
	    case 'string':
	    case 'undefined':
	      return true;
	    case 'boolean':
	      return !propValue;
	    case 'object':
	      if (Array.isArray(propValue)) {
	        return propValue.every(isNode);
	      }
	      if (propValue === null || ReactElement.isValidElement(propValue)) {
	        return true;
	      }
	
	      var iteratorFn = getIteratorFn(propValue);
	      if (iteratorFn) {
	        var iterator = iteratorFn.call(propValue);
	        var step;
	        if (iteratorFn !== propValue.entries) {
	          while (!(step = iterator.next()).done) {
	            if (!isNode(step.value)) {
	              return false;
	            }
	          }
	        } else {
	          // Iterator will provide entry [k,v] tuples rather than values.
	          while (!(step = iterator.next()).done) {
	            var entry = step.value;
	            if (entry) {
	              if (!isNode(entry[1])) {
	                return false;
	              }
	            }
	          }
	        }
	      } else {
	        return false;
	      }
	
	      return true;
	    default:
	      return false;
	  }
	}
	
	function isSymbol(propType, propValue) {
	  // Native Symbol.
	  if (propType === 'symbol') {
	    return true;
	  }
	
	  // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	  if (propValue['@@toStringTag'] === 'Symbol') {
	    return true;
	  }
	
	  // Fallback for non-spec compliant Symbols which are polyfilled.
	  if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	    return true;
	  }
	
	  return false;
	}
	
	// Equivalent of `typeof` but with special handling for array and regexp.
	function getPropType(propValue) {
	  var propType = typeof propValue;
	  if (Array.isArray(propValue)) {
	    return 'array';
	  }
	  if (propValue instanceof RegExp) {
	    // Old webkits (at least until Android 4.0) return 'function' rather than
	    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	    // passes PropTypes.object.
	    return 'object';
	  }
	  if (isSymbol(propType, propValue)) {
	    return 'symbol';
	  }
	  return propType;
	}
	
	// This handles more types than `getPropType`. Only used for error messages.
	// See `createPrimitiveTypeChecker`.
	function getPreciseType(propValue) {
	  var propType = getPropType(propValue);
	  if (propType === 'object') {
	    if (propValue instanceof Date) {
	      return 'date';
	    } else if (propValue instanceof RegExp) {
	      return 'regexp';
	    }
	  }
	  return propType;
	}
	
	// Returns class name of the object, if any.
	function getClassName(propValue) {
	  if (!propValue.constructor || !propValue.constructor.name) {
	    return ANONYMOUS;
	  }
	  return propValue.constructor.name;
	}
	
	module.exports = ReactPropTypes;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(34);
	
	var ReactComponent = __webpack_require__(51);
	var ReactNoopUpdateQueue = __webpack_require__(52);
	
	var emptyObject = __webpack_require__(57);
	
	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactPureComponent(props, context, updater) {
	  // Duplicated from ReactComponent.
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	
	function ComponentDummy() {}
	ComponentDummy.prototype = ReactComponent.prototype;
	ReactPureComponent.prototype = new ComponentDummy();
	ReactPureComponent.prototype.constructor = ReactPureComponent;
	// Avoid an extra prototype jump for these methods.
	_assign(ReactPureComponent.prototype, ReactComponent.prototype);
	ReactPureComponent.prototype.isPureReactComponent = true;
	
	module.exports = ReactPureComponent;

/***/ },
/* 191 */
144,
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(19);
	
	var ReactPropTypeLocationNames = __webpack_require__(53);
	var ReactPropTypesSecret = __webpack_require__(85);
	
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(12);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(8);
	}
	
	var loggedTypeFailures = {};
	
	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?object} element The React element that is being type-checked
	 * @param {?number} debugID The React component instance that is being type-checked
	 * @private
	 */
	function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
	  for (var typeSpecName in typeSpecs) {
	    if (typeSpecs.hasOwnProperty(typeSpecName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
	        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	      } catch (ex) {
	        error = ex;
	      }
	      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var componentStackInfo = '';
	
	        if (process.env.NODE_ENV !== 'production') {
	          if (!ReactComponentTreeHook) {
	            ReactComponentTreeHook = __webpack_require__(8);
	          }
	          if (debugID !== null) {
	            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
	          } else if (element !== null) {
	            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
	          }
	        }
	
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
	      }
	    }
	  }
	}
	
	module.exports = checkReactTypeSpec;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	'use strict';
	
	var _prodInvariant = __webpack_require__(19);
	
	var ReactElement = __webpack_require__(18);
	
	var invariant = __webpack_require__(20);
	
	/**
	 * Returns the first child in a collection of children and verifies that there
	 * is only one child in the collection.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.only
	 *
	 * The current implementation of this function assumes that a single child gets
	 * passed without a wrapper, but the purpose of this helper function is to
	 * abstract away the particular structure of children.
	 *
	 * @param {?object} children Child collection structure.
	 * @return {ReactElement} The first and only `ReactElement` contained in the
	 * structure.
	 */
	function onlyChild(children) {
	  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
	  return children;
	}
	
	module.exports = onlyChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(19);
	
	var ReactCurrentOwner = __webpack_require__(11);
	var REACT_ELEMENT_TYPE = __webpack_require__(83);
	
	var getIteratorFn = __webpack_require__(55);
	var invariant = __webpack_require__(20);
	var KeyEscapeUtils = __webpack_require__(184);
	var warning = __webpack_require__(12);
	
	var SEPARATOR = '.';
	var SUBSEPARATOR = ':';
	
	/**
	 * This is inlined from ReactElement since this file is shared between
	 * isomorphic and renderers. We could extract this to a
	 *
	 */
	
	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */
	
	var didWarnAboutMaps = false;
	
	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  // Do some typechecking here since we call this blindly. We want to ensure
	  // that we don't block potential future ES APIs.
	  if (component && typeof component === 'object' && component.key != null) {
	    // Explicit key
	    return KeyEscapeUtils.escape(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}
	
	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children;
	
	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }
	
	  if (children === null || type === 'string' || type === 'number' ||
	  // The following is inlined from ReactElement. This means we can optimize
	  // some checks. React Fiber also inlines this logic for similar purposes.
	  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }
	
	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
	
	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          var mapsAsChildrenAddendum = '';
	          if (ReactCurrentOwner.current) {
	            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
	            if (mapsAsChildrenOwnerName) {
	              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
	            }
	          }
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (process.env.NODE_ENV !== 'production') {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
	    }
	  }
	
	  return subtreeCount;
	}
	
	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }
	
	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}
	
	module.exports = traverseAllChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 195 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 196 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 197 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 198 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 199 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 200 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 201 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 202 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 203 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 204 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 205 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 206 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 207 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 208 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 209 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(__webpack_module_template_argument_0__);
	
	var invariant = __webpack_require__(__webpack_module_template_argument_1__);
	
	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function (copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};
	
	var twoArgumentPooler = function (a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};
	
	var threeArgumentPooler = function (a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};
	
	var fourArgumentPooler = function (a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};
	
	var fiveArgumentPooler = function (a1, a2, a3, a4, a5) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4, a5);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4, a5);
	  }
	};
	
	var standardReleaser = function (instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};
	
	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;
	
	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances.
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function (CopyConstructor, pooler) {
	  // Casting as any so that flow ignores the actual implementation and trusts
	  // it to match the type we declared
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};
	
	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler,
	  fiveArgumentPooler: fiveArgumentPooler
	};
	
	module.exports = PooledClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(__webpack_module_template_argument_0__);
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  (function () {
	    var printWarning = function printWarning(format) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    };
	
	    warning = function warning(condition, format) {
	      if (format === undefined) {
	        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	      }
	
	      if (format.indexOf('Failed Composite propType: ') === 0) {
	        return; // Ignore CompositeComponent proptype check.
	      }
	
	      if (!condition) {
	        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	          args[_key2 - 2] = arguments[_key2];
	        }
	
	        printWarning.apply(undefined, [format].concat(args));
	      }
	    };
	  })();
	}
	
	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }
/******/ ])));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYzc3ZTRjNGE0YWM3N2JlMzYyOWIiLCJ3ZWJwYWNrOi8vLy4vcm91dGVzL2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjaykvfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9+L2ZianMvbGliL2ludmFyaWFudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvcmVhY3RQcm9kSW52YXJpYW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTUNvbXBvbmVudFRyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vfi9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL34vZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vay5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RJbnN0cnVtZW50YXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0VXBkYXRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L3JlYWN0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9+L2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL0RPTVByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvRE9NTGF6eVRyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0UmVjb25jaWxlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvRXZlbnRQbHVnaW5IdWIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL0V2ZW50UHJvcGFnYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0SW5zdGFuY2VNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY1VJRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL0V2ZW50UGx1Z2luUmVnaXN0cnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljTW91c2VFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvVHJhbnNhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvc2V0SW5uZXJIVE1MLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9ET01DaGlsZHJlbk9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL0RPTU5hbWVzcGFjZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL0V2ZW50UGx1Z2luVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL0tleUVzY2FwZVV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9MaW5rZWRWYWx1ZVV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdEVycm9yVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0VXBkYXRlUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL2dldEV2ZW50Q2hhckNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL2dldEV2ZW50TW9kaWZpZXJTdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvZ2V0RXZlbnRUYXJnZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL2lzRXZlbnRTdXBwb3J0ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi92YWxpZGF0ZURPTU5lc3RpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vfi9mYmpzL2xpYi9zaGFsbG93RXF1YWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3ROb29wVXBkYXRlUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvY2FuRGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZ2V0SXRlcmF0b3JGbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvZW1wdHlPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL0NTU1Byb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9DYWxsYmFja1F1ZXVlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NQ29tcG9uZW50RmxhZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NU2VsZWN0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdEVtcHR5Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdEZlYXR1cmVGbGFncy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RIb3N0Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdElucHV0U2VsZWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdE1vdW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdE5vZGVUeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1ZpZXdwb3J0TWV0cmljcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvYWNjdW11bGF0ZUludG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL2ZvckVhY2hBY2N1bXVsYXRlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL2dldFRleHRDb250ZW50QWNjZXNzb3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL2lzVGV4dElucHV0RWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvc2V0VGV4dENvbnRlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL3RyYXZlcnNlQWxsQ2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vfi9mYmpzL2xpYi9FdmVudExpc3RlbmVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL34vZmJqcy9saWIvZm9jdXNOb2RlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL34vZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnRTeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RFbGVtZW50VmFsaWRhdG9yLmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvYXBwLmpzIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvZnJ1aXQtaXRlbXMuanMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy90ZWFtLW1lbXMuanMiLCJ3ZWJwYWNrOi8vLy4vZGF0YS9mcnVpdHMuanMiLCJ3ZWJwYWNrOi8vLy4vZGF0YS9wYWdlLXBpY3MuanMiLCJ3ZWJwYWNrOi8vLy4vZGF0YS90ZWFtLmpzIiwid2VicGFjazovLy8uL3JvdXRlcy9uYXYuanMiLCJ3ZWJwYWNrOi8vLy4vc2VjdGlvbnMvYWJvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vc2VjdGlvbnMvZnJ1aXRzLmpzIiwid2VicGFjazovLy8uL3NlY3Rpb25zL2hvbWUuanMiLCJ3ZWJwYWNrOi8vLy4vc2VjdGlvbnMvcmVnaXN0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc2VjdGlvbnMvdGVhbS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvQVJJQURPTVByb3BlcnR5Q29uZmlnLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9BdXRvRm9jdXNVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvQmVmb3JlSW5wdXRFdmVudFBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvQ1NTUHJvcGVydHlPcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9DaGFuZ2VFdmVudFBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvRGFuZ2VyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9EZWZhdWx0RXZlbnRQbHVnaW5PcmRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9GYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL0hUTUxET01Qcm9wZXJ0eUNvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RDaGlsZFJlY29uY2lsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET00uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NQ29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTUNvbnRhaW5lckluZm8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NRW1wdHlDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NRmVhdHVyZUZsYWdzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTUlET3BlcmF0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01JbnB1dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01JbnZhbGlkQVJJQUhvb2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vay5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01PcHRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NU2VsZWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTVRleHRDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NVGV4dGFyZWEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NVHJlZVRyYXZlcnNhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERlYnVnVG9vbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3REZWZhdWx0SW5qZWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdEV2ZW50RW1pdHRlck1peGluLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdEV2ZW50TGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1JlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdEluamVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vay5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RNYXJrdXBDaGVja3N1bS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RNdWx0aUNoaWxkLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdE93bmVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9SZWFjdFJlZi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RWZXJzaW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9TVkdET01Qcm9wZXJ0eUNvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvU2VsZWN0RXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1NpbXBsZUV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNBbmltYXRpb25FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljQ2xpcGJvYXJkRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0RyYWdFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljRm9jdXNFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljSW5wdXRFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljS2V5Ym9hcmRFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljVG91Y2hFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljVHJhbnNpdGlvbkV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNXaGVlbEV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9hZGxlcjMyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9jaGVja1JlYWN0VHlwZVNwZWMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL2Rhbmdlcm91c1N0eWxlVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL2ZpbmRET01Ob2RlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9mbGF0dGVuQ2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL2dldEV2ZW50S2V5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9nZXROZXh0RGVidWdJRC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9saWIvZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vbGliL3F1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2xpYi9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9+L2ZianMvbGliL2NhbWVsaXplLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL34vZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vfi9mYmpzL2xpYi9jb250YWluc05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vfi9mYmpzL2xpYi9jcmVhdGVBcnJheUZyb21NaXhlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9+L2ZianMvbGliL2NyZWF0ZU5vZGVzRnJvbU1hcmt1cC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9+L2ZianMvbGliL2dldE1hcmt1cFdyYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vfi9mYmpzL2xpYi9nZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9+L2ZianMvbGliL2h5cGhlbmF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9+L2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9+L2ZianMvbGliL2lzTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9+L2ZianMvbGliL2lzVGV4dE5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vfi9mYmpzL2xpYi9tZW1vaXplU3RyaW5nT25seS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9+L2ZianMvbGliL3BlcmZvcm1hbmNlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL34vZmJqcy9saWIvcGVyZm9ybWFuY2VOb3cuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDaGlsZHJlbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENsYXNzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NRmFjdG9yaWVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UHVyZUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9jaGVja1JlYWN0VHlwZVNwZWMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvb25seUNoaWxkLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL3RyYXZlcnNlQWxsQ2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9mcnVpdHMvYXBwbGUuanBlZyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvaW1hZ2VzL2ZydWl0cy9iYW5hbmEuanBlZyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvaW1hZ2VzL2ZydWl0cy9ncmFwZXMuanBlZyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvaW1hZ2VzL2ZydWl0cy9seWNoZWUuanBlZyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvaW1hZ2VzL2ZydWl0cy9tYW5nby5qcGVnIiwid2VicGFjazovLy8uL3B1YmxpYy9pbWFnZXMvZnJ1aXRzL29yYW5nZS5qcGVnIiwid2VicGFjazovLy8uL3B1YmxpYy9pbWFnZXMvZnJ1aXRzL3BlYWNoLmpwZWciLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9mcnVpdHMvcGluZWFwcGxlLmpwZWciLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9mcnVpdHMvcG9tZWdyYW5hdGUuanBlZyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvaW1hZ2VzL2ZydWl0cy9yYXNwYmVycnkuanBlZyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvaW1hZ2VzL2ZydWl0cy9zdHJhd2JlcnJ5LmpwZWciLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9mcnVpdHMvdG9tYXRvLmpwZWciLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9vdGhlcnMvYWJvdXQuanBnIiwid2VicGFjazovLy8uL3B1YmxpYy9pbWFnZXMvb3RoZXJzL2hvbWUuanBnIiwid2VicGFjazovLy8uL3B1YmxpYy9pbWFnZXMvdGVhbS9zb21ld2hlcmUuanBlZyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9Qb29sZWRDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvd2FybmluZy5qcyJdLCJuYW1lcyI6WyJyZW5kZXIiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiQXBwIiwicHJvcHMiLCJzdGF0ZSIsImZydWl0cyIsInRlYW1NZW1zIiwiYmtJbWciLCJDb21wb25lbnQiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJhcnJheSIsImlzUmVxdWlyZWQiLCJkZWZhdWx0UHJvcHMiLCJGcnVpdEl0ZW1zIiwiaWQiLCJjbmFtZSIsImxuYW1lIiwicHJpY2UiLCJpbWciLCJzaXplIiwibGluayIsIm15U3R5bGUxIiwiYm9yZGVyIiwiYm9yZGVyUmFkaXVzIiwibWFyZ2luTGVmdCIsIm1hcmdpblJpZ2h0IiwibWFyZ2luQm90dG9tIiwibXlTdHlsZTIiLCJjb2xvciIsIm51bWJlciIsInN0cmluZyIsIm5vZGUiLCJUZWFtTWVtcyIsImZuYW1lIiwidGl0bGUiLCJsaW5rZWRpbiIsInBob3RvIiwiaXNDaGVja2VkIiwiaG9tZUltZyIsImFib3V0SW1nIiwiTmF2IiwiQWJvdXQiLCJmb250RmFtaWx5IiwicGFkZGluZ1RvcCIsInBhZGRpbmdCb3R0b20iLCJoZWlnaHQiLCJiYWNrZ3JvdW5kQ29sb3IiLCJteVN0eWxlMyIsIkZydWl0cyIsIm15U3R5bGUiLCJzaG93RnJ1aXRzIiwibWFwIiwiZnJ1aXQiLCJIb21lIiwiYmFja2dyb3VuZEltYWdlIiwiYmFja2dyb3VuZFNpemUiLCJSZWdp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QUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsV0FBVSxvQkFBb0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUSw0Q0FBNEM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFRLGdCQUFnQjtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Qzs7Ozs7OztBQzFMQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxtQ0FBa0M7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFnQixzQkFBc0I7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUM7Ozs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBLHlDOzs7Ozs7O0FDcFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFrQix3Qjs7Ozs7OztBQ3RCbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxjQUFhLGVBQWU7QUFDNUIsY0FBYSxhQUFhO0FBQzFCLGNBQWEsMEJBQTBCO0FBQ3ZDLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxjQUFhLGVBQWU7QUFDNUIsY0FBYSwwQkFBMEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtDOzs7Ozs7O0FDdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEIsZUFBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNDOzs7Ozs7O0FDN1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsZUFBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFDOztBQUVELDJDOzs7Ozs7QUN0VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0M7Ozs7OztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsNEJBQTRCO0FBQ3ZDO0FBQ0EsYUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQSxlQUFjLDBCQUEwQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsU0FBUztBQUN0QixjQUFhLE9BQU87QUFDcEIsY0FBYSxTQUFTO0FBQ3RCLGNBQWEsU0FBUztBQUN0QixjQUFhLFNBQVM7QUFDdEIsY0FBYSxTQUFTO0FBQ3RCLGNBQWEsU0FBUztBQUN0QixjQUFhLFNBQVM7QUFDdEI7QUFDQSxlQUFjLEVBQUU7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWCxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSw2QkFBNEIsZ0NBQWdDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSwyREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEIsZ0NBQWdDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0Esc0RBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQzs7Ozs7OztBQy9OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQixhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0EseUJBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx5QkFBd0IsRUFBRSw4QkFBOEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsYUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDOzs7Ozs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxXQUFXO0FBQ3RCLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0I7Ozs7Ozs7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFdBQVc7QUFDdEIsWUFBVyxXQUFXO0FBQ3RCLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQzs7Ozs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlSQUF3UjtBQUN4Ujs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWEsV0FBVztBQUN4QixlQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsV0FBVztBQUN4QixjQUFhLFVBQVU7QUFDdkIsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsV0FB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QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQXlEO0FBQ3pEO0FBQ0E7QUFDQSx3Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBaUM7QUFDakMsaUJBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQzs7Ozs7OztBQzVYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBLE1BQUs7QUFDTCxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQzs7Ozs7OztBQ3RNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNDOzs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DOzs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxhQUFhO0FBQ3hCLGFBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsYUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Qzs7Ozs7O0FDL1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsRUFBRTtBQUNmLGNBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQywwQkFBMEI7QUFDMUQscUJBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEIsY0FBYSxrQkFBa0I7QUFDL0IsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWdGO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLFdBQVc7QUFDeEIsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx3Qzs7Ozs7OztBQy9NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0M7Ozs7OztBQy9UQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLFdBQVc7QUFDeEIsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlCOzs7Ozs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMEM7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHdDOzs7Ozs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQSwyQzs7Ozs7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBLHdDOzs7Ozs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0tBQXFLO0FBQ3JLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsUUFBUTtBQUNyQixlQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYSxRQUFRO0FBQ3JCLGNBQWEsUUFBUTtBQUNyQixjQUFhLDBCQUEwQjtBQUN2QyxjQUFhLE9BQU87QUFDcEIsZUFBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVDOzs7Ozs7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtRDs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxjQUFhLDBEQUEwRDtBQUN2RSxjQUFhLFFBQVE7QUFDckIsY0FBYSxRQUFRO0FBQ3JCLGNBQWEsUUFBUTtBQUNyQixlQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1gsVUFBUztBQUNULFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWCxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQixlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrSEFBOEg7O0FBRTlIO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIsNkJBQTZCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkI7Ozs7Ozs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUseUJBQXlCO0FBQ3hDO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVB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QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUM7Ozs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJHQUEwRztBQUMxRztBQUNBO0FBQ0E7QUFDQSw2R0FBNEc7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnQzs7Ozs7OztBQzFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQzs7Ozs7OztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUQ7Ozs7Ozs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMEI7QUFDMUIsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQSw4QkFBNkIsMkNBQTJDOztBQUV4RTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsaUM7Ozs7Ozs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxXQUFXO0FBQ3RCLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsV0FBVztBQUN0QixhQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFXLHVCQUF1QjtBQUNsQyxZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLHVCQUF1QjtBQUNsQyxZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFhLFdBQVc7QUFDeEI7QUFDQTs7QUFFQTtBQUNBLGNBQWEsdUJBQXVCO0FBQ3BDLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUEsb0M7Ozs7OztBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsMERBQTBEO0FBQ3ZFLGVBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYSxVQUFVO0FBQ3ZCLGNBQWEsMEJBQTBCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFDOztBQUVELHdDOzs7Ozs7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhHQUE2RztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUM7Ozs7Ozs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCLE9BQU87QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0EsY0FBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0EsMEJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEc7Ozs7Ozs7QUN0SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQTZDO0FBQzdDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDOzs7Ozs7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHLElBQUk7QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0Esb0JBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDOzs7Ozs7O0FDdldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQzs7Ozs7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRzs7Ozs7Ozs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNB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TUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLFdBQVc7QUFDeEIsY0FBYSxnQkFBZ0I7QUFDN0I7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUM7O0FBRUQseUM7Ozs7Ozs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDJCOzs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRCx1Qzs7Ozs7O0FDNVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxXQUFXO0FBQ3RCLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DOzs7Ozs7QUM3TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0M7Ozs7Ozs7QUNqUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBDOzs7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQzs7Ozs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0Qzs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQzs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQzs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNDOzs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5Qzs7Ozs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNDOzs7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDJDOzs7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNDOzs7Ozs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCLEtBQUs7QUFDbEM7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsUUFB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O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNkI7Ozs7Ozs7QUMzc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DOzs7Ozs7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUiw0QkFBMkI7QUFDM0IsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCLEtBQUs7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCwyQkFBMEI7QUFDMUIsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW1CLGdDQUFnQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCOzs7Ozs7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUZBQXdGLGFBQWE7QUFDckc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFlO0FBQ2Y7O0FBRUE7QUFDQSwrRkFBOEYsZUFBZTtBQUM3RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQSwwQiIsImZpbGUiOiJidW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBjNzdlNGM0YTRhYzc3YmUzNjI5YiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nXG5pbXBvcnQgQXBwIGZyb20gJy4uL2NvbXBvbmVudHMvYXBwJ1xuXG5SZWFjdERPTS5yZW5kZXIoXG4gIDxBcHAgLz4sXG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyb290Jylcbik7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcm91dGVzL2luZGV4LmpzIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9+L25vZGUtbGlicy1icm93c2VyL34vcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9+L2ZianMvbGliL2ludmFyaWFudC5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBXQVJOSU5HOiBETyBOT1QgbWFudWFsbHkgcmVxdWlyZSB0aGlzIG1vZHVsZS5cbiAqIFRoaXMgaXMgYSByZXBsYWNlbWVudCBmb3IgYGludmFyaWFudCguLi4pYCB1c2VkIGJ5IHRoZSBlcnJvciBjb2RlIHN5c3RlbVxuICogYW5kIHdpbGwgX29ubHlfIGJlIHJlcXVpcmVkIGJ5IHRoZSBjb3JyZXNwb25kaW5nIGJhYmVsIHBhc3MuXG4gKiBJdCBhbHdheXMgdGhyb3dzLlxuICovXG5cbmZ1bmN0aW9uIHJlYWN0UHJvZEludmFyaWFudChjb2RlKSB7XG4gIHZhciBhcmdDb3VudCA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuXG4gIHZhciBtZXNzYWdlID0gJ01pbmlmaWVkIFJlYWN0IGVycm9yICMnICsgY29kZSArICc7IHZpc2l0ICcgKyAnaHR0cDovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL2Vycm9yLWRlY29kZXIuaHRtbD9pbnZhcmlhbnQ9JyArIGNvZGU7XG5cbiAgZm9yICh2YXIgYXJnSWR4ID0gMDsgYXJnSWR4IDwgYXJnQ291bnQ7IGFyZ0lkeCsrKSB7XG4gICAgbWVzc2FnZSArPSAnJmFyZ3NbXT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFyZ3VtZW50c1thcmdJZHggKyAxXSk7XG4gIH1cblxuICBtZXNzYWdlICs9ICcgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50JyArICcgZm9yIGZ1bGwgZXJyb3JzIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJztcblxuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCByZWFjdFByb2RJbnZhcmlhbnQncyBvd24gZnJhbWVcblxuICB0aHJvdyBlcnJvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWFjdFByb2RJbnZhcmlhbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvcmVhY3RQcm9kSW52YXJpYW50LmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudEZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudEZsYWdzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIEFUVFJfTkFNRSA9IERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FO1xudmFyIEZsYWdzID0gUmVhY3RET01Db21wb25lbnRGbGFncztcblxudmFyIGludGVybmFsSW5zdGFuY2VLZXkgPSAnX19yZWFjdEludGVybmFsSW5zdGFuY2UkJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuXG4vKipcbiAqIERyaWxsIGRvd24gKHRocm91Z2ggY29tcG9zaXRlcyBhbmQgZW1wdHkgY29tcG9uZW50cykgdW50aWwgd2UgZ2V0IGEgaG9zdCBvclxuICogaG9zdCB0ZXh0IGNvbXBvbmVudC5cbiAqXG4gKiBUaGlzIGlzIHByZXR0eSBwb2x5bW9ycGhpYyBidXQgdW5hdm9pZGFibGUgd2l0aCB0aGUgY3VycmVudCBzdHJ1Y3R1cmUgd2UgaGF2ZVxuICogZm9yIGBfcmVuZGVyZWRDaGlsZHJlbmAuXG4gKi9cbmZ1bmN0aW9uIGdldFJlbmRlcmVkSG9zdE9yVGV4dEZyb21Db21wb25lbnQoY29tcG9uZW50KSB7XG4gIHZhciByZW5kZXJlZDtcbiAgd2hpbGUgKHJlbmRlcmVkID0gY29tcG9uZW50Ll9yZW5kZXJlZENvbXBvbmVudCkge1xuICAgIGNvbXBvbmVudCA9IHJlbmRlcmVkO1xuICB9XG4gIHJldHVybiBjb21wb25lbnQ7XG59XG5cbi8qKlxuICogUG9wdWxhdGUgYF9ob3N0Tm9kZWAgb24gdGhlIHJlbmRlcmVkIGhvc3QvdGV4dCBjb21wb25lbnQgd2l0aCB0aGUgZ2l2ZW5cbiAqIERPTSBub2RlLiBUaGUgcGFzc2VkIGBpbnN0YCBjYW4gYmUgYSBjb21wb3NpdGUuXG4gKi9cbmZ1bmN0aW9uIHByZWNhY2hlTm9kZShpbnN0LCBub2RlKSB7XG4gIHZhciBob3N0SW5zdCA9IGdldFJlbmRlcmVkSG9zdE9yVGV4dEZyb21Db21wb25lbnQoaW5zdCk7XG4gIGhvc3RJbnN0Ll9ob3N0Tm9kZSA9IG5vZGU7XG4gIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSBob3N0SW5zdDtcbn1cblxuZnVuY3Rpb24gdW5jYWNoZU5vZGUoaW5zdCkge1xuICB2YXIgbm9kZSA9IGluc3QuX2hvc3ROb2RlO1xuICBpZiAobm9kZSkge1xuICAgIGRlbGV0ZSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICAgIGluc3QuX2hvc3ROb2RlID0gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFBvcHVsYXRlIGBfaG9zdE5vZGVgIG9uIGVhY2ggY2hpbGQgb2YgYGluc3RgLCBhc3N1bWluZyB0aGF0IHRoZSBjaGlsZHJlblxuICogbWF0Y2ggdXAgd2l0aCB0aGUgRE9NIChlbGVtZW50KSBjaGlsZHJlbiBvZiBgbm9kZWAuXG4gKlxuICogV2UgY2FjaGUgZW50aXJlIGxldmVscyBhdCBvbmNlIHRvIGF2b2lkIGFuIG5eMiBwcm9ibGVtIHdoZXJlIHdlIGFjY2VzcyB0aGVcbiAqIGNoaWxkcmVuIG9mIGEgbm9kZSBzZXF1ZW50aWFsbHkgYW5kIGhhdmUgdG8gd2FsayBmcm9tIHRoZSBzdGFydCB0byBvdXIgdGFyZ2V0XG4gKiBub2RlIGV2ZXJ5IHRpbWUuXG4gKlxuICogU2luY2Ugd2UgdXBkYXRlIGBfcmVuZGVyZWRDaGlsZHJlbmAgYW5kIHRoZSBhY3R1YWwgRE9NIGF0IChzbGlnaHRseSlcbiAqIGRpZmZlcmVudCB0aW1lcywgd2UgY291bGQgcmFjZSBoZXJlIGFuZCBzZWUgYSBuZXdlciBgX3JlbmRlcmVkQ2hpbGRyZW5gIHRoYW5cbiAqIHRoZSBET00gbm9kZXMgd2Ugc2VlLiBUbyBhdm9pZCB0aGlzLCBSZWFjdE11bHRpQ2hpbGQgY2FsbHNcbiAqIGBwcmVwYXJlVG9NYW5hZ2VDaGlsZHJlbmAgYmVmb3JlIHdlIGNoYW5nZSBgX3JlbmRlcmVkQ2hpbGRyZW5gLCBhdCB3aGljaFxuICogdGltZSB0aGUgY29udGFpbmVyJ3MgY2hpbGQgbm9kZXMgYXJlIGFsd2F5cyBjYWNoZWQgKHVudGlsIGl0IHVubW91bnRzKS5cbiAqL1xuZnVuY3Rpb24gcHJlY2FjaGVDaGlsZE5vZGVzKGluc3QsIG5vZGUpIHtcbiAgaWYgKGluc3QuX2ZsYWdzICYgRmxhZ3MuaGFzQ2FjaGVkQ2hpbGROb2Rlcykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY2hpbGRyZW4gPSBpbnN0Ll9yZW5kZXJlZENoaWxkcmVuO1xuICB2YXIgY2hpbGROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICBvdXRlcjogZm9yICh2YXIgbmFtZSBpbiBjaGlsZHJlbikge1xuICAgIGlmICghY2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgY2hpbGRJbnN0ID0gY2hpbGRyZW5bbmFtZV07XG4gICAgdmFyIGNoaWxkSUQgPSBnZXRSZW5kZXJlZEhvc3RPclRleHRGcm9tQ29tcG9uZW50KGNoaWxkSW5zdCkuX2RvbUlEO1xuICAgIGlmIChjaGlsZElEID09PSAwKSB7XG4gICAgICAvLyBXZSdyZSBjdXJyZW50bHkgdW5tb3VudGluZyB0aGlzIGNoaWxkIGluIFJlYWN0TXVsdGlDaGlsZDsgc2tpcCBpdC5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBXZSBhc3N1bWUgdGhlIGNoaWxkIG5vZGVzIGFyZSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgY2hpbGQgaW5zdGFuY2VzLlxuICAgIGZvciAoOyBjaGlsZE5vZGUgIT09IG51bGw7IGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZykge1xuICAgICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBjaGlsZE5vZGUuZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSkgPT09IFN0cmluZyhjaGlsZElEKSB8fCBjaGlsZE5vZGUubm9kZVR5cGUgPT09IDggJiYgY2hpbGROb2RlLm5vZGVWYWx1ZSA9PT0gJyByZWFjdC10ZXh0OiAnICsgY2hpbGRJRCArICcgJyB8fCBjaGlsZE5vZGUubm9kZVR5cGUgPT09IDggJiYgY2hpbGROb2RlLm5vZGVWYWx1ZSA9PT0gJyByZWFjdC1lbXB0eTogJyArIGNoaWxkSUQgKyAnICcpIHtcbiAgICAgICAgcHJlY2FjaGVOb2RlKGNoaWxkSW5zdCwgY2hpbGROb2RlKTtcbiAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFdlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgRE9NIGNoaWxkcmVuIHdpdGhvdXQgZmluZGluZyBhbiBJRCBtYXRjaC5cbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgZWxlbWVudCB3aXRoIElEICVzLicsIGNoaWxkSUQpIDogX3Byb2RJbnZhcmlhbnQoJzMyJywgY2hpbGRJRCkgOiB2b2lkIDA7XG4gIH1cbiAgaW5zdC5fZmxhZ3MgfD0gRmxhZ3MuaGFzQ2FjaGVkQ2hpbGROb2Rlcztcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIGNsb3Nlc3QgUmVhY3RET01Db21wb25lbnQgb3JcbiAqIFJlYWN0RE9NVGV4dENvbXBvbmVudCBpbnN0YW5jZSBhbmNlc3Rvci5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobm9kZSkge1xuICBpZiAobm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkge1xuICAgIHJldHVybiBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICB9XG5cbiAgLy8gV2FsayB1cCB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGFuIGFuY2VzdG9yIHdob3NlIGluc3RhbmNlIHdlIGhhdmUgY2FjaGVkLlxuICB2YXIgcGFyZW50cyA9IFtdO1xuICB3aGlsZSAoIW5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pIHtcbiAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVG9wIG9mIHRoZSB0cmVlLiBUaGlzIG5vZGUgbXVzdCBub3QgYmUgcGFydCBvZiBhIFJlYWN0IHRyZWUgKG9yIGlzXG4gICAgICAvLyB1bm1vdW50ZWQsIHBvdGVudGlhbGx5KS5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjbG9zZXN0O1xuICB2YXIgaW5zdDtcbiAgZm9yICg7IG5vZGUgJiYgKGluc3QgPSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldKTsgbm9kZSA9IHBhcmVudHMucG9wKCkpIHtcbiAgICBjbG9zZXN0ID0gaW5zdDtcbiAgICBpZiAocGFyZW50cy5sZW5ndGgpIHtcbiAgICAgIHByZWNhY2hlQ2hpbGROb2RlcyhpbnN0LCBub2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2xvc2VzdDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICogaW5zdGFuY2UsIG9yIG51bGwgaWYgdGhlIG5vZGUgd2FzIG5vdCByZW5kZXJlZCBieSB0aGlzIFJlYWN0LlxuICovXG5mdW5jdGlvbiBnZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpIHtcbiAgdmFyIGluc3QgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShub2RlKTtcbiAgaWYgKGluc3QgIT0gbnVsbCAmJiBpbnN0Ll9ob3N0Tm9kZSA9PT0gbm9kZSkge1xuICAgIHJldHVybiBpbnN0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYSBSZWFjdERPTUNvbXBvbmVudCBvciBSZWFjdERPTVRleHRDb21wb25lbnQsIHJldHVybiB0aGUgY29ycmVzcG9uZGluZ1xuICogRE9NIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCkge1xuICAvLyBXaXRob3V0IHRoaXMgZmlyc3QgaW52YXJpYW50LCBwYXNzaW5nIGEgbm9uLURPTS1jb21wb25lbnQgdHJpZ2dlcnMgdGhlIG5leHRcbiAgLy8gaW52YXJpYW50IGZvciBhIG1pc3NpbmcgcGFyZW50LCB3aGljaCBpcyBzdXBlciBjb25mdXNpbmcuXG4gICEoaW5zdC5faG9zdE5vZGUgIT09IHVuZGVmaW5lZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZ2V0Tm9kZUZyb21JbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczMycpIDogdm9pZCAwO1xuXG4gIGlmIChpbnN0Ll9ob3N0Tm9kZSkge1xuICAgIHJldHVybiBpbnN0Ll9ob3N0Tm9kZTtcbiAgfVxuXG4gIC8vIFdhbGsgdXAgdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhbiBhbmNlc3RvciB3aG9zZSBET00gbm9kZSB3ZSBoYXZlIGNhY2hlZC5cbiAgdmFyIHBhcmVudHMgPSBbXTtcbiAgd2hpbGUgKCFpbnN0Ll9ob3N0Tm9kZSkge1xuICAgIHBhcmVudHMucHVzaChpbnN0KTtcbiAgICAhaW5zdC5faG9zdFBhcmVudCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdCBET00gdHJlZSByb290IHNob3VsZCBhbHdheXMgaGF2ZSBhIG5vZGUgcmVmZXJlbmNlLicpIDogX3Byb2RJbnZhcmlhbnQoJzM0JykgOiB2b2lkIDA7XG4gICAgaW5zdCA9IGluc3QuX2hvc3RQYXJlbnQ7XG4gIH1cblxuICAvLyBOb3cgcGFyZW50cyBjb250YWlucyBlYWNoIGFuY2VzdG9yIHRoYXQgZG9lcyAqbm90KiBoYXZlIGEgY2FjaGVkIG5hdGl2ZVxuICAvLyBub2RlLCBhbmQgYGluc3RgIGlzIHRoZSBkZWVwZXN0IGFuY2VzdG9yIHRoYXQgZG9lcy5cbiAgZm9yICg7IHBhcmVudHMubGVuZ3RoOyBpbnN0ID0gcGFyZW50cy5wb3AoKSkge1xuICAgIHByZWNhY2hlQ2hpbGROb2RlcyhpbnN0LCBpbnN0Ll9ob3N0Tm9kZSk7XG4gIH1cblxuICByZXR1cm4gaW5zdC5faG9zdE5vZGU7XG59XG5cbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSB7XG4gIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlOiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSxcbiAgZ2V0SW5zdGFuY2VGcm9tTm9kZTogZ2V0SW5zdGFuY2VGcm9tTm9kZSxcbiAgZ2V0Tm9kZUZyb21JbnN0YW5jZTogZ2V0Tm9kZUZyb21JbnN0YW5jZSxcbiAgcHJlY2FjaGVDaGlsZE5vZGVzOiBwcmVjYWNoZUNoaWxkTm9kZXMsXG4gIHByZWNhY2hlTm9kZTogcHJlY2FjaGVOb2RlLFxuICB1bmNhY2hlTm9kZTogdW5jYWNoZU5vZGVcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01Db21wb25lbnRUcmVlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NQ29tcG9uZW50VHJlZS5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL34vb2JqZWN0LWFzc2lnbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbi8qKlxuICogU2ltcGxlLCBsaWdodHdlaWdodCBtb2R1bGUgYXNzaXN0aW5nIHdpdGggdGhlIGRldGVjdGlvbiBhbmQgY29udGV4dCBvZlxuICogV29ya2VyLiBIZWxwcyBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXMgYW5kIGFsbG93cyBjb2RlIHRvIHJlYXNvbiBhYm91dFxuICogd2hldGhlciBvciBub3QgdGhleSBhcmUgaW4gYSBXb3JrZXIsIGV2ZW4gaWYgdGhleSBuZXZlciBpbmNsdWRlIHRoZSBtYWluXG4gKiBgUmVhY3RXb3JrZXJgIGRlcGVuZGVuY3kuXG4gKi9cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHtcblxuICBjYW5Vc2VET006IGNhblVzZURPTSxcblxuICBjYW5Vc2VXb3JrZXJzOiB0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJyxcblxuICBjYW5Vc2VFdmVudExpc3RlbmVyczogY2FuVXNlRE9NICYmICEhKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyIHx8IHdpbmRvdy5hdHRhY2hFdmVudCksXG5cbiAgY2FuVXNlVmlld3BvcnQ6IGNhblVzZURPTSAmJiAhIXdpbmRvdy5zY3JlZW4sXG5cbiAgaXNJbldvcmtlcjogIWNhblVzZURPTSAvLyBGb3Igbm93LCB0aGlzIGlzIHRydWUgLSBtaWdodCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL34vZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBpc05hdGl2ZShmbikge1xuICAvLyBCYXNlZCBvbiBpc05hdGl2ZSgpIGZyb20gTG9kYXNoXG4gIHZhciBmdW5jVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArIGZ1bmNUb1N0cmluZ1xuICAvLyBUYWtlIGFuIGV4YW1wbGUgbmF0aXZlIGZ1bmN0aW9uIHNvdXJjZSBmb3IgY29tcGFyaXNvblxuICAuY2FsbChoYXNPd25Qcm9wZXJ0eSlcbiAgLy8gU3RyaXAgcmVnZXggY2hhcmFjdGVycyBzbyB3ZSBjYW4gdXNlIGl0IGZvciByZWdleFxuICAucmVwbGFjZSgvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csICdcXFxcJCYnKVxuICAvLyBSZW1vdmUgaGFzT3duUHJvcGVydHkgZnJvbSB0aGUgdGVtcGxhdGUgdG8gbWFrZSBpdCBnZW5lcmljXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJyk7XG4gIHRyeSB7XG4gICAgdmFyIHNvdXJjZSA9IGZ1bmNUb1N0cmluZy5jYWxsKGZuKTtcbiAgICByZXR1cm4gcmVJc05hdGl2ZS50ZXN0KHNvdXJjZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG52YXIgY2FuVXNlQ29sbGVjdGlvbnMgPVxuLy8gQXJyYXkuZnJvbVxudHlwZW9mIEFycmF5LmZyb20gPT09ICdmdW5jdGlvbicgJiZcbi8vIE1hcFxudHlwZW9mIE1hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBpc05hdGl2ZShNYXApICYmXG4vLyBNYXAucHJvdG90eXBlLmtleXNcbk1hcC5wcm90b3R5cGUgIT0gbnVsbCAmJiB0eXBlb2YgTWFwLnByb3RvdHlwZS5rZXlzID09PSAnZnVuY3Rpb24nICYmIGlzTmF0aXZlKE1hcC5wcm90b3R5cGUua2V5cykgJiZcbi8vIFNldFxudHlwZW9mIFNldCA9PT0gJ2Z1bmN0aW9uJyAmJiBpc05hdGl2ZShTZXQpICYmXG4vLyBTZXQucHJvdG90eXBlLmtleXNcblNldC5wcm90b3R5cGUgIT0gbnVsbCAmJiB0eXBlb2YgU2V0LnByb3RvdHlwZS5rZXlzID09PSAnZnVuY3Rpb24nICYmIGlzTmF0aXZlKFNldC5wcm90b3R5cGUua2V5cyk7XG5cbmlmIChjYW5Vc2VDb2xsZWN0aW9ucykge1xuICB2YXIgaXRlbU1hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIHJvb3RJRFNldCA9IG5ldyBTZXQoKTtcblxuICB2YXIgc2V0SXRlbSA9IGZ1bmN0aW9uIChpZCwgaXRlbSkge1xuICAgIGl0ZW1NYXAuc2V0KGlkLCBpdGVtKTtcbiAgfTtcbiAgdmFyIGdldEl0ZW0gPSBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gaXRlbU1hcC5nZXQoaWQpO1xuICB9O1xuICB2YXIgcmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIChpZCkge1xuICAgIGl0ZW1NYXBbJ2RlbGV0ZSddKGlkKTtcbiAgfTtcbiAgdmFyIGdldEl0ZW1JRHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oaXRlbU1hcC5rZXlzKCkpO1xuICB9O1xuXG4gIHZhciBhZGRSb290ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgcm9vdElEU2V0LmFkZChpZCk7XG4gIH07XG4gIHZhciByZW1vdmVSb290ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgcm9vdElEU2V0WydkZWxldGUnXShpZCk7XG4gIH07XG4gIHZhciBnZXRSb290SURzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHJvb3RJRFNldC5rZXlzKCkpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIGl0ZW1CeUtleSA9IHt9O1xuICB2YXIgcm9vdEJ5S2V5ID0ge307XG5cbiAgLy8gVXNlIG5vbi1udW1lcmljIGtleXMgdG8gcHJldmVudCBWOCBwZXJmb3JtYW5jZSBpc3N1ZXM6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcyMzJcbiAgdmFyIGdldEtleUZyb21JRCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHJldHVybiAnLicgKyBpZDtcbiAgfTtcbiAgdmFyIGdldElERnJvbUtleSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoa2V5LnN1YnN0cigxKSwgMTApO1xuICB9O1xuXG4gIHZhciBzZXRJdGVtID0gZnVuY3Rpb24gKGlkLCBpdGVtKSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgaXRlbUJ5S2V5W2tleV0gPSBpdGVtO1xuICB9O1xuICB2YXIgZ2V0SXRlbSA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xuICAgIHJldHVybiBpdGVtQnlLZXlba2V5XTtcbiAgfTtcbiAgdmFyIHJlbW92ZUl0ZW0gPSBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcbiAgICBkZWxldGUgaXRlbUJ5S2V5W2tleV07XG4gIH07XG4gIHZhciBnZXRJdGVtSURzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhpdGVtQnlLZXkpLm1hcChnZXRJREZyb21LZXkpO1xuICB9O1xuXG4gIHZhciBhZGRSb290ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgcm9vdEJ5S2V5W2tleV0gPSB0cnVlO1xuICB9O1xuICB2YXIgcmVtb3ZlUm9vdCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xuICAgIGRlbGV0ZSByb290QnlLZXlba2V5XTtcbiAgfTtcbiAgdmFyIGdldFJvb3RJRHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHJvb3RCeUtleSkubWFwKGdldElERnJvbUtleSk7XG4gIH07XG59XG5cbnZhciB1bm1vdW50ZWRJRHMgPSBbXTtcblxuZnVuY3Rpb24gcHVyZ2VEZWVwKGlkKSB7XG4gIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gIGlmIChpdGVtKSB7XG4gICAgdmFyIGNoaWxkSURzID0gaXRlbS5jaGlsZElEcztcblxuICAgIHJlbW92ZUl0ZW0oaWQpO1xuICAgIGNoaWxkSURzLmZvckVhY2gocHVyZ2VEZWVwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHJldHVybiAnXFxuICAgIGluICcgKyAobmFtZSB8fCAnVW5rbm93bicpICsgKHNvdXJjZSA/ICcgKGF0ICcgKyBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKScgOiBvd25lck5hbWUgPyAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKScgOiAnJyk7XG59XG5cbmZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiAnI2VtcHR5JztcbiAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsZW1lbnQgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuICcjdGV4dCc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZWxlbWVudC50eXBlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbGVtZW50LnR5cGUuZGlzcGxheU5hbWUgfHwgZWxlbWVudC50eXBlLm5hbWUgfHwgJ1Vua25vd24nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlSUQoaWQpIHtcbiAgdmFyIG5hbWUgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldERpc3BsYXlOYW1lKGlkKTtcbiAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoaWQpO1xuICB2YXIgb3duZXJJRCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0T3duZXJJRChpZCk7XG4gIHZhciBvd25lck5hbWU7XG4gIGlmIChvd25lcklEKSB7XG4gICAgb3duZXJOYW1lID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXREaXNwbGF5TmFtZShvd25lcklEKTtcbiAgfVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhlbGVtZW50LCAnUmVhY3RDb21wb25lbnRUcmVlSG9vazogTWlzc2luZyBSZWFjdCBlbGVtZW50IGZvciBkZWJ1Z0lEICVzIHdoZW4gJyArICdidWlsZGluZyBzdGFjaycsIGlkKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgZWxlbWVudCAmJiBlbGVtZW50Ll9zb3VyY2UsIG93bmVyTmFtZSk7XG59XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0ge1xuICBvblNldENoaWxkcmVuOiBmdW5jdGlvbiAoaWQsIG5leHRDaGlsZElEcykge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgIWl0ZW0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnSXRlbSBtdXN0IGhhdmUgYmVlbiBzZXQnKSA6IF9wcm9kSW52YXJpYW50KCcxNDQnKSA6IHZvaWQgMDtcbiAgICBpdGVtLmNoaWxkSURzID0gbmV4dENoaWxkSURzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXh0Q2hpbGRJRHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuZXh0Q2hpbGRJRCA9IG5leHRDaGlsZElEc1tpXTtcbiAgICAgIHZhciBuZXh0Q2hpbGQgPSBnZXRJdGVtKG5leHRDaGlsZElEKTtcbiAgICAgICFuZXh0Q2hpbGQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgaG9vayBldmVudHMgdG8gZmlyZSBmb3IgdGhlIGNoaWxkIGJlZm9yZSBpdHMgcGFyZW50IGluY2x1ZGVzIGl0IGluIG9uU2V0Q2hpbGRyZW4oKS4nKSA6IF9wcm9kSW52YXJpYW50KCcxNDAnKSA6IHZvaWQgMDtcbiAgICAgICEobmV4dENoaWxkLmNoaWxkSURzICE9IG51bGwgfHwgdHlwZW9mIG5leHRDaGlsZC5lbGVtZW50ICE9PSAnb2JqZWN0JyB8fCBuZXh0Q2hpbGQuZWxlbWVudCA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBvblNldENoaWxkcmVuKCkgdG8gZmlyZSBmb3IgYSBjb250YWluZXIgY2hpbGQgYmVmb3JlIGl0cyBwYXJlbnQgaW5jbHVkZXMgaXQgaW4gb25TZXRDaGlsZHJlbigpLicpIDogX3Byb2RJbnZhcmlhbnQoJzE0MScpIDogdm9pZCAwO1xuICAgICAgIW5leHRDaGlsZC5pc01vdW50ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgb25Nb3VudENvbXBvbmVudCgpIHRvIGZpcmUgZm9yIHRoZSBjaGlsZCBiZWZvcmUgaXRzIHBhcmVudCBpbmNsdWRlcyBpdCBpbiBvblNldENoaWxkcmVuKCkuJykgOiBfcHJvZEludmFyaWFudCgnNzEnKSA6IHZvaWQgMDtcbiAgICAgIGlmIChuZXh0Q2hpbGQucGFyZW50SUQgPT0gbnVsbCkge1xuICAgICAgICBuZXh0Q2hpbGQucGFyZW50SUQgPSBpZDtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBzaG91bGRuJ3QgYmUgbmVjZXNzYXJ5IGJ1dCBtb3VudGluZyBhIG5ldyByb290IGR1cmluZyBpblxuICAgICAgICAvLyBjb21wb25lbnRXaWxsTW91bnQgY3VycmVudGx5IGNhdXNlcyBub3QteWV0LW1vdW50ZWQgY29tcG9uZW50cyB0b1xuICAgICAgICAvLyBiZSBwdXJnZWQgZnJvbSBvdXIgdHJlZSBkYXRhIHNvIHRoZWlyIHBhcmVudCBpZCBpcyBtaXNzaW5nLlxuICAgICAgfVxuICAgICAgIShuZXh0Q2hpbGQucGFyZW50SUQgPT09IGlkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBvbkJlZm9yZU1vdW50Q29tcG9uZW50KCkgcGFyZW50IGFuZCBvblNldENoaWxkcmVuKCkgdG8gYmUgY29uc2lzdGVudCAoJXMgaGFzIHBhcmVudHMgJXMgYW5kICVzKS4nLCBuZXh0Q2hpbGRJRCwgbmV4dENoaWxkLnBhcmVudElELCBpZCkgOiBfcHJvZEludmFyaWFudCgnMTQyJywgbmV4dENoaWxkSUQsIG5leHRDaGlsZC5wYXJlbnRJRCwgaWQpIDogdm9pZCAwO1xuICAgIH1cbiAgfSxcbiAgb25CZWZvcmVNb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGlkLCBlbGVtZW50LCBwYXJlbnRJRCkge1xuICAgIHZhciBpdGVtID0ge1xuICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgIHBhcmVudElEOiBwYXJlbnRJRCxcbiAgICAgIHRleHQ6IG51bGwsXG4gICAgICBjaGlsZElEczogW10sXG4gICAgICBpc01vdW50ZWQ6IGZhbHNlLFxuICAgICAgdXBkYXRlQ291bnQ6IDBcbiAgICB9O1xuICAgIHNldEl0ZW0oaWQsIGl0ZW0pO1xuICB9LFxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGlkLCBlbGVtZW50KSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICBpZiAoIWl0ZW0gfHwgIWl0ZW0uaXNNb3VudGVkKSB7XG4gICAgICAvLyBXZSBtYXkgZW5kIHVwIGhlcmUgYXMgYSByZXN1bHQgb2Ygc2V0U3RhdGUoKSBpbiBjb21wb25lbnRXaWxsVW5tb3VudCgpLlxuICAgICAgLy8gSW4gdGhpcyBjYXNlLCBpZ25vcmUgdGhlIGVsZW1lbnQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGl0ZW0uZWxlbWVudCA9IGVsZW1lbnQ7XG4gIH0sXG4gIG9uTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgIWl0ZW0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnSXRlbSBtdXN0IGhhdmUgYmVlbiBzZXQnKSA6IF9wcm9kSW52YXJpYW50KCcxNDQnKSA6IHZvaWQgMDtcbiAgICBpdGVtLmlzTW91bnRlZCA9IHRydWU7XG4gICAgdmFyIGlzUm9vdCA9IGl0ZW0ucGFyZW50SUQgPT09IDA7XG4gICAgaWYgKGlzUm9vdCkge1xuICAgICAgYWRkUm9vdChpZCk7XG4gICAgfVxuICB9LFxuICBvblVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICBpZiAoIWl0ZW0gfHwgIWl0ZW0uaXNNb3VudGVkKSB7XG4gICAgICAvLyBXZSBtYXkgZW5kIHVwIGhlcmUgYXMgYSByZXN1bHQgb2Ygc2V0U3RhdGUoKSBpbiBjb21wb25lbnRXaWxsVW5tb3VudCgpLlxuICAgICAgLy8gSW4gdGhpcyBjYXNlLCBpZ25vcmUgdGhlIGVsZW1lbnQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGl0ZW0udXBkYXRlQ291bnQrKztcbiAgfSxcbiAgb25Vbm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgIGlmIChpdGVtKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIGl0IGV4aXN0cy5cbiAgICAgIC8vIGBpdGVtYCBtaWdodCBub3QgZXhpc3QgaWYgaXQgaXMgaW5zaWRlIGFuIGVycm9yIGJvdW5kYXJ5LCBhbmQgYSBzaWJsaW5nXG4gICAgICAvLyBlcnJvciBib3VuZGFyeSBjaGlsZCB0aHJldyB3aGlsZSBtb3VudGluZy4gVGhlbiB0aGlzIGluc3RhbmNlIG5ldmVyXG4gICAgICAvLyBnb3QgYSBjaGFuY2UgdG8gbW91bnQsIGJ1dCBpdCBzdGlsbCBnZXRzIGFuIHVubW91bnRpbmcgZXZlbnQgZHVyaW5nXG4gICAgICAvLyB0aGUgZXJyb3IgYm91bmRhcnkgY2xlYW51cC5cbiAgICAgIGl0ZW0uaXNNb3VudGVkID0gZmFsc2U7XG4gICAgICB2YXIgaXNSb290ID0gaXRlbS5wYXJlbnRJRCA9PT0gMDtcbiAgICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgICAgcmVtb3ZlUm9vdChpZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHVubW91bnRlZElEcy5wdXNoKGlkKTtcbiAgfSxcbiAgcHVyZ2VVbm1vdW50ZWRDb21wb25lbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKFJlYWN0Q29tcG9uZW50VHJlZUhvb2suX3ByZXZlbnRQdXJnaW5nKSB7XG4gICAgICAvLyBTaG91bGQgb25seSBiZSB1c2VkIGZvciB0ZXN0aW5nLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5tb3VudGVkSURzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWQgPSB1bm1vdW50ZWRJRHNbaV07XG4gICAgICBwdXJnZURlZXAoaWQpO1xuICAgIH1cbiAgICB1bm1vdW50ZWRJRHMubGVuZ3RoID0gMDtcbiAgfSxcbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS5pc01vdW50ZWQgOiBmYWxzZTtcbiAgfSxcbiAgZ2V0Q3VycmVudFN0YWNrQWRkZW5kdW06IGZ1bmN0aW9uICh0b3BFbGVtZW50KSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICBpZiAodG9wRWxlbWVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXREaXNwbGF5TmFtZSh0b3BFbGVtZW50KTtcbiAgICAgIHZhciBvd25lciA9IHRvcEVsZW1lbnQuX293bmVyO1xuICAgICAgaW5mbyArPSBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIHRvcEVsZW1lbnQuX3NvdXJjZSwgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpKTtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudE93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB2YXIgaWQgPSBjdXJyZW50T3duZXIgJiYgY3VycmVudE93bmVyLl9kZWJ1Z0lEO1xuXG4gICAgaW5mbyArPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGlkKTtcbiAgICByZXR1cm4gaW5mbztcbiAgfSxcbiAgZ2V0U3RhY2tBZGRlbmR1bUJ5SUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAgd2hpbGUgKGlkKSB7XG4gICAgICBpbmZvICs9IGRlc2NyaWJlSUQoaWQpO1xuICAgICAgaWQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFBhcmVudElEKGlkKTtcbiAgICB9XG4gICAgcmV0dXJuIGluZm87XG4gIH0sXG4gIGdldENoaWxkSURzOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS5jaGlsZElEcyA6IFtdO1xuICB9LFxuICBnZXREaXNwbGF5TmFtZTogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoaWQpO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBnZXREaXNwbGF5TmFtZShlbGVtZW50KTtcbiAgfSxcbiAgZ2V0RWxlbWVudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0uZWxlbWVudCA6IG51bGw7XG4gIH0sXG4gIGdldE93bmVySUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBlbGVtZW50ID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGlkKTtcbiAgICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQuX293bmVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQuX293bmVyLl9kZWJ1Z0lEO1xuICB9LFxuICBnZXRQYXJlbnRJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0ucGFyZW50SUQgOiBudWxsO1xuICB9LFxuICBnZXRTb3VyY2U6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgdmFyIGVsZW1lbnQgPSBpdGVtID8gaXRlbS5lbGVtZW50IDogbnVsbDtcbiAgICB2YXIgc291cmNlID0gZWxlbWVudCAhPSBudWxsID8gZWxlbWVudC5fc291cmNlIDogbnVsbDtcbiAgICByZXR1cm4gc291cmNlO1xuICB9LFxuICBnZXRUZXh0OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChpZCk7XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiAnJyArIGVsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSxcbiAgZ2V0VXBkYXRlQ291bnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLnVwZGF0ZUNvdW50IDogMDtcbiAgfSxcblxuXG4gIGdldFJvb3RJRHM6IGdldFJvb3RJRHMsXG4gIGdldFJlZ2lzdGVyZWRJRHM6IGdldEl0ZW1JRHNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnRUcmVlSG9vaztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2suanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUcnVzdCB0aGUgZGV2ZWxvcGVyIHRvIG9ubHkgdXNlIFJlYWN0SW5zdHJ1bWVudGF0aW9uIHdpdGggYSBfX0RFVl9fIGNoZWNrXG5cbnZhciBkZWJ1Z1Rvb2wgPSBudWxsO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3REZWJ1Z1Rvb2wgPSByZXF1aXJlKCcuL1JlYWN0RGVidWdUb29sJyk7XG4gIGRlYnVnVG9vbCA9IFJlYWN0RGVidWdUb29sO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgZGVidWdUb29sOiBkZWJ1Z1Rvb2wgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdEluc3RydW1lbnRhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBDYWxsYmFja1F1ZXVlID0gcmVxdWlyZSgnLi9DYWxsYmFja1F1ZXVlJyk7XG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RGZWF0dXJlRmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RmVhdHVyZUZsYWdzJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgZGlydHlDb21wb25lbnRzID0gW107XG52YXIgdXBkYXRlQmF0Y2hOdW1iZXIgPSAwO1xudmFyIGFzYXBDYWxsYmFja1F1ZXVlID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKTtcbnZhciBhc2FwRW5xdWV1ZWQgPSBmYWxzZTtcblxudmFyIGJhdGNoaW5nU3RyYXRlZ3kgPSBudWxsO1xuXG5mdW5jdGlvbiBlbnN1cmVJbmplY3RlZCgpIHtcbiAgIShSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiAmJiBiYXRjaGluZ1N0cmF0ZWd5KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgaW5qZWN0IGEgcmVjb25jaWxlIHRyYW5zYWN0aW9uIGNsYXNzIGFuZCBiYXRjaGluZyBzdHJhdGVneScpIDogX3Byb2RJbnZhcmlhbnQoJzEyMycpIDogdm9pZCAwO1xufVxuXG52YXIgTkVTVEVEX1VQREFURVMgPSB7XG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IGRpcnR5Q29tcG9uZW50cy5sZW5ndGg7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoICE9PSBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBBZGRpdGlvbmFsIHVwZGF0ZXMgd2VyZSBlbnF1ZXVlZCBieSBjb21wb25lbnREaWRVcGRhdGUgaGFuZGxlcnMgb3JcbiAgICAgIC8vIHNpbWlsYXI7IGJlZm9yZSBvdXIgb3duIFVQREFURV9RVUVVRUlORyB3cmFwcGVyIGNsb3Nlcywgd2Ugd2FudCB0byBydW5cbiAgICAgIC8vIHRoZXNlIG5ldyB1cGRhdGVzIHNvIHRoYXQgaWYgQSdzIGNvbXBvbmVudERpZFVwZGF0ZSBjYWxscyBzZXRTdGF0ZSBvblxuICAgICAgLy8gQiwgQiB3aWxsIHVwZGF0ZSBiZWZvcmUgdGhlIGNhbGxiYWNrIEEncyB1cGRhdGVyIHByb3ZpZGVkIHdoZW4gY2FsbGluZ1xuICAgICAgLy8gc2V0U3RhdGUuXG4gICAgICBkaXJ0eUNvbXBvbmVudHMuc3BsaWNlKDAsIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoKTtcbiAgICAgIGZsdXNoQmF0Y2hlZFVwZGF0ZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlydHlDb21wb25lbnRzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9XG59O1xuXG52YXIgVVBEQVRFX1FVRVVFSU5HID0ge1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jYWxsYmFja1F1ZXVlLnJlc2V0KCk7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jYWxsYmFja1F1ZXVlLm5vdGlmeUFsbCgpO1xuICB9XG59O1xuXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbTkVTVEVEX1VQREFURVMsIFVQREFURV9RVUVVRUlOR107XG5cbmZ1bmN0aW9uIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24oKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbiAgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggPSBudWxsO1xuICB0aGlzLmNhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xuICB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKFxuICAvKiB1c2VDcmVhdGVFbGVtZW50ICovdHJ1ZSk7XG59XG5cbl9hc3NpZ24oUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLCB7XG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH0sXG5cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoID0gbnVsbDtcbiAgICBDYWxsYmFja1F1ZXVlLnJlbGVhc2UodGhpcy5jYWxsYmFja1F1ZXVlKTtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUgPSBudWxsO1xuICAgIFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLnJlbGVhc2UodGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbik7XG4gICAgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbiA9IG51bGw7XG4gIH0sXG5cbiAgcGVyZm9ybTogZnVuY3Rpb24gKG1ldGhvZCwgc2NvcGUsIGEpIHtcbiAgICAvLyBFc3NlbnRpYWxseSBjYWxscyBgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbi5wZXJmb3JtKG1ldGhvZCwgc2NvcGUsIGEpYFxuICAgIC8vIHdpdGggdGhpcyB0cmFuc2FjdGlvbidzIHdyYXBwZXJzIGFyb3VuZCBpdC5cbiAgICByZXR1cm4gVHJhbnNhY3Rpb24ucGVyZm9ybS5jYWxsKHRoaXMsIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24ucGVyZm9ybSwgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbiwgbWV0aG9kLCBzY29wZSwgYSk7XG4gIH1cbn0pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbik7XG5cbmZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGNhbGxiYWNrLCBhLCBiLCBjLCBkLCBlKSB7XG4gIGVuc3VyZUluamVjdGVkKCk7XG4gIHJldHVybiBiYXRjaGluZ1N0cmF0ZWd5LmJhdGNoZWRVcGRhdGVzKGNhbGxiYWNrLCBhLCBiLCBjLCBkLCBlKTtcbn1cblxuLyoqXG4gKiBBcnJheSBjb21wYXJhdG9yIGZvciBSZWFjdENvbXBvbmVudHMgYnkgbW91bnQgb3JkZXJpbmcuXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gYzEgZmlyc3QgY29tcG9uZW50IHlvdSdyZSBjb21wYXJpbmdcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGMyIHNlY29uZCBjb21wb25lbnQgeW91J3JlIGNvbXBhcmluZ1xuICogQHJldHVybiB7bnVtYmVyfSBSZXR1cm4gdmFsdWUgdXNhYmxlIGJ5IEFycmF5LnByb3RvdHlwZS5zb3J0KCkuXG4gKi9cbmZ1bmN0aW9uIG1vdW50T3JkZXJDb21wYXJhdG9yKGMxLCBjMikge1xuICByZXR1cm4gYzEuX21vdW50T3JkZXIgLSBjMi5fbW91bnRPcmRlcjtcbn1cblxuZnVuY3Rpb24gcnVuQmF0Y2hlZFVwZGF0ZXModHJhbnNhY3Rpb24pIHtcbiAgdmFyIGxlbiA9IHRyYW5zYWN0aW9uLmRpcnR5Q29tcG9uZW50c0xlbmd0aDtcbiAgIShsZW4gPT09IGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGZsdXNoIHRyYW5zYWN0aW9uXFwncyBzdG9yZWQgZGlydHktY29tcG9uZW50cyBsZW5ndGggKCVzKSB0byBtYXRjaCBkaXJ0eS1jb21wb25lbnRzIGFycmF5IGxlbmd0aCAoJXMpLicsIGxlbiwgZGlydHlDb21wb25lbnRzLmxlbmd0aCkgOiBfcHJvZEludmFyaWFudCgnMTI0JywgbGVuLCBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSA6IHZvaWQgMDtcblxuICAvLyBTaW5jZSByZWNvbmNpbGluZyBhIGNvbXBvbmVudCBoaWdoZXIgaW4gdGhlIG93bmVyIGhpZXJhcmNoeSB1c3VhbGx5IChub3RcbiAgLy8gYWx3YXlzIC0tIHNlZSBzaG91bGRDb21wb25lbnRVcGRhdGUoKSkgd2lsbCByZWNvbmNpbGUgY2hpbGRyZW4sIHJlY29uY2lsZVxuICAvLyB0aGVtIGJlZm9yZSB0aGVpciBjaGlsZHJlbiBieSBzb3J0aW5nIHRoZSBhcnJheS5cbiAgZGlydHlDb21wb25lbnRzLnNvcnQobW91bnRPcmRlckNvbXBhcmF0b3IpO1xuXG4gIC8vIEFueSB1cGRhdGVzIGVucXVldWVkIHdoaWxlIHJlY29uY2lsaW5nIG11c3QgYmUgcGVyZm9ybWVkIGFmdGVyIHRoaXMgZW50aXJlXG4gIC8vIGJhdGNoLiBPdGhlcndpc2UsIGlmIGRpcnR5Q29tcG9uZW50cyBpcyBbQSwgQl0gd2hlcmUgQSBoYXMgY2hpbGRyZW4gQiBhbmRcbiAgLy8gQywgQiBjb3VsZCB1cGRhdGUgdHdpY2UgaW4gYSBzaW5nbGUgYmF0Y2ggaWYgQydzIHJlbmRlciBlbnF1ZXVlcyBhbiB1cGRhdGVcbiAgLy8gdG8gQiAoc2luY2UgQiB3b3VsZCBoYXZlIGFscmVhZHkgdXBkYXRlZCwgd2Ugc2hvdWxkIHNraXAgaXQsIGFuZCB0aGUgb25seVxuICAvLyB3YXkgd2UgY2FuIGtub3cgdG8gZG8gc28gaXMgYnkgY2hlY2tpbmcgdGhlIGJhdGNoIGNvdW50ZXIpLlxuICB1cGRhdGVCYXRjaE51bWJlcisrO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAvLyBJZiBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgYmVmb3JlIHBlbmRpbmcgY2hhbmdlcyBhcHBseSwgaXQgd2lsbCBzdGlsbFxuICAgIC8vIGJlIGhlcmUsIGJ1dCB3ZSBhc3N1bWUgdGhhdCBpdCBoYXMgY2xlYXJlZCBpdHMgX3BlbmRpbmdDYWxsYmFja3MgYW5kXG4gICAgLy8gdGhhdCBwZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkgaXMgYSBub29wLlxuICAgIHZhciBjb21wb25lbnQgPSBkaXJ0eUNvbXBvbmVudHNbaV07XG5cbiAgICAvLyBJZiBwZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkgaGFwcGVucyB0byBlbnF1ZXVlIGFueSBuZXcgdXBkYXRlcywgd2VcbiAgICAvLyBzaG91bGRuJ3QgZXhlY3V0ZSB0aGUgY2FsbGJhY2tzIHVudGlsIHRoZSBuZXh0IHJlbmRlciBoYXBwZW5zLCBzb1xuICAgIC8vIHN0YXNoIHRoZSBjYWxsYmFja3MgZmlyc3RcbiAgICB2YXIgY2FsbGJhY2tzID0gY29tcG9uZW50Ll9wZW5kaW5nQ2FsbGJhY2tzO1xuICAgIGNvbXBvbmVudC5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XG5cbiAgICB2YXIgbWFya2VyTmFtZTtcbiAgICBpZiAoUmVhY3RGZWF0dXJlRmxhZ3MubG9nVG9wTGV2ZWxSZW5kZXJzKSB7XG4gICAgICB2YXIgbmFtZWRDb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAvLyBEdWNrIHR5cGUgVG9wTGV2ZWxXcmFwcGVyLiBUaGlzIGlzIHByb2JhYmx5IGFsd2F5cyB0cnVlLlxuICAgICAgaWYgKGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQudHlwZS5pc1JlYWN0VG9wTGV2ZWxXcmFwcGVyKSB7XG4gICAgICAgIG5hbWVkQ29tcG9uZW50ID0gY29tcG9uZW50Ll9yZW5kZXJlZENvbXBvbmVudDtcbiAgICAgIH1cbiAgICAgIG1hcmtlck5hbWUgPSAnUmVhY3QgdXBkYXRlOiAnICsgbmFtZWRDb21wb25lbnQuZ2V0TmFtZSgpO1xuICAgICAgY29uc29sZS50aW1lKG1hcmtlck5hbWUpO1xuICAgIH1cblxuICAgIFJlYWN0UmVjb25jaWxlci5wZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkoY29tcG9uZW50LCB0cmFuc2FjdGlvbi5yZWNvbmNpbGVUcmFuc2FjdGlvbiwgdXBkYXRlQmF0Y2hOdW1iZXIpO1xuXG4gICAgaWYgKG1hcmtlck5hbWUpIHtcbiAgICAgIGNvbnNvbGUudGltZUVuZChtYXJrZXJOYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNhbGxiYWNrcy5sZW5ndGg7IGorKykge1xuICAgICAgICB0cmFuc2FjdGlvbi5jYWxsYmFja1F1ZXVlLmVucXVldWUoY2FsbGJhY2tzW2pdLCBjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBmbHVzaEJhdGNoZWRVcGRhdGVzID0gZnVuY3Rpb24gKCkge1xuICAvLyBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uJ3Mgd3JhcHBlcnMgd2lsbCBjbGVhciB0aGUgZGlydHlDb21wb25lbnRzXG4gIC8vIGFycmF5IGFuZCBwZXJmb3JtIGFueSB1cGRhdGVzIGVucXVldWVkIGJ5IG1vdW50LXJlYWR5IGhhbmRsZXJzIChpLmUuLFxuICAvLyBjb21wb25lbnREaWRVcGRhdGUpIGJ1dCB3ZSBuZWVkIHRvIGNoZWNrIGhlcmUgdG9vIGluIG9yZGVyIHRvIGNhdGNoXG4gIC8vIHVwZGF0ZXMgZW5xdWV1ZWQgYnkgc2V0U3RhdGUgY2FsbGJhY2tzIGFuZCBhc2FwIGNhbGxzLlxuICB3aGlsZSAoZGlydHlDb21wb25lbnRzLmxlbmd0aCB8fCBhc2FwRW5xdWV1ZWQpIHtcbiAgICBpZiAoZGlydHlDb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgdmFyIHRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbi5nZXRQb29sZWQoKTtcbiAgICAgIHRyYW5zYWN0aW9uLnBlcmZvcm0ocnVuQmF0Y2hlZFVwZGF0ZXMsIG51bGwsIHRyYW5zYWN0aW9uKTtcbiAgICAgIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24ucmVsZWFzZSh0cmFuc2FjdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGFzYXBFbnF1ZXVlZCkge1xuICAgICAgYXNhcEVucXVldWVkID0gZmFsc2U7XG4gICAgICB2YXIgcXVldWUgPSBhc2FwQ2FsbGJhY2tRdWV1ZTtcbiAgICAgIGFzYXBDYWxsYmFja1F1ZXVlID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKTtcbiAgICAgIHF1ZXVlLm5vdGlmeUFsbCgpO1xuICAgICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHF1ZXVlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTWFyayBhIGNvbXBvbmVudCBhcyBuZWVkaW5nIGEgcmVyZW5kZXIsIGFkZGluZyBhbiBvcHRpb25hbCBjYWxsYmFjayB0byBhXG4gKiBsaXN0IG9mIGZ1bmN0aW9ucyB3aGljaCB3aWxsIGJlIGV4ZWN1dGVkIG9uY2UgdGhlIHJlcmVuZGVyIG9jY3Vycy5cbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShjb21wb25lbnQpIHtcbiAgZW5zdXJlSW5qZWN0ZWQoKTtcblxuICAvLyBWYXJpb3VzIHBhcnRzIG9mIG91ciBjb2RlIChzdWNoIGFzIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50J3NcbiAgLy8gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCkgYXNzdW1lIHRoYXQgY2FsbHMgdG8gcmVuZGVyIGFyZW4ndCBuZXN0ZWQ7XG4gIC8vIHZlcmlmeSB0aGF0IHRoYXQncyB0aGUgY2FzZS4gKFRoaXMgaXMgY2FsbGVkIGJ5IGVhY2ggdG9wLWxldmVsIHVwZGF0ZVxuICAvLyBmdW5jdGlvbiwgbGlrZSBzZXRTdGF0ZSwgZm9yY2VVcGRhdGUsIGV0Yy47IGNyZWF0aW9uIGFuZFxuICAvLyBkZXN0cnVjdGlvbiBvZiB0b3AtbGV2ZWwgY29tcG9uZW50cyBpcyBndWFyZGVkIGluIFJlYWN0TW91bnQuKVxuXG4gIGlmICghYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcykge1xuICAgIGJhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMoZW5xdWV1ZVVwZGF0ZSwgY29tcG9uZW50KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBkaXJ0eUNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICBpZiAoY29tcG9uZW50Ll91cGRhdGVCYXRjaE51bWJlciA9PSBudWxsKSB7XG4gICAgY29tcG9uZW50Ll91cGRhdGVCYXRjaE51bWJlciA9IHVwZGF0ZUJhdGNoTnVtYmVyICsgMTtcbiAgfVxufVxuXG4vKipcbiAqIEVucXVldWUgYSBjYWxsYmFjayB0byBiZSBydW4gYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBiYXRjaGluZyBjeWNsZS4gVGhyb3dzXG4gKiBpZiBubyB1cGRhdGVzIGFyZSBjdXJyZW50bHkgYmVpbmcgcGVyZm9ybWVkLlxuICovXG5mdW5jdGlvbiBhc2FwKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICFiYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlcy5hc2FwOiBDYW5cXCd0IGVucXVldWUgYW4gYXNhcCBjYWxsYmFjayBpbiBhIGNvbnRleHQgd2hlcmV1cGRhdGVzIGFyZSBub3QgYmVpbmcgYmF0Y2hlZC4nKSA6IF9wcm9kSW52YXJpYW50KCcxMjUnKSA6IHZvaWQgMDtcbiAgYXNhcENhbGxiYWNrUXVldWUuZW5xdWV1ZShjYWxsYmFjaywgY29udGV4dCk7XG4gIGFzYXBFbnF1ZXVlZCA9IHRydWU7XG59XG5cbnZhciBSZWFjdFVwZGF0ZXNJbmplY3Rpb24gPSB7XG4gIGluamVjdFJlY29uY2lsZVRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoUmVjb25jaWxlVHJhbnNhY3Rpb24pIHtcbiAgICAhUmVjb25jaWxlVHJhbnNhY3Rpb24gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSByZWNvbmNpbGUgdHJhbnNhY3Rpb24gY2xhc3MnKSA6IF9wcm9kSW52YXJpYW50KCcxMjYnKSA6IHZvaWQgMDtcbiAgICBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiA9IFJlY29uY2lsZVRyYW5zYWN0aW9uO1xuICB9LFxuXG4gIGluamVjdEJhdGNoaW5nU3RyYXRlZ3k6IGZ1bmN0aW9uIChfYmF0Y2hpbmdTdHJhdGVneSkge1xuICAgICFfYmF0Y2hpbmdTdHJhdGVneSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhIGJhdGNoaW5nIHN0cmF0ZWd5JykgOiBfcHJvZEludmFyaWFudCgnMTI3JykgOiB2b2lkIDA7XG4gICAgISh0eXBlb2YgX2JhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMgPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGEgYmF0Y2hlZFVwZGF0ZXMoKSBmdW5jdGlvbicpIDogX3Byb2RJbnZhcmlhbnQoJzEyOCcpIDogdm9pZCAwO1xuICAgICEodHlwZW9mIF9iYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID09PSAnYm9vbGVhbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGFuIGlzQmF0Y2hpbmdVcGRhdGVzIGJvb2xlYW4gYXR0cmlidXRlJykgOiBfcHJvZEludmFyaWFudCgnMTI5JykgOiB2b2lkIDA7XG4gICAgYmF0Y2hpbmdTdHJhdGVneSA9IF9iYXRjaGluZ1N0cmF0ZWd5O1xuICB9XG59O1xuXG52YXIgUmVhY3RVcGRhdGVzID0ge1xuICAvKipcbiAgICogUmVhY3QgcmVmZXJlbmNlcyBgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbmAgdXNpbmcgdGhpcyBwcm9wZXJ0eSBpbiBvcmRlclxuICAgKiB0byBhbGxvdyBkZXBlbmRlbmN5IGluamVjdGlvbi5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uOiBudWxsLFxuXG4gIGJhdGNoZWRVcGRhdGVzOiBiYXRjaGVkVXBkYXRlcyxcbiAgZW5xdWV1ZVVwZGF0ZTogZW5xdWV1ZVVwZGF0ZSxcbiAgZmx1c2hCYXRjaGVkVXBkYXRlczogZmx1c2hCYXRjaGVkVXBkYXRlcyxcbiAgaW5qZWN0aW9uOiBSZWFjdFVwZGF0ZXNJbmplY3Rpb24sXG4gIGFzYXA6IGFzYXBcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RVcGRhdGVzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0VXBkYXRlcy5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVyLlxuICpcbiAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcbiAqIGN1cnJlbnRseSBiZWluZyBjb25zdHJ1Y3RlZC5cbiAqL1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q3VycmVudE93bmVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXIuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9SZWFjdCcpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0L3JlYWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgPSBmYWxzZTtcbnZhciBpc1Byb3h5U3VwcG9ydGVkID0gdHlwZW9mIFByb3h5ID09PSAnZnVuY3Rpb24nO1xuXG52YXIgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMgPSBbJ2Rpc3BhdGNoQ29uZmlnJywgJ190YXJnZXRJbnN0JywgJ25hdGl2ZUV2ZW50JywgJ2lzRGVmYXVsdFByZXZlbnRlZCcsICdpc1Byb3BhZ2F0aW9uU3RvcHBlZCcsICdfZGlzcGF0Y2hMaXN0ZW5lcnMnLCAnX2Rpc3BhdGNoSW5zdGFuY2VzJ107XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBFdmVudEludGVyZmFjZSA9IHtcbiAgdHlwZTogbnVsbCxcbiAgdGFyZ2V0OiBudWxsLFxuICAvLyBjdXJyZW50VGFyZ2V0IGlzIHNldCB3aGVuIGRpc3BhdGNoaW5nOyBubyB1c2UgaW4gY29weWluZyBpdCBoZXJlXG4gIGN1cnJlbnRUYXJnZXQ6IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsLFxuICBldmVudFBoYXNlOiBudWxsLFxuICBidWJibGVzOiBudWxsLFxuICBjYW5jZWxhYmxlOiBudWxsLFxuICB0aW1lU3RhbXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcbiAgfSxcbiAgZGVmYXVsdFByZXZlbnRlZDogbnVsbCxcbiAgaXNUcnVzdGVkOiBudWxsXG59O1xuXG4vKipcbiAqIFN5bnRoZXRpYyBldmVudHMgYXJlIGRpc3BhdGNoZWQgYnkgZXZlbnQgcGx1Z2lucywgdHlwaWNhbGx5IGluIHJlc3BvbnNlIHRvIGFcbiAqIHRvcC1sZXZlbCBldmVudCBkZWxlZ2F0aW9uIGhhbmRsZXIuXG4gKlxuICogVGhlc2Ugc3lzdGVtcyBzaG91bGQgZ2VuZXJhbGx5IHVzZSBwb29saW5nIHRvIHJlZHVjZSB0aGUgZnJlcXVlbmN5IG9mIGdhcmJhZ2VcbiAqIGNvbGxlY3Rpb24uIFRoZSBzeXN0ZW0gc2hvdWxkIGNoZWNrIGBpc1BlcnNpc3RlbnRgIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZVxuICogZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGludG8gdGhlIHBvb2wgYWZ0ZXIgYmVpbmcgZGlzcGF0Y2hlZC4gVXNlcnMgdGhhdFxuICogbmVlZCBhIHBlcnNpc3RlZCBldmVudCBzaG91bGQgaW52b2tlIGBwZXJzaXN0YC5cbiAqXG4gKiBTeW50aGV0aWMgZXZlbnRzIChhbmQgc3ViY2xhc3NlcykgaW1wbGVtZW50IHRoZSBET00gTGV2ZWwgMyBFdmVudHMgQVBJIGJ5XG4gKiBub3JtYWxpemluZyBicm93c2VyIHF1aXJrcy4gU3ViY2xhc3NlcyBkbyBub3QgbmVjZXNzYXJpbHkgaGF2ZSB0byBpbXBsZW1lbnQgYVxuICogRE9NIGludGVyZmFjZTsgY3VzdG9tIGFwcGxpY2F0aW9uLXNwZWNpZmljIGV2ZW50cyBjYW4gYWxzbyBzdWJjbGFzcyB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0SW5zdCBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IG5hdGl2ZUV2ZW50VGFyZ2V0IFRhcmdldCBub2RlLlxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNFdmVudChkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gdGhlc2UgaGF2ZSBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgZGVsZXRlIHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgZGVsZXRlIHRoaXMucHJldmVudERlZmF1bHQ7XG4gICAgZGVsZXRlIHRoaXMuc3RvcFByb3BhZ2F0aW9uO1xuICB9XG5cbiAgdGhpcy5kaXNwYXRjaENvbmZpZyA9IGRpc3BhdGNoQ29uZmlnO1xuICB0aGlzLl90YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuXG4gIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgaWYgKCFJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGRlbGV0ZSB0aGlzW3Byb3BOYW1lXTsgLy8gdGhpcyBoYXMgYSBnZXR0ZXIvc2V0dGVyIGZvciB3YXJuaW5nc1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplID0gSW50ZXJmYWNlW3Byb3BOYW1lXTtcbiAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICB0aGlzW3Byb3BOYW1lXSA9IG5vcm1hbGl6ZShuYXRpdmVFdmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wTmFtZSA9PT0gJ3RhcmdldCcpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbcHJvcE5hbWVdID0gbmF0aXZlRXZlbnRbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBkZWZhdWx0UHJldmVudGVkID0gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCAhPSBudWxsID8gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCA6IG5hdGl2ZUV2ZW50LnJldHVyblZhbHVlID09PSBmYWxzZTtcbiAgaWYgKGRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlO1xuICB9XG4gIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2U7XG4gIHJldHVybiB0aGlzO1xufVxuXG5fYXNzaWduKFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZSwge1xuXG4gIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQucmV0dXJuVmFsdWUgIT09ICd1bmtub3duJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSB2YWxpZC10eXBlb2ZcbiAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQuY2FuY2VsQnViYmxlICE9PSAndW5rbm93bicpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgdmFsaWQtdHlwZW9mXG4gICAgICAvLyBUaGUgQ2hhbmdlRXZlbnRQbHVnaW4gcmVnaXN0ZXJzIGEgXCJwcm9wZXJ0eWNoYW5nZVwiIGV2ZW50IGZvclxuICAgICAgLy8gSUUuIFRoaXMgZXZlbnQgZG9lcyBub3Qgc3VwcG9ydCBidWJibGluZyBvciBjYW5jZWxsaW5nLCBhbmRcbiAgICAgIC8vIGFueSByZWZlcmVuY2VzIHRvIGNhbmNlbEJ1YmJsZSB0aHJvdyBcIk1lbWJlciBub3QgZm91bmRcIi4gIEFcbiAgICAgIC8vIHR5cGVvZiBjaGVjayBvZiBcInVua25vd25cIiBjaXJjdW12ZW50cyB0aGlzIGlzc3VlIChhbmQgaXMgYWxzb1xuICAgICAgLy8gSUUgc3BlY2lmaWMpLlxuICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdlIHJlbGVhc2UgYWxsIGRpc3BhdGNoZWQgYFN5bnRoZXRpY0V2ZW50YHMgYWZ0ZXIgZWFjaCBldmVudCBsb29wLCBhZGRpbmdcbiAgICogdGhlbSBiYWNrIGludG8gdGhlIHBvb2wuIFRoaXMgYWxsb3dzIGEgd2F5IHRvIGhvbGQgb250byBhIHJlZmVyZW5jZSB0aGF0XG4gICAqIHdvbid0IGJlIGFkZGVkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICovXG4gIHBlcnNpc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzUGVyc2lzdGVudCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoaXMgc2hvdWxkIG5vdCBiZSByZWxlYXNlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNQZXJzaXN0ZW50OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UsXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIGBkZXN0cnVjdG9yYCBvbiBlYWNoIGluc3RhbmNlIGl0IHJlbGVhc2VzLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wTmFtZSwgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihwcm9wTmFtZSwgSW50ZXJmYWNlW3Byb3BOYW1lXSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1twcm9wTmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzW3Nob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzW2ldXSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ25hdGl2ZUV2ZW50JywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbignbmF0aXZlRXZlbnQnLCBudWxsKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3ByZXZlbnREZWZhdWx0JywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbigncHJldmVudERlZmF1bHQnLCBlbXB0eUZ1bmN0aW9uKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3N0b3BQcm9wYWdhdGlvbicsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ3N0b3BQcm9wYWdhdGlvbicsIGVtcHR5RnVuY3Rpb24pKTtcbiAgICB9XG4gIH1cblxufSk7XG5cblN5bnRoZXRpY0V2ZW50LkludGVyZmFjZSA9IEV2ZW50SW50ZXJmYWNlO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBpZiAoaXNQcm94eVN1cHBvcnRlZCkge1xuICAgIC8qZXNsaW50LWRpc2FibGUgbm8tZnVuYy1hc3NpZ24gKi9cbiAgICBTeW50aGV0aWNFdmVudCA9IG5ldyBQcm94eShTeW50aGV0aWNFdmVudCwge1xuICAgICAgY29uc3RydWN0OiBmdW5jdGlvbiAodGFyZ2V0LCBhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5KHRhcmdldCwgT2JqZWN0LmNyZWF0ZSh0YXJnZXQucHJvdG90eXBlKSwgYXJncyk7XG4gICAgICB9LFxuICAgICAgYXBwbHk6IGZ1bmN0aW9uIChjb25zdHJ1Y3RvciwgdGhhdCwgYXJncykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3h5KGNvbnN0cnVjdG9yLmFwcGx5KHRoYXQsIGFyZ3MpLCB7XG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHByb3AgIT09ICdpc1BlcnNpc3RlbnQnICYmICF0YXJnZXQuY29uc3RydWN0b3IuSW50ZXJmYWNlLmhhc093blByb3BlcnR5KHByb3ApICYmIHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5IHx8IHRhcmdldC5pc1BlcnNpc3RlbnQoKSwgJ1RoaXMgc3ludGhldGljIGV2ZW50IGlzIHJldXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gSWYgeW91XFwncmUgJyArICdzZWVpbmcgdGhpcywgeW91XFwncmUgYWRkaW5nIGEgbmV3IHByb3BlcnR5IGluIHRoZSBzeW50aGV0aWMgZXZlbnQgb2JqZWN0LiAnICsgJ1RoZSBwcm9wZXJ0eSBpcyBuZXZlciByZWxlYXNlZC4gU2VlICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1ldmVudC1wb29saW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgICBkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyplc2xpbnQtZW5hYmxlIG5vLWZ1bmMtYXNzaWduICovXG4gIH1cbn1cbi8qKlxuICogSGVscGVyIHRvIHJlZHVjZSBib2lsZXJwbGF0ZSB3aGVuIGNyZWF0aW5nIHN1YmNsYXNzZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3NcbiAqIEBwYXJhbSB7P29iamVjdH0gSW50ZXJmYWNlXG4gKi9cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyA9IGZ1bmN0aW9uIChDbGFzcywgSW50ZXJmYWNlKSB7XG4gIHZhciBTdXBlciA9IHRoaXM7XG5cbiAgdmFyIEUgPSBmdW5jdGlvbiAoKSB7fTtcbiAgRS5wcm90b3R5cGUgPSBTdXBlci5wcm90b3R5cGU7XG4gIHZhciBwcm90b3R5cGUgPSBuZXcgRSgpO1xuXG4gIF9hc3NpZ24ocHJvdG90eXBlLCBDbGFzcy5wcm90b3R5cGUpO1xuICBDbGFzcy5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gIENsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENsYXNzO1xuXG4gIENsYXNzLkludGVyZmFjZSA9IF9hc3NpZ24oe30sIFN1cGVyLkludGVyZmFjZSwgSW50ZXJmYWNlKTtcbiAgQ2xhc3MuYXVnbWVudENsYXNzID0gU3VwZXIuYXVnbWVudENsYXNzO1xuXG4gIFBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhDbGFzcywgUG9vbGVkQ2xhc3MuZm91ckFyZ3VtZW50UG9vbGVyKTtcbn07XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhTeW50aGV0aWNFdmVudCwgUG9vbGVkQ2xhc3MuZm91ckFyZ3VtZW50UG9vbGVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNFdmVudDtcblxuLyoqXG4gICogSGVscGVyIHRvIG51bGxpZnkgc3ludGhldGljRXZlbnQgaW5zdGFuY2UgcHJvcGVydGllcyB3aGVuIGRlc3RydWN0aW5nXG4gICpcbiAgKiBAcGFyYW0ge29iamVjdH0gU3ludGhldGljRXZlbnRcbiAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcE5hbWVcbiAgKiBAcmV0dXJuIHtvYmplY3R9IGRlZmluZVByb3BlcnR5IG9iamVjdFxuICAqL1xuZnVuY3Rpb24gZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihwcm9wTmFtZSwgZ2V0VmFsKSB7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIGdldFZhbCA9PT0gJ2Z1bmN0aW9uJztcbiAgcmV0dXJuIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgc2V0OiBzZXQsXG4gICAgZ2V0OiBnZXRcbiAgfTtcblxuICBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgdmFyIGFjdGlvbiA9IGlzRnVuY3Rpb24gPyAnc2V0dGluZyB0aGUgbWV0aG9kJyA6ICdzZXR0aW5nIHRoZSBwcm9wZXJ0eSc7XG4gICAgd2FybihhY3Rpb24sICdUaGlzIGlzIGVmZmVjdGl2ZWx5IGEgbm8tb3AnKTtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0KCkge1xuICAgIHZhciBhY3Rpb24gPSBpc0Z1bmN0aW9uID8gJ2FjY2Vzc2luZyB0aGUgbWV0aG9kJyA6ICdhY2Nlc3NpbmcgdGhlIHByb3BlcnR5JztcbiAgICB2YXIgcmVzdWx0ID0gaXNGdW5jdGlvbiA/ICdUaGlzIGlzIGEgbm8tb3AgZnVuY3Rpb24nIDogJ1RoaXMgaXMgc2V0IHRvIG51bGwnO1xuICAgIHdhcm4oYWN0aW9uLCByZXN1bHQpO1xuICAgIHJldHVybiBnZXRWYWw7XG4gIH1cblxuICBmdW5jdGlvbiB3YXJuKGFjdGlvbiwgcmVzdWx0KSB7XG4gICAgdmFyIHdhcm5pbmdDb25kaXRpb24gPSBmYWxzZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh3YXJuaW5nQ29uZGl0aW9uLCAnVGhpcyBzeW50aGV0aWMgZXZlbnQgaXMgcmV1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3VcXCdyZSBzZWVpbmcgdGhpcywgJyArICd5b3VcXCdyZSAlcyBgJXNgIG9uIGEgcmVsZWFzZWQvbnVsbGlmaWVkIHN5bnRoZXRpYyBldmVudC4gJXMuICcgKyAnSWYgeW91IG11c3Qga2VlcCB0aGUgb3JpZ2luYWwgc3ludGhldGljIGV2ZW50IGFyb3VuZCwgdXNlIGV2ZW50LnBlcnNpc3QoKS4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1ldmVudC1wb29saW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGFjdGlvbiwgcHJvcE5hbWUsIHJlc3VsdCkgOiB2b2lkIDA7XG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNFdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG5mdW5jdGlvbiBtYWtlRW1wdHlGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuICogYWx3YXlzIG5lZWQgdG8gYmUgY2FsbGFibGUsIHNpbmNlIEpTIGxhY2tzIGEgbnVsbC1jYWxsIGlkaW9tIGFsYSBDb2NvYS5cbiAqL1xudmFyIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge307XG5cbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIGFyZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlGdW5jdGlvbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL34vZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG5mdW5jdGlvbiBjaGVja01hc2sodmFsdWUsIGJpdG1hc2spIHtcbiAgcmV0dXJuICh2YWx1ZSAmIGJpdG1hc2spID09PSBiaXRtYXNrO1xufVxuXG52YXIgRE9NUHJvcGVydHlJbmplY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gbm9ybWFsaXplZCwgY2FtZWxjYXNlZCBwcm9wZXJ0eSBuYW1lcyB0byBhIGNvbmZpZ3VyYXRpb24gdGhhdFxuICAgKiBzcGVjaWZpZXMgaG93IHRoZSBhc3NvY2lhdGVkIERPTSBwcm9wZXJ0eSBzaG91bGQgYmUgYWNjZXNzZWQgb3IgcmVuZGVyZWQuXG4gICAqL1xuICBNVVNUX1VTRV9QUk9QRVJUWTogMHgxLFxuICBIQVNfQk9PTEVBTl9WQUxVRTogMHg0LFxuICBIQVNfTlVNRVJJQ19WQUxVRTogMHg4LFxuICBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRTogMHgxMCB8IDB4OCxcbiAgSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRTogMHgyMCxcblxuICAvKipcbiAgICogSW5qZWN0IHNvbWUgc3BlY2lhbGl6ZWQga25vd2xlZGdlIGFib3V0IHRoZSBET00uIFRoaXMgdGFrZXMgYSBjb25maWcgb2JqZWN0XG4gICAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiBpc0N1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gdGhhdCBnaXZlbiBhbiBhdHRyaWJ1dGUgbmFtZSB3aWxsIHJldHVybiB0cnVlXG4gICAqIGlmIGl0IGNhbiBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00gdmVyYmF0aW0uIFVzZWZ1bCBmb3IgZGF0YS0qIG9yIGFyaWEtKlxuICAgKiBhdHRyaWJ1dGVzIHdoZXJlIGl0J3MgaW1wb3NzaWJsZSB0byBlbnVtZXJhdGUgYWxsIG9mIHRoZSBwb3NzaWJsZVxuICAgKiBhdHRyaWJ1dGUgbmFtZXMsXG4gICAqXG4gICAqIFByb3BlcnRpZXM6IG9iamVjdCBtYXBwaW5nIERPTSBwcm9wZXJ0eSBuYW1lIHRvIG9uZSBvZiB0aGVcbiAgICogRE9NUHJvcGVydHlJbmplY3Rpb24gY29uc3RhbnRzIG9yIG51bGwuIElmIHlvdXIgYXR0cmlidXRlIGlzbid0IGluIGhlcmUsXG4gICAqIGl0IHdvbid0IGdldCB3cml0dGVuIHRvIHRoZSBET00uXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzOiBvYmplY3QgbWFwcGluZyBSZWFjdCBhdHRyaWJ1dGUgbmFtZSB0byB0aGUgRE9NXG4gICAqIGF0dHJpYnV0ZSBuYW1lLiBBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2UgdGhlICoqbG93ZXJjYXNlKipcbiAgICogbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01BdHRyaWJ1dGVOYW1lc3BhY2VzOiBvYmplY3QgbWFwcGluZyBSZWFjdCBhdHRyaWJ1dGUgbmFtZSB0byB0aGUgRE9NXG4gICAqIGF0dHJpYnV0ZSBuYW1lc3BhY2UgVVJMLiAoQXR0cmlidXRlIG5hbWVzIG5vdCBzcGVjaWZpZWQgdXNlIG5vIG5hbWVzcGFjZS4pXG4gICAqXG4gICAqIERPTVByb3BlcnR5TmFtZXM6IHNpbWlsYXIgdG8gRE9NQXR0cmlidXRlTmFtZXMgYnV0IGZvciBET00gcHJvcGVydGllcy5cbiAgICogUHJvcGVydHkgbmFtZXMgbm90IHNwZWNpZmllZCB1c2UgdGhlIG5vcm1hbGl6ZWQgbmFtZS5cbiAgICpcbiAgICogRE9NTXV0YXRpb25NZXRob2RzOiBQcm9wZXJ0aWVzIHRoYXQgcmVxdWlyZSBzcGVjaWFsIG11dGF0aW9uIG1ldGhvZHMuIElmXG4gICAqIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLCB0aGUgbXV0YXRpb24gbWV0aG9kIHNob3VsZCB1bnNldCB0aGUgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkb21Qcm9wZXJ0eUNvbmZpZyB0aGUgY29uZmlnIGFzIGRlc2NyaWJlZCBhYm92ZS5cbiAgICovXG4gIGluamVjdERPTVByb3BlcnR5Q29uZmlnOiBmdW5jdGlvbiAoZG9tUHJvcGVydHlDb25maWcpIHtcbiAgICB2YXIgSW5qZWN0aW9uID0gRE9NUHJvcGVydHlJbmplY3Rpb247XG4gICAgdmFyIFByb3BlcnRpZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5Qcm9wZXJ0aWVzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lc3BhY2VzID0gZG9tUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXNwYWNlcyB8fCB7fTtcbiAgICB2YXIgRE9NQXR0cmlidXRlTmFtZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lcyB8fCB7fTtcbiAgICB2YXIgRE9NUHJvcGVydHlOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTVByb3BlcnR5TmFtZXMgfHwge307XG4gICAgdmFyIERPTU11dGF0aW9uTWV0aG9kcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTU11dGF0aW9uTWV0aG9kcyB8fCB7fTtcblxuICAgIGlmIChkb21Qcm9wZXJ0eUNvbmZpZy5pc0N1c3RvbUF0dHJpYnV0ZSkge1xuICAgICAgRE9NUHJvcGVydHkuX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zLnB1c2goZG9tUHJvcGVydHlDb25maWcuaXNDdXN0b21BdHRyaWJ1dGUpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIFByb3BlcnRpZXMpIHtcbiAgICAgICEhRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnaW5qZWN0RE9NUHJvcGVydHlDb25maWcoLi4uKTogWW91XFwncmUgdHJ5aW5nIHRvIGluamVjdCBET00gcHJvcGVydHkgXFwnJXNcXCcgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiBpbmplY3RlZC4gWW91IG1heSBiZSBhY2NpZGVudGFsbHkgaW5qZWN0aW5nIHRoZSBzYW1lIERPTSBwcm9wZXJ0eSBjb25maWcgdHdpY2UsIG9yIHlvdSBtYXkgYmUgaW5qZWN0aW5nIHR3byBjb25maWdzIHRoYXQgaGF2ZSBjb25mbGljdGluZyBwcm9wZXJ0eSBuYW1lcy4nLCBwcm9wTmFtZSkgOiBfcHJvZEludmFyaWFudCgnNDgnLCBwcm9wTmFtZSkgOiB2b2lkIDA7XG5cbiAgICAgIHZhciBsb3dlckNhc2VkID0gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBwcm9wQ29uZmlnID0gUHJvcGVydGllc1twcm9wTmFtZV07XG5cbiAgICAgIHZhciBwcm9wZXJ0eUluZm8gPSB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6IGxvd2VyQ2FzZWQsXG4gICAgICAgIGF0dHJpYnV0ZU5hbWVzcGFjZTogbnVsbCxcbiAgICAgICAgcHJvcGVydHlOYW1lOiBwcm9wTmFtZSxcbiAgICAgICAgbXV0YXRpb25NZXRob2Q6IG51bGwsXG5cbiAgICAgICAgbXVzdFVzZVByb3BlcnR5OiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLk1VU1RfVVNFX1BST1BFUlRZKSxcbiAgICAgICAgaGFzQm9vbGVhblZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19CT09MRUFOX1ZBTFVFKSxcbiAgICAgICAgaGFzTnVtZXJpY1ZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19OVU1FUklDX1ZBTFVFKSxcbiAgICAgICAgaGFzUG9zaXRpdmVOdW1lcmljVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUpLFxuICAgICAgICBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUpXG4gICAgICB9O1xuICAgICAgIShwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlICsgcHJvcGVydHlJbmZvLmhhc051bWVyaWNWYWx1ZSArIHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlIDw9IDEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0RPTVByb3BlcnR5OiBWYWx1ZSBjYW4gYmUgb25lIG9mIGJvb2xlYW4sIG92ZXJsb2FkZWQgYm9vbGVhbiwgb3IgbnVtZXJpYyB2YWx1ZSwgYnV0IG5vdCBhIGNvbWJpbmF0aW9uOiAlcycsIHByb3BOYW1lKSA6IF9wcm9kSW52YXJpYW50KCc1MCcsIHByb3BOYW1lKSA6IHZvaWQgMDtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWVbbG93ZXJDYXNlZF0gPSBwcm9wTmFtZTtcbiAgICAgIH1cblxuICAgICAgaWYgKERPTUF0dHJpYnV0ZU5hbWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IERPTUF0dHJpYnV0ZU5hbWVzW3Byb3BOYW1lXTtcbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2F0dHJpYnV0ZU5hbWVdID0gcHJvcE5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKERPTUF0dHJpYnV0ZU5hbWVzcGFjZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBET01BdHRyaWJ1dGVOYW1lc3BhY2VzW3Byb3BOYW1lXTtcbiAgICAgIH1cblxuICAgICAgaWYgKERPTVByb3BlcnR5TmFtZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWUgPSBET01Qcm9wZXJ0eU5hbWVzW3Byb3BOYW1lXTtcbiAgICAgIH1cblxuICAgICAgaWYgKERPTU11dGF0aW9uTWV0aG9kcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kID0gRE9NTXV0YXRpb25NZXRob2RzW3Byb3BOYW1lXTtcbiAgICAgIH1cblxuICAgICAgRE9NUHJvcGVydHkucHJvcGVydGllc1twcm9wTmFtZV0gPSBwcm9wZXJ0eUluZm87XG4gICAgfVxuICB9XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG52YXIgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiA9ICc6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEJztcbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIERPTVByb3BlcnR5IGV4cG9ydHMgbG9va3VwIG9iamVjdHMgdGhhdCBjYW4gYmUgdXNlZCBsaWtlIGZ1bmN0aW9uczpcbiAqXG4gKiAgID4gRE9NUHJvcGVydHkuaXNWYWxpZFsnaWQnXVxuICogICB0cnVlXG4gKiAgID4gRE9NUHJvcGVydHkuaXNWYWxpZFsnZm9vYmFyJ11cbiAqICAgdW5kZWZpbmVkXG4gKlxuICogQWx0aG91Z2ggdGhpcyBtYXkgYmUgY29uZnVzaW5nLCBpdCBwZXJmb3JtcyBiZXR0ZXIgaW4gZ2VuZXJhbC5cbiAqXG4gKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2tleS1leGlzdHNcbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20va2V5LW1pc3NpbmdcbiAqL1xudmFyIERPTVByb3BlcnR5ID0ge1xuXG4gIElEX0FUVFJJQlVURV9OQU1FOiAnZGF0YS1yZWFjdGlkJyxcbiAgUk9PVF9BVFRSSUJVVEVfTkFNRTogJ2RhdGEtcmVhY3Ryb290JyxcblxuICBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSOiBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSLFxuICBBVFRSSUJVVEVfTkFNRV9DSEFSOiBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgJ1xcXFwtLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwJyxcblxuICAvKipcbiAgICogTWFwIGZyb20gcHJvcGVydHkgXCJzdGFuZGFyZCBuYW1lXCIgdG8gYW4gb2JqZWN0IHdpdGggaW5mbyBhYm91dCBob3cgdG8gc2V0XG4gICAqIHRoZSBwcm9wZXJ0eSBpbiB0aGUgRE9NLiBFYWNoIG9iamVjdCBjb250YWluczpcbiAgICpcbiAgICogYXR0cmlidXRlTmFtZTpcbiAgICogICBVc2VkIHdoZW4gcmVuZGVyaW5nIG1hcmt1cCBvciB3aXRoIGAqQXR0cmlidXRlKClgLlxuICAgKiBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgICogcHJvcGVydHlOYW1lOlxuICAgKiAgIFVzZWQgb24gRE9NIG5vZGUgaW5zdGFuY2VzLiAoVGhpcyBpbmNsdWRlcyBwcm9wZXJ0aWVzIHRoYXQgbXV0YXRlIGR1ZSB0b1xuICAgKiAgIGV4dGVybmFsIGZhY3RvcnMuKVxuICAgKiBtdXRhdGlvbk1ldGhvZDpcbiAgICogICBJZiBub24tbnVsbCwgdXNlZCBpbnN0ZWFkIG9mIHRoZSBwcm9wZXJ0eSBvciBgc2V0QXR0cmlidXRlKClgIGFmdGVyXG4gICAqICAgaW5pdGlhbCByZW5kZXIuXG4gICAqIG11c3RVc2VQcm9wZXJ0eTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIGFjY2Vzc2VkIGFuZCBtdXRhdGVkIGFzIGFuIG9iamVjdCBwcm9wZXJ0eS5cbiAgICogaGFzQm9vbGVhblZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IHNob3VsZCBiZSByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBoYXNOdW1lcmljVmFsdWU6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgbXVzdCBiZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgbnVtZXJpYyBhbmQgc2hvdWxkIGJlXG4gICAqICAgcmVtb3ZlZCB3aGVuIHNldCB0byBhIGZhbHNleSB2YWx1ZS5cbiAgICogaGFzUG9zaXRpdmVOdW1lcmljVmFsdWU6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgbXVzdCBiZSBwb3NpdGl2ZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgcG9zaXRpdmVcbiAgICogICBudW1lcmljIGFuZCBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIHNldCB0byBhIGZhbHNleSB2YWx1ZS5cbiAgICogaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBjYW4gYmUgdXNlZCBhcyBhIGZsYWcgYXMgd2VsbCBhcyB3aXRoIGEgdmFsdWUuXG4gICAqICAgUmVtb3ZlZCB3aGVuIHN0cmljdGx5IGVxdWFsIHRvIGZhbHNlOyBwcmVzZW50IHdpdGhvdXQgYSB2YWx1ZSB3aGVuXG4gICAqICAgc3RyaWN0bHkgZXF1YWwgdG8gdHJ1ZTsgcHJlc2VudCB3aXRoIGEgdmFsdWUgb3RoZXJ3aXNlLlxuICAgKi9cbiAgcHJvcGVydGllczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBsb3dlcmNhc2UgcHJvcGVydHkgbmFtZXMgdG8gdGhlIHByb3Blcmx5IGNhc2VkIHZlcnNpb24sIHVzZWRcbiAgICogdG8gd2FybiBpbiB0aGUgY2FzZSBvZiBtaXNzaW5nIHByb3BlcnRpZXMuIEF2YWlsYWJsZSBvbmx5IGluIF9fREVWX18uXG4gICAqXG4gICAqIGF1dG9mb2N1cyBpcyBwcmVkZWZpbmVkLCBiZWNhdXNlIGFkZGluZyBpdCB0byB0aGUgcHJvcGVydHkgd2hpdGVsaXN0XG4gICAqIGNhdXNlcyB1bmludGVuZGVkIHNpZGUgZWZmZWN0cy5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGdldFBvc3NpYmxlU3RhbmRhcmROYW1lOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8geyBhdXRvZm9jdXM6ICdhdXRvRm9jdXMnIH0gOiBudWxsLFxuXG4gIC8qKlxuICAgKiBBbGwgb2YgdGhlIGlzQ3VzdG9tQXR0cmlidXRlKCkgZnVuY3Rpb25zIHRoYXQgaGF2ZSBiZWVuIGluamVjdGVkLlxuICAgKi9cbiAgX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zOiBbXSxcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgYSBwcm9wZXJ0eSBuYW1lIGlzIGEgY3VzdG9tIGF0dHJpYnV0ZS5cbiAgICogQG1ldGhvZFxuICAgKi9cbiAgaXNDdXN0b21BdHRyaWJ1dGU6IGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpc0N1c3RvbUF0dHJpYnV0ZUZuID0gRE9NUHJvcGVydHkuX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zW2ldO1xuICAgICAgaWYgKGlzQ3VzdG9tQXR0cmlidXRlRm4oYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICBpbmplY3Rpb246IERPTVByb3BlcnR5SW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTVByb3BlcnR5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL0RPTVByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vY2FuRGVmaW5lUHJvcGVydHknKTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFN5bWJvbCcpO1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xuXG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24sIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKSA6IHZvaWQgMDtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpIDogdm9pZCAwO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIG5vIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3cgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTtcblxuICAgIC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cbiAgICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IHNlbGZcbiAgICAgIH0pO1xuICAgICAgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogc291cmNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICBlbGVtZW50Ll9zZWxmID0gc2VsZjtcbiAgICAgIGVsZW1lbnQuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY3JlYXRlZWxlbWVudFxuICovXG5SZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBwcm9wcyA9IHt9O1xuXG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlO1xuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkQXJyYXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BzLiQkdHlwZW9mID09PSAndW5kZWZpbmVkJyB8fCBwcm9wcy4kJHR5cGVvZiAhPT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG59O1xuXG4vKipcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgUmVhY3RFbGVtZW50cyBvZiBhIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY3JlYXRlZmFjdG9yeVxuICovXG5SZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHZhciBmYWN0b3J5ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQuYmluZChudWxsLCB0eXBlKTtcbiAgLy8gRXhwb3NlIHRoZSB0eXBlIG9uIHRoZSBmYWN0b3J5IGFuZCB0aGUgcHJvdG90eXBlIHNvIHRoYXQgaXQgY2FuIGJlXG4gIC8vIGVhc2lseSBhY2Nlc3NlZCBvbiBlbGVtZW50cy4gRS5nLiBgPEZvbyAvPi50eXBlID09PSBGb29gLlxuICAvLyBUaGlzIHNob3VsZCBub3QgYmUgbmFtZWQgYGNvbnN0cnVjdG9yYCBzaW5jZSB0aGlzIG1heSBub3QgYmUgdGhlIGZ1bmN0aW9uXG4gIC8vIHRoYXQgY3JlYXRlZCB0aGUgZWxlbWVudCwgYW5kIGl0IG1heSBub3QgZXZlbiBiZSBhIGNvbnN0cnVjdG9yLlxuICAvLyBMZWdhY3kgaG9vayBUT0RPOiBXYXJuIGlmIHRoaXMgaXMgYWNjZXNzZWRcbiAgZmFjdG9yeS50eXBlID0gdHlwZTtcbiAgcmV0dXJuIGZhY3Rvcnk7XG59O1xuXG5SZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlS2V5ID0gZnVuY3Rpb24gKG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG5ld0tleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG9sZEVsZW1lbnQucHJvcHMpO1xuXG4gIHJldHVybiBuZXdFbGVtZW50O1xufTtcblxuLyoqXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jbG9uZWVsZW1lbnRcbiAqL1xuUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG4gIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gIC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjtcbiAgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG4gIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG5cbiAgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcbiAgICBpZiAoZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgfVxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn07XG5cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5pc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBjb21wb25lbnQuXG4gKiBAZmluYWxcbiAqL1xuUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVsZW1lbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01OYW1lc3BhY2VzID0gcmVxdWlyZSgnLi9ET01OYW1lc3BhY2VzJyk7XG52YXIgc2V0SW5uZXJIVE1MID0gcmVxdWlyZSgnLi9zZXRJbm5lckhUTUwnKTtcblxudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSByZXF1aXJlKCcuL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24nKTtcbnZhciBzZXRUZXh0Q29udGVudCA9IHJlcXVpcmUoJy4vc2V0VGV4dENvbnRlbnQnKTtcblxudmFyIEVMRU1FTlRfTk9ERV9UWVBFID0gMTtcbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUgPSAxMTtcblxuLyoqXG4gKiBJbiBJRSAoOC0xMSkgYW5kIEVkZ2UsIGFwcGVuZGluZyBub2RlcyB3aXRoIG5vIGNoaWxkcmVuIGlzIGRyYW1hdGljYWxseVxuICogZmFzdGVyIHRoYW4gYXBwZW5kaW5nIGEgZnVsbCBzdWJ0cmVlLCBzbyB3ZSBlc3NlbnRpYWxseSBxdWV1ZSB1cCB0aGVcbiAqIC5hcHBlbmRDaGlsZCBjYWxscyBoZXJlIGFuZCBhcHBseSB0aGVtIHNvIGVhY2ggbm9kZSBpcyBhZGRlZCB0byBpdHMgcGFyZW50XG4gKiBiZWZvcmUgYW55IGNoaWxkcmVuIGFyZSBhZGRlZC5cbiAqXG4gKiBJbiBvdGhlciBicm93c2VycywgZG9pbmcgc28gaXMgc2xvd2VyIG9yIG5ldXRyYWwgY29tcGFyZWQgdG8gdGhlIG90aGVyIG9yZGVyXG4gKiAoaW4gRmlyZWZveCwgdHdpY2UgYXMgc2xvdykgc28gd2Ugb25seSBkbyB0aGlzIGludmVyc2lvbiBpbiBJRS5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NwaWN5ai9pbm5lcmh0bWwtdnMtY3JlYXRlZWxlbWVudC12cy1jbG9uZW5vZGUuXG4gKi9cbnZhciBlbmFibGVMYXp5ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbmF2aWdhdG9yLnVzZXJBZ2VudCA9PT0gJ3N0cmluZycgJiYgL1xcYkVkZ2VcXC9cXGQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbmZ1bmN0aW9uIGluc2VydFRyZWVDaGlsZHJlbih0cmVlKSB7XG4gIGlmICghZW5hYmxlTGF6eSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbm9kZSA9IHRyZWUubm9kZTtcbiAgdmFyIGNoaWxkcmVuID0gdHJlZS5jaGlsZHJlbjtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGluc2VydFRyZWVCZWZvcmUobm9kZSwgY2hpbGRyZW5baV0sIG51bGwpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0cmVlLmh0bWwgIT0gbnVsbCkge1xuICAgIHNldElubmVySFRNTChub2RlLCB0cmVlLmh0bWwpO1xuICB9IGVsc2UgaWYgKHRyZWUudGV4dCAhPSBudWxsKSB7XG4gICAgc2V0VGV4dENvbnRlbnQobm9kZSwgdHJlZS50ZXh0KTtcbiAgfVxufVxuXG52YXIgaW5zZXJ0VHJlZUJlZm9yZSA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKHBhcmVudE5vZGUsIHRyZWUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgLy8gRG9jdW1lbnRGcmFnbWVudHMgYXJlbid0IGFjdHVhbGx5IHBhcnQgb2YgdGhlIERPTSBhZnRlciBpbnNlcnRpb24gc29cbiAgLy8gYXBwZW5kaW5nIGNoaWxkcmVuIHdvbid0IHVwZGF0ZSB0aGUgRE9NLiBXZSBuZWVkIHRvIGVuc3VyZSB0aGUgZnJhZ21lbnRcbiAgLy8gaXMgcHJvcGVybHkgcG9wdWxhdGVkIGZpcnN0LCBicmVha2luZyBvdXQgb2Ygb3VyIGxhenkgYXBwcm9hY2ggZm9yIGp1c3RcbiAgLy8gdGhpcyBsZXZlbC4gQWxzbywgc29tZSA8b2JqZWN0PiBwbHVnaW5zIChsaWtlIEZsYXNoIFBsYXllcikgd2lsbCByZWFkXG4gIC8vIDxwYXJhbT4gbm9kZXMgaW1tZWRpYXRlbHkgdXBvbiBpbnNlcnRpb24gaW50byB0aGUgRE9NLCBzbyA8b2JqZWN0PlxuICAvLyBtdXN0IGFsc28gYmUgcG9wdWxhdGVkIHByaW9yIHRvIGluc2VydGlvbiBpbnRvIHRoZSBET00uXG4gIGlmICh0cmVlLm5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSB8fCB0cmVlLm5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFICYmIHRyZWUubm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb2JqZWN0JyAmJiAodHJlZS5ub2RlLm5hbWVzcGFjZVVSSSA9PSBudWxsIHx8IHRyZWUubm9kZS5uYW1lc3BhY2VVUkkgPT09IERPTU5hbWVzcGFjZXMuaHRtbCkpIHtcbiAgICBpbnNlcnRUcmVlQ2hpbGRyZW4odHJlZSk7XG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodHJlZS5ub2RlLCByZWZlcmVuY2VOb2RlKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZSh0cmVlLm5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICAgIGluc2VydFRyZWVDaGlsZHJlbih0cmVlKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHJlcGxhY2VDaGlsZFdpdGhUcmVlKG9sZE5vZGUsIG5ld1RyZWUpIHtcbiAgb2xkTm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdUcmVlLm5vZGUsIG9sZE5vZGUpO1xuICBpbnNlcnRUcmVlQ2hpbGRyZW4obmV3VHJlZSk7XG59XG5cbmZ1bmN0aW9uIHF1ZXVlQ2hpbGQocGFyZW50VHJlZSwgY2hpbGRUcmVlKSB7XG4gIGlmIChlbmFibGVMYXp5KSB7XG4gICAgcGFyZW50VHJlZS5jaGlsZHJlbi5wdXNoKGNoaWxkVHJlZSk7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50VHJlZS5ub2RlLmFwcGVuZENoaWxkKGNoaWxkVHJlZS5ub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBxdWV1ZUhUTUwodHJlZSwgaHRtbCkge1xuICBpZiAoZW5hYmxlTGF6eSkge1xuICAgIHRyZWUuaHRtbCA9IGh0bWw7XG4gIH0gZWxzZSB7XG4gICAgc2V0SW5uZXJIVE1MKHRyZWUubm9kZSwgaHRtbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcXVldWVUZXh0KHRyZWUsIHRleHQpIHtcbiAgaWYgKGVuYWJsZUxhenkpIHtcbiAgICB0cmVlLnRleHQgPSB0ZXh0O1xuICB9IGVsc2Uge1xuICAgIHNldFRleHRDb250ZW50KHRyZWUubm9kZSwgdGV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0aGlzLm5vZGUubm9kZU5hbWU7XG59XG5cbmZ1bmN0aW9uIERPTUxhenlUcmVlKG5vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICBub2RlOiBub2RlLFxuICAgIGNoaWxkcmVuOiBbXSxcbiAgICBodG1sOiBudWxsLFxuICAgIHRleHQ6IG51bGwsXG4gICAgdG9TdHJpbmc6IHRvU3RyaW5nXG4gIH07XG59XG5cbkRPTUxhenlUcmVlLmluc2VydFRyZWVCZWZvcmUgPSBpbnNlcnRUcmVlQmVmb3JlO1xuRE9NTGF6eVRyZWUucmVwbGFjZUNoaWxkV2l0aFRyZWUgPSByZXBsYWNlQ2hpbGRXaXRoVHJlZTtcbkRPTUxhenlUcmVlLnF1ZXVlQ2hpbGQgPSBxdWV1ZUNoaWxkO1xuRE9NTGF6eVRyZWUucXVldWVIVE1MID0gcXVldWVIVE1MO1xuRE9NTGF6eVRyZWUucXVldWVUZXh0ID0gcXVldWVUZXh0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTUxhenlUcmVlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL0RPTUxhenlUcmVlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RSZWYgPSByZXF1aXJlKCcuL1JlYWN0UmVmJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIEhlbHBlciB0byBjYWxsIFJlYWN0UmVmLmF0dGFjaFJlZnMgd2l0aCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQsIHNwbGl0IG91dFxuICogdG8gYXZvaWQgYWxsb2NhdGlvbnMgaW4gdGhlIHRyYW5zYWN0aW9uIG1vdW50LXJlYWR5IHF1ZXVlLlxuICovXG5mdW5jdGlvbiBhdHRhY2hSZWZzKCkge1xuICBSZWFjdFJlZi5hdHRhY2hSZWZzKHRoaXMsIHRoaXMuX2N1cnJlbnRFbGVtZW50KTtcbn1cblxudmFyIFJlYWN0UmVjb25jaWxlciA9IHtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbXBvbmVudCwgcmVuZGVycyBtYXJrdXAsIGFuZCByZWdpc3RlcnMgZXZlbnQgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9vYmplY3R9IHRoZSBjb250YWluaW5nIGhvc3QgY29tcG9uZW50IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gaW5mbyBhYm91dCB0aGUgaG9zdCBjb250YWluZXJcbiAgICogQHJldHVybiB7P3N0cmluZ30gUmVuZGVyZWQgbWFya3VwIHRvIGJlIGluc2VydGVkIGludG8gdGhlIERPTS5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCB0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHBhcmVudERlYnVnSUQgLy8gMCBpbiBwcm9kdWN0aW9uIGFuZCBmb3Igcm9vdHNcbiAgKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZm9yZU1vdW50Q29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQsIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LCBwYXJlbnREZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG1hcmt1cCA9IGludGVybmFsSW5zdGFuY2UubW91bnRDb21wb25lbnQodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBwYXJlbnREZWJ1Z0lEKTtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQgJiYgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQucmVmICE9IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoYXR0YWNoUmVmcywgaW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Nb3VudENvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHZhbHVlIHRoYXQgY2FuIGJlIHBhc3NlZCB0b1xuICAgKiBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cC5cbiAgICovXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIHJldHVybiBpbnRlcm5hbEluc3RhbmNlLmdldEhvc3ROb2RlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIGFueSByZXNvdXJjZXMgYWxsb2NhdGVkIGJ5IGBtb3VudENvbXBvbmVudGAuXG4gICAqXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBzYWZlbHkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVmb3JlVW5tb3VudENvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gICAgUmVhY3RSZWYuZGV0YWNoUmVmcyhpbnRlcm5hbEluc3RhbmNlLCBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCk7XG4gICAgaW50ZXJuYWxJbnN0YW5jZS51bm1vdW50Q29tcG9uZW50KHNhZmVseSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVubW91bnRDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgYSBjb21wb25lbnQgdXNpbmcgYSBuZXcgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW50ZXJuYWxJbnN0YW5jZVxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnRcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJldkVsZW1lbnQgPSBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudDtcblxuICAgIGlmIChuZXh0RWxlbWVudCA9PT0gcHJldkVsZW1lbnQgJiYgY29udGV4dCA9PT0gaW50ZXJuYWxJbnN0YW5jZS5fY29udGV4dCkge1xuICAgICAgLy8gU2luY2UgZWxlbWVudHMgYXJlIGltbXV0YWJsZSBhZnRlciB0aGUgb3duZXIgaXMgcmVuZGVyZWQsXG4gICAgICAvLyB3ZSBjYW4gZG8gYSBjaGVhcCBpZGVudGl0eSBjb21wYXJlIGhlcmUgdG8gZGV0ZXJtaW5lIGlmIHRoaXMgaXMgYVxuICAgICAgLy8gc3VwZXJmbHVvdXMgcmVjb25jaWxlLiBJdCdzIHBvc3NpYmxlIGZvciBzdGF0ZSB0byBiZSBtdXRhYmxlIGJ1dCBzdWNoXG4gICAgICAvLyBjaGFuZ2Ugc2hvdWxkIHRyaWdnZXIgYW4gdXBkYXRlIG9mIHRoZSBvd25lciB3aGljaCB3b3VsZCByZWNyZWF0ZVxuICAgICAgLy8gdGhlIGVsZW1lbnQuIFdlIGV4cGxpY2l0bHkgY2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYW4gb3duZXIgc2luY2VcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgZm9yIGFuIGVsZW1lbnQgY3JlYXRlZCBvdXRzaWRlIGEgY29tcG9zaXRlIHRvIGJlXG4gICAgICAvLyBkZWVwbHkgbXV0YXRlZCBhbmQgcmV1c2VkLlxuXG4gICAgICAvLyBUT0RPOiBCYWlsaW5nIG91dCBlYXJseSBpcyBqdXN0IGEgcGVyZiBvcHRpbWl6YXRpb24gcmlnaHQ/XG4gICAgICAvLyBUT0RPOiBSZW1vdmluZyB0aGUgcmV0dXJuIHN0YXRlbWVudCBzaG91bGQgYWZmZWN0IGNvcnJlY3RuZXNzP1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVVcGRhdGVDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCwgbmV4dEVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZWZzQ2hhbmdlZCA9IFJlYWN0UmVmLnNob3VsZFVwZGF0ZVJlZnMocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KTtcblxuICAgIGlmIChyZWZzQ2hhbmdlZCkge1xuICAgICAgUmVhY3RSZWYuZGV0YWNoUmVmcyhpbnRlcm5hbEluc3RhbmNlLCBwcmV2RWxlbWVudCk7XG4gICAgfVxuXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5yZWNlaXZlQ29tcG9uZW50KG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG5cbiAgICBpZiAocmVmc0NoYW5nZWQgJiYgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQgJiYgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQucmVmICE9IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoYXR0YWNoUmVmcywgaW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVwZGF0ZUNvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZsdXNoIGFueSBkaXJ0eSBjaGFuZ2VzIGluIGEgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCB0cmFuc2FjdGlvbiwgdXBkYXRlQmF0Y2hOdW1iZXIpIHtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fdXBkYXRlQmF0Y2hOdW1iZXIgIT09IHVwZGF0ZUJhdGNoTnVtYmVyKSB7XG4gICAgICAvLyBUaGUgY29tcG9uZW50J3MgZW5xdWV1ZWQgYmF0Y2ggbnVtYmVyIHNob3VsZCBhbHdheXMgYmUgdGhlIGN1cnJlbnRcbiAgICAgIC8vIGJhdGNoIG9yIHRoZSBmb2xsb3dpbmcgb25lLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoaW50ZXJuYWxJbnN0YW5jZS5fdXBkYXRlQmF0Y2hOdW1iZXIgPT0gbnVsbCB8fCBpbnRlcm5hbEluc3RhbmNlLl91cGRhdGVCYXRjaE51bWJlciA9PT0gdXBkYXRlQmF0Y2hOdW1iZXIgKyAxLCAncGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5OiBVbmV4cGVjdGVkIGJhdGNoIG51bWJlciAoY3VycmVudCAlcywgJyArICdwZW5kaW5nICVzKScsIHVwZGF0ZUJhdGNoTnVtYmVyLCBpbnRlcm5hbEluc3RhbmNlLl91cGRhdGVCYXRjaE51bWJlcikgOiB2b2lkIDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVVcGRhdGVDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCwgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnRlcm5hbEluc3RhbmNlLnBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSh0cmFuc2FjdGlvbik7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVwZGF0ZUNvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJlY29uY2lsZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RSZWNvbmNpbGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q2hpbGRyZW4gPSByZXF1aXJlKCcuL1JlYWN0Q2hpbGRyZW4nKTtcbnZhciBSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnQnKTtcbnZhciBSZWFjdFB1cmVDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0UHVyZUNvbXBvbmVudCcpO1xudmFyIFJlYWN0Q2xhc3MgPSByZXF1aXJlKCcuL1JlYWN0Q2xhc3MnKTtcbnZhciBSZWFjdERPTUZhY3RvcmllcyA9IHJlcXVpcmUoJy4vUmVhY3RET01GYWN0b3JpZXMnKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlcycpO1xudmFyIFJlYWN0VmVyc2lvbiA9IHJlcXVpcmUoJy4vUmVhY3RWZXJzaW9uJyk7XG5cbnZhciBvbmx5Q2hpbGQgPSByZXF1aXJlKCcuL29ubHlDaGlsZCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBjcmVhdGVFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQ7XG52YXIgY3JlYXRlRmFjdG9yeSA9IFJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5O1xudmFyIGNsb25lRWxlbWVudCA9IFJlYWN0RWxlbWVudC5jbG9uZUVsZW1lbnQ7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFZhbGlkYXRvcicpO1xuICBjcmVhdGVFbGVtZW50ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUVsZW1lbnQ7XG4gIGNyZWF0ZUZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRmFjdG9yeTtcbiAgY2xvbmVFbGVtZW50ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNsb25lRWxlbWVudDtcbn1cblxudmFyIF9fc3ByZWFkID0gX2Fzc2lnbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBfX3NwcmVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh3YXJuZWQsICdSZWFjdC5fX3NwcmVhZCBpcyBkZXByZWNhdGVkIGFuZCBzaG91bGQgbm90IGJlIHVzZWQuIFVzZSAnICsgJ09iamVjdC5hc3NpZ24gZGlyZWN0bHkgb3IgYW5vdGhlciBoZWxwZXIgZnVuY3Rpb24gd2l0aCBzaW1pbGFyICcgKyAnc2VtYW50aWNzLiBZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIHlvdXIgY29tcGlsZXIuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtc3ByZWFkLWRlcHJlY2F0aW9uIGZvciBtb3JlIGRldGFpbHMuJykgOiB2b2lkIDA7XG4gICAgd2FybmVkID0gdHJ1ZTtcbiAgICByZXR1cm4gX2Fzc2lnbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG52YXIgUmVhY3QgPSB7XG5cbiAgLy8gTW9kZXJuXG5cbiAgQ2hpbGRyZW46IHtcbiAgICBtYXA6IFJlYWN0Q2hpbGRyZW4ubWFwLFxuICAgIGZvckVhY2g6IFJlYWN0Q2hpbGRyZW4uZm9yRWFjaCxcbiAgICBjb3VudDogUmVhY3RDaGlsZHJlbi5jb3VudCxcbiAgICB0b0FycmF5OiBSZWFjdENoaWxkcmVuLnRvQXJyYXksXG4gICAgb25seTogb25seUNoaWxkXG4gIH0sXG5cbiAgQ29tcG9uZW50OiBSZWFjdENvbXBvbmVudCxcbiAgUHVyZUNvbXBvbmVudDogUmVhY3RQdXJlQ29tcG9uZW50LFxuXG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQsXG4gIGNsb25lRWxlbWVudDogY2xvbmVFbGVtZW50LFxuICBpc1ZhbGlkRWxlbWVudDogUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50LFxuXG4gIC8vIENsYXNzaWNcblxuICBQcm9wVHlwZXM6IFJlYWN0UHJvcFR5cGVzLFxuICBjcmVhdGVDbGFzczogUmVhY3RDbGFzcy5jcmVhdGVDbGFzcyxcbiAgY3JlYXRlRmFjdG9yeTogY3JlYXRlRmFjdG9yeSxcbiAgY3JlYXRlTWl4aW46IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIC8vIEN1cnJlbnRseSBhIG5vb3AuIFdpbGwgYmUgdXNlZCB0byB2YWxpZGF0ZSBhbmQgdHJhY2UgbWl4aW5zLlxuICAgIHJldHVybiBtaXhpbjtcbiAgfSxcblxuICAvLyBUaGlzIGxvb2tzIERPTSBzcGVjaWZpYyBidXQgdGhlc2UgYXJlIGFjdHVhbGx5IGlzb21vcnBoaWMgaGVscGVyc1xuICAvLyBzaW5jZSB0aGV5IGFyZSBqdXN0IGdlbmVyYXRpbmcgRE9NIHN0cmluZ3MuXG4gIERPTTogUmVhY3RET01GYWN0b3JpZXMsXG5cbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIC8vIERlcHJlY2F0ZWQgaG9vayBmb3IgSlNYIHNwcmVhZCwgZG9uJ3QgdXNlIHRoaXMgZm9yIGFueXRoaW5nLlxuICBfX3NwcmVhZDogX19zcHJlYWRcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3Q7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdC5qc1xuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luUmVnaXN0cnknKTtcbnZhciBFdmVudFBsdWdpblV0aWxzID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblV0aWxzJyk7XG52YXIgUmVhY3RFcnJvclV0aWxzID0gcmVxdWlyZSgnLi9SZWFjdEVycm9yVXRpbHMnKTtcblxudmFyIGFjY3VtdWxhdGVJbnRvID0gcmVxdWlyZSgnLi9hY2N1bXVsYXRlSW50bycpO1xudmFyIGZvckVhY2hBY2N1bXVsYXRlZCA9IHJlcXVpcmUoJy4vZm9yRWFjaEFjY3VtdWxhdGVkJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogSW50ZXJuYWwgc3RvcmUgZm9yIGV2ZW50IGxpc3RlbmVyc1xuICovXG52YXIgbGlzdGVuZXJCYW5rID0ge307XG5cbi8qKlxuICogSW50ZXJuYWwgcXVldWUgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhY2N1bXVsYXRlZCB0aGVpciBkaXNwYXRjaGVzIGFuZCBhcmVcbiAqIHdhaXRpbmcgdG8gaGF2ZSB0aGVpciBkaXNwYXRjaGVzIGV4ZWN1dGVkLlxuICovXG52YXIgZXZlbnRRdWV1ZSA9IG51bGw7XG5cbi8qKlxuICogRGlzcGF0Y2hlcyBhbiBldmVudCBhbmQgcmVsZWFzZXMgaXQgYmFjayBpbnRvIHRoZSBwb29sLCB1bmxlc3MgcGVyc2lzdGVudC5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGV2ZW50IFN5bnRoZXRpYyBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlID0gZnVuY3Rpb24gKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgaWYgKGV2ZW50KSB7XG4gICAgRXZlbnRQbHVnaW5VdGlscy5leGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIHNpbXVsYXRlZCk7XG5cbiAgICBpZiAoIWV2ZW50LmlzUGVyc2lzdGVudCgpKSB7XG4gICAgICBldmVudC5jb25zdHJ1Y3Rvci5yZWxlYXNlKGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCB0cnVlKTtcbn07XG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwgPSBmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlKGUsIGZhbHNlKTtcbn07XG5cbnZhciBnZXREaWN0aW9uYXJ5S2V5ID0gZnVuY3Rpb24gKGluc3QpIHtcbiAgLy8gUHJldmVudHMgVjggcGVyZm9ybWFuY2UgaXNzdWU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcyMzJcbiAgcmV0dXJuICcuJyArIGluc3QuX3Jvb3ROb2RlSUQ7XG59O1xuXG4vKipcbiAqIFRoaXMgaXMgYSB1bmlmaWVkIGludGVyZmFjZSBmb3IgZXZlbnQgcGx1Z2lucyB0byBiZSBpbnN0YWxsZWQgYW5kIGNvbmZpZ3VyZWQuXG4gKlxuICogRXZlbnQgcGx1Z2lucyBjYW4gaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIGBleHRyYWN0RXZlbnRzYCB7ZnVuY3Rpb24oc3RyaW5nLCBET01FdmVudFRhcmdldCwgc3RyaW5nLCBvYmplY3QpOiAqfVxuICogICAgIFJlcXVpcmVkLiBXaGVuIGEgdG9wLWxldmVsIGV2ZW50IGlzIGZpcmVkLCB0aGlzIG1ldGhvZCBpcyBleHBlY3RlZCB0b1xuICogICAgIGV4dHJhY3Qgc3ludGhldGljIGV2ZW50cyB0aGF0IHdpbGwgaW4gdHVybiBiZSBxdWV1ZWQgYW5kIGRpc3BhdGNoZWQuXG4gKlxuICogICBgZXZlbnRUeXBlc2Age29iamVjdH1cbiAqICAgICBPcHRpb25hbCwgcGx1Z2lucyB0aGF0IGZpcmUgZXZlbnRzIG11c3QgcHVibGlzaCBhIG1hcHBpbmcgb2YgcmVnaXN0cmF0aW9uXG4gKiAgICAgbmFtZXMgdGhhdCBhcmUgdXNlZCB0byByZWdpc3RlciBsaXN0ZW5lcnMuIFZhbHVlcyBvZiB0aGlzIG1hcHBpbmcgbXVzdFxuICogICAgIGJlIG9iamVjdHMgdGhhdCBjb250YWluIGByZWdpc3RyYXRpb25OYW1lYCBvciBgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNgLlxuICpcbiAqICAgYGV4ZWN1dGVEaXNwYXRjaGAge2Z1bmN0aW9uKG9iamVjdCwgZnVuY3Rpb24sIHN0cmluZyl9XG4gKiAgICAgT3B0aW9uYWwsIGFsbG93cyBwbHVnaW5zIHRvIG92ZXJyaWRlIGhvdyBhbiBldmVudCBnZXRzIGRpc3BhdGNoZWQuIEJ5XG4gKiAgICAgZGVmYXVsdCwgdGhlIGxpc3RlbmVyIGlzIHNpbXBseSBpbnZva2VkLlxuICpcbiAqIEVhY2ggcGx1Z2luIHRoYXQgaXMgaW5qZWN0ZWQgaW50byBgRXZlbnRzUGx1Z2luSHViYCBpcyBpbW1lZGlhdGVseSBvcGVyYWJsZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBFdmVudFBsdWdpbkh1YiA9IHtcblxuICAvKipcbiAgICogTWV0aG9kcyBmb3IgaW5qZWN0aW5nIGRlcGVuZGVuY2llcy5cbiAgICovXG4gIGluamVjdGlvbjoge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHthcnJheX0gSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IEV2ZW50UGx1Z2luUmVnaXN0cnkuaW5qZWN0RXZlbnRQbHVnaW5PcmRlcixcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICAgICAqL1xuICAgIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogRXZlbnRQbHVnaW5SZWdpc3RyeS5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWVcblxuICB9LFxuXG4gIC8qKlxuICAgKiBTdG9yZXMgYGxpc3RlbmVyYCBhdCBgbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2tleV1gLiBJcyBpZGVtcG90ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIFRoZSBjYWxsYmFjayB0byBzdG9yZS5cbiAgICovXG4gIHB1dExpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICAhKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgJXMgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgdHlwZSAlcycsIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBsaXN0ZW5lcikgOiBfcHJvZEludmFyaWFudCgnOTQnLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIpIDogdm9pZCAwO1xuXG4gICAgdmFyIGtleSA9IGdldERpY3Rpb25hcnlLZXkoaW5zdCk7XG4gICAgdmFyIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lID0gbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdIHx8IChsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV0gPSB7fSk7XG4gICAgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVba2V5XSA9IGxpc3RlbmVyO1xuXG4gICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgaWYgKFBsdWdpbk1vZHVsZSAmJiBQbHVnaW5Nb2R1bGUuZGlkUHV0TGlzdGVuZXIpIHtcbiAgICAgIFBsdWdpbk1vZHVsZS5kaWRQdXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn0gVGhlIHN0b3JlZCBjYWxsYmFjay5cbiAgICovXG4gIGdldExpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9IGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcbiAgICByZXR1cm4gYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgJiYgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVba2V5XTtcbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhIGxpc3RlbmVyIGZyb20gdGhlIHJlZ2lzdHJhdGlvbiBiYW5rLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqL1xuICBkZWxldGVMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICBpZiAoUGx1Z2luTW9kdWxlICYmIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIpIHtcbiAgICAgIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lID0gbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIG5ldmVyIGJlIG51bGwgLS0gd2hlbiBpcyBpdD9cbiAgICBpZiAoYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xuICAgICAgZGVsZXRlIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lW2tleV07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBET00gZWxlbWVudCB3aXRoIHRoZSBzdXBwbGllZCBJRC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAgICovXG4gIGRlbGV0ZUFsbExpc3RlbmVyczogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcbiAgICBmb3IgKHZhciByZWdpc3RyYXRpb25OYW1lIGluIGxpc3RlbmVyQmFuaykge1xuICAgICAgaWYgKCFsaXN0ZW5lckJhbmsuaGFzT3duUHJvcGVydHkocmVnaXN0cmF0aW9uTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2tleV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgICAgaWYgKFBsdWdpbk1vZHVsZSAmJiBQbHVnaW5Nb2R1bGUud2lsbERlbGV0ZUxpc3RlbmVyKSB7XG4gICAgICAgIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV1ba2V5XTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFsbG93cyByZWdpc3RlcmVkIHBsdWdpbnMgYW4gb3Bwb3J0dW5pdHkgdG8gZXh0cmFjdCBldmVudHMgZnJvbSB0b3AtbGV2ZWxcbiAgICogbmF0aXZlIGJyb3dzZXIgZXZlbnRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgZXZlbnRzO1xuICAgIHZhciBwbHVnaW5zID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gTm90IGV2ZXJ5IHBsdWdpbiBpbiB0aGUgb3JkZXJpbmcgbWF5IGJlIGxvYWRlZCBhdCBydW50aW1lLlxuICAgICAgdmFyIHBvc3NpYmxlUGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICAgIGlmIChwb3NzaWJsZVBsdWdpbikge1xuICAgICAgICB2YXIgZXh0cmFjdGVkRXZlbnRzID0gcG9zc2libGVQbHVnaW4uZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAgIGlmIChleHRyYWN0ZWRFdmVudHMpIHtcbiAgICAgICAgICBldmVudHMgPSBhY2N1bXVsYXRlSW50byhldmVudHMsIGV4dHJhY3RlZEV2ZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50cztcbiAgfSxcblxuICAvKipcbiAgICogRW5xdWV1ZXMgYSBzeW50aGV0aWMgZXZlbnQgdGhhdCBzaG91bGQgYmUgZGlzcGF0Y2hlZCB3aGVuXG4gICAqIGBwcm9jZXNzRXZlbnRRdWV1ZWAgaXMgaW52b2tlZC5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBldmVudHMgQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUV2ZW50czogZnVuY3Rpb24gKGV2ZW50cykge1xuICAgIGlmIChldmVudHMpIHtcbiAgICAgIGV2ZW50UXVldWUgPSBhY2N1bXVsYXRlSW50byhldmVudFF1ZXVlLCBldmVudHMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbGwgc3ludGhldGljIGV2ZW50cyBvbiB0aGUgZXZlbnQgcXVldWUuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvY2Vzc0V2ZW50UXVldWU6IGZ1bmN0aW9uIChzaW11bGF0ZWQpIHtcbiAgICAvLyBTZXQgYGV2ZW50UXVldWVgIHRvIG51bGwgYmVmb3JlIHByb2Nlc3NpbmcgaXQgc28gdGhhdCB3ZSBjYW4gdGVsbCBpZiBtb3JlXG4gICAgLy8gZXZlbnRzIGdldCBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nLlxuICAgIHZhciBwcm9jZXNzaW5nRXZlbnRRdWV1ZSA9IGV2ZW50UXVldWU7XG4gICAgZXZlbnRRdWV1ZSA9IG51bGw7XG4gICAgaWYgKHNpbXVsYXRlZCkge1xuICAgICAgZm9yRWFjaEFjY3VtdWxhdGVkKHByb2Nlc3NpbmdFdmVudFF1ZXVlLCBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsKTtcbiAgICB9XG4gICAgISFldmVudFF1ZXVlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3Byb2Nlc3NFdmVudFF1ZXVlKCk6IEFkZGl0aW9uYWwgZXZlbnRzIHdlcmUgZW5xdWV1ZWQgd2hpbGUgcHJvY2Vzc2luZyBhbiBldmVudCBxdWV1ZS4gU3VwcG9ydCBmb3IgdGhpcyBoYXMgbm90IHlldCBiZWVuIGltcGxlbWVudGVkLicpIDogX3Byb2RJbnZhcmlhbnQoJzk1JykgOiB2b2lkIDA7XG4gICAgLy8gVGhpcyB3b3VsZCBiZSBhIGdvb2QgdGltZSB0byByZXRocm93IGlmIGFueSBvZiB0aGUgZXZlbnQgaGFuZGxlcnMgdGhyZXcuXG4gICAgUmVhY3RFcnJvclV0aWxzLnJldGhyb3dDYXVnaHRFcnJvcigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGVzZSBhcmUgbmVlZGVkIGZvciB0ZXN0cyBvbmx5LiBEbyBub3QgdXNlIVxuICAgKi9cbiAgX19wdXJnZTogZnVuY3Rpb24gKCkge1xuICAgIGxpc3RlbmVyQmFuayA9IHt9O1xuICB9LFxuXG4gIF9fZ2V0TGlzdGVuZXJCYW5rOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQmFuaztcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luSHViO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL0V2ZW50UGx1Z2luSHViLmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XG52YXIgRXZlbnRQbHVnaW5VdGlscyA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5VdGlscycpO1xuXG52YXIgYWNjdW11bGF0ZUludG8gPSByZXF1aXJlKCcuL2FjY3VtdWxhdGVJbnRvJyk7XG52YXIgZm9yRWFjaEFjY3VtdWxhdGVkID0gcmVxdWlyZSgnLi9mb3JFYWNoQWNjdW11bGF0ZWQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgZ2V0TGlzdGVuZXIgPSBFdmVudFBsdWdpbkh1Yi5nZXRMaXN0ZW5lcjtcblxuLyoqXG4gKiBTb21lIGV2ZW50IHR5cGVzIGhhdmUgYSBub3Rpb24gb2YgZGlmZmVyZW50IHJlZ2lzdHJhdGlvbiBuYW1lcyBmb3IgZGlmZmVyZW50XG4gKiBcInBoYXNlc1wiIG9mIHByb3BhZ2F0aW9uLiBUaGlzIGZpbmRzIGxpc3RlbmVycyBieSBhIGdpdmVuIHBoYXNlLlxuICovXG5mdW5jdGlvbiBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHByb3BhZ2F0aW9uUGhhc2UpIHtcbiAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1twcm9wYWdhdGlvblBoYXNlXTtcbiAgcmV0dXJuIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xufVxuXG4vKipcbiAqIFRhZ3MgYSBgU3ludGhldGljRXZlbnRgIHdpdGggZGlzcGF0Y2hlZCBsaXN0ZW5lcnMuIENyZWF0aW5nIHRoaXMgZnVuY3Rpb25cbiAqIGhlcmUsIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBiaW5kIG9yIGNyZWF0ZSBmdW5jdGlvbnMgZm9yIGVhY2ggZXZlbnQuXG4gKiBNdXRhdGluZyB0aGUgZXZlbnQncyBtZW1iZXJzIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBjcmVhdGUgYSB3cmFwcGluZ1xuICogXCJkaXNwYXRjaFwiIG9iamVjdCB0aGF0IHBhaXJzIHRoZSBldmVudCB3aXRoIHRoZSBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyhpbnN0LCBwaGFzZSwgZXZlbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpbnN0LCAnRGlzcGF0Y2hpbmcgaW5zdCBtdXN0IG5vdCBiZSBudWxsJykgOiB2b2lkIDA7XG4gIH1cbiAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJBdFBoYXNlKGluc3QsIGV2ZW50LCBwaGFzZSk7XG4gIGlmIChsaXN0ZW5lcikge1xuICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycywgbGlzdGVuZXIpO1xuICAgIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcywgaW5zdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRpc3BhdGNoZXMgKG11c3QgYmUgZW50aXJlbHkgY29sbGVjdGVkIGJlZm9yZSBkaXNwYXRjaGluZyAtIHNlZSB1bml0XG4gKiB0ZXN0cykuIExhemlseSBhbGxvY2F0ZSB0aGUgYXJyYXkgdG8gY29uc2VydmUgbWVtb3J5LiAgV2UgbXVzdCBsb29wIHRocm91Z2hcbiAqIGVhY2ggZXZlbnQgYW5kIHBlcmZvcm0gdGhlIHRyYXZlcnNhbCBmb3IgZWFjaCBvbmUuIFdlIGNhbm5vdCBwZXJmb3JtIGFcbiAqIHNpbmdsZSB0cmF2ZXJzYWwgZm9yIHRoZSBlbnRpcmUgY29sbGVjdGlvbiBvZiBldmVudHMgYmVjYXVzZSBlYWNoIGV2ZW50IG1heVxuICogaGF2ZSBhIGRpZmZlcmVudCB0YXJnZXQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgRXZlbnRQbHVnaW5VdGlscy50cmF2ZXJzZVR3b1BoYXNlKGV2ZW50Ll90YXJnZXRJbnN0LCBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLCBldmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTYW1lIGFzIGBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlYCwgYnV0IHNraXBzIG92ZXIgdGhlIHRhcmdldElELlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldChldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICB2YXIgdGFyZ2V0SW5zdCA9IGV2ZW50Ll90YXJnZXRJbnN0O1xuICAgIHZhciBwYXJlbnRJbnN0ID0gdGFyZ2V0SW5zdCA/IEV2ZW50UGx1Z2luVXRpbHMuZ2V0UGFyZW50SW5zdGFuY2UodGFyZ2V0SW5zdCkgOiBudWxsO1xuICAgIEV2ZW50UGx1Z2luVXRpbHMudHJhdmVyc2VUd29QaGFzZShwYXJlbnRJbnN0LCBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLCBldmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyB3aXRob3V0IHJlZ2FyZCB0byBkaXJlY3Rpb24sIGRvZXMgbm90IGxvb2sgZm9yIHBoYXNlZFxuICogcmVnaXN0cmF0aW9uIG5hbWVzLiBTYW1lIGFzIGBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZWAgYnV0IHdpdGhvdXRcbiAqIHJlcXVpcmluZyB0aGF0IHRoZSBgZGlzcGF0Y2hNYXJrZXJgIGJlIHRoZSBzYW1lIGFzIHRoZSBkaXNwYXRjaGVkIElELlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhpbnN0LCBpZ25vcmVkRGlyZWN0aW9uLCBldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZTtcbiAgICB2YXIgbGlzdGVuZXIgPSBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycywgbGlzdGVuZXIpO1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzLCBpbnN0KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyBkaXNwYXRjaGVzIG9uIGFuIGBTeW50aGV0aWNFdmVudGAsIGJ1dCBvbmx5IGZvciB0aGVcbiAqIGBkaXNwYXRjaE1hcmtlcmAuXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudFxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGV2ZW50Ll90YXJnZXRJbnN0LCBudWxsLCBldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0KGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldCk7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyhsZWF2ZSwgZW50ZXIsIGZyb20sIHRvKSB7XG4gIEV2ZW50UGx1Z2luVXRpbHMudHJhdmVyc2VFbnRlckxlYXZlKGZyb20sIHRvLCBhY2N1bXVsYXRlRGlzcGF0Y2hlcywgbGVhdmUsIGVudGVyKTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxuLyoqXG4gKiBBIHNtYWxsIHNldCBvZiBwcm9wYWdhdGlvbiBwYXR0ZXJucywgZWFjaCBvZiB3aGljaCB3aWxsIGFjY2VwdCBhIHNtYWxsIGFtb3VudFxuICogb2YgaW5mb3JtYXRpb24sIGFuZCBnZW5lcmF0ZSBhIHNldCBvZiBcImRpc3BhdGNoIHJlYWR5IGV2ZW50IG9iamVjdHNcIiAtIHdoaWNoXG4gKiBhcmUgc2V0cyBvZiBldmVudHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBhbm5vdGF0ZWQgd2l0aCBhIHNldCBvZiBkaXNwYXRjaGVkXG4gKiBsaXN0ZW5lciBmdW5jdGlvbnMvaWRzLiBUaGUgQVBJIGlzIGRlc2lnbmVkIHRoaXMgd2F5IHRvIGRpc2NvdXJhZ2UgdGhlc2VcbiAqIHByb3BhZ2F0aW9uIHN0cmF0ZWdpZXMgZnJvbSBhY3R1YWxseSBleGVjdXRpbmcgdGhlIGRpc3BhdGNoZXMsIHNpbmNlIHdlXG4gKiBhbHdheXMgd2FudCB0byBjb2xsZWN0IHRoZSBlbnRpcmUgc2V0IG9mIGRpc3BhdGNoZXMgYmVmb3JlIGV4ZWN1dGluZyBldmVudCBhXG4gKiBzaW5nbGUgb25lLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBFdmVudFByb3BhZ2F0b3JzXG4gKi9cbnZhciBFdmVudFByb3BhZ2F0b3JzID0ge1xuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzOiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzLFxuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldDogYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQsXG4gIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzOiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyxcbiAgYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzOiBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQcm9wYWdhdG9ycztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9FdmVudFByb3BhZ2F0b3JzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICovXG5cbi8vIFRPRE86IFJlcGxhY2UgdGhpcyB3aXRoIEVTNjogdmFyIFJlYWN0SW5zdGFuY2VNYXAgPSBuZXcgTWFwKCk7XG5cbnZhciBSZWFjdEluc3RhbmNlTWFwID0ge1xuXG4gIC8qKlxuICAgKiBUaGlzIEFQSSBzaG91bGQgYmUgY2FsbGVkIGBkZWxldGVgIGJ1dCB3ZSdkIGhhdmUgdG8gbWFrZSBzdXJlIHRvIGFsd2F5c1xuICAgKiB0cmFuc2Zvcm0gdGhlc2UgdG8gc3RyaW5ncyBmb3IgSUUgc3VwcG9ydC4gV2hlbiB0aGlzIHRyYW5zZm9ybSBpcyBmdWxseVxuICAgKiBzdXBwb3J0ZWQgd2UgY2FuIHJlbmFtZSBpdC5cbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKGtleSkge1xuICAgIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB9LFxuXG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZTtcbiAgfSxcblxuICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgIT09IHVuZGVmaW5lZDtcbiAgfSxcblxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgPSB2YWx1ZTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5zdGFuY2VNYXA7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RJbnN0YW5jZU1hcC5qc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG52YXIgZ2V0RXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2dldEV2ZW50VGFyZ2V0Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBVSUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFVJRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHZpZXc6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC52aWV3KSB7XG4gICAgICByZXR1cm4gZXZlbnQudmlldztcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpO1xuICAgIGlmICh0YXJnZXQud2luZG93ID09PSB0YXJnZXQpIHtcbiAgICAgIC8vIHRhcmdldCBpcyBhIHdpbmRvdyBvYmplY3RcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgdmFyIGRvYyA9IHRhcmdldC5vd25lckRvY3VtZW50O1xuICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IGBvd25lckRvY3VtZW50YCBpcyBzb21ldGltZXMgdW5kZWZpbmVkIGluIElFOC5cbiAgICBpZiAoZG9jKSB7XG4gICAgICByZXR1cm4gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfVxuICB9LFxuICBkZXRhaWw6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC5kZXRhaWwgfHwgMDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1VJRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljVUlFdmVudCwgVUlFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljVUlFdmVudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNVSUV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBJbmplY3RhYmxlIG9yZGVyaW5nIG9mIGV2ZW50IHBsdWdpbnMuXG4gKi9cbnZhciBldmVudFBsdWdpbk9yZGVyID0gbnVsbDtcblxuLyoqXG4gKiBJbmplY3RhYmxlIG1hcHBpbmcgZnJvbSBuYW1lcyB0byBldmVudCBwbHVnaW4gbW9kdWxlcy5cbiAqL1xudmFyIG5hbWVzVG9QbHVnaW5zID0ge307XG5cbi8qKlxuICogUmVjb21wdXRlcyB0aGUgcGx1Z2luIGxpc3QgdXNpbmcgdGhlIGluamVjdGVkIHBsdWdpbnMgYW5kIHBsdWdpbiBvcmRlcmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpIHtcbiAgaWYgKCFldmVudFBsdWdpbk9yZGVyKSB7XG4gICAgLy8gV2FpdCB1bnRpbCBhbiBgZXZlbnRQbHVnaW5PcmRlcmAgaXMgaW5qZWN0ZWQuXG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gbmFtZXNUb1BsdWdpbnMpIHtcbiAgICB2YXIgcGx1Z2luTW9kdWxlID0gbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgdmFyIHBsdWdpbkluZGV4ID0gZXZlbnRQbHVnaW5PcmRlci5pbmRleE9mKHBsdWdpbk5hbWUpO1xuICAgICEocGx1Z2luSW5kZXggPiAtMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW5zIHRoYXQgZG8gbm90IGV4aXN0IGluIHRoZSBwbHVnaW4gb3JkZXJpbmcsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiBfcHJvZEludmFyaWFudCgnOTYnLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICBpZiAoRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zW3BsdWdpbkluZGV4XSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgICFwbHVnaW5Nb2R1bGUuZXh0cmFjdEV2ZW50cyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBFdmVudCBwbHVnaW5zIG11c3QgaW1wbGVtZW50IGFuIGBleHRyYWN0RXZlbnRzYCBtZXRob2QsIGJ1dCBgJXNgIGRvZXMgbm90LicsIHBsdWdpbk5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzk3JywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zW3BsdWdpbkluZGV4XSA9IHBsdWdpbk1vZHVsZTtcbiAgICB2YXIgcHVibGlzaGVkRXZlbnRzID0gcGx1Z2luTW9kdWxlLmV2ZW50VHlwZXM7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHB1Ymxpc2hlZEV2ZW50cykge1xuICAgICAgIXB1Ymxpc2hFdmVudEZvclBsdWdpbihwdWJsaXNoZWRFdmVudHNbZXZlbnROYW1lXSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEZhaWxlZCB0byBwdWJsaXNoIGV2ZW50IGAlc2AgZm9yIHBsdWdpbiBgJXNgLicsIGV2ZW50TmFtZSwgcGx1Z2luTmFtZSkgOiBfcHJvZEludmFyaWFudCgnOTgnLCBldmVudE5hbWUsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhbiBldmVudCBzbyB0aGF0IGl0IGNhbiBiZSBkaXNwYXRjaGVkIGJ5IHRoZSBzdXBwbGllZCBwbHVnaW4uXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIERpc3BhdGNoIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgd2FzIHN1Y2Nlc3NmdWxseSBwdWJsaXNoZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoRXZlbnRGb3JQbHVnaW4oZGlzcGF0Y2hDb25maWcsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gICEhRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgZXZlbnQgbmFtZSwgYCVzYC4nLCBldmVudE5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzk5JywgZXZlbnROYW1lKSA6IHZvaWQgMDtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3NbZXZlbnROYW1lXSA9IGRpc3BhdGNoQ29uZmlnO1xuXG4gIHZhciBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcyA9IGRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzO1xuICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBmb3IgKHZhciBwaGFzZU5hbWUgaW4gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShwaGFzZU5hbWUpKSB7XG4gICAgICAgIHZhciBwaGFzZWRSZWdpc3RyYXRpb25OYW1lID0gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcGhhc2VOYW1lXTtcbiAgICAgICAgcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocGhhc2VkUmVnaXN0cmF0aW9uTmFtZSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBQdWJsaXNoZXMgYSByZWdpc3RyYXRpb24gbmFtZSB0aGF0IGlzIHVzZWQgdG8gaWRlbnRpZnkgZGlzcGF0Y2hlZCBldmVudHMgYW5kXG4gKiBjYW4gYmUgdXNlZCB3aXRoIGBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcmAgdG8gcmVnaXN0ZXIgbGlzdGVuZXJzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIFJlZ2lzdHJhdGlvbiBuYW1lIHRvIGFkZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocmVnaXN0cmF0aW9uTmFtZSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSByZWdpc3RyYXRpb24gbmFtZSwgYCVzYC4nLCByZWdpc3RyYXRpb25OYW1lKSA6IF9wcm9kSW52YXJpYW50KCcxMDAnLCByZWdpc3RyYXRpb25OYW1lKSA6IHZvaWQgMDtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSA9IHBsdWdpbk1vZHVsZTtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gcGx1Z2luTW9kdWxlLmV2ZW50VHlwZXNbZXZlbnROYW1lXS5kZXBlbmRlbmNpZXM7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSByZWdpc3RyYXRpb25OYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA9IHJlZ2lzdHJhdGlvbk5hbWU7XG5cbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gJ29uRG91YmxlQ2xpY2snKSB7XG4gICAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMub25kYmxjbGljayA9IHJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIHBsdWdpbnMgc28gdGhhdCB0aGV5IGNhbiBleHRyYWN0IGFuZCBkaXNwYXRjaCBldmVudHMuXG4gKlxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWJ9XG4gKi9cbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0ge1xuXG4gIC8qKlxuICAgKiBPcmRlcmVkIGxpc3Qgb2YgaW5qZWN0ZWQgcGx1Z2lucy5cbiAgICovXG4gIHBsdWdpbnM6IFtdLFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gZXZlbnQgbmFtZSB0byBkaXNwYXRjaCBjb25maWdcbiAgICovXG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBwbHVnaW4gbW9kdWxlXG4gICAqL1xuICByZWdpc3RyYXRpb25OYW1lTW9kdWxlczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBldmVudCBuYW1lXG4gICAqL1xuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSByZWdpc3RyYXRpb24gbmFtZXMgdG8gdGhlIHByb3Blcmx5IGNhc2VkIHZlcnNpb24sXG4gICAqIHVzZWQgdG8gd2FybiBpbiB0aGUgY2FzZSBvZiBtaXNzaW5nIGV2ZW50IGhhbmRsZXJzLiBBdmFpbGFibGVcbiAgICogb25seSBpbiBfX0RFVl9fLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHt9IDogbnVsbCxcbiAgLy8gVHJ1c3QgdGhlIGRldmVsb3BlciB0byBvbmx5IHVzZSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzIGluIF9fREVWX19cblxuICAvKipcbiAgICogSW5qZWN0cyBhbiBvcmRlcmluZyBvZiBwbHVnaW5zIChieSBwbHVnaW4gbmFtZSkuIFRoaXMgYWxsb3dzIHRoZSBvcmRlcmluZ1xuICAgKiB0byBiZSBkZWNvdXBsZWQgZnJvbSBpbmplY3Rpb24gb2YgdGhlIGFjdHVhbCBwbHVnaW5zIHNvIHRoYXQgb3JkZXJpbmcgaXNcbiAgICogYWx3YXlzIGRldGVybWluaXN0aWMgcmVnYXJkbGVzcyBvZiBwYWNrYWdpbmcsIG9uLXRoZS1mbHkgaW5qZWN0aW9uLCBldGMuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICAgKiBAaW50ZXJuYWxcbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXJ9XG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBmdW5jdGlvbiAoaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKSB7XG4gICAgISFldmVudFBsdWdpbk9yZGVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2luIG9yZGVyaW5nIG1vcmUgdGhhbiBvbmNlLiBZb3UgYXJlIGxpa2VseSB0cnlpbmcgdG8gbG9hZCBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QuJykgOiBfcHJvZEludmFyaWFudCgnMTAxJykgOiB2b2lkIDA7XG4gICAgLy8gQ2xvbmUgdGhlIG9yZGVyaW5nIHNvIGl0IGNhbm5vdCBiZSBkeW5hbWljYWxseSBtdXRhdGVkLlxuICAgIGV2ZW50UGx1Z2luT3JkZXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChpbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpO1xuICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluamVjdHMgcGx1Z2lucyB0byBiZSB1c2VkIGJ5IGBFdmVudFBsdWdpbkh1YmAuIFRoZSBwbHVnaW4gbmFtZXMgbXVzdCBiZVxuICAgKiBpbiB0aGUgb3JkZXJpbmcgaW5qZWN0ZWQgYnkgYGluamVjdEV2ZW50UGx1Z2luT3JkZXJgLlxuICAgKlxuICAgKiBQbHVnaW5zIGNhbiBiZSBpbmplY3RlZCBhcyBwYXJ0IG9mIHBhZ2UgaW5pdGlhbGl6YXRpb24gb3Igb24tdGhlLWZseS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lfVxuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBmdW5jdGlvbiAoaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBpc09yZGVyaW5nRGlydHkgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIGluamVjdGVkTmFtZXNUb1BsdWdpbnMpIHtcbiAgICAgIGlmICghaW5qZWN0ZWROYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgICAgaWYgKCFuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSB8fCBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSAhPT0gcGx1Z2luTW9kdWxlKSB7XG4gICAgICAgICEhbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCB0d28gZGlmZmVyZW50IGV2ZW50IHBsdWdpbnMgdXNpbmcgdGhlIHNhbWUgbmFtZSwgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IF9wcm9kSW52YXJpYW50KCcxMDInLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPSBwbHVnaW5Nb2R1bGU7XG4gICAgICAgIGlzT3JkZXJpbmdEaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc09yZGVyaW5nRGlydHkpIHtcbiAgICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMb29rcyB1cCB0aGUgcGx1Z2luIGZvciB0aGUgc3VwcGxpZWQgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBBIHN5bnRoZXRpYyBldmVudC5cbiAgICogQHJldHVybiB7P29iamVjdH0gVGhlIHBsdWdpbiB0aGF0IGNyZWF0ZWQgdGhlIHN1cHBsaWVkIGV2ZW50LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldFBsdWdpbk1vZHVsZUZvckV2ZW50OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hDb25maWcgPSBldmVudC5kaXNwYXRjaENvbmZpZztcbiAgICBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgICAgcmV0dXJuIEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZV0gfHwgbnVsbDtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHB1bGxpbmcgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMgb3V0IG9mIGRpc3BhdGNoQ29uZmlnIGhlbHBzIEZsb3cgc2VlXG4gICAgICAvLyB0aGF0IGl0IGlzIG5vdCB1bmRlZmluZWQuXG4gICAgICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMgPSBkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcztcblxuICAgICAgZm9yICh2YXIgcGhhc2UgaW4gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgICAgaWYgKCFwaGFzZWRSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShwaGFzZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1twaGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZV1dO1xuICAgICAgICBpZiAocGx1Z2luTW9kdWxlKSB7XG4gICAgICAgICAgcmV0dXJuIHBsdWdpbk1vZHVsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgdW5pdCB0ZXN0aW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc2V0RXZlbnRQbHVnaW5zOiBmdW5jdGlvbiAoKSB7XG4gICAgZXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XG4gICAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgICAgaWYgKG5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zLmxlbmd0aCA9IDA7XG5cbiAgICB2YXIgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncykge1xuICAgICAgaWYgKGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3NbZXZlbnROYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzO1xuICAgIGZvciAodmFyIHJlZ2lzdHJhdGlvbk5hbWUgaW4gcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMpIHtcbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShyZWdpc3RyYXRpb25OYW1lKSkge1xuICAgICAgICBkZWxldGUgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzO1xuICAgICAgZm9yICh2YXIgbG93ZXJDYXNlZE5hbWUgaW4gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgICBpZiAocG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgICAgICBkZWxldGUgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL0V2ZW50UGx1Z2luUmVnaXN0cnkuanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5SZWdpc3RyeScpO1xudmFyIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW4gPSByZXF1aXJlKCcuL1JlYWN0RXZlbnRFbWl0dGVyTWl4aW4nKTtcbnZhciBWaWV3cG9ydE1ldHJpY3MgPSByZXF1aXJlKCcuL1ZpZXdwb3J0TWV0cmljcycpO1xuXG52YXIgZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUgPSByZXF1aXJlKCcuL2dldFZlbmRvclByZWZpeGVkRXZlbnROYW1lJyk7XG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vaXNFdmVudFN1cHBvcnRlZCcpO1xuXG4vKipcbiAqIFN1bW1hcnkgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgZXZlbnQgaGFuZGxpbmc6XG4gKlxuICogIC0gVG9wLWxldmVsIGRlbGVnYXRpb24gaXMgdXNlZCB0byB0cmFwIG1vc3QgbmF0aXZlIGJyb3dzZXIgZXZlbnRzLiBUaGlzXG4gKiAgICBtYXkgb25seSBvY2N1ciBpbiB0aGUgbWFpbiB0aHJlYWQgYW5kIGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZlxuICogICAgUmVhY3RFdmVudExpc3RlbmVyLCB3aGljaCBpcyBpbmplY3RlZCBhbmQgY2FuIHRoZXJlZm9yZSBzdXBwb3J0IHBsdWdnYWJsZVxuICogICAgZXZlbnQgc291cmNlcy4gVGhpcyBpcyB0aGUgb25seSB3b3JrIHRoYXQgb2NjdXJzIGluIHRoZSBtYWluIHRocmVhZC5cbiAqXG4gKiAgLSBXZSBub3JtYWxpemUgYW5kIGRlLWR1cGxpY2F0ZSBldmVudHMgdG8gYWNjb3VudCBmb3IgYnJvd3NlciBxdWlya3MuIFRoaXNcbiAqICAgIG1heSBiZSBkb25lIGluIHRoZSB3b3JrZXIgdGhyZWFkLlxuICpcbiAqICAtIEZvcndhcmQgdGhlc2UgbmF0aXZlIGV2ZW50cyAod2l0aCB0aGUgYXNzb2NpYXRlZCB0b3AtbGV2ZWwgdHlwZSB1c2VkIHRvXG4gKiAgICB0cmFwIGl0KSB0byBgRXZlbnRQbHVnaW5IdWJgLCB3aGljaCBpbiB0dXJuIHdpbGwgYXNrIHBsdWdpbnMgaWYgdGhleSB3YW50XG4gKiAgICB0byBleHRyYWN0IGFueSBzeW50aGV0aWMgZXZlbnRzLlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHdpbGwgdGhlbiBwcm9jZXNzIGVhY2ggZXZlbnQgYnkgYW5ub3RhdGluZyB0aGVtIHdpdGhcbiAqICAgIFwiZGlzcGF0Y2hlc1wiLCBhIHNlcXVlbmNlIG9mIGxpc3RlbmVycyBhbmQgSURzIHRoYXQgY2FyZSBhYm91dCB0aGF0IGV2ZW50LlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHRoZW4gZGlzcGF0Y2hlcyB0aGUgZXZlbnRzLlxuICpcbiAqIE92ZXJ2aWV3IG9mIFJlYWN0IGFuZCB0aGUgZXZlbnQgc3lzdGVtOlxuICpcbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgICAgRE9NICAgICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqICAgICAgIHwgICAgICAgICAgIC5cbiAqICAgICAgIHYgICAgICAgICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgUmVhY3RFdmVudCB8ICAgIC5cbiAqIHwgIExpc3RlbmVyICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICstLS0tLS0tLSt8U2ltcGxlRXZlbnR8XG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgfCAgICAgICAgIHxQbHVnaW4gICAgIHxcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICB2ICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58RXZlbnRQbHVnaW5IdWJ8ICAgICAgICAgICAgICAgICAgICB8ICAgIEV2ZW50ICAgfFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8IFByb3BhZ2F0b3JzfFxuICogfCBSZWFjdEV2ZW50IHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICB8VGFwRXZlbnQgICB8ICB8LS0tLS0tLS0tLS0tfFxuICogfCAgRW1pdHRlciAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8PC0tLSt8UGx1Z2luICAgICB8ICB8b3RoZXIgcGx1Z2lufFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8ICB1dGlsaXRpZXMgfFxuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rXG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgIF4gICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICAgfCAgICAgICAgfEVudGVyL0xlYXZlfFxuICogICAgICAgKyAgICAgICAgICAgLiAgICAgICAgICAgICAgICArLS0tLS0tLSt8UGx1Z2luICAgICB8XG4gKiArLS0tLS0tLS0tLS0tLSsgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgYXBwbGljYXRpb24gfCAgIC5cbiAqIHwtLS0tLS0tLS0tLS0tfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqICstLS0tLS0tLS0tLS0tKyAgIC5cbiAqICAgICAgICAgICAgICAgICAgIC5cbiAqICAgIFJlYWN0IENvcmUgICAgIC4gIEdlbmVyYWwgUHVycG9zZSBFdmVudCBQbHVnaW4gU3lzdGVtXG4gKi9cblxudmFyIGhhc0V2ZW50UGFnZVhZO1xudmFyIGFscmVhZHlMaXN0ZW5pbmdUbyA9IHt9O1xudmFyIGlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlID0gZmFsc2U7XG52YXIgcmVhY3RUb3BMaXN0ZW5lcnNDb3VudGVyID0gMDtcblxuLy8gRm9yIGV2ZW50cyBsaWtlICdzdWJtaXQnIHdoaWNoIGRvbid0IGNvbnNpc3RlbnRseSBidWJibGUgKHdoaWNoIHdlIHRyYXAgYXQgYVxuLy8gbG93ZXIgbm9kZSB0aGFuIGBkb2N1bWVudGApLCBiaW5kaW5nIGF0IGBkb2N1bWVudGAgd291bGQgY2F1c2UgZHVwbGljYXRlXG4vLyBldmVudHMgc28gd2UgZG9uJ3QgaW5jbHVkZSB0aGVtIGhlcmVcbnZhciB0b3BFdmVudE1hcHBpbmcgPSB7XG4gIHRvcEFib3J0OiAnYWJvcnQnLFxuICB0b3BBbmltYXRpb25FbmQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25lbmQnKSB8fCAnYW5pbWF0aW9uZW5kJyxcbiAgdG9wQW5pbWF0aW9uSXRlcmF0aW9uOiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uaXRlcmF0aW9uJykgfHwgJ2FuaW1hdGlvbml0ZXJhdGlvbicsXG4gIHRvcEFuaW1hdGlvblN0YXJ0OiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uc3RhcnQnKSB8fCAnYW5pbWF0aW9uc3RhcnQnLFxuICB0b3BCbHVyOiAnYmx1cicsXG4gIHRvcENhblBsYXk6ICdjYW5wbGF5JyxcbiAgdG9wQ2FuUGxheVRocm91Z2g6ICdjYW5wbGF5dGhyb3VnaCcsXG4gIHRvcENoYW5nZTogJ2NoYW5nZScsXG4gIHRvcENsaWNrOiAnY2xpY2snLFxuICB0b3BDb21wb3NpdGlvbkVuZDogJ2NvbXBvc2l0aW9uZW5kJyxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogJ2NvbXBvc2l0aW9uc3RhcnQnLFxuICB0b3BDb21wb3NpdGlvblVwZGF0ZTogJ2NvbXBvc2l0aW9udXBkYXRlJyxcbiAgdG9wQ29udGV4dE1lbnU6ICdjb250ZXh0bWVudScsXG4gIHRvcENvcHk6ICdjb3B5JyxcbiAgdG9wQ3V0OiAnY3V0JyxcbiAgdG9wRG91YmxlQ2xpY2s6ICdkYmxjbGljaycsXG4gIHRvcERyYWc6ICdkcmFnJyxcbiAgdG9wRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICB0b3BEcmFnRW50ZXI6ICdkcmFnZW50ZXInLFxuICB0b3BEcmFnRXhpdDogJ2RyYWdleGl0JyxcbiAgdG9wRHJhZ0xlYXZlOiAnZHJhZ2xlYXZlJyxcbiAgdG9wRHJhZ092ZXI6ICdkcmFnb3ZlcicsXG4gIHRvcERyYWdTdGFydDogJ2RyYWdzdGFydCcsXG4gIHRvcERyb3A6ICdkcm9wJyxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6ICdkdXJhdGlvbmNoYW5nZScsXG4gIHRvcEVtcHRpZWQ6ICdlbXB0aWVkJyxcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcbiAgdG9wRW5kZWQ6ICdlbmRlZCcsXG4gIHRvcEVycm9yOiAnZXJyb3InLFxuICB0b3BGb2N1czogJ2ZvY3VzJyxcbiAgdG9wSW5wdXQ6ICdpbnB1dCcsXG4gIHRvcEtleURvd246ICdrZXlkb3duJyxcbiAgdG9wS2V5UHJlc3M6ICdrZXlwcmVzcycsXG4gIHRvcEtleVVwOiAna2V5dXAnLFxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXG4gIHRvcExvYWRlZE1ldGFkYXRhOiAnbG9hZGVkbWV0YWRhdGEnLFxuICB0b3BMb2FkU3RhcnQ6ICdsb2Fkc3RhcnQnLFxuICB0b3BNb3VzZURvd246ICdtb3VzZWRvd24nLFxuICB0b3BNb3VzZU1vdmU6ICdtb3VzZW1vdmUnLFxuICB0b3BNb3VzZU91dDogJ21vdXNlb3V0JyxcbiAgdG9wTW91c2VPdmVyOiAnbW91c2VvdmVyJyxcbiAgdG9wTW91c2VVcDogJ21vdXNldXAnLFxuICB0b3BQYXN0ZTogJ3Bhc3RlJyxcbiAgdG9wUGF1c2U6ICdwYXVzZScsXG4gIHRvcFBsYXk6ICdwbGF5JyxcbiAgdG9wUGxheWluZzogJ3BsYXlpbmcnLFxuICB0b3BQcm9ncmVzczogJ3Byb2dyZXNzJyxcbiAgdG9wUmF0ZUNoYW5nZTogJ3JhdGVjaGFuZ2UnLFxuICB0b3BTY3JvbGw6ICdzY3JvbGwnLFxuICB0b3BTZWVrZWQ6ICdzZWVrZWQnLFxuICB0b3BTZWVraW5nOiAnc2Vla2luZycsXG4gIHRvcFNlbGVjdGlvbkNoYW5nZTogJ3NlbGVjdGlvbmNoYW5nZScsXG4gIHRvcFN0YWxsZWQ6ICdzdGFsbGVkJyxcbiAgdG9wU3VzcGVuZDogJ3N1c3BlbmQnLFxuICB0b3BUZXh0SW5wdXQ6ICd0ZXh0SW5wdXQnLFxuICB0b3BUaW1lVXBkYXRlOiAndGltZXVwZGF0ZScsXG4gIHRvcFRvdWNoQ2FuY2VsOiAndG91Y2hjYW5jZWwnLFxuICB0b3BUb3VjaEVuZDogJ3RvdWNoZW5kJyxcbiAgdG9wVG91Y2hNb3ZlOiAndG91Y2htb3ZlJyxcbiAgdG9wVG91Y2hTdGFydDogJ3RvdWNoc3RhcnQnLFxuICB0b3BUcmFuc2l0aW9uRW5kOiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgndHJhbnNpdGlvbmVuZCcpIHx8ICd0cmFuc2l0aW9uZW5kJyxcbiAgdG9wVm9sdW1lQ2hhbmdlOiAndm9sdW1lY2hhbmdlJyxcbiAgdG9wV2FpdGluZzogJ3dhaXRpbmcnLFxuICB0b3BXaGVlbDogJ3doZWVsJ1xufTtcblxuLyoqXG4gKiBUbyBlbnN1cmUgbm8gY29uZmxpY3RzIHdpdGggb3RoZXIgcG90ZW50aWFsIFJlYWN0IGluc3RhbmNlcyBvbiB0aGUgcGFnZVxuICovXG52YXIgdG9wTGlzdGVuZXJzSURLZXkgPSAnX3JlYWN0TGlzdGVuZXJzSUQnICsgU3RyaW5nKE1hdGgucmFuZG9tKCkpLnNsaWNlKDIpO1xuXG5mdW5jdGlvbiBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KSB7XG4gIC8vIEluIElFOCwgYG1vdW50QXRgIGlzIGEgaG9zdCBvYmplY3QgYW5kIGRvZXNuJ3QgaGF2ZSBgaGFzT3duUHJvcGVydHlgXG4gIC8vIGRpcmVjdGx5LlxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3VudEF0LCB0b3BMaXN0ZW5lcnNJREtleSkpIHtcbiAgICBtb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XSA9IHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlcisrO1xuICAgIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV0gPSB7fTtcbiAgfVxuICByZXR1cm4gYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXTtcbn1cblxuLyoqXG4gKiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBpcyB1c2VkIHRvIGF0dGFjaCB0b3AtbGV2ZWwgZXZlbnQgbGlzdGVuZXJzLiBGb3JcbiAqIGV4YW1wbGU6XG4gKlxuICogICBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcignbXlJRCcsICdvbkNsaWNrJywgbXlGdW5jdGlvbik7XG4gKlxuICogVGhpcyB3b3VsZCBhbGxvY2F0ZSBhIFwicmVnaXN0cmF0aW9uXCIgb2YgYCgnb25DbGljaycsIG15RnVuY3Rpb24pYCBvbiAnbXlJRCcuXG4gKlxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSBfYXNzaWduKHt9LCBSZWFjdEV2ZW50RW1pdHRlck1peGluLCB7XG5cbiAgLyoqXG4gICAqIEluamVjdGFibGUgZXZlbnQgYmFja2VuZFxuICAgKi9cbiAgUmVhY3RFdmVudExpc3RlbmVyOiBudWxsLFxuXG4gIGluamVjdGlvbjoge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBSZWFjdEV2ZW50TGlzdGVuZXJcbiAgICAgKi9cbiAgICBpbmplY3RSZWFjdEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIChSZWFjdEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5zZXRIYW5kbGVUb3BMZXZlbChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaGFuZGxlVG9wTGV2ZWwpO1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lciA9IFJlYWN0RXZlbnRMaXN0ZW5lcjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciBvciBub3QgYW55IGNyZWF0ZWQgY2FsbGJhY2tzIHNob3VsZCBiZSBlbmFibGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWQgVHJ1ZSBpZiBjYWxsYmFja3Mgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqL1xuICBzZXRFbmFibGVkOiBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgIGlmIChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyKSB7XG4gICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnNldEVuYWJsZWQoZW5hYmxlZCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGNhbGxiYWNrcyBhcmUgZW5hYmxlZC5cbiAgICovXG4gIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIShSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyICYmIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIuaXNFbmFibGVkKCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSBsaXN0ZW4gZm9yIGJ1YmJsZWQgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudCBvYmplY3QuXG4gICAqXG4gICAqIEZpcmVmb3ggdjguMDEgKGFuZCBwb3NzaWJseSBvdGhlcnMpIGV4aGliaXRlZCBzdHJhbmdlIGJlaGF2aW9yIHdoZW5cbiAgICogbW91bnRpbmcgYG9ubW91c2Vtb3ZlYCBldmVudHMgYXQgc29tZSBub2RlIHRoYXQgd2FzIG5vdCB0aGUgZG9jdW1lbnRcbiAgICogZWxlbWVudC4gVGhlIHN5bXB0b21zIHdlcmUgdGhhdCBpZiB5b3VyIG1vdXNlIGlzIG5vdCBtb3Zpbmcgb3ZlciBzb21ldGhpbmdcbiAgICogY29udGFpbmVkIHdpdGhpbiB0aGF0IG1vdW50IHBvaW50IChmb3IgZXhhbXBsZSBvbiB0aGUgYmFja2dyb3VuZCkgdGhlXG4gICAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgZm9yIGBvbm1vdXNlbW92ZWAgd29uJ3QgYmUgY2FsbGVkLiBIb3dldmVyLCBpZiB5b3VcbiAgICogcmVnaXN0ZXIgdGhlIGBtb3VzZW1vdmVgIG9uIHRoZSBkb2N1bWVudCBvYmplY3QsIHRoZW4gaXQgd2lsbCBvZiBjb3Vyc2VcbiAgICogY2F0Y2ggYWxsIGBtb3VzZW1vdmVgcy4gVGhpcyBhbG9uZyB3aXRoIGlPUyBxdWlya3MsIGp1c3RpZmllcyByZXN0cmljdGluZ1xuICAgKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIHRvIHRoZSBkb2N1bWVudCBvYmplY3Qgb25seSwgYXQgbGVhc3QgZm9yIHRoZXNlXG4gICAqIG1vdmVtZW50IHR5cGVzIG9mIGV2ZW50cyBhbmQgcG9zc2libHkgYWxsIGV2ZW50cy5cbiAgICpcbiAgICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICAgKlxuICAgKiBBbHNvLCBga2V5dXBgL2BrZXlwcmVzc2AvYGtleWRvd25gIGRvIG5vdCBidWJibGUgdG8gdGhlIHdpbmRvdyBvbiBJRSwgYnV0XG4gICAqIHRoZXkgYnViYmxlIHRvIGRvY3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZW50RG9jdW1lbnRIYW5kbGUgRG9jdW1lbnQgd2hpY2ggb3ducyB0aGUgY29udGFpbmVyXG4gICAqL1xuICBsaXN0ZW5UbzogZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbk5hbWUsIGNvbnRlbnREb2N1bWVudEhhbmRsZSkge1xuICAgIHZhciBtb3VudEF0ID0gY29udGVudERvY3VtZW50SGFuZGxlO1xuICAgIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xuICAgIHZhciBkZXBlbmRlbmNpZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgICBpZiAoIShpc0xpc3RlbmluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSAmJiBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSkpIHtcbiAgICAgICAgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BXaGVlbCcpIHtcbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnd2hlZWwnKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KCd0b3BXaGVlbCcsICd3aGVlbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNFdmVudFN1cHBvcnRlZCgnbW91c2V3aGVlbCcpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcFdoZWVsJywgJ21vdXNld2hlZWwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmlyZWZveCBuZWVkcyB0byBjYXB0dXJlIGEgZGlmZmVyZW50IG1vdXNlIHNjcm9sbCBldmVudC5cbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vZXZlbnRzL3Rlc3RzL3Njcm9sbC5odG1sXG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcFdoZWVsJywgJ0RPTU1vdXNlU2Nyb2xsJywgbW91bnRBdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BTY3JvbGwnKSB7XG5cbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnc2Nyb2xsJywgdHJ1ZSkpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQoJ3RvcFNjcm9sbCcsICdzY3JvbGwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KCd0b3BTY3JvbGwnLCAnc2Nyb2xsJywgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5XSU5ET1dfSEFORExFKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcEZvY3VzJyB8fCBkZXBlbmRlbmN5ID09PSAndG9wQmx1cicpIHtcblxuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdmb2N1cycsIHRydWUpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KCd0b3BGb2N1cycsICdmb2N1cycsIG1vdW50QXQpO1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCgndG9wQmx1cicsICdibHVyJywgbW91bnRBdCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdmb2N1c2luJykpIHtcbiAgICAgICAgICAgIC8vIElFIGhhcyBgZm9jdXNpbmAgYW5kIGBmb2N1c291dGAgZXZlbnRzIHdoaWNoIGJ1YmJsZS5cbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMDgvMDQvZGVsZWdhdGluZ190aGUuaHRtbFxuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KCd0b3BGb2N1cycsICdmb2N1c2luJywgbW91bnRBdCk7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcEJsdXInLCAnZm9jdXNvdXQnLCBtb3VudEF0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB0byBtYWtlIHN1cmUgYmx1ciBhbmQgZm9jdXMgZXZlbnQgbGlzdGVuZXJzIGFyZSBvbmx5IGF0dGFjaGVkIG9uY2VcbiAgICAgICAgICBpc0xpc3RlbmluZy50b3BCbHVyID0gdHJ1ZTtcbiAgICAgICAgICBpc0xpc3RlbmluZy50b3BGb2N1cyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodG9wRXZlbnRNYXBwaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpKSB7XG4gICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KGRlcGVuZGVuY3ksIHRvcEV2ZW50TWFwcGluZ1tkZXBlbmRlbmN5XSwgbW91bnRBdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHRyYXBCdWJibGVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgcmV0dXJuIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKTtcbiAgfSxcblxuICB0cmFwQ2FwdHVyZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICByZXR1cm4gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKTtcbiAgfSxcblxuICAvKipcbiAgICogUHJvdGVjdCBhZ2FpbnN0IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCkgcmV0dXJuaW5nIG51bGxcbiAgICogU29tZSBwb3B1cCBibG9ja2VyIGV4dGVuc2lvbnMgYXBwZWFyIHRvIGRvIHRoaXM6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNjg4N1xuICAgKi9cbiAgc3VwcG9ydHNFdmVudFBhZ2VYWTogZnVuY3Rpb24gKCkge1xuICAgIGlmICghZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGV2ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnQnKTtcbiAgICByZXR1cm4gZXYgIT0gbnVsbCAmJiAncGFnZVgnIGluIGV2O1xuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW5zIHRvIHdpbmRvdyBzY3JvbGwgYW5kIHJlc2l6ZSBldmVudHMuIFdlIGNhY2hlIHNjcm9sbCB2YWx1ZXMgc28gdGhhdFxuICAgKiBhcHBsaWNhdGlvbiBjb2RlIGNhbiBhY2Nlc3MgdGhlbSB3aXRob3V0IHRyaWdnZXJpbmcgcmVmbG93cy5cbiAgICpcbiAgICogVmlld3BvcnRNZXRyaWNzIGlzIG9ubHkgdXNlZCBieSBTeW50aGV0aWNNb3VzZS9Ub3VjaEV2ZW50IGFuZCBvbmx5IHdoZW5cbiAgICogcGFnZVgvcGFnZVkgaXNuJ3Qgc3VwcG9ydGVkIChsZWdhY3kgYnJvd3NlcnMpLlxuICAgKlxuICAgKiBOT1RFOiBTY3JvbGwgZXZlbnRzIGRvIG5vdCBidWJibGUuXG4gICAqXG4gICAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vZXZlbnRzL3Njcm9sbC5odG1sXG4gICAqL1xuICBlbnN1cmVTY3JvbGxWYWx1ZU1vbml0b3Jpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaGFzRXZlbnRQYWdlWFkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaGFzRXZlbnRQYWdlWFkgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuc3VwcG9ydHNFdmVudFBhZ2VYWSgpO1xuICAgIH1cbiAgICBpZiAoIWhhc0V2ZW50UGFnZVhZICYmICFpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSkge1xuICAgICAgdmFyIHJlZnJlc2ggPSBWaWV3cG9ydE1ldHJpY3MucmVmcmVzaFNjcm9sbFZhbHVlcztcbiAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIubW9uaXRvclNjcm9sbFZhbHVlKHJlZnJlc2gpO1xuICAgICAgaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xudmFyIFZpZXdwb3J0TWV0cmljcyA9IHJlcXVpcmUoJy4vVmlld3BvcnRNZXRyaWNzJyk7XG5cbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKCcuL2dldEV2ZW50TW9kaWZpZXJTdGF0ZScpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgTW91c2VFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBNb3VzZUV2ZW50SW50ZXJmYWNlID0ge1xuICBzY3JlZW5YOiBudWxsLFxuICBzY3JlZW5ZOiBudWxsLFxuICBjbGllbnRYOiBudWxsLFxuICBjbGllbnRZOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIGJ1dHRvbjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gV2Via2l0LCBGaXJlZm94LCBJRTkrXG4gICAgLy8gd2hpY2g6ICAxIDIgM1xuICAgIC8vIGJ1dHRvbjogMCAxIDIgKHN0YW5kYXJkKVxuICAgIHZhciBidXR0b24gPSBldmVudC5idXR0b247XG4gICAgaWYgKCd3aGljaCcgaW4gZXZlbnQpIHtcbiAgICAgIHJldHVybiBidXR0b247XG4gICAgfVxuICAgIC8vIElFPDlcbiAgICAvLyB3aGljaDogIHVuZGVmaW5lZFxuICAgIC8vIGJ1dHRvbjogMCAwIDBcbiAgICAvLyBidXR0b246IDEgNCAyIChvbm1vdXNldXApXG4gICAgcmV0dXJuIGJ1dHRvbiA9PT0gMiA/IDIgOiBidXR0b24gPT09IDQgPyAxIDogMDtcbiAgfSxcbiAgYnV0dG9uczogbnVsbCxcbiAgcmVsYXRlZFRhcmdldDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgKGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC5zcmNFbGVtZW50ID8gZXZlbnQudG9FbGVtZW50IDogZXZlbnQuZnJvbUVsZW1lbnQpO1xuICB9LFxuICAvLyBcIlByb3ByaWV0YXJ5XCIgSW50ZXJmYWNlLlxuICBwYWdlWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdwYWdlWCcgaW4gZXZlbnQgPyBldmVudC5wYWdlWCA6IGV2ZW50LmNsaWVudFggKyBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbExlZnQ7XG4gIH0sXG4gIHBhZ2VZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ3BhZ2VZJyBpbiBldmVudCA/IGV2ZW50LnBhZ2VZIDogZXZlbnQuY2xpZW50WSArIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsVG9wO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNNb3VzZUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNNb3VzZUV2ZW50LCBNb3VzZUV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY01vdXNlRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgT0JTRVJWRURfRVJST1IgPSB7fTtcblxuLyoqXG4gKiBgVHJhbnNhY3Rpb25gIGNyZWF0ZXMgYSBibGFjayBib3ggdGhhdCBpcyBhYmxlIHRvIHdyYXAgYW55IG1ldGhvZCBzdWNoIHRoYXRcbiAqIGNlcnRhaW4gaW52YXJpYW50cyBhcmUgbWFpbnRhaW5lZCBiZWZvcmUgYW5kIGFmdGVyIHRoZSBtZXRob2QgaXMgaW52b2tlZFxuICogKEV2ZW4gaWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biB3aGlsZSBpbnZva2luZyB0aGUgd3JhcHBlZCBtZXRob2QpLiBXaG9ldmVyXG4gKiBpbnN0YW50aWF0ZXMgYSB0cmFuc2FjdGlvbiBjYW4gcHJvdmlkZSBlbmZvcmNlcnMgb2YgdGhlIGludmFyaWFudHMgYXRcbiAqIGNyZWF0aW9uIHRpbWUuIFRoZSBgVHJhbnNhY3Rpb25gIGNsYXNzIGl0c2VsZiB3aWxsIHN1cHBseSBvbmUgYWRkaXRpb25hbFxuICogYXV0b21hdGljIGludmFyaWFudCBmb3IgeW91IC0gdGhlIGludmFyaWFudCB0aGF0IGFueSB0cmFuc2FjdGlvbiBpbnN0YW5jZVxuICogc2hvdWxkIG5vdCBiZSBydW4gd2hpbGUgaXQgaXMgYWxyZWFkeSBiZWluZyBydW4uIFlvdSB3b3VsZCB0eXBpY2FsbHkgY3JlYXRlIGFcbiAqIHNpbmdsZSBpbnN0YW5jZSBvZiBhIGBUcmFuc2FjdGlvbmAgZm9yIHJldXNlIG11bHRpcGxlIHRpbWVzLCB0aGF0IHBvdGVudGlhbGx5XG4gKiBpcyB1c2VkIHRvIHdyYXAgc2V2ZXJhbCBkaWZmZXJlbnQgbWV0aG9kcy4gV3JhcHBlcnMgYXJlIGV4dHJlbWVseSBzaW1wbGUgLVxuICogdGhleSBvbmx5IHJlcXVpcmUgaW1wbGVtZW50aW5nIHR3byBtZXRob2RzLlxuICpcbiAqIDxwcmU+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlcnMgKGluamVjdGVkIGF0IGNyZWF0aW9uIHRpbWUpXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAgICAgICAgK1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS18LS0tLS0tLS0tLS0tLS0rXG4gKiAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgdiAgICAgICAgfCAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICAgICArLS0tLS0tLS0tLS0tLS0tKyAgIHwgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgKy0tfCAgICB3cmFwcGVyMSAgIHwtLS18LS0tLSsgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICstLS0tLS0tLS0tLS0tLS0rICAgdiAgICB8ICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICAgICAgICstLS0tLS0tLS0tLS0tKyAgfCAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgKy0tLS18ICAgd3JhcHBlcjIgIHwtLS0tLS0tLSsgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgIHwgICAgKy0tLS0tLS0tLS0tLS0rICB8ICAgICB8ICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICB8ICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgdiAgICAgdiAgICAgICAgICAgICAgICAgICAgIHYgICAgIHYgICB8IHdyYXBwZXJcbiAqICAgICAgICAgICAgICAgICAgICB8ICstLS0rICstLS0rICAgKy0tLS0tLS0tLSsgICArLS0tKyArLS0tKyB8IGludmFyaWFudHNcbiAqIHBlcmZvcm0oYW55TWV0aG9kKSB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8IG1haW50YWluZWRcbiAqICstLS0tLS0tLS0tLS0tLS0tLT58LXwtLS18LXwtLS18LS0+fGFueU1ldGhvZHwtLS18LS0tfC18LS0tfC18LS0tLS0tLS0+XG4gKiAgICAgICAgICAgICAgICAgICAgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfFxuICogICAgICAgICAgICAgICAgICAgIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHxcbiAqICAgICAgICAgICAgICAgICAgICB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCArLS0tKyArLS0tKyAgICstLS0tLS0tLS0rICAgKy0tLSsgKy0tLSsgfFxuICogICAgICAgICAgICAgICAgICAgIHwgIGluaXRpYWxpemUgICAgICAgICAgICAgICAgICAgIGNsb3NlICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gKiA8L3ByZT5cbiAqXG4gKiBVc2UgY2FzZXM6XG4gKiAtIFByZXNlcnZpbmcgdGhlIGlucHV0IHNlbGVjdGlvbiByYW5nZXMgYmVmb3JlL2FmdGVyIHJlY29uY2lsaWF0aW9uLlxuICogICBSZXN0b3Jpbmcgc2VsZWN0aW9uIGV2ZW4gaW4gdGhlIGV2ZW50IG9mIGFuIHVuZXhwZWN0ZWQgZXJyb3IuXG4gKiAtIERlYWN0aXZhdGluZyBldmVudHMgd2hpbGUgcmVhcnJhbmdpbmcgdGhlIERPTSwgcHJldmVudGluZyBibHVycy9mb2N1c2VzLFxuICogICB3aGlsZSBndWFyYW50ZWVpbmcgdGhhdCBhZnRlcndhcmRzLCB0aGUgZXZlbnQgc3lzdGVtIGlzIHJlYWN0aXZhdGVkLlxuICogLSBGbHVzaGluZyBhIHF1ZXVlIG9mIGNvbGxlY3RlZCBET00gbXV0YXRpb25zIHRvIHRoZSBtYWluIFVJIHRocmVhZCBhZnRlciBhXG4gKiAgIHJlY29uY2lsaWF0aW9uIHRha2VzIHBsYWNlIGluIGEgd29ya2VyIHRocmVhZC5cbiAqIC0gSW52b2tpbmcgYW55IGNvbGxlY3RlZCBgY29tcG9uZW50RGlkVXBkYXRlYCBjYWxsYmFja3MgYWZ0ZXIgcmVuZGVyaW5nIG5ld1xuICogICBjb250ZW50LlxuICogLSAoRnV0dXJlIHVzZSBjYXNlKTogV3JhcHBpbmcgcGFydGljdWxhciBmbHVzaGVzIG9mIHRoZSBgUmVhY3RXb3JrZXJgIHF1ZXVlXG4gKiAgIHRvIHByZXNlcnZlIHRoZSBgc2Nyb2xsVG9wYCAoYW4gYXV0b21hdGljIHNjcm9sbCBhd2FyZSBET00pLlxuICogLSAoRnV0dXJlIHVzZSBjYXNlKTogTGF5b3V0IGNhbGN1bGF0aW9ucyBiZWZvcmUgYW5kIGFmdGVyIERPTSB1cGRhdGVzLlxuICpcbiAqIFRyYW5zYWN0aW9uYWwgcGx1Z2luIEFQSTpcbiAqIC0gQSBtb2R1bGUgdGhhdCBoYXMgYW4gYGluaXRpYWxpemVgIG1ldGhvZCB0aGF0IHJldHVybnMgYW55IHByZWNvbXB1dGF0aW9uLlxuICogLSBhbmQgYSBgY2xvc2VgIG1ldGhvZCB0aGF0IGFjY2VwdHMgdGhlIHByZWNvbXB1dGF0aW9uLiBgY2xvc2VgIGlzIGludm9rZWRcbiAqICAgd2hlbiB0aGUgd3JhcHBlZCBwcm9jZXNzIGlzIGNvbXBsZXRlZCwgb3IgaGFzIGZhaWxlZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFRyYW5zYWN0aW9uYWxXcmFwcGVyPn0gdHJhbnNhY3Rpb25XcmFwcGVyIFdyYXBwZXIgbW9kdWxlc1xuICogdGhhdCBpbXBsZW1lbnQgYGluaXRpYWxpemVgIGFuZCBgY2xvc2VgLlxuICogQHJldHVybiB7VHJhbnNhY3Rpb259IFNpbmdsZSB0cmFuc2FjdGlvbiBmb3IgcmV1c2UgaW4gdGhyZWFkLlxuICpcbiAqIEBjbGFzcyBUcmFuc2FjdGlvblxuICovXG52YXIgVHJhbnNhY3Rpb25JbXBsID0ge1xuICAvKipcbiAgICogU2V0cyB1cCB0aGlzIGluc3RhbmNlIHNvIHRoYXQgaXQgaXMgcHJlcGFyZWQgZm9yIGNvbGxlY3RpbmcgbWV0cmljcy4gRG9lc1xuICAgKiBzbyBzdWNoIHRoYXQgdGhpcyBzZXR1cCBtZXRob2QgbWF5IGJlIHVzZWQgb24gYW4gaW5zdGFuY2UgdGhhdCBpcyBhbHJlYWR5XG4gICAqIGluaXRpYWxpemVkLCBpbiBhIHdheSB0aGF0IGRvZXMgbm90IGNvbnN1bWUgYWRkaXRpb25hbCBtZW1vcnkgdXBvbiByZXVzZS5cbiAgICogVGhhdCBjYW4gYmUgdXNlZnVsIGlmIHlvdSBkZWNpZGUgdG8gbWFrZSB5b3VyIHN1YmNsYXNzIG9mIHRoaXMgbWl4aW4gYVxuICAgKiBcIlBvb2xlZENsYXNzXCIuXG4gICAqL1xuICByZWluaXRpYWxpemVUcmFuc2FjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25XcmFwcGVycygpO1xuICAgIGlmICh0aGlzLndyYXBwZXJJbml0RGF0YSkge1xuICAgICAgdGhpcy53cmFwcGVySW5pdERhdGEubGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53cmFwcGVySW5pdERhdGEgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gZmFsc2U7XG4gIH0sXG5cbiAgX2lzSW5UcmFuc2FjdGlvbjogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtBcnJheTxUcmFuc2FjdGlvbldyYXBwZXI+fSBBcnJheSBvZiB0cmFuc2FjdGlvbiB3cmFwcGVycy5cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IG51bGwsXG5cbiAgaXNJblRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5faXNJblRyYW5zYWN0aW9uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgZnVuY3Rpb24gd2l0aGluIGEgc2FmZXR5IHdpbmRvdy4gVXNlIHRoaXMgZm9yIHRoZSB0b3AgbGV2ZWxcbiAgICogbWV0aG9kcyB0aGF0IHJlc3VsdCBpbiBsYXJnZSBhbW91bnRzIG9mIGNvbXB1dGF0aW9uL211dGF0aW9ucyB0aGF0IHdvdWxkXG4gICAqIG5lZWQgdG8gYmUgc2FmZXR5IGNoZWNrZWQuIFRoZSBvcHRpb25hbCBhcmd1bWVudHMgaGVscHMgcHJldmVudCB0aGUgbmVlZFxuICAgKiB0byBiaW5kIGluIG1hbnkgY2FzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCBNZW1iZXIgb2Ygc2NvcGUgdG8gY2FsbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlIFNjb3BlIHRvIGludm9rZSBmcm9tLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBhIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gYiBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGMgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBkIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gZSBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGYgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKlxuICAgKiBAcmV0dXJuIHsqfSBSZXR1cm4gdmFsdWUgZnJvbSBgbWV0aG9kYC5cbiAgICovXG4gIHBlcmZvcm06IGZ1bmN0aW9uIChtZXRob2QsIHNjb3BlLCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgISF0aGlzLmlzSW5UcmFuc2FjdGlvbigpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RyYW5zYWN0aW9uLnBlcmZvcm0oLi4uKTogQ2Fubm90IGluaXRpYWxpemUgYSB0cmFuc2FjdGlvbiB3aGVuIHRoZXJlIGlzIGFscmVhZHkgYW4gb3V0c3RhbmRpbmcgdHJhbnNhY3Rpb24uJykgOiBfcHJvZEludmFyaWFudCgnMjcnKSA6IHZvaWQgMDtcbiAgICB2YXIgZXJyb3JUaHJvd247XG4gICAgdmFyIHJldDtcbiAgICB0cnkge1xuICAgICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gdHJ1ZTtcbiAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGhcbiAgICAgIC8vIGVycm9yVGhyb3duIHNldCB0byB0cnVlIGJlZm9yZSBzZXR0aW5nIGl0IHRvIGZhbHNlIGFmdGVyIGNhbGxpbmdcbiAgICAgIC8vIGNsb3NlIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIHRydWUgaW4gdGhlIGZpbmFsbHkgYmxvY2ssIGl0IG1lYW5zXG4gICAgICAvLyBvbmUgb2YgdGhlc2UgY2FsbHMgdGhyZXcuXG4gICAgICBlcnJvclRocm93biA9IHRydWU7XG4gICAgICB0aGlzLmluaXRpYWxpemVBbGwoMCk7XG4gICAgICByZXQgPSBtZXRob2QuY2FsbChzY29wZSwgYSwgYiwgYywgZCwgZSwgZik7XG4gICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAvLyBJZiBgbWV0aG9kYCB0aHJvd3MsIHByZWZlciB0byBzaG93IHRoYXQgc3RhY2sgdHJhY2Ugb3ZlciBhbnkgdGhyb3duXG4gICAgICAgICAgLy8gYnkgaW52b2tpbmcgYGNsb3NlQWxsYC5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUFsbCgwKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU2luY2UgYG1ldGhvZGAgZGlkbid0IHRocm93LCB3ZSBkb24ndCB3YW50IHRvIHNpbGVuY2UgdGhlIGV4Y2VwdGlvblxuICAgICAgICAgIC8vIGhlcmUuXG4gICAgICAgICAgdGhpcy5jbG9zZUFsbCgwKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUFsbDogZnVuY3Rpb24gKHN0YXJ0SW5kZXgpIHtcbiAgICB2YXIgdHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycztcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IHRyYW5zYWN0aW9uV3JhcHBlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3cmFwcGVyID0gdHJhbnNhY3Rpb25XcmFwcGVyc1tpXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGggdGhlXG4gICAgICAgIC8vIE9CU0VSVkVEX0VSUk9SIHN0YXRlIGJlZm9yZSBvdmVyd3JpdGluZyBpdCB3aXRoIHRoZSByZWFsIHJldHVybiB2YWx1ZVxuICAgICAgICAvLyBvZiBpbml0aWFsaXplIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIE9CU0VSVkVEX0VSUk9SIGluIHRoZSBmaW5hbGx5XG4gICAgICAgIC8vIGJsb2NrLCBpdCBtZWFucyB3cmFwcGVyLmluaXRpYWxpemUgdGhyZXcuXG4gICAgICAgIHRoaXMud3JhcHBlckluaXREYXRhW2ldID0gT0JTRVJWRURfRVJST1I7XG4gICAgICAgIHRoaXMud3JhcHBlckluaXREYXRhW2ldID0gd3JhcHBlci5pbml0aWFsaXplID8gd3JhcHBlci5pbml0aWFsaXplLmNhbGwodGhpcykgOiBudWxsO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRoaXMud3JhcHBlckluaXREYXRhW2ldID09PSBPQlNFUlZFRF9FUlJPUikge1xuICAgICAgICAgIC8vIFRoZSBpbml0aWFsaXplciBmb3Igd3JhcHBlciBpIHRocmV3IGFuIGVycm9yOyBpbml0aWFsaXplIHRoZVxuICAgICAgICAgIC8vIHJlbWFpbmluZyB3cmFwcGVycyBidXQgc2lsZW5jZSBhbnkgZXhjZXB0aW9ucyBmcm9tIHRoZW0gdG8gZW5zdXJlXG4gICAgICAgICAgLy8gdGhhdCB0aGUgZmlyc3QgZXJyb3IgaXMgdGhlIG9uZSB0byBidWJibGUgdXAuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZUFsbChpICsgMSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VzIGVhY2ggb2YgYHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycy5jbG9zZVtpXWAgZnVuY3Rpb25zLCBwYXNzaW5nIGludG9cbiAgICogdGhlbSB0aGUgcmVzcGVjdGl2ZSByZXR1cm4gdmFsdWVzIG9mIGB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnMuaW5pdFtpXWBcbiAgICogKGBjbG9zZWBycyB0aGF0IGNvcnJlc3BvbmQgdG8gaW5pdGlhbGl6ZXJzIHRoYXQgZmFpbGVkIHdpbGwgbm90IGJlXG4gICAqIGludm9rZWQpLlxuICAgKi9cbiAgY2xvc2VBbGw6IGZ1bmN0aW9uIChzdGFydEluZGV4KSB7XG4gICAgIXRoaXMuaXNJblRyYW5zYWN0aW9uKCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVHJhbnNhY3Rpb24uY2xvc2VBbGwoKTogQ2Fubm90IGNsb3NlIHRyYW5zYWN0aW9uIHdoZW4gbm9uZSBhcmUgb3Blbi4nKSA6IF9wcm9kSW52YXJpYW50KCcyOCcpIDogdm9pZCAwO1xuICAgIHZhciB0cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzO1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgdHJhbnNhY3Rpb25XcmFwcGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdyYXBwZXIgPSB0cmFuc2FjdGlvbldyYXBwZXJzW2ldO1xuICAgICAgdmFyIGluaXREYXRhID0gdGhpcy53cmFwcGVySW5pdERhdGFbaV07XG4gICAgICB2YXIgZXJyb3JUaHJvd247XG4gICAgICB0cnkge1xuICAgICAgICAvLyBDYXRjaGluZyBlcnJvcnMgbWFrZXMgZGVidWdnaW5nIG1vcmUgZGlmZmljdWx0LCBzbyB3ZSBzdGFydCB3aXRoXG4gICAgICAgIC8vIGVycm9yVGhyb3duIHNldCB0byB0cnVlIGJlZm9yZSBzZXR0aW5nIGl0IHRvIGZhbHNlIGFmdGVyIGNhbGxpbmdcbiAgICAgICAgLy8gY2xvc2UgLS0gaWYgaXQncyBzdGlsbCBzZXQgdG8gdHJ1ZSBpbiB0aGUgZmluYWxseSBibG9jaywgaXQgbWVhbnNcbiAgICAgICAgLy8gd3JhcHBlci5jbG9zZSB0aHJldy5cbiAgICAgICAgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICBpZiAoaW5pdERhdGEgIT09IE9CU0VSVkVEX0VSUk9SICYmIHdyYXBwZXIuY2xvc2UpIHtcbiAgICAgICAgICB3cmFwcGVyLmNsb3NlLmNhbGwodGhpcywgaW5pdERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yVGhyb3duID0gZmFsc2U7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAvLyBUaGUgY2xvc2VyIGZvciB3cmFwcGVyIGkgdGhyZXcgYW4gZXJyb3I7IGNsb3NlIHRoZSByZW1haW5pbmdcbiAgICAgICAgICAvLyB3cmFwcGVycyBidXQgc2lsZW5jZSBhbnkgZXhjZXB0aW9ucyBmcm9tIHRoZW0gdG8gZW5zdXJlIHRoYXQgdGhlXG4gICAgICAgICAgLy8gZmlyc3QgZXJyb3IgaXMgdGhlIG9uZSB0byBidWJibGUgdXAuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VBbGwoaSArIDEpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy53cmFwcGVySW5pdERhdGEubGVuZ3RoID0gMDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2FjdGlvbkltcGw7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvVHJhbnNhY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEJhc2VkIG9uIHRoZSBlc2NhcGUtaHRtbCBsaWJyYXJ5LCB3aGljaCBpcyB1c2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSBiZWxvdzpcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxMyBUSiBIb2xvd2F5Y2h1a1xuICogQ29weXJpZ2h0IChjKSAyMDE1IEFuZHJlYXMgTHViYmVcbiAqIENvcHlyaWdodCAoYykgMjAxNSBUaWFuY2hlbmcgXCJUaW1vdGh5XCIgR3VcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbiAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuICogJ1NvZnR3YXJlJyksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4gKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbiAqIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cbiAqIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZXG4gKiBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULFxuICogVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEVcbiAqIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG4vKipcbiAqIE1vZHVsZSB2YXJpYWJsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBtYXRjaEh0bWxSZWdFeHAgPSAvW1wiJyY8Pl0vO1xuXG4vKipcbiAqIEVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gdGhlIGdpdmVuIHN0cmluZyBvZiBodG1sLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gZXNjYXBlIGZvciBpbnNlcnRpbmcgaW50byBIVE1MXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHJpbmcpIHtcbiAgdmFyIHN0ciA9ICcnICsgc3RyaW5nO1xuICB2YXIgbWF0Y2ggPSBtYXRjaEh0bWxSZWdFeHAuZXhlYyhzdHIpO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIGVzY2FwZTtcbiAgdmFyIGh0bWwgPSAnJztcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RJbmRleCA9IDA7XG5cbiAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgY2FzZSAzNDpcbiAgICAgICAgLy8gXCJcbiAgICAgICAgZXNjYXBlID0gJyZxdW90Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzODpcbiAgICAgICAgLy8gJlxuICAgICAgICBlc2NhcGUgPSAnJmFtcDsnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIC8vICdcbiAgICAgICAgZXNjYXBlID0gJyYjeDI3Oyc7IC8vIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWw7IHVzZWQgdG8gYmUgJyYjMzknXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MDpcbiAgICAgICAgLy8gPFxuICAgICAgICBlc2NhcGUgPSAnJmx0Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MjpcbiAgICAgICAgLy8gPlxuICAgICAgICBlc2NhcGUgPSAnJmd0Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIGh0bWwgKz0gc3RyLnN1YnN0cmluZyhsYXN0SW5kZXgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgaHRtbCArPSBlc2NhcGU7XG4gIH1cblxuICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcbn1cbi8vIGVuZCBjb2RlIGNvcGllZCBhbmQgbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbFxuXG5cbi8qKlxuICogRXNjYXBlcyB0ZXh0IHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IFRleHQgdmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRleHQpIHtcbiAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHRleHQgPT09ICdudW1iZXInKSB7XG4gICAgLy8gdGhpcyBzaG9ydGNpcmN1aXQgaGVscHMgcGVyZiBmb3IgdHlwZXMgdGhhdCB3ZSBrbm93IHdpbGwgbmV2ZXIgaGF2ZVxuICAgIC8vIHNwZWNpYWwgY2hhcmFjdGVycywgZXNwZWNpYWxseSBnaXZlbiB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgdXNlZCBvZnRlblxuICAgIC8vIGZvciBudW1lcmljIGRvbSBpZHMuXG4gICAgcmV0dXJuICcnICsgdGV4dDtcbiAgfVxuICByZXR1cm4gZXNjYXBlSHRtbCh0ZXh0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIERPTU5hbWVzcGFjZXMgPSByZXF1aXJlKCcuL0RPTU5hbWVzcGFjZXMnKTtcblxudmFyIFdISVRFU1BBQ0VfVEVTVCA9IC9eWyBcXHJcXG5cXHRcXGZdLztcbnZhciBOT05WSVNJQkxFX1RFU1QgPSAvPCghLS18bGlua3xub3NjcmlwdHxtZXRhfHNjcmlwdHxzdHlsZSlbIFxcclxcblxcdFxcZlxcLz5dLztcblxudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSByZXF1aXJlKCcuL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24nKTtcblxuLy8gU1ZHIHRlbXAgY29udGFpbmVyIGZvciBJRSBsYWNraW5nIGlubmVySFRNTFxudmFyIHJldXNhYmxlU1ZHQ29udGFpbmVyO1xuXG4vKipcbiAqIFNldCB0aGUgaW5uZXJIVE1MIHByb3BlcnR5IG9mIGEgbm9kZSwgZW5zdXJpbmcgdGhhdCB3aGl0ZXNwYWNlIGlzIHByZXNlcnZlZFxuICogZXZlbiBpbiBJRTguXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRJbm5lckhUTUwgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gIC8vIElFIGRvZXMgbm90IGhhdmUgaW5uZXJIVE1MIGZvciBTVkcgbm9kZXMsIHNvIGluc3RlYWQgd2UgaW5qZWN0IHRoZVxuICAvLyBuZXcgbWFya3VwIGluIGEgdGVtcCBub2RlIGFuZCB0aGVuIG1vdmUgdGhlIGNoaWxkIG5vZGVzIGFjcm9zcyBpbnRvXG4gIC8vIHRoZSB0YXJnZXQgbm9kZVxuICBpZiAobm9kZS5uYW1lc3BhY2VVUkkgPT09IERPTU5hbWVzcGFjZXMuc3ZnICYmICEoJ2lubmVySFRNTCcgaW4gbm9kZSkpIHtcbiAgICByZXVzYWJsZVNWR0NvbnRhaW5lciA9IHJldXNhYmxlU1ZHQ29udGFpbmVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyLmlubmVySFRNTCA9ICc8c3ZnPicgKyBodG1sICsgJzwvc3ZnPic7XG4gICAgdmFyIHN2Z05vZGUgPSByZXVzYWJsZVNWR0NvbnRhaW5lci5maXJzdENoaWxkO1xuICAgIHdoaWxlIChzdmdOb2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoc3ZnTm9kZS5maXJzdENoaWxkKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5pbm5lckhUTUwgPSBodG1sO1xuICB9XG59KTtcblxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBJRTg6IFdoZW4gdXBkYXRpbmcgYSBqdXN0IGNyZWF0ZWQgbm9kZSB3aXRoIGlubmVySFRNTCBvbmx5IGxlYWRpbmdcbiAgLy8gd2hpdGVzcGFjZSBpcyByZW1vdmVkLiBXaGVuIHVwZGF0aW5nIGFuIGV4aXN0aW5nIG5vZGUgd2l0aCBpbm5lckhUTUxcbiAgLy8gd2hpdGVzcGFjZSBpbiByb290IFRleHROb2RlcyBpcyBhbHNvIGNvbGxhcHNlZC5cbiAgLy8gQHNlZSBxdWlya3Ntb2RlLm9yZy9idWdyZXBvcnRzL2FyY2hpdmVzLzIwMDQvMTEvaW5uZXJodG1sX2FuZF90Lmh0bWxcblxuICAvLyBGZWF0dXJlIGRldGVjdGlvbjsgb25seSBJRTggaXMga25vd24gdG8gYmVoYXZlIGltcHJvcGVybHkgbGlrZSB0aGlzLlxuICB2YXIgdGVzdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGVzdEVsZW1lbnQuaW5uZXJIVE1MID0gJyAnO1xuICBpZiAodGVzdEVsZW1lbnQuaW5uZXJIVE1MID09PSAnJykge1xuICAgIHNldElubmVySFRNTCA9IGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gICAgICAvLyBNYWdpYyB0aGVvcnk6IElFOCBzdXBwb3NlZGx5IGRpZmZlcmVudGlhdGVzIGJldHdlZW4gYWRkZWQgYW5kIHVwZGF0ZWRcbiAgICAgIC8vIG5vZGVzIHdoZW4gcHJvY2Vzc2luZyBpbm5lckhUTUwsIGlubmVySFRNTCBvbiB1cGRhdGVkIG5vZGVzIHN1ZmZlcnNcbiAgICAgIC8vIGZyb20gd29yc2Ugd2hpdGVzcGFjZSBiZWhhdmlvci4gUmUtYWRkaW5nIGEgbm9kZSBsaWtlIHRoaXMgdHJpZ2dlcnNcbiAgICAgIC8vIHRoZSBpbml0aWFsIGFuZCBtb3JlIGZhdm9yYWJsZSB3aGl0ZXNwYWNlIGJlaGF2aW9yLlxuICAgICAgLy8gVE9ETzogV2hhdCB0byBkbyBvbiBhIGRldGFjaGVkIG5vZGU/XG4gICAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobm9kZSwgbm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIGFsc28gaW1wbGVtZW50IGEgd29ya2Fyb3VuZCBmb3Igbm9uLXZpc2libGUgdGFncyBkaXNhcHBlYXJpbmcgaW50b1xuICAgICAgLy8gdGhpbiBhaXIgb24gSUU4LCB0aGlzIG9ubHkgaGFwcGVucyBpZiB0aGVyZSBpcyBubyB2aXNpYmxlIHRleHRcbiAgICAgIC8vIGluLWZyb250IG9mIHRoZSBub24tdmlzaWJsZSB0YWdzLiBQaWdneWJhY2sgb24gdGhlIHdoaXRlc3BhY2UgZml4XG4gICAgICAvLyBhbmQgc2ltcGx5IGNoZWNrIGlmIGFueSBub24tdmlzaWJsZSB0YWdzIGFwcGVhciBpbiB0aGUgc291cmNlLlxuICAgICAgaWYgKFdISVRFU1BBQ0VfVEVTVC50ZXN0KGh0bWwpIHx8IGh0bWxbMF0gPT09ICc8JyAmJiBOT05WSVNJQkxFX1RFU1QudGVzdChodG1sKSkge1xuICAgICAgICAvLyBSZWNvdmVyIGxlYWRpbmcgd2hpdGVzcGFjZSBieSB0ZW1wb3JhcmlseSBwcmVwZW5kaW5nIGFueSBjaGFyYWN0ZXIuXG4gICAgICAgIC8vIFxcdUZFRkYgaGFzIHRoZSBwb3RlbnRpYWwgYWR2YW50YWdlIG9mIGJlaW5nIHplcm8td2lkdGgvaW52aXNpYmxlLlxuICAgICAgICAvLyBVZ2xpZnlKUyBkcm9wcyBVK0ZFRkYgY2hhcnMgd2hlbiBwYXJzaW5nLCBzbyB1c2UgU3RyaW5nLmZyb21DaGFyQ29kZVxuICAgICAgICAvLyBpbiBob3BlcyB0aGF0IHRoaXMgaXMgcHJlc2VydmVkIGV2ZW4gaWYgXCJcXHVGRUZGXCIgaXMgdHJhbnNmb3JtZWQgdG9cbiAgICAgICAgLy8gdGhlIGFjdHVhbCBVbmljb2RlIGNoYXJhY3RlciAoYnkgQmFiZWwsIGZvciBleGFtcGxlKS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzIvYmxvYi92Mi40LjIwL2xpYi9wYXJzZS5qcyNMMjE2XG4gICAgICAgIG5vZGUuaW5uZXJIVE1MID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZFRkYpICsgaHRtbDtcblxuICAgICAgICAvLyBkZWxldGVEYXRhIGxlYXZlcyBhbiBlbXB0eSBgVGV4dE5vZGVgIHdoaWNoIG9mZnNldHMgdGhlIGluZGV4IG9mIGFsbFxuICAgICAgICAvLyBjaGlsZHJlbi4gRGVmaW5pdGVseSB3YW50IHRvIGF2b2lkIHRoaXMuXG4gICAgICAgIHZhciB0ZXh0Tm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKHRleHROb2RlLmRhdGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZCh0ZXh0Tm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dE5vZGUuZGVsZXRlRGF0YSgwLCAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdGVzdEVsZW1lbnQgPSBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldElubmVySFRNTDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9zZXRJbm5lckhUTUwuanNcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBEYW5nZXIgPSByZXF1aXJlKCcuL0RhbmdlcicpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG5cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gcmVxdWlyZSgnLi9jcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uJyk7XG52YXIgc2V0SW5uZXJIVE1MID0gcmVxdWlyZSgnLi9zZXRJbm5lckhUTUwnKTtcbnZhciBzZXRUZXh0Q29udGVudCA9IHJlcXVpcmUoJy4vc2V0VGV4dENvbnRlbnQnKTtcblxuZnVuY3Rpb24gZ2V0Tm9kZUFmdGVyKHBhcmVudE5vZGUsIG5vZGUpIHtcbiAgLy8gU3BlY2lhbCBjYXNlIGZvciB0ZXh0IGNvbXBvbmVudHMsIHdoaWNoIHJldHVybiBbb3BlbiwgY2xvc2VdIGNvbW1lbnRzXG4gIC8vIGZyb20gZ2V0SG9zdE5vZGUuXG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgbm9kZSA9IG5vZGVbMV07XG4gIH1cbiAgcmV0dXJuIG5vZGUgPyBub2RlLm5leHRTaWJsaW5nIDogcGFyZW50Tm9kZS5maXJzdENoaWxkO1xufVxuXG4vKipcbiAqIEluc2VydHMgYGNoaWxkTm9kZWAgYXMgYSBjaGlsZCBvZiBgcGFyZW50Tm9kZWAgYXQgdGhlIGBpbmRleGAuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBwYXJlbnROb2RlIFBhcmVudCBub2RlIGluIHdoaWNoIHRvIGluc2VydC5cbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY2hpbGROb2RlIENoaWxkIG5vZGUgdG8gaW5zZXJ0LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRvIGluc2VydCB0aGUgY2hpbGQuXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIGluc2VydENoaWxkQXQgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uIChwYXJlbnROb2RlLCBjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgLy8gV2UgcmVseSBleGNsdXNpdmVseSBvbiBgaW5zZXJ0QmVmb3JlKG5vZGUsIG51bGwpYCBpbnN0ZWFkIG9mIGFsc28gdXNpbmdcbiAgLy8gYGFwcGVuZENoaWxkKG5vZGUpYC4gKFVzaW5nIGB1bmRlZmluZWRgIGlzIG5vdCBhbGxvd2VkIGJ5IGFsbCBicm93c2VycyBzb1xuICAvLyB3ZSBhcmUgY2FyZWZ1bCB0byB1c2UgYG51bGxgLilcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKTtcbn0pO1xuXG5mdW5jdGlvbiBpbnNlcnRMYXp5VHJlZUNoaWxkQXQocGFyZW50Tm9kZSwgY2hpbGRUcmVlLCByZWZlcmVuY2VOb2RlKSB7XG4gIERPTUxhenlUcmVlLmluc2VydFRyZWVCZWZvcmUocGFyZW50Tm9kZSwgY2hpbGRUcmVlLCByZWZlcmVuY2VOb2RlKTtcbn1cblxuZnVuY3Rpb24gbW92ZUNoaWxkKHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZE5vZGUpKSB7XG4gICAgbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgY2hpbGROb2RlWzBdLCBjaGlsZE5vZGVbMV0sIHJlZmVyZW5jZU5vZGUpO1xuICB9IGVsc2Uge1xuICAgIGluc2VydENoaWxkQXQocGFyZW50Tm9kZSwgY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZChwYXJlbnROb2RlLCBjaGlsZE5vZGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGROb2RlKSkge1xuICAgIHZhciBjbG9zaW5nQ29tbWVudCA9IGNoaWxkTm9kZVsxXTtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGVbMF07XG4gICAgcmVtb3ZlRGVsaW1pdGVkVGV4dChwYXJlbnROb2RlLCBjaGlsZE5vZGUsIGNsb3NpbmdDb21tZW50KTtcbiAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNsb3NpbmdDb21tZW50KTtcbiAgfVxuICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZSk7XG59XG5cbmZ1bmN0aW9uIG1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIG9wZW5pbmdDb21tZW50LCBjbG9zaW5nQ29tbWVudCwgcmVmZXJlbmNlTm9kZSkge1xuICB2YXIgbm9kZSA9IG9wZW5pbmdDb21tZW50O1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBuZXh0Tm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgaW5zZXJ0Q2hpbGRBdChwYXJlbnROb2RlLCBub2RlLCByZWZlcmVuY2VOb2RlKTtcbiAgICBpZiAobm9kZSA9PT0gY2xvc2luZ0NvbW1lbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBub2RlID0gbmV4dE5vZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlRGVsaW1pdGVkVGV4dChwYXJlbnROb2RlLCBzdGFydE5vZGUsIGNsb3NpbmdDb21tZW50KSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIG5vZGUgPSBzdGFydE5vZGUubmV4dFNpYmxpbmc7XG4gICAgaWYgKG5vZGUgPT09IGNsb3NpbmdDb21tZW50KSB7XG4gICAgICAvLyBUaGUgY2xvc2luZyBjb21tZW50IGlzIHJlbW92ZWQgYnkgUmVhY3RNdWx0aUNoaWxkLlxuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VEZWxpbWl0ZWRUZXh0KG9wZW5pbmdDb21tZW50LCBjbG9zaW5nQ29tbWVudCwgc3RyaW5nVGV4dCkge1xuICB2YXIgcGFyZW50Tm9kZSA9IG9wZW5pbmdDb21tZW50LnBhcmVudE5vZGU7XG4gIHZhciBub2RlQWZ0ZXJDb21tZW50ID0gb3BlbmluZ0NvbW1lbnQubmV4dFNpYmxpbmc7XG4gIGlmIChub2RlQWZ0ZXJDb21tZW50ID09PSBjbG9zaW5nQ29tbWVudCkge1xuICAgIC8vIFRoZXJlIGFyZSBubyB0ZXh0IG5vZGVzIGJldHdlZW4gdGhlIG9wZW5pbmcgYW5kIGNsb3NpbmcgY29tbWVudHM7IGluc2VydFxuICAgIC8vIGEgbmV3IG9uZSBpZiBzdHJpbmdUZXh0IGlzbid0IGVtcHR5LlxuICAgIGlmIChzdHJpbmdUZXh0KSB7XG4gICAgICBpbnNlcnRDaGlsZEF0KHBhcmVudE5vZGUsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHN0cmluZ1RleHQpLCBub2RlQWZ0ZXJDb21tZW50KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHN0cmluZ1RleHQpIHtcbiAgICAgIC8vIFNldCB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBmaXJzdCBub2RlIGFmdGVyIHRoZSBvcGVuaW5nIGNvbW1lbnQsIGFuZFxuICAgICAgLy8gcmVtb3ZlIGFsbCBmb2xsb3dpbmcgbm9kZXMgdXAgdW50aWwgdGhlIGNsb3NpbmcgY29tbWVudC5cbiAgICAgIHNldFRleHRDb250ZW50KG5vZGVBZnRlckNvbW1lbnQsIHN0cmluZ1RleHQpO1xuICAgICAgcmVtb3ZlRGVsaW1pdGVkVGV4dChwYXJlbnROb2RlLCBub2RlQWZ0ZXJDb21tZW50LCBjbG9zaW5nQ29tbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgb3BlbmluZ0NvbW1lbnQsIGNsb3NpbmdDb21tZW50KTtcbiAgICB9XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgaW5zdGFuY2VJRDogUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUob3BlbmluZ0NvbW1lbnQpLl9kZWJ1Z0lELFxuICAgICAgdHlwZTogJ3JlcGxhY2UgdGV4dCcsXG4gICAgICBwYXlsb2FkOiBzdHJpbmdUZXh0XG4gICAgfSk7XG4gIH1cbn1cblxudmFyIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwID0gRGFuZ2VyLmRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAgPSBmdW5jdGlvbiAob2xkQ2hpbGQsIG1hcmt1cCwgcHJldkluc3RhbmNlKSB7XG4gICAgRGFuZ2VyLmRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKG9sZENoaWxkLCBtYXJrdXApO1xuICAgIGlmIChwcmV2SW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICBpbnN0YW5jZUlEOiBwcmV2SW5zdGFuY2UuX2RlYnVnSUQsXG4gICAgICAgIHR5cGU6ICdyZXBsYWNlIHdpdGgnLFxuICAgICAgICBwYXlsb2FkOiBtYXJrdXAudG9TdHJpbmcoKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBuZXh0SW5zdGFuY2UgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShtYXJrdXAubm9kZSk7XG4gICAgICBpZiAobmV4dEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICAgIGluc3RhbmNlSUQ6IG5leHRJbnN0YW5jZS5fZGVidWdJRCxcbiAgICAgICAgICB0eXBlOiAnbW91bnQnLFxuICAgICAgICAgIHBheWxvYWQ6IG1hcmt1cC50b1N0cmluZygpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciB1cGRhdGluZyB3aXRoIERPTSBjaGlsZHJlbi5cbiAqL1xudmFyIERPTUNoaWxkcmVuT3BlcmF0aW9ucyA9IHtcblxuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cDogZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAsXG5cbiAgcmVwbGFjZURlbGltaXRlZFRleHQ6IHJlcGxhY2VEZWxpbWl0ZWRUZXh0LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgY29tcG9uZW50J3MgY2hpbGRyZW4gYnkgcHJvY2Vzc2luZyBhIHNlcmllcyBvZiB1cGRhdGVzLiBUaGVcbiAgICogdXBkYXRlIGNvbmZpZ3VyYXRpb25zIGFyZSBlYWNoIGV4cGVjdGVkIHRvIGhhdmUgYSBgcGFyZW50Tm9kZWAgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXk8b2JqZWN0Pn0gdXBkYXRlcyBMaXN0IG9mIHVwZGF0ZSBjb25maWd1cmF0aW9ucy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm9jZXNzVXBkYXRlczogZnVuY3Rpb24gKHBhcmVudE5vZGUsIHVwZGF0ZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHBhcmVudE5vZGVEZWJ1Z0lEID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUocGFyZW50Tm9kZSkuX2RlYnVnSUQ7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCB1cGRhdGVzLmxlbmd0aDsgaysrKSB7XG4gICAgICB2YXIgdXBkYXRlID0gdXBkYXRlc1trXTtcbiAgICAgIHN3aXRjaCAodXBkYXRlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnSU5TRVJUX01BUktVUCc6XG4gICAgICAgICAgaW5zZXJ0TGF6eVRyZWVDaGlsZEF0KHBhcmVudE5vZGUsIHVwZGF0ZS5jb250ZW50LCBnZXROb2RlQWZ0ZXIocGFyZW50Tm9kZSwgdXBkYXRlLmFmdGVyTm9kZSkpO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgICAgICAgICAgaW5zdGFuY2VJRDogcGFyZW50Tm9kZURlYnVnSUQsXG4gICAgICAgICAgICAgIHR5cGU6ICdpbnNlcnQgY2hpbGQnLFxuICAgICAgICAgICAgICBwYXlsb2FkOiB7IHRvSW5kZXg6IHVwZGF0ZS50b0luZGV4LCBjb250ZW50OiB1cGRhdGUuY29udGVudC50b1N0cmluZygpIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTU9WRV9FWElTVElORyc6XG4gICAgICAgICAgbW92ZUNoaWxkKHBhcmVudE5vZGUsIHVwZGF0ZS5mcm9tTm9kZSwgZ2V0Tm9kZUFmdGVyKHBhcmVudE5vZGUsIHVwZGF0ZS5hZnRlck5vZGUpKTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgICAgICAgIGluc3RhbmNlSUQ6IHBhcmVudE5vZGVEZWJ1Z0lELFxuICAgICAgICAgICAgICB0eXBlOiAnbW92ZSBjaGlsZCcsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IHsgZnJvbUluZGV4OiB1cGRhdGUuZnJvbUluZGV4LCB0b0luZGV4OiB1cGRhdGUudG9JbmRleCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1NFVF9NQVJLVVAnOlxuICAgICAgICAgIHNldElubmVySFRNTChwYXJlbnROb2RlLCB1cGRhdGUuY29udGVudCk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICAgICAgICBpbnN0YW5jZUlEOiBwYXJlbnROb2RlRGVidWdJRCxcbiAgICAgICAgICAgICAgdHlwZTogJ3JlcGxhY2UgY2hpbGRyZW4nLFxuICAgICAgICAgICAgICBwYXlsb2FkOiB1cGRhdGUuY29udGVudC50b1N0cmluZygpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1RFWFRfQ09OVEVOVCc6XG4gICAgICAgICAgc2V0VGV4dENvbnRlbnQocGFyZW50Tm9kZSwgdXBkYXRlLmNvbnRlbnQpO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgICAgICAgICAgaW5zdGFuY2VJRDogcGFyZW50Tm9kZURlYnVnSUQsXG4gICAgICAgICAgICAgIHR5cGU6ICdyZXBsYWNlIHRleHQnLFxuICAgICAgICAgICAgICBwYXlsb2FkOiB1cGRhdGUuY29udGVudC50b1N0cmluZygpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1JFTU9WRV9OT0RFJzpcbiAgICAgICAgICByZW1vdmVDaGlsZChwYXJlbnROb2RlLCB1cGRhdGUuZnJvbU5vZGUpO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgICAgICAgICAgaW5zdGFuY2VJRDogcGFyZW50Tm9kZURlYnVnSUQsXG4gICAgICAgICAgICAgIHR5cGU6ICdyZW1vdmUgY2hpbGQnLFxuICAgICAgICAgICAgICBwYXlsb2FkOiB7IGZyb21JbmRleDogdXBkYXRlLmZyb21JbmRleCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NQ2hpbGRyZW5PcGVyYXRpb25zO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL0RPTUNoaWxkcmVuT3BlcmF0aW9ucy5qc1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTU5hbWVzcGFjZXMgPSB7XG4gIGh0bWw6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJyxcbiAgbWF0aG1sOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCcsXG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01OYW1lc3BhY2VzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL0RPTU5hbWVzcGFjZXMuanNcbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEVycm9yVXRpbHMgPSByZXF1aXJlKCcuL1JlYWN0RXJyb3JVdGlscycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBJbmplY3RlZCBkZXBlbmRlbmNpZXM6XG4gKi9cblxuLyoqXG4gKiAtIGBDb21wb25lbnRUcmVlYDogW3JlcXVpcmVkXSBNb2R1bGUgdGhhdCBjYW4gY29udmVydCBiZXR3ZWVuIFJlYWN0IGluc3RhbmNlc1xuICogICBhbmQgYWN0dWFsIG5vZGUgcmVmZXJlbmNlcy5cbiAqL1xudmFyIENvbXBvbmVudFRyZWU7XG52YXIgVHJlZVRyYXZlcnNhbDtcbnZhciBpbmplY3Rpb24gPSB7XG4gIGluamVjdENvbXBvbmVudFRyZWU6IGZ1bmN0aW9uIChJbmplY3RlZCkge1xuICAgIENvbXBvbmVudFRyZWUgPSBJbmplY3RlZDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoSW5qZWN0ZWQgJiYgSW5qZWN0ZWQuZ2V0Tm9kZUZyb21JbnN0YW5jZSAmJiBJbmplY3RlZC5nZXRJbnN0YW5jZUZyb21Ob2RlLCAnRXZlbnRQbHVnaW5VdGlscy5pbmplY3Rpb24uaW5qZWN0Q29tcG9uZW50VHJlZSguLi4pOiBJbmplY3RlZCAnICsgJ21vZHVsZSBpcyBtaXNzaW5nIGdldE5vZGVGcm9tSW5zdGFuY2Ugb3IgZ2V0SW5zdGFuY2VGcm9tTm9kZS4nKSA6IHZvaWQgMDtcbiAgICB9XG4gIH0sXG4gIGluamVjdFRyZWVUcmF2ZXJzYWw6IGZ1bmN0aW9uIChJbmplY3RlZCkge1xuICAgIFRyZWVUcmF2ZXJzYWwgPSBJbmplY3RlZDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoSW5qZWN0ZWQgJiYgSW5qZWN0ZWQuaXNBbmNlc3RvciAmJiBJbmplY3RlZC5nZXRMb3dlc3RDb21tb25BbmNlc3RvciwgJ0V2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLmluamVjdFRyZWVUcmF2ZXJzYWwoLi4uKTogSW5qZWN0ZWQgJyArICdtb2R1bGUgaXMgbWlzc2luZyBpc0FuY2VzdG9yIG9yIGdldExvd2VzdENvbW1vbkFuY2VzdG9yLicpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gaXNFbmRpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09ICd0b3BNb3VzZVVwJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BUb3VjaEVuZCcgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wVG91Y2hDYW5jZWwnO1xufVxuXG5mdW5jdGlvbiBpc01vdmVpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09ICd0b3BNb3VzZU1vdmUnIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcFRvdWNoTW92ZSc7XG59XG5mdW5jdGlvbiBpc1N0YXJ0aXNoKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSAndG9wTW91c2VEb3duJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BUb3VjaFN0YXJ0Jztcbn1cblxudmFyIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gICAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuXG4gICAgdmFyIGxpc3RlbmVyc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycyk7XG4gICAgdmFyIGxpc3RlbmVyc0xlbiA9IGxpc3RlbmVyc0lzQXJyID8gZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoIDogZGlzcGF0Y2hMaXN0ZW5lcnMgPyAxIDogMDtcblxuICAgIHZhciBpbnN0YW5jZXNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hJbnN0YW5jZXMpO1xuICAgIHZhciBpbnN0YW5jZXNMZW4gPSBpbnN0YW5jZXNJc0FyciA/IGRpc3BhdGNoSW5zdGFuY2VzLmxlbmd0aCA6IGRpc3BhdGNoSW5zdGFuY2VzID8gMSA6IDA7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpbnN0YW5jZXNJc0FyciA9PT0gbGlzdGVuZXJzSXNBcnIgJiYgaW5zdGFuY2VzTGVuID09PSBsaXN0ZW5lcnNMZW4sICdFdmVudFBsdWdpblV0aWxzOiBJbnZhbGlkIGBldmVudGAuJykgOiB2b2lkIDA7XG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggdGhlIGV2ZW50IHRvIHRoZSBsaXN0ZW5lci5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFN5bnRoZXRpY0V2ZW50IHRvIGhhbmRsZVxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciBBcHBsaWNhdGlvbi1sZXZlbCBjYWxsYmFja1xuICogQHBhcmFtIHsqfSBpbnN0IEludGVybmFsIGNvbXBvbmVudCBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgbGlzdGVuZXIsIGluc3QpIHtcbiAgdmFyIHR5cGUgPSBldmVudC50eXBlIHx8ICd1bmtub3duLWV2ZW50JztcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IEV2ZW50UGx1Z2luVXRpbHMuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgaWYgKHNpbXVsYXRlZCkge1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2tXaXRoQ2F0Y2godHlwZSwgbGlzdGVuZXIsIGV2ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrKHR5cGUsIGxpc3RlbmVyLCBldmVudCk7XG4gIH1cbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG59XG5cbi8qKlxuICogU3RhbmRhcmQvc2ltcGxlIGl0ZXJhdGlvbiB0aHJvdWdoIGFuIGV2ZW50J3MgY29sbGVjdGVkIGRpc3BhdGNoZXMuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgc2ltdWxhdGVkKSB7XG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSW5zdGFuY2VzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzW2ldLCBkaXNwYXRjaEluc3RhbmNlc1tpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzLCBkaXNwYXRjaEluc3RhbmNlcyk7XG4gIH1cbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcywgYnV0IHN0b3BzXG4gKiBhdCB0aGUgZmlyc3QgZGlzcGF0Y2ggZXhlY3V0aW9uIHJldHVybmluZyB0cnVlLCBhbmQgcmV0dXJucyB0aGF0IGlkLlxuICpcbiAqIEByZXR1cm4gez9zdHJpbmd9IGlkIG9mIHRoZSBmaXJzdCBkaXNwYXRjaCBleGVjdXRpb24gd2hvJ3MgbGlzdGVuZXIgcmV0dXJuc1xuICogdHJ1ZSwgb3IgbnVsbCBpZiBubyBsaXN0ZW5lciByZXR1cm5lZCB0cnVlLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbChldmVudCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBMaXN0ZW5lcnMgYW5kIEluc3RhbmNlcyBhcmUgdHdvIHBhcmFsbGVsIGFycmF5cyB0aGF0IGFyZSBhbHdheXMgaW4gc3luYy5cbiAgICAgIGlmIChkaXNwYXRjaExpc3RlbmVyc1tpXShldmVudCwgZGlzcGF0Y2hJbnN0YW5jZXNbaV0pKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaEluc3RhbmNlc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMpIHtcbiAgICBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMoZXZlbnQsIGRpc3BhdGNoSW5zdGFuY2VzKSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoSW5zdGFuY2VzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAc2VlIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWUoZXZlbnQpIHtcbiAgdmFyIHJldCA9IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsKGV2ZW50KTtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBFeGVjdXRpb24gb2YgYSBcImRpcmVjdFwiIGRpc3BhdGNoIC0gdGhlcmUgbXVzdCBiZSBhdCBtb3N0IG9uZSBkaXNwYXRjaFxuICogYWNjdW11bGF0ZWQgb24gdGhlIGV2ZW50IG9yIGl0IGlzIGNvbnNpZGVyZWQgYW4gZXJyb3IuIEl0IGRvZXNuJ3QgcmVhbGx5IG1ha2VcbiAqIHNlbnNlIGZvciBhbiBldmVudCB3aXRoIG11bHRpcGxlIGRpc3BhdGNoZXMgKGJ1YmJsZWQpIHRvIGtlZXAgdHJhY2sgb2YgdGhlXG4gKiByZXR1cm4gdmFsdWVzIGF0IGVhY2ggZGlzcGF0Y2ggZXhlY3V0aW9uLCBidXQgaXQgZG9lcyB0ZW5kIHRvIG1ha2Ugc2Vuc2Ugd2hlblxuICogZGVhbGluZyB3aXRoIFwiZGlyZWN0XCIgZGlzcGF0Y2hlcy5cbiAqXG4gKiBAcmV0dXJuIHsqfSBUaGUgcmV0dXJuIHZhbHVlIG9mIGV4ZWN1dGluZyB0aGUgc2luZ2xlIGRpc3BhdGNoLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlyZWN0RGlzcGF0Y2goZXZlbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXIgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuICAhIUFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZXhlY3V0ZURpcmVjdERpc3BhdGNoKC4uLik6IEludmFsaWQgYGV2ZW50YC4nKSA6IF9wcm9kSW52YXJpYW50KCcxMDMnKSA6IHZvaWQgMDtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IGRpc3BhdGNoTGlzdGVuZXIgPyBFdmVudFBsdWdpblV0aWxzLmdldE5vZGVGcm9tSW5zdGFuY2UoZGlzcGF0Y2hJbnN0YW5jZSkgOiBudWxsO1xuICB2YXIgcmVzID0gZGlzcGF0Y2hMaXN0ZW5lciA/IGRpc3BhdGNoTGlzdGVuZXIoZXZlbnQpIDogbnVsbDtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IG51bGw7XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWZmIG51bWJlciBvZiBkaXNwYXRjaGVzIGFjY3VtdWxhdGVkIGlzIGdyZWF0ZXIgdGhhbiAwLlxuICovXG5mdW5jdGlvbiBoYXNEaXNwYXRjaGVzKGV2ZW50KSB7XG4gIHJldHVybiAhIWV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbn1cblxuLyoqXG4gKiBHZW5lcmFsIHV0aWxpdGllcyB0aGF0IGFyZSB1c2VmdWwgaW4gY3JlYXRpbmcgY3VzdG9tIEV2ZW50IFBsdWdpbnMuXG4gKi9cbnZhciBFdmVudFBsdWdpblV0aWxzID0ge1xuICBpc0VuZGlzaDogaXNFbmRpc2gsXG4gIGlzTW92ZWlzaDogaXNNb3ZlaXNoLFxuICBpc1N0YXJ0aXNoOiBpc1N0YXJ0aXNoLFxuXG4gIGV4ZWN1dGVEaXJlY3REaXNwYXRjaDogZXhlY3V0ZURpcmVjdERpc3BhdGNoLFxuICBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXI6IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcixcbiAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZTogZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZSxcbiAgaGFzRGlzcGF0Y2hlczogaGFzRGlzcGF0Y2hlcyxcblxuICBnZXRJbnN0YW5jZUZyb21Ob2RlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBDb21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSk7XG4gIH0sXG4gIGdldE5vZGVGcm9tSW5zdGFuY2U6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIENvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShub2RlKTtcbiAgfSxcbiAgaXNBbmNlc3RvcjogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC5pc0FuY2VzdG9yKGEsIGIpO1xuICB9LFxuICBnZXRMb3dlc3RDb21tb25BbmNlc3RvcjogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC5nZXRMb3dlc3RDb21tb25BbmNlc3RvcihhLCBiKTtcbiAgfSxcbiAgZ2V0UGFyZW50SW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgcmV0dXJuIFRyZWVUcmF2ZXJzYWwuZ2V0UGFyZW50SW5zdGFuY2UoaW5zdCk7XG4gIH0sXG4gIHRyYXZlcnNlVHdvUGhhc2U6IGZ1bmN0aW9uICh0YXJnZXQsIGZuLCBhcmcpIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC50cmF2ZXJzZVR3b1BoYXNlKHRhcmdldCwgZm4sIGFyZyk7XG4gIH0sXG4gIHRyYXZlcnNlRW50ZXJMZWF2ZTogZnVuY3Rpb24gKGZyb20sIHRvLCBmbiwgYXJnRnJvbSwgYXJnVG8pIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC50cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGZuLCBhcmdGcm9tLCBhcmdUbyk7XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiBpbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQbHVnaW5VdGlscztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9FdmVudFBsdWdpblV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRXNjYXBlIGFuZCB3cmFwIGtleSBzbyBpdCBpcyBzYWZlIHRvIHVzZSBhcyBhIHJlYWN0aWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBlc2NhcGVkIGtleS5cbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGUoa2V5KSB7XG4gIHZhciBlc2NhcGVSZWdleCA9IC9bPTpdL2c7XG4gIHZhciBlc2NhcGVyTG9va3VwID0ge1xuICAgICc9JzogJz0wJyxcbiAgICAnOic6ICc9MidcbiAgfTtcbiAgdmFyIGVzY2FwZWRTdHJpbmcgPSAoJycgKyBrZXkpLnJlcGxhY2UoZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBlc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG5cbiAgcmV0dXJuICckJyArIGVzY2FwZWRTdHJpbmc7XG59XG5cbi8qKlxuICogVW5lc2NhcGUgYW5kIHVud3JhcCBrZXkgZm9yIGh1bWFuLXJlYWRhYmxlIGRpc3BsYXlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIHVuZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgdW5lc2NhcGVkIGtleS5cbiAqL1xuZnVuY3Rpb24gdW5lc2NhcGUoa2V5KSB7XG4gIHZhciB1bmVzY2FwZVJlZ2V4ID0gLyg9MHw9MikvZztcbiAgdmFyIHVuZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPTAnOiAnPScsXG4gICAgJz0yJzogJzonXG4gIH07XG4gIHZhciBrZXlTdWJzdHJpbmcgPSBrZXlbMF0gPT09ICcuJyAmJiBrZXlbMV0gPT09ICckJyA/IGtleS5zdWJzdHJpbmcoMikgOiBrZXkuc3Vic3RyaW5nKDEpO1xuXG4gIHJldHVybiAoJycgKyBrZXlTdWJzdHJpbmcpLnJlcGxhY2UodW5lc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIHVuZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xufVxuXG52YXIgS2V5RXNjYXBlVXRpbHMgPSB7XG4gIGVzY2FwZTogZXNjYXBlLFxuICB1bmVzY2FwZTogdW5lc2NhcGVcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gS2V5RXNjYXBlVXRpbHM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvS2V5RXNjYXBlVXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdCcpO1xudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGhhc1JlYWRPbmx5VmFsdWUgPSB7XG4gICdidXR0b24nOiB0cnVlLFxuICAnY2hlY2tib3gnOiB0cnVlLFxuICAnaW1hZ2UnOiB0cnVlLFxuICAnaGlkZGVuJzogdHJ1ZSxcbiAgJ3JhZGlvJzogdHJ1ZSxcbiAgJ3Jlc2V0JzogdHJ1ZSxcbiAgJ3N1Ym1pdCc6IHRydWVcbn07XG5cbmZ1bmN0aW9uIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0UHJvcHMpIHtcbiAgIShpbnB1dFByb3BzLmNoZWNrZWRMaW5rID09IG51bGwgfHwgaW5wdXRQcm9wcy52YWx1ZUxpbmsgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSBjaGVja2VkTGluayBhbmQgYSB2YWx1ZUxpbmsuIElmIHlvdSB3YW50IHRvIHVzZSBjaGVja2VkTGluaywgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgdmFsdWVMaW5rIGFuZCB2aWNlIHZlcnNhLicpIDogX3Byb2RJbnZhcmlhbnQoJzg3JykgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0UHJvcHMpIHtcbiAgX2Fzc2VydFNpbmdsZUxpbmsoaW5wdXRQcm9wcyk7XG4gICEoaW5wdXRQcm9wcy52YWx1ZSA9PSBudWxsICYmIGlucHV0UHJvcHMub25DaGFuZ2UgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSB2YWx1ZUxpbmsgYW5kIGEgdmFsdWUgb3Igb25DaGFuZ2UgZXZlbnQuIElmIHlvdSB3YW50IHRvIHVzZSB2YWx1ZSBvciBvbkNoYW5nZSwgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgdmFsdWVMaW5rLicpIDogX3Byb2RJbnZhcmlhbnQoJzg4JykgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRDaGVja2VkTGluayhpbnB1dFByb3BzKSB7XG4gIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0UHJvcHMpO1xuICAhKGlucHV0UHJvcHMuY2hlY2tlZCA9PSBudWxsICYmIGlucHV0UHJvcHMub25DaGFuZ2UgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSBjaGVja2VkTGluayBhbmQgYSBjaGVja2VkIHByb3BlcnR5IG9yIG9uQ2hhbmdlIGV2ZW50LiBJZiB5b3Ugd2FudCB0byB1c2UgY2hlY2tlZCBvciBvbkNoYW5nZSwgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgY2hlY2tlZExpbmsnKSA6IF9wcm9kSW52YXJpYW50KCc4OScpIDogdm9pZCAwO1xufVxuXG52YXIgcHJvcFR5cGVzID0ge1xuICB2YWx1ZTogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8IGhhc1JlYWRPbmx5VmFsdWVbcHJvcHMudHlwZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICB9LFxuICBjaGVja2VkOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgfSxcbiAgb25DaGFuZ2U6IFJlYWN0LlByb3BUeXBlcy5mdW5jXG59O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpIHtcbiAgaWYgKG93bmVyKSB7XG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBQcm92aWRlIGEgbGlua2VkIGB2YWx1ZWAgYXR0cmlidXRlIGZvciBjb250cm9sbGVkIGZvcm1zLiBZb3Ugc2hvdWxkIG5vdCB1c2VcbiAqIHRoaXMgb3V0c2lkZSBvZiB0aGUgUmVhY3RET00gY29udHJvbGxlZCBmb3JtIGNvbXBvbmVudHMuXG4gKi9cbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0ge1xuICBjaGVja1Byb3BUeXBlczogZnVuY3Rpb24gKHRhZ05hbWUsIHByb3BzLCBvd25lcikge1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BUeXBlcykge1xuICAgICAgaWYgKHByb3BUeXBlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yID0gcHJvcFR5cGVzW3Byb3BOYW1lXShwcm9wcywgcHJvcE5hbWUsIHRhZ05hbWUsICdwcm9wJywgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgdmFyIGFkZGVuZHVtID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgZm9ybSBwcm9wVHlwZTogJXMlcycsIGVycm9yLm1lc3NhZ2UsIGFkZGVuZHVtKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnB1dFByb3BzIFByb3BzIGZvciBmb3JtIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHsqfSBjdXJyZW50IHZhbHVlIG9mIHRoZSBpbnB1dCBlaXRoZXIgZnJvbSB2YWx1ZSBwcm9wIG9yIGxpbmsuXG4gICAqL1xuICBnZXRWYWx1ZTogZnVuY3Rpb24gKGlucHV0UHJvcHMpIHtcbiAgICBpZiAoaW5wdXRQcm9wcy52YWx1ZUxpbmspIHtcbiAgICAgIF9hc3NlcnRWYWx1ZUxpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy52YWx1ZUxpbmsudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dFByb3BzLnZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5wdXRQcm9wcyBQcm9wcyBmb3IgZm9ybSBjb21wb25lbnRcbiAgICogQHJldHVybiB7Kn0gY3VycmVudCBjaGVja2VkIHN0YXR1cyBvZiB0aGUgaW5wdXQgZWl0aGVyIGZyb20gY2hlY2tlZCBwcm9wXG4gICAqICAgICAgICAgICAgIG9yIGxpbmsuXG4gICAqL1xuICBnZXRDaGVja2VkOiBmdW5jdGlvbiAoaW5wdXRQcm9wcykge1xuICAgIGlmIChpbnB1dFByb3BzLmNoZWNrZWRMaW5rKSB7XG4gICAgICBfYXNzZXJ0Q2hlY2tlZExpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy5jaGVja2VkTGluay52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0UHJvcHMuY2hlY2tlZDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGlucHV0UHJvcHMgUHJvcHMgZm9yIGZvcm0gY29tcG9uZW50XG4gICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IGNoYW5nZSBldmVudCB0byBoYW5kbGVcbiAgICovXG4gIGV4ZWN1dGVPbkNoYW5nZTogZnVuY3Rpb24gKGlucHV0UHJvcHMsIGV2ZW50KSB7XG4gICAgaWYgKGlucHV0UHJvcHMudmFsdWVMaW5rKSB7XG4gICAgICBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMudmFsdWVMaW5rLnJlcXVlc3RDaGFuZ2UoZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0UHJvcHMuY2hlY2tlZExpbmspIHtcbiAgICAgIF9hc3NlcnRDaGVja2VkTGluayhpbnB1dFByb3BzKTtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLmNoZWNrZWRMaW5rLnJlcXVlc3RDaGFuZ2UoZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRQcm9wcy5vbkNoYW5nZSkge1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMub25DaGFuZ2UuY2FsbCh1bmRlZmluZWQsIGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGlua2VkVmFsdWVVdGlscztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9MaW5rZWRWYWx1ZVV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIGluamVjdGVkID0gZmFsc2U7XG5cbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0ge1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbGx5IGluamVjdGFibGUgaG9vayBmb3Igc3dhcHBpbmcgb3V0IG1vdW50IGltYWdlcyBpbiB0aGUgbWlkZGxlIG9mXG4gICAqIHRoZSB0cmVlLlxuICAgKi9cbiAgcmVwbGFjZU5vZGVXaXRoTWFya3VwOiBudWxsLFxuXG4gIC8qKlxuICAgKiBPcHRpb25hbGx5IGluamVjdGFibGUgaG9vayBmb3IgcHJvY2Vzc2luZyBhIHF1ZXVlIG9mIGNoaWxkIHVwZGF0ZXMuIFdpbGxcbiAgICogbGF0ZXIgbW92ZSBpbnRvIE11bHRpQ2hpbGRDb21wb25lbnRzLlxuICAgKi9cbiAgcHJvY2Vzc0NoaWxkcmVuVXBkYXRlczogbnVsbCxcblxuICBpbmplY3Rpb246IHtcbiAgICBpbmplY3RFbnZpcm9ubWVudDogZnVuY3Rpb24gKGVudmlyb25tZW50KSB7XG4gICAgICAhIWluamVjdGVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50OiBpbmplY3RFbnZpcm9ubWVudCgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLicpIDogX3Byb2RJbnZhcmlhbnQoJzEwNCcpIDogdm9pZCAwO1xuICAgICAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5yZXBsYWNlTm9kZVdpdGhNYXJrdXAgPSBlbnZpcm9ubWVudC5yZXBsYWNlTm9kZVdpdGhNYXJrdXA7XG4gICAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnByb2Nlc3NDaGlsZHJlblVwZGF0ZXMgPSBlbnZpcm9ubWVudC5wcm9jZXNzQ2hpbGRyZW5VcGRhdGVzO1xuICAgICAgaW5qZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5qc1xuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2F1Z2h0RXJyb3IgPSBudWxsO1xuXG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiB3aGlsZSBndWFyZGluZyBhZ2FpbnN0IGVycm9ycyB0aGF0IGhhcHBlbnMgd2l0aGluIGl0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHRoZSBndWFyZCB0byB1c2UgZm9yIGxvZ2dpbmcgb3IgZGVidWdnaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAqIEBwYXJhbSB7Kn0gYSBGaXJzdCBhcmd1bWVudFxuICogQHBhcmFtIHsqfSBiIFNlY29uZCBhcmd1bWVudFxuICovXG5mdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobmFtZSwgZnVuYywgYSkge1xuICB0cnkge1xuICAgIGZ1bmMoYSk7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICBpZiAoY2F1Z2h0RXJyb3IgPT09IG51bGwpIHtcbiAgICAgIGNhdWdodEVycm9yID0geDtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0RXJyb3JVdGlscyA9IHtcbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrOiBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssXG5cbiAgLyoqXG4gICAqIEludm9rZWQgYnkgUmVhY3RUZXN0VXRpbHMuU2ltdWxhdGUgc28gdGhhdCBhbnkgZXJyb3JzIHRocm93biBieSB0aGUgZXZlbnRcbiAgICogaGFuZGxlciBhcmUgc3VyZSB0byBiZSByZXRocm93biBieSByZXRocm93Q2F1Z2h0RXJyb3IuXG4gICAqL1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tXaXRoQ2F0Y2g6IGludm9rZUd1YXJkZWRDYWxsYmFjayxcblxuICAvKipcbiAgICogRHVyaW5nIGV4ZWN1dGlvbiBvZiBndWFyZGVkIGZ1bmN0aW9ucyB3ZSB3aWxsIGNhcHR1cmUgdGhlIGZpcnN0IGVycm9yIHdoaWNoXG4gICAqIHdlIHdpbGwgcmV0aHJvdyB0byBiZSBoYW5kbGVkIGJ5IHRoZSB0b3AgbGV2ZWwgZXJyb3IgaGFuZGxlci5cbiAgICovXG4gIHJldGhyb3dDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYXVnaHRFcnJvcikge1xuICAgICAgdmFyIGVycm9yID0gY2F1Z2h0RXJyb3I7XG4gICAgICBjYXVnaHRFcnJvciA9IG51bGw7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn07XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8qKlxuICAgKiBUbyBoZWxwIGRldmVsb3BtZW50IHdlIGNhbiBnZXQgYmV0dGVyIGRldnRvb2xzIGludGVncmF0aW9uIGJ5IHNpbXVsYXRpbmcgYVxuICAgKiByZWFsIGJyb3dzZXIgZXZlbnQuXG4gICAqL1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kaXNwYXRjaEV2ZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGZha2VOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncmVhY3QnKTtcbiAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMsIGEpIHtcbiAgICAgIHZhciBib3VuZEZ1bmMgPSBmdW5jLmJpbmQobnVsbCwgYSk7XG4gICAgICB2YXIgZXZ0VHlwZSA9ICdyZWFjdC0nICsgbmFtZTtcbiAgICAgIGZha2VOb2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgYm91bmRGdW5jLCBmYWxzZSk7XG4gICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAvLyAkRmxvd0ZpeE1lIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yMzM2XG4gICAgICBldnQuaW5pdEV2ZW50KGV2dFR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICBmYWtlTm9kZS5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgICBmYWtlTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGJvdW5kRnVuYywgZmFsc2UpO1xuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVycm9yVXRpbHM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RFcnJvclV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSkge1xuICBSZWFjdFVwZGF0ZXMuZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VW5leHBlY3RlZEFyZ3VtZW50KGFyZykge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBhcmc7XG4gIGlmICh0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIHZhciBkaXNwbGF5TmFtZSA9IGFyZy5jb25zdHJ1Y3RvciAmJiBhcmcuY29uc3RydWN0b3IubmFtZSB8fCB0eXBlO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFyZyk7XG4gIGlmIChrZXlzLmxlbmd0aCA+IDAgJiYga2V5cy5sZW5ndGggPCAyMCkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZSArICcgKGtleXM6ICcgKyBrZXlzLmpvaW4oJywgJykgKyAnKSc7XG4gIH1cbiAgcmV0dXJuIGRpc3BsYXlOYW1lO1xufVxuXG5mdW5jdGlvbiBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBSZWFjdEluc3RhbmNlTWFwLmdldChwdWJsaWNJbnN0YW5jZSk7XG4gIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgY3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgICAgLy8gT25seSB3YXJuIHdoZW4gd2UgaGF2ZSBhIGNhbGxlck5hbWUuIE90aGVyd2lzZSB3ZSBzaG91bGQgYmUgc2lsZW50LlxuICAgICAgLy8gV2UncmUgcHJvYmFibHkgY2FsbGluZyBmcm9tIGVucXVldWVDYWxsYmFjay4gV2UgZG9uJ3Qgd2FudCB0byB3YXJuXG4gICAgICAvLyB0aGVyZSBiZWNhdXNlIHdlIGFscmVhZHkgd2FybmVkIGZvciB0aGUgY29ycmVzcG9uZGluZyBsaWZlY3ljbGUgbWV0aG9kLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNhbGxlck5hbWUsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuICcgKyAnVGhpcyBpcyBhIG5vLW9wLiBQbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgY3RvciAmJiAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJykgOiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsICclcyguLi4pOiBDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uIChzdWNoIGFzICcgKyAnd2l0aGluIGByZW5kZXJgIG9yIGFub3RoZXIgY29tcG9uZW50XFwncyBjb25zdHJ1Y3RvcikuIFJlbmRlciBtZXRob2RzICcgKyAnc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7IGNvbnN0cnVjdG9yICcgKyAnc2lkZS1lZmZlY3RzIGFyZSBhbiBhbnRpLXBhdHRlcm4sIGJ1dCBjYW4gYmUgbW92ZWQgdG8gJyArICdgY29tcG9uZW50V2lsbE1vdW50YC4nLCBjYWxsZXJOYW1lKSA6IHZvaWQgMDtcbiAgfVxuXG4gIHJldHVybiBpbnRlcm5hbEluc3RhbmNlO1xufVxuXG4vKipcbiAqIFJlYWN0VXBkYXRlUXVldWUgYWxsb3dzIGZvciBzdGF0ZSB1cGRhdGVzIHRvIGJlIHNjaGVkdWxlZCBpbnRvIGEgbGF0ZXJcbiAqIHJlY29uY2lsaWF0aW9uIHN0ZXAuXG4gKi9cbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0ge1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgICAgaWYgKG93bmVyICE9PSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciwgJyVzIGlzIGFjY2Vzc2luZyBpc01vdW50ZWQgaW5zaWRlIGl0cyByZW5kZXIoKSBmdW5jdGlvbi4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgICAgb3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBSZWFjdEluc3RhbmNlTWFwLmdldChwdWJsaWNJbnN0YW5jZSk7XG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIC8vIER1cmluZyBjb21wb25lbnRXaWxsTW91bnQgYW5kIHJlbmRlciB0aGlzIHdpbGwgc3RpbGwgYmUgbnVsbCBidXQgYWZ0ZXJcbiAgICAgIC8vIHRoYXQgd2lsbCBhbHdheXMgcmVuZGVyIHRvIHNvbWV0aGluZy4gQXQgbGVhc3QgZm9yIG5vdy4gU28gd2UgY2FuIHVzZVxuICAgICAgLy8gdGhpcyBoYWNrLlxuICAgICAgcmV0dXJuICEhaW50ZXJuYWxJbnN0YW5jZS5fcmVuZGVyZWRDb21wb25lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVucXVldWUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgYWxsIHRoZSBwZW5kaW5nIHVwZGF0ZXNcbiAgICogaGF2ZSBwcm9jZXNzZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIHVzZSBhcyBgdGhpc2AgY29udGV4dC5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FsbGVyTmFtZSBOYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVDYWxsYmFjazogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIFJlYWN0VXBkYXRlUXVldWUudmFsaWRhdGVDYWxsYmFjayhjYWxsYmFjaywgY2FsbGVyTmFtZSk7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UpO1xuXG4gICAgLy8gUHJldmlvdXNseSB3ZSB3b3VsZCB0aHJvdyBhbiBlcnJvciBpZiB3ZSBkaWRuJ3QgaGF2ZSBhbiBpbnRlcm5hbFxuICAgIC8vIGluc3RhbmNlLiBTaW5jZSB3ZSB3YW50IHRvIG1ha2UgaXQgYSBuby1vcCBpbnN0ZWFkLCB3ZSBtaXJyb3IgdGhlIHNhbWVcbiAgICAvLyBiZWhhdmlvciB3ZSBoYXZlIGluIG90aGVyIGVucXVldWUqIG1ldGhvZHMuXG4gICAgLy8gV2UgYWxzbyBuZWVkIHRvIGlnbm9yZSBjYWxsYmFja3MgaW4gY29tcG9uZW50V2lsbE1vdW50LiBTZWVcbiAgICAvLyBlbnF1ZXVlVXBkYXRlcy5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzKSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzID0gW2NhbGxiYWNrXTtcbiAgICB9XG4gICAgLy8gVE9ETzogVGhlIGNhbGxiYWNrIGhlcmUgaXMgaWdub3JlZCB3aGVuIHNldFN0YXRlIGlzIGNhbGxlZCBmcm9tXG4gICAgLy8gY29tcG9uZW50V2lsbE1vdW50LiBFaXRoZXIgZml4IGl0IG9yIGRpc2FsbG93IGRvaW5nIHNvIGNvbXBsZXRlbHkgaW5cbiAgICAvLyBmYXZvciBvZiBnZXRJbml0aWFsU3RhdGUuIEFsdGVybmF0aXZlbHksIHdlIGNhbiBkaXNhbGxvd1xuICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBkdXJpbmcgc2VydmVyLXNpZGUgcmVuZGVyaW5nLlxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgZW5xdWV1ZUNhbGxiYWNrSW50ZXJuYWw6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBjYWxsYmFjaykge1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzKSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzID0gW2NhbGxiYWNrXTtcbiAgICB9XG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IHRydWU7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gW2NvbXBsZXRlU3RhdGVdO1xuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSB0cnVlO1xuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0U3RhdGUoKTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHBhcnRpYWxTdGF0ZSAhPSBudWxsLCAnc2V0U3RhdGUoLi4uKTogWW91IHBhc3NlZCBhbiB1bmRlZmluZWQgb3IgbnVsbCBzdGF0ZSBvYmplY3Q7ICcgKyAnaW5zdGVhZCwgdXNlIGZvcmNlVXBkYXRlKCkuJykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHF1ZXVlID0gaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ1N0YXRlUXVldWUgfHwgKGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gW10pO1xuICAgIHF1ZXVlLnB1c2gocGFydGlhbFN0YXRlKTtcblxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgZW5xdWV1ZUVsZW1lbnRJbnRlcm5hbDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIG5leHRFbGVtZW50LCBuZXh0Q29udGV4dCkge1xuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdFbGVtZW50ID0gbmV4dEVsZW1lbnQ7XG4gICAgLy8gVE9ETzogaW50cm9kdWNlIF9wZW5kaW5nQ29udGV4dCBpbnN0ZWFkIG9mIHNldHRpbmcgaXQgZGlyZWN0bHkuXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fY29udGV4dCA9IG5leHRDb250ZXh0O1xuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgdmFsaWRhdGVDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgISghY2FsbGJhY2sgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcyguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGZvcm1hdFVuZXhwZWN0ZWRBcmd1bWVudChjYWxsYmFjaykpIDogX3Byb2RJbnZhcmlhbnQoJzEyMicsIGNhbGxlck5hbWUsIGZvcm1hdFVuZXhwZWN0ZWRBcmd1bWVudChjYWxsYmFjaykpIDogdm9pZCAwO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RVcGRhdGVRdWV1ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdFVwZGF0ZVF1ZXVlLmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuLyogZ2xvYmFscyBNU0FwcCAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggaGFzICd1bnNhZmUnIHByaXZpbGVnZXMgKHJlcXVpcmVkIGJ5IHdpbmRvd3M4IGFwcHMpXG4gKi9cblxudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSBmdW5jdGlvbiAoZnVuYykge1xuICBpZiAodHlwZW9mIE1TQXBwICE9PSAndW5kZWZpbmVkJyAmJiBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuYyhhcmcwLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9jcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIGBjaGFyQ29kZWAgcmVwcmVzZW50cyB0aGUgYWN0dWFsIFwiY2hhcmFjdGVyIGNvZGVcIiBhbmQgaXMgc2FmZSB0byB1c2Ugd2l0aFxuICogYFN0cmluZy5mcm9tQ2hhckNvZGVgLiBBcyBzdWNoLCBvbmx5IGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIHByaW50YWJsZVxuICogY2hhcmFjdGVycyBwcm9kdWNlIGEgdmFsaWQgYGNoYXJDb2RlYCwgdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgRW50ZXIuXG4gKiBUaGUgVGFiLWtleSBpcyBjb25zaWRlcmVkIG5vbi1wcmludGFibGUgYW5kIGRvZXMgbm90IGhhdmUgYSBgY2hhckNvZGVgLFxuICogcHJlc3VtYWJseSBiZWNhdXNlIGl0IGRvZXMgbm90IHByb2R1Y2UgYSB0YWItY2hhcmFjdGVyIGluIGJyb3dzZXJzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gTm9ybWFsaXplZCBgY2hhckNvZGVgIHByb3BlcnR5LlxuICovXG5cbmZ1bmN0aW9uIGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGNoYXJDb2RlO1xuICB2YXIga2V5Q29kZSA9IG5hdGl2ZUV2ZW50LmtleUNvZGU7XG5cbiAgaWYgKCdjaGFyQ29kZScgaW4gbmF0aXZlRXZlbnQpIHtcbiAgICBjaGFyQ29kZSA9IG5hdGl2ZUV2ZW50LmNoYXJDb2RlO1xuXG4gICAgLy8gRkYgZG9lcyBub3Qgc2V0IGBjaGFyQ29kZWAgZm9yIHRoZSBFbnRlci1rZXksIGNoZWNrIGFnYWluc3QgYGtleUNvZGVgLlxuICAgIGlmIChjaGFyQ29kZSA9PT0gMCAmJiBrZXlDb2RlID09PSAxMykge1xuICAgICAgY2hhckNvZGUgPSAxMztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBgY2hhckNvZGVgLCBidXQgYGtleUNvZGVgIGhhcyB0aGUgY29ycmVjdCB2YWx1ZS5cbiAgICBjaGFyQ29kZSA9IGtleUNvZGU7XG4gIH1cblxuICAvLyBTb21lIG5vbi1wcmludGFibGUga2V5cyBhcmUgcmVwb3J0ZWQgaW4gYGNoYXJDb2RlYC9ga2V5Q29kZWAsIGRpc2NhcmQgdGhlbS5cbiAgLy8gTXVzdCBub3QgZGlzY2FyZCB0aGUgKG5vbi0pcHJpbnRhYmxlIEVudGVyLWtleS5cbiAgaWYgKGNoYXJDb2RlID49IDMyIHx8IGNoYXJDb2RlID09PSAxMykge1xuICAgIHJldHVybiBjaGFyQ29kZTtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50Q2hhckNvZGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvZ2V0RXZlbnRDaGFyQ29kZS5qc1xuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIG1vZGlmaWVyIGtleSB0byB0aGUgYXNzb2NpYXRlZCBwcm9wZXJ0eSBpbiB0aGUgZXZlbnQuXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8ja2V5cy1Nb2RpZmllcnNcbiAqL1xuXG52YXIgbW9kaWZpZXJLZXlUb1Byb3AgPSB7XG4gICdBbHQnOiAnYWx0S2V5JyxcbiAgJ0NvbnRyb2wnOiAnY3RybEtleScsXG4gICdNZXRhJzogJ21ldGFLZXknLFxuICAnU2hpZnQnOiAnc2hpZnRLZXknXG59O1xuXG4vLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGdldE1vZGlmaWVyU3RhdGUgc28gd2Ugc2ltcGx5IG1hcCBpdCB0byB0aGUgb25seVxuLy8gbW9kaWZpZXIga2V5cyBleHBvc2VkIGJ5IHRoZSBldmVudCBpdHNlbGYsIGRvZXMgbm90IHN1cHBvcnQgTG9jay1rZXlzLlxuLy8gQ3VycmVudGx5LCBhbGwgbWFqb3IgYnJvd3NlcnMgZXhjZXB0IENocm9tZSBzZWVtcyB0byBzdXBwb3J0IExvY2sta2V5cy5cbmZ1bmN0aW9uIG1vZGlmaWVyU3RhdGVHZXR0ZXIoa2V5QXJnKSB7XG4gIHZhciBzeW50aGV0aWNFdmVudCA9IHRoaXM7XG4gIHZhciBuYXRpdmVFdmVudCA9IHN5bnRoZXRpY0V2ZW50Lm5hdGl2ZUV2ZW50O1xuICBpZiAobmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZSkge1xuICAgIHJldHVybiBuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKGtleUFyZyk7XG4gIH1cbiAgdmFyIGtleVByb3AgPSBtb2RpZmllcktleVRvUHJvcFtrZXlBcmddO1xuICByZXR1cm4ga2V5UHJvcCA/ICEhbmF0aXZlRXZlbnRba2V5UHJvcF0gOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RXZlbnRNb2RpZmllclN0YXRlKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiBtb2RpZmllclN0YXRlR2V0dGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50TW9kaWZpZXJTdGF0ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9nZXRFdmVudE1vZGlmaWVyU3RhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2V0cyB0aGUgdGFyZ2V0IG5vZGUgZnJvbSBhIG5hdGl2ZSBicm93c2VyIGV2ZW50IGJ5IGFjY291bnRpbmcgZm9yXG4gKiBpbmNvbnNpc3RlbmNpZXMgaW4gYnJvd3NlciBET00gQVBJcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtET01FdmVudFRhcmdldH0gVGFyZ2V0IG5vZGUuXG4gKi9cblxuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldCB8fCBuYXRpdmVFdmVudC5zcmNFbGVtZW50IHx8IHdpbmRvdztcblxuICAvLyBOb3JtYWxpemUgU1ZHIDx1c2U+IGVsZW1lbnQgZXZlbnRzICM0OTYzXG4gIGlmICh0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XG4gIH1cblxuICAvLyBTYWZhcmkgbWF5IGZpcmUgZXZlbnRzIG9uIHRleHQgbm9kZXMgKE5vZGUuVEVYVF9OT0RFIGlzIDMpLlxuICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxuICByZXR1cm4gdGFyZ2V0Lm5vZGVUeXBlID09PSAzID8gdGFyZ2V0LnBhcmVudE5vZGUgOiB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRUYXJnZXQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvZ2V0RXZlbnRUYXJnZXQuanNcbi8vIG1vZHVsZSBpZCA9IDQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciB1c2VIYXNGZWF0dXJlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICB1c2VIYXNGZWF0dXJlID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24gJiYgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSAmJlxuICAvLyBhbHdheXMgcmV0dXJucyB0cnVlIGluIG5ld2VyIGJyb3dzZXJzIGFzIHBlciB0aGUgc3RhbmRhcmQuXG4gIC8vIEBzZWUgaHR0cDovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1kb21pbXBsZW1lbnRhdGlvbi1oYXNmZWF0dXJlXG4gIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoJycsICcnKSAhPT0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYW4gZXZlbnQgaXMgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBlbnZpcm9ubWVudC5cbiAqXG4gKiBOT1RFOiBUaGlzIHdpbGwgbm90IHdvcmsgY29ycmVjdGx5IGZvciBub24tZ2VuZXJpYyBldmVudHMgc3VjaCBhcyBgY2hhbmdlYCxcbiAqIGByZXNldGAsIGBsb2FkYCwgYGVycm9yYCwgYW5kIGBzZWxlY3RgLlxuICpcbiAqIEJvcnJvd3MgZnJvbSBNb2Rlcm5penIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVN1ZmZpeCBFdmVudCBuYW1lLCBlLmcuIFwiY2xpY2tcIi5cbiAqIEBwYXJhbSB7P2Jvb2xlYW59IGNhcHR1cmUgQ2hlY2sgaWYgdGhlIGNhcHR1cmUgcGhhc2UgaXMgc3VwcG9ydGVkLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgaXMgc3VwcG9ydGVkLlxuICogQGludGVybmFsXG4gKiBAbGljZW5zZSBNb2Rlcm5penIgMy4wLjBwcmUgKEN1c3RvbSBCdWlsZCkgfCBNSVRcbiAqL1xuZnVuY3Rpb24gaXNFdmVudFN1cHBvcnRlZChldmVudE5hbWVTdWZmaXgsIGNhcHR1cmUpIHtcbiAgaWYgKCFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gfHwgY2FwdHVyZSAmJiAhKCdhZGRFdmVudExpc3RlbmVyJyBpbiBkb2N1bWVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZXZlbnROYW1lID0gJ29uJyArIGV2ZW50TmFtZVN1ZmZpeDtcbiAgdmFyIGlzU3VwcG9ydGVkID0gZXZlbnROYW1lIGluIGRvY3VtZW50O1xuXG4gIGlmICghaXNTdXBwb3J0ZWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGV2ZW50TmFtZSwgJ3JldHVybjsnKTtcbiAgICBpc1N1cHBvcnRlZCA9IHR5cGVvZiBlbGVtZW50W2V2ZW50TmFtZV0gPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICBpZiAoIWlzU3VwcG9ydGVkICYmIHVzZUhhc0ZlYXR1cmUgJiYgZXZlbnROYW1lU3VmZml4ID09PSAnd2hlZWwnKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgb25seSB3YXkgdG8gdGVzdCBzdXBwb3J0IGZvciB0aGUgYHdoZWVsYCBldmVudCBpbiBJRTkrLlxuICAgIGlzU3VwcG9ydGVkID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnRXZlbnRzLndoZWVsJywgJzMuMCcpO1xuICB9XG5cbiAgcmV0dXJuIGlzU3VwcG9ydGVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRXZlbnRTdXBwb3J0ZWQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvaXNFdmVudFN1cHBvcnRlZC5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHaXZlbiBhIGBwcmV2RWxlbWVudGAgYW5kIGBuZXh0RWxlbWVudGAsIGRldGVybWluZXMgaWYgdGhlIGV4aXN0aW5nXG4gKiBpbnN0YW5jZSBzaG91bGQgYmUgdXBkYXRlZCBhcyBvcHBvc2VkIHRvIGJlaW5nIGRlc3Ryb3llZCBvciByZXBsYWNlZCBieSBhIG5ld1xuICogaW5zdGFuY2UuIEJvdGggYXJndW1lbnRzIGFyZSBlbGVtZW50cy4gVGhpcyBlbnN1cmVzIHRoYXQgdGhpcyBsb2dpYyBjYW5cbiAqIG9wZXJhdGUgb24gc3RhdGVsZXNzIHRyZWVzIHdpdGhvdXQgYW55IGJhY2tpbmcgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2RWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0RWxlbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXhpc3RpbmcgaW5zdGFuY2Ugc2hvdWxkIGJlIHVwZGF0ZWQuXG4gKiBAcHJvdGVjdGVkXG4gKi9cblxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSB7XG4gIHZhciBwcmV2RW1wdHkgPSBwcmV2RWxlbWVudCA9PT0gbnVsbCB8fCBwcmV2RWxlbWVudCA9PT0gZmFsc2U7XG4gIHZhciBuZXh0RW1wdHkgPSBuZXh0RWxlbWVudCA9PT0gbnVsbCB8fCBuZXh0RWxlbWVudCA9PT0gZmFsc2U7XG4gIGlmIChwcmV2RW1wdHkgfHwgbmV4dEVtcHR5KSB7XG4gICAgcmV0dXJuIHByZXZFbXB0eSA9PT0gbmV4dEVtcHR5O1xuICB9XG5cbiAgdmFyIHByZXZUeXBlID0gdHlwZW9mIHByZXZFbGVtZW50O1xuICB2YXIgbmV4dFR5cGUgPSB0eXBlb2YgbmV4dEVsZW1lbnQ7XG4gIGlmIChwcmV2VHlwZSA9PT0gJ3N0cmluZycgfHwgcHJldlR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIG5leHRUeXBlID09PSAnc3RyaW5nJyB8fCBuZXh0VHlwZSA9PT0gJ251bWJlcic7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5leHRUeXBlID09PSAnb2JqZWN0JyAmJiBwcmV2RWxlbWVudC50eXBlID09PSBuZXh0RWxlbWVudC50eXBlICYmIHByZXZFbGVtZW50LmtleSA9PT0gbmV4dEVsZW1lbnQua2V5O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gVGhpcyB2YWxpZGF0aW9uIGNvZGUgd2FzIHdyaXR0ZW4gYmFzZWQgb24gdGhlIEhUTUw1IHBhcnNpbmcgc3BlYzpcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgLy9cbiAgLy8gTm90ZTogdGhpcyBkb2VzIG5vdCBjYXRjaCBhbGwgaW52YWxpZCBuZXN0aW5nLCBub3IgZG9lcyBpdCB0cnkgdG8gKGFzIGl0J3NcbiAgLy8gbm90IGNsZWFyIHdoYXQgcHJhY3RpY2FsIGJlbmVmaXQgZG9pbmcgc28gcHJvdmlkZXMpOyBpbnN0ZWFkLCB3ZSB3YXJuIG9ubHlcbiAgLy8gZm9yIGNhc2VzIHdoZXJlIHRoZSBwYXJzZXIgd2lsbCBnaXZlIGEgcGFyc2UgdHJlZSBkaWZmZXJpbmcgZnJvbSB3aGF0IFJlYWN0XG4gIC8vIGludGVuZGVkLiBGb3IgZXhhbXBsZSwgPGI+PGRpdj48L2Rpdj48L2I+IGlzIGludmFsaWQgYnV0IHdlIGRvbid0IHdhcm5cbiAgLy8gYmVjYXVzZSBpdCBzdGlsbCBwYXJzZXMgY29ycmVjdGx5OyB3ZSBkbyB3YXJuIGZvciBvdGhlciBjYXNlcyBsaWtlIG5lc3RlZFxuICAvLyA8cD4gdGFncyB3aGVyZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBpbXBsaWNpdGx5IGNsb3NlcyB0aGVcbiAgLy8gZmlyc3QsIGNhdXNpbmcgYSBjb25mdXNpbmcgbWVzcy5cblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNzcGVjaWFsXG4gIHZhciBzcGVjaWFsVGFncyA9IFsnYWRkcmVzcycsICdhcHBsZXQnLCAnYXJlYScsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2Jhc2UnLCAnYmFzZWZvbnQnLCAnYmdzb3VuZCcsICdibG9ja3F1b3RlJywgJ2JvZHknLCAnYnInLCAnYnV0dG9uJywgJ2NhcHRpb24nLCAnY2VudGVyJywgJ2NvbCcsICdjb2xncm91cCcsICdkZCcsICdkZXRhaWxzJywgJ2RpcicsICdkaXYnLCAnZGwnLCAnZHQnLCAnZW1iZWQnLCAnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9vdGVyJywgJ2Zvcm0nLCAnZnJhbWUnLCAnZnJhbWVzZXQnLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZCcsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ2h0bWwnLCAnaWZyYW1lJywgJ2ltZycsICdpbnB1dCcsICdpc2luZGV4JywgJ2xpJywgJ2xpbmsnLCAnbGlzdGluZycsICdtYWluJywgJ21hcnF1ZWUnLCAnbWVudScsICdtZW51aXRlbScsICdtZXRhJywgJ25hdicsICdub2VtYmVkJywgJ25vZnJhbWVzJywgJ25vc2NyaXB0JywgJ29iamVjdCcsICdvbCcsICdwJywgJ3BhcmFtJywgJ3BsYWludGV4dCcsICdwcmUnLCAnc2NyaXB0JywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NvdXJjZScsICdzdHlsZScsICdzdW1tYXJ5JywgJ3RhYmxlJywgJ3Rib2R5JywgJ3RkJywgJ3RlbXBsYXRlJywgJ3RleHRhcmVhJywgJ3Rmb290JywgJ3RoJywgJ3RoZWFkJywgJ3RpdGxlJywgJ3RyJywgJ3RyYWNrJywgJ3VsJywgJ3dicicsICd4bXAnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICB2YXIgaW5TY29wZVRhZ3MgPSBbJ2FwcGxldCcsICdjYXB0aW9uJywgJ2h0bWwnLCAndGFibGUnLCAndGQnLCAndGgnLCAnbWFycXVlZScsICdvYmplY3QnLCAndGVtcGxhdGUnLFxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2h0bWwtaW50ZWdyYXRpb24tcG9pbnRcbiAgLy8gVE9ETzogRGlzdGluZ3Vpc2ggYnkgbmFtZXNwYWNlIGhlcmUgLS0gZm9yIDx0aXRsZT4sIGluY2x1ZGluZyBpdCBoZXJlXG4gIC8vIGVycnMgb24gdGhlIHNpZGUgb2YgZmV3ZXIgd2FybmluZ3NcbiAgJ2ZvcmVpZ25PYmplY3QnLCAnZGVzYycsICd0aXRsZSddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLWJ1dHRvbi1zY29wZVxuICB2YXIgYnV0dG9uU2NvcGVUYWdzID0gaW5TY29wZVRhZ3MuY29uY2F0KFsnYnV0dG9uJ10pO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2dlbmVyYXRlLWltcGxpZWQtZW5kLXRhZ3NcbiAgdmFyIGltcGxpZWRFbmRUYWdzID0gWydkZCcsICdkdCcsICdsaScsICdvcHRpb24nLCAnb3B0Z3JvdXAnLCAncCcsICdycCcsICdydCddO1xuXG4gIHZhciBlbXB0eUFuY2VzdG9ySW5mbyA9IHtcbiAgICBjdXJyZW50OiBudWxsLFxuXG4gICAgZm9ybVRhZzogbnVsbCxcbiAgICBhVGFnSW5TY29wZTogbnVsbCxcbiAgICBidXR0b25UYWdJblNjb3BlOiBudWxsLFxuICAgIG5vYnJUYWdJblNjb3BlOiBudWxsLFxuICAgIHBUYWdJbkJ1dHRvblNjb3BlOiBudWxsLFxuXG4gICAgbGlzdEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbCxcbiAgICBkbEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbFxuICB9O1xuXG4gIHZhciB1cGRhdGVkQW5jZXN0b3JJbmZvID0gZnVuY3Rpb24gKG9sZEluZm8sIHRhZywgaW5zdGFuY2UpIHtcbiAgICB2YXIgYW5jZXN0b3JJbmZvID0gX2Fzc2lnbih7fSwgb2xkSW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIGluZm8gPSB7IHRhZzogdGFnLCBpbnN0YW5jZTogaW5zdGFuY2UgfTtcblxuICAgIGlmIChpblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGJ1dHRvblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlZSBydWxlcyBmb3IgJ2xpJywgJ2RkJywgJ2R0JyBzdGFydCB0YWdzIGluXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIGlmIChzcGVjaWFsVGFncy5pbmRleE9mKHRhZykgIT09IC0xICYmIHRhZyAhPT0gJ2FkZHJlc3MnICYmIHRhZyAhPT0gJ2RpdicgJiYgdGFnICE9PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgfVxuXG4gICAgYW5jZXN0b3JJbmZvLmN1cnJlbnQgPSBpbmZvO1xuXG4gICAgaWYgKHRhZyA9PT0gJ2Zvcm0nKSB7XG4gICAgICBhbmNlc3RvckluZm8uZm9ybVRhZyA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdhJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2J1dHRvbicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ25vYnInKSB7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdsaScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2RkJyB8fCB0YWcgPT09ICdkdCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuY2VzdG9ySW5mbztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuICB2YXIgaXNUYWdWYWxpZFdpdGhQYXJlbnQgPSBmdW5jdGlvbiAodGFnLCBwYXJlbnRUYWcpIHtcbiAgICAvLyBGaXJzdCwgbGV0J3MgY2hlY2sgaWYgd2UncmUgaW4gYW4gdW51c3VhbCBwYXJzaW5nIG1vZGUuLi5cbiAgICBzd2l0Y2ggKHBhcmVudFRhZykge1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluc2VsZWN0XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICdvcHRncm91cCcgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgY2FzZSAnb3B0Z3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBTdHJpY3RseSBzcGVha2luZywgc2VlaW5nIGFuIDxvcHRpb24+IGRvZXNuJ3QgbWVhbiB3ZSdyZSBpbiBhIDxzZWxlY3Q+XG4gICAgICAvLyBidXRcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICcjdGV4dCc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRkXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jYXB0aW9uXG4gICAgICAvLyBObyBzcGVjaWFsIGJlaGF2aW9yIHNpbmNlIHRoZXNlIHJ1bGVzIGZhbGwgYmFjayB0byBcImluIGJvZHlcIiBtb2RlIGZvclxuICAgICAgLy8gYWxsIGV4Y2VwdCBzcGVjaWFsIHRhYmxlIG5vZGVzIHdoaWNoIGNhdXNlIGJhZCBwYXJzaW5nIGJlaGF2aW9yIGFueXdheS5cblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludHJcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RoJyB8fCB0YWcgPT09ICd0ZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50Ym9keVxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndHInIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY29sZ3JvdXBcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NvbCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50YWJsZVxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY2FwdGlvbicgfHwgdGFnID09PSAnY29sZ3JvdXAnIHx8IHRhZyA9PT0gJ3Rib2R5JyB8fCB0YWcgPT09ICd0Zm9vdCcgfHwgdGFnID09PSAndGhlYWQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluaGVhZFxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdiYXNlJyB8fCB0YWcgPT09ICdiYXNlZm9udCcgfHwgdGFnID09PSAnYmdzb3VuZCcgfHwgdGFnID09PSAnbGluaycgfHwgdGFnID09PSAnbWV0YScgfHwgdGFnID09PSAndGl0bGUnIHx8IHRhZyA9PT0gJ25vc2NyaXB0JyB8fCB0YWcgPT09ICdub2ZyYW1lcycgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZW1hbnRpY3MuaHRtbCN0aGUtaHRtbC1lbGVtZW50XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2hlYWQnIHx8IHRhZyA9PT0gJ2JvZHknO1xuICAgICAgY2FzZSAnI2RvY3VtZW50JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2h0bWwnO1xuICAgIH1cblxuICAgIC8vIFByb2JhYmx5IGluIHRoZSBcImluIGJvZHlcIiBwYXJzaW5nIG1vZGUsIHNvIHdlIG91dGxhdyBvbmx5IHRhZyBjb21ib3NcbiAgICAvLyB3aGVyZSB0aGUgcGFyc2luZyBydWxlcyBjYXVzZSBpbXBsaWNpdCBvcGVucyBvciBjbG9zZXMgdG8gYmUgYWRkZWQuXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgIT09ICdoMScgJiYgcGFyZW50VGFnICE9PSAnaDInICYmIHBhcmVudFRhZyAhPT0gJ2gzJyAmJiBwYXJlbnRUYWcgIT09ICdoNCcgJiYgcGFyZW50VGFnICE9PSAnaDUnICYmIHBhcmVudFRhZyAhPT0gJ2g2JztcblxuICAgICAgY2FzZSAncnAnOlxuICAgICAgY2FzZSAncnQnOlxuICAgICAgICByZXR1cm4gaW1wbGllZEVuZFRhZ3MuaW5kZXhPZihwYXJlbnRUYWcpID09PSAtMTtcblxuICAgICAgY2FzZSAnYm9keSc6XG4gICAgICBjYXNlICdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2NvbCc6XG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICBjYXNlICdmcmFtZSc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgY2FzZSAndGgnOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndHInOlxuICAgICAgICAvLyBUaGVzZSB0YWdzIGFyZSBvbmx5IHZhbGlkIHdpdGggYSBmZXcgcGFyZW50cyB0aGF0IGhhdmUgc3BlY2lhbCBjaGlsZFxuICAgICAgICAvLyBwYXJzaW5nIHJ1bGVzIC0tIGlmIHdlJ3JlIGRvd24gaGVyZSwgdGhlbiBub25lIG9mIHRob3NlIG1hdGNoZWQgYW5kXG4gICAgICAgIC8vIHNvIHdlIGFsbG93IGl0IG9ubHkgaWYgd2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBwYXJlbnQgaXMsIGFzIGFsbCBvdGhlclxuICAgICAgICAvLyBjYXNlcyBhcmUgaW52YWxpZC5cbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyA9PSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgY2FzZSAnYXJ0aWNsZSc6XG4gICAgICBjYXNlICdhc2lkZSc6XG4gICAgICBjYXNlICdibG9ja3F1b3RlJzpcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIGNhc2UgJ2RpYWxvZyc6XG4gICAgICBjYXNlICdkaXInOlxuICAgICAgY2FzZSAnZGl2JzpcbiAgICAgIGNhc2UgJ2RsJzpcbiAgICAgIGNhc2UgJ2ZpZWxkc2V0JzpcbiAgICAgIGNhc2UgJ2ZpZ2NhcHRpb24nOlxuICAgICAgY2FzZSAnZmlndXJlJzpcbiAgICAgIGNhc2UgJ2Zvb3Rlcic6XG4gICAgICBjYXNlICdoZWFkZXInOlxuICAgICAgY2FzZSAnaGdyb3VwJzpcbiAgICAgIGNhc2UgJ21haW4nOlxuICAgICAgY2FzZSAnbWVudSc6XG4gICAgICBjYXNlICduYXYnOlxuICAgICAgY2FzZSAnb2wnOlxuICAgICAgY2FzZSAncCc6XG4gICAgICBjYXNlICdzZWN0aW9uJzpcbiAgICAgIGNhc2UgJ3N1bW1hcnknOlxuICAgICAgY2FzZSAndWwnOlxuXG4gICAgICBjYXNlICdwcmUnOlxuICAgICAgY2FzZSAnbGlzdGluZyc6XG5cbiAgICAgIGNhc2UgJ3RhYmxlJzpcblxuICAgICAgY2FzZSAnaHInOlxuXG4gICAgICBjYXNlICd4bXAnOlxuXG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmZvcm1UYWcgfHwgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdsaSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnZGQnOlxuICAgICAgY2FzZSAnZHQnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAvLyBTcGVjIHNheXMgc29tZXRoaW5nIGFib3V0IHN0b3JpbmcgYSBsaXN0IG9mIG1hcmtlcnMsIGJ1dCBpdCBzb3VuZHNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byB0aGlzIGNoZWNrLlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdub2JyJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR2l2ZW4gYSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCBpbnN0YW5jZSwgcmV0dXJuIGEgbGlzdCBvZiBpdHMgcmVjdXJzaXZlXG4gICAqIG93bmVycywgc3RhcnRpbmcgYXQgdGhlIHJvb3QgYW5kIGVuZGluZyB3aXRoIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICB2YXIgZmluZE93bmVyU3RhY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgZG8ge1xuICAgICAgc3RhY2sucHVzaChpbnN0YW5jZSk7XG4gICAgfSB3aGlsZSAoaW5zdGFuY2UgPSBpbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyKTtcbiAgICBzdGFjay5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xuXG4gIHZhciBkaWRXYXJuID0ge307XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nID0gZnVuY3Rpb24gKGNoaWxkVGFnLCBjaGlsZFRleHQsIGNoaWxkSW5zdGFuY2UsIGFuY2VzdG9ySW5mbykge1xuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5jdXJyZW50O1xuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xuXG4gICAgaWYgKGNoaWxkVGV4dCAhPSBudWxsKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhjaGlsZFRhZyA9PSBudWxsLCAndmFsaWRhdGVET01OZXN0aW5nOiB3aGVuIGNoaWxkVGV4dCBpcyBwYXNzZWQsIGNoaWxkVGFnIHNob3VsZCBiZSBudWxsJykgOiB2b2lkIDA7XG4gICAgICBjaGlsZFRhZyA9ICcjdGV4dCc7XG4gICAgfVxuXG4gICAgdmFyIGludmFsaWRQYXJlbnQgPSBpc1RhZ1ZhbGlkV2l0aFBhcmVudChjaGlsZFRhZywgcGFyZW50VGFnKSA/IG51bGwgOiBwYXJlbnRJbmZvO1xuICAgIHZhciBpbnZhbGlkQW5jZXN0b3IgPSBpbnZhbGlkUGFyZW50ID8gbnVsbCA6IGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcoY2hpbGRUYWcsIGFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIHByb2JsZW1hdGljID0gaW52YWxpZFBhcmVudCB8fCBpbnZhbGlkQW5jZXN0b3I7XG5cbiAgICBpZiAocHJvYmxlbWF0aWMpIHtcbiAgICAgIHZhciBhbmNlc3RvclRhZyA9IHByb2JsZW1hdGljLnRhZztcbiAgICAgIHZhciBhbmNlc3Rvckluc3RhbmNlID0gcHJvYmxlbWF0aWMuaW5zdGFuY2U7XG5cbiAgICAgIHZhciBjaGlsZE93bmVyID0gY2hpbGRJbnN0YW5jZSAmJiBjaGlsZEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgYW5jZXN0b3JPd25lciA9IGFuY2VzdG9ySW5zdGFuY2UgJiYgYW5jZXN0b3JJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuXG4gICAgICB2YXIgY2hpbGRPd25lcnMgPSBmaW5kT3duZXJTdGFjayhjaGlsZE93bmVyKTtcbiAgICAgIHZhciBhbmNlc3Rvck93bmVycyA9IGZpbmRPd25lclN0YWNrKGFuY2VzdG9yT3duZXIpO1xuXG4gICAgICB2YXIgbWluU3RhY2tMZW4gPSBNYXRoLm1pbihjaGlsZE93bmVycy5sZW5ndGgsIGFuY2VzdG9yT3duZXJzLmxlbmd0aCk7XG4gICAgICB2YXIgaTtcblxuICAgICAgdmFyIGRlZXBlc3RDb21tb24gPSAtMTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtaW5TdGFja0xlbjsgaSsrKSB7XG4gICAgICAgIGlmIChjaGlsZE93bmVyc1tpXSA9PT0gYW5jZXN0b3JPd25lcnNbaV0pIHtcbiAgICAgICAgICBkZWVwZXN0Q29tbW9uID0gaTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgVU5LTk9XTiA9ICcodW5rbm93biknO1xuICAgICAgdmFyIGNoaWxkT3duZXJOYW1lcyA9IGNoaWxkT3duZXJzLnNsaWNlKGRlZXBlc3RDb21tb24gKyAxKS5tYXAoZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgICAgcmV0dXJuIGluc3QuZ2V0TmFtZSgpIHx8IFVOS05PV047XG4gICAgICB9KTtcbiAgICAgIHZhciBhbmNlc3Rvck93bmVyTmFtZXMgPSBhbmNlc3Rvck93bmVycy5zbGljZShkZWVwZXN0Q29tbW9uICsgMSkubWFwKGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgICAgIHJldHVybiBpbnN0LmdldE5hbWUoKSB8fCBVTktOT1dOO1xuICAgICAgfSk7XG4gICAgICB2YXIgb3duZXJJbmZvID0gW10uY29uY2F0KFxuICAgICAgLy8gSWYgdGhlIHBhcmVudCBhbmQgY2hpbGQgaW5zdGFuY2VzIGhhdmUgYSBjb21tb24gb3duZXIgYW5jZXN0b3IsIHN0YXJ0XG4gICAgICAvLyB3aXRoIHRoYXQgLS0gb3RoZXJ3aXNlIHdlIGp1c3Qgc3RhcnQgd2l0aCB0aGUgcGFyZW50J3Mgb3duZXJzLlxuICAgICAgZGVlcGVzdENvbW1vbiAhPT0gLTEgPyBjaGlsZE93bmVyc1tkZWVwZXN0Q29tbW9uXS5nZXROYW1lKCkgfHwgVU5LTk9XTiA6IFtdLCBhbmNlc3Rvck93bmVyTmFtZXMsIGFuY2VzdG9yVGFnLFxuICAgICAgLy8gSWYgd2UncmUgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIChub24tcGFyZW50KSBhbmNlc3RyeSwgYWRkICcuLi4nXG4gICAgICBpbnZhbGlkQW5jZXN0b3IgPyBbJy4uLiddIDogW10sIGNoaWxkT3duZXJOYW1lcywgY2hpbGRUYWcpLmpvaW4oJyA+ICcpO1xuXG4gICAgICB2YXIgd2FybktleSA9ICEhaW52YWxpZFBhcmVudCArICd8JyArIGNoaWxkVGFnICsgJ3wnICsgYW5jZXN0b3JUYWcgKyAnfCcgKyBvd25lckluZm87XG4gICAgICBpZiAoZGlkV2Fyblt3YXJuS2V5XSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkaWRXYXJuW3dhcm5LZXldID0gdHJ1ZTtcblxuICAgICAgdmFyIHRhZ0Rpc3BsYXlOYW1lID0gY2hpbGRUYWc7XG4gICAgICB2YXIgd2hpdGVzcGFjZUluZm8gPSAnJztcbiAgICAgIGlmIChjaGlsZFRhZyA9PT0gJyN0ZXh0Jykge1xuICAgICAgICBpZiAoL1xcUy8udGVzdChjaGlsZFRleHQpKSB7XG4gICAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnVGV4dCBub2Rlcyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnV2hpdGVzcGFjZSB0ZXh0IG5vZGVzJztcbiAgICAgICAgICB3aGl0ZXNwYWNlSW5mbyA9ICcgTWFrZSBzdXJlIHlvdSBkb25cXCd0IGhhdmUgYW55IGV4dHJhIHdoaXRlc3BhY2UgYmV0d2VlbiB0YWdzIG9uICcgKyAnZWFjaCBsaW5lIG9mIHlvdXIgc291cmNlIGNvZGUuJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnPCcgKyBjaGlsZFRhZyArICc+JztcbiAgICAgIH1cblxuICAgICAgaWYgKGludmFsaWRQYXJlbnQpIHtcbiAgICAgICAgdmFyIGluZm8gPSAnJztcbiAgICAgICAgaWYgKGFuY2VzdG9yVGFnID09PSAndGFibGUnICYmIGNoaWxkVGFnID09PSAndHInKSB7XG4gICAgICAgICAgaW5mbyArPSAnIEFkZCBhIDx0Ym9keT4gdG8geW91ciBjb2RlIHRvIG1hdGNoIHRoZSBET00gdHJlZSBnZW5lcmF0ZWQgYnkgJyArICd0aGUgYnJvd3Nlci4nO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBjaGlsZCBvZiA8JXM+LiVzICcgKyAnU2VlICVzLiVzJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCB3aGl0ZXNwYWNlSW5mbywgb3duZXJJbmZvLCBpbmZvKSA6IHZvaWQgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBkZXNjZW5kYW50IG9mICcgKyAnPCVzPi4gU2VlICVzLicsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZywgb3duZXJJbmZvKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nLnVwZGF0ZWRBbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvO1xuXG4gIC8vIEZvciB0ZXN0aW5nXG4gIHZhbGlkYXRlRE9NTmVzdGluZy5pc1RhZ1ZhbGlkSW5Db250ZXh0ID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG4gICAgcmV0dXJuIGlzVGFnVmFsaWRXaXRoUGFyZW50KHRhZywgcGFyZW50VGFnKSAmJiAhZmluZEludmFsaWRBbmNlc3RvckZvclRhZyh0YWcsIGFuY2VzdG9ySW5mbyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmFsaWRhdGVET01OZXN0aW5nO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL3ZhbGlkYXRlRE9NTmVzdGluZy5qc1xuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKiBcbiAqL1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICBpZiAoeCA9PT0geSkge1xuICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgLy8gQWRkZWQgdGhlIG5vbnplcm8geSBjaGVjayB0byBtYWtlIEZsb3cgaGFwcHksIGJ1dCBpdCBpcyByZWR1bmRhbnRcbiAgICByZXR1cm4geCAhPT0gMCB8fCB5ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBlcXVhbGl0eSBieSBpdGVyYXRpbmcgdGhyb3VnaCBrZXlzIG9uIGFuIG9iamVjdCBhbmQgcmV0dXJuaW5nIGZhbHNlXG4gKiB3aGVuIGFueSBrZXkgaGFzIHZhbHVlcyB3aGljaCBhcmUgbm90IHN0cmljdGx5IGVxdWFsIGJldHdlZW4gdGhlIGFyZ3VtZW50cy5cbiAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICovXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAoaXMob2JqQSwgb2JqQikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gJ29iamVjdCcgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdCcgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleXNBW2ldKSB8fCAhaXMob2JqQVtrZXlzQVtpXV0sIG9iakJba2V5c0FbaV1dKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNoYWxsb3dFcXVhbDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL34vZmJqcy9saWIvc2hhbGxvd0VxdWFsLmpzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlJyk7XG5cbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vY2FuRGVmaW5lUHJvcGVydHknKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gUmVhY3RDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cblJlYWN0Q29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5cbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5SZWFjdENvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAhKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgfHwgcGFydGlhbFN0YXRlID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3NldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLicpIDogX3Byb2RJbnZhcmlhbnQoJzg1JykgOiB2b2lkIDA7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlKTtcbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgdGhpcy51cGRhdGVyLmVucXVldWVDYWxsYmFjayh0aGlzLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG4gIH1cbn07XG5cbi8qKlxuICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gKlxuICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gKlxuICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAqXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHVwZGF0ZSBpcyBjb21wbGV0ZS5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5SZWFjdENvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzKTtcbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgdGhpcy51cGRhdGVyLmVucXVldWVDYWxsYmFjayh0aGlzLCBjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG4gIH1cbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddXG4gIH07XG4gIHZhciBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5mbykge1xuICAgIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZSwgbWV0aG9kTmFtZSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSkgOiB2b2lkIDA7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudC5qc1xuLy8gbW9kdWxlIGlkID0gNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuICcgKyAnVGhpcyBpcyBhIG5vLW9wLiBQbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgY29uc3RydWN0b3IgJiYgKGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJykgOiB2b2lkIDA7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciBhbGwgdGhlIHBlbmRpbmcgdXBkYXRlc1xuICAgKiBoYXZlIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gdXNlIGFzIGB0aGlzYCBjb250ZXh0LlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUNhbGxiYWNrOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrKSB7fSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC9saWIvUmVhY3ROb29wVXBkYXRlUXVldWUuanNcbi8vIG1vZHVsZSBpZCA9IDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge1xuICAgIHByb3A6ICdwcm9wJyxcbiAgICBjb250ZXh0OiAnY29udGV4dCcsXG4gICAgY2hpbGRDb250ZXh0OiAnY2hpbGQgY29udGV4dCdcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzLmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IGZhbHNlO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdHJ5IHtcbiAgICAvLyAkRmxvd0ZpeE1lIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yODVcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICd4JywgeyBnZXQ6IGZ1bmN0aW9uICgpIHt9IH0pO1xuICAgIGNhbkRlZmluZVByb3BlcnR5ID0gdHJ1ZTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIC8vIElFIHdpbGwgZmFpbCBvbiBkZWZpbmVQcm9wZXJ0eVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FuRGVmaW5lUHJvcGVydHk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0L2xpYi9jYW5EZWZpbmVQcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgU3ltYm9sICovXG5cbnZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4vKipcbiAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAqXG4gKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAqXG4gKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gKiAgICAgICAuLi5cbiAqICAgICB9XG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEl0ZXJhdG9yRm47XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0L2xpYi9nZXRJdGVyYXRvckZuLmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5T2JqZWN0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC9+L2ZianMvbGliL2VtcHR5T2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL1xuXG52YXIgaXNVbml0bGVzc051bWJlciA9IHtcbiAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IHRydWUsXG4gIGJvcmRlckltYWdlT3V0c2V0OiB0cnVlLFxuICBib3JkZXJJbWFnZVNsaWNlOiB0cnVlLFxuICBib3JkZXJJbWFnZVdpZHRoOiB0cnVlLFxuICBib3hGbGV4OiB0cnVlLFxuICBib3hGbGV4R3JvdXA6IHRydWUsXG4gIGJveE9yZGluYWxHcm91cDogdHJ1ZSxcbiAgY29sdW1uQ291bnQ6IHRydWUsXG4gIGZsZXg6IHRydWUsXG4gIGZsZXhHcm93OiB0cnVlLFxuICBmbGV4UG9zaXRpdmU6IHRydWUsXG4gIGZsZXhTaHJpbms6IHRydWUsXG4gIGZsZXhOZWdhdGl2ZTogdHJ1ZSxcbiAgZmxleE9yZGVyOiB0cnVlLFxuICBncmlkUm93OiB0cnVlLFxuICBncmlkQ29sdW1uOiB0cnVlLFxuICBmb250V2VpZ2h0OiB0cnVlLFxuICBsaW5lQ2xhbXA6IHRydWUsXG4gIGxpbmVIZWlnaHQ6IHRydWUsXG4gIG9wYWNpdHk6IHRydWUsXG4gIG9yZGVyOiB0cnVlLFxuICBvcnBoYW5zOiB0cnVlLFxuICB0YWJTaXplOiB0cnVlLFxuICB3aWRvd3M6IHRydWUsXG4gIHpJbmRleDogdHJ1ZSxcbiAgem9vbTogdHJ1ZSxcblxuICAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4gIGZpbGxPcGFjaXR5OiB0cnVlLFxuICBmbG9vZE9wYWNpdHk6IHRydWUsXG4gIHN0b3BPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VEYXNoYXJyYXk6IHRydWUsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IHRydWUsXG4gIHN0cm9rZU1pdGVybGltaXQ6IHRydWUsXG4gIHN0cm9rZU9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZVdpZHRoOiB0cnVlXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggdmVuZG9yLXNwZWNpZmljIHByZWZpeCwgZWc6IFdlYmtpdFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBzdHlsZSBuYW1lLCBlZzogdHJhbnNpdGlvbkR1cmF0aW9uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHN0eWxlIG5hbWUgcHJlZml4ZWQgd2l0aCBgcHJlZml4YCwgcHJvcGVybHkgY2FtZWxDYXNlZCwgZWc6XG4gKiBXZWJraXRUcmFuc2l0aW9uRHVyYXRpb25cbiAqL1xuZnVuY3Rpb24gcHJlZml4S2V5KHByZWZpeCwga2V5KSB7XG4gIHJldHVybiBwcmVmaXggKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyaW5nKDEpO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgc3R5bGUgbmFtZXMgdGhhdCBtYXkgY29tZSBwYXNzZWQgaW4gcHJlZml4ZWQgYnkgYWRkaW5nIHBlcm11dGF0aW9uc1xuICogb2YgdmVuZG9yIHByZWZpeGVzLlxuICovXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdtcycsICdNb3onLCAnTyddO1xuXG4vLyBVc2luZyBPYmplY3Qua2V5cyBoZXJlLCBvciBlbHNlIHRoZSB2YW5pbGxhIGZvci1pbiBsb29wIG1ha2VzIElFOCBnbyBpbnRvIGFuXG4vLyBpbmZpbml0ZSBsb29wLCBiZWNhdXNlIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIG5ld2x5IGFkZGVkIHByb3BzIHRvby5cbk9iamVjdC5rZXlzKGlzVW5pdGxlc3NOdW1iZXIpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgcHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgaXNVbml0bGVzc051bWJlcltwcmVmaXhLZXkocHJlZml4LCBwcm9wKV0gPSBpc1VuaXRsZXNzTnVtYmVyW3Byb3BdO1xuICB9KTtcbn0pO1xuXG4vKipcbiAqIE1vc3Qgc3R5bGUgcHJvcGVydGllcyBjYW4gYmUgdW5zZXQgYnkgZG9pbmcgLnN0eWxlW3Byb3BdID0gJycgYnV0IElFOFxuICogZG9lc24ndCBsaWtlIGRvaW5nIHRoYXQgd2l0aCBzaG9ydGhhbmQgcHJvcGVydGllcyBzbyBmb3IgdGhlIHByb3BlcnRpZXMgdGhhdFxuICogSUU4IGJyZWFrcyBvbiwgd2hpY2ggYXJlIGxpc3RlZCBoZXJlLCB3ZSBpbnN0ZWFkIHVuc2V0IGVhY2ggb2YgdGhlXG4gKiBpbmRpdmlkdWFsIHByb3BlcnRpZXMuIFNlZSBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM4NS5cbiAqIFRoZSA0LXZhbHVlICdjbG9jaycgcHJvcGVydGllcyBsaWtlIG1hcmdpbiwgcGFkZGluZywgYm9yZGVyLXdpZHRoIHNlZW0gdG9cbiAqIGJlaGF2ZSB3aXRob3V0IGFueSBwcm9ibGVtcy4gQ3VyaW91c2x5LCBsaXN0LXN0eWxlIHdvcmtzIHRvbyB3aXRob3V0IGFueVxuICogc3BlY2lhbCBwcm9kZGluZy5cbiAqL1xudmFyIHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9ucyA9IHtcbiAgYmFja2dyb3VuZDoge1xuICAgIGJhY2tncm91bmRBdHRhY2htZW50OiB0cnVlLFxuICAgIGJhY2tncm91bmRDb2xvcjogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IHRydWUsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWDogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25ZOiB0cnVlLFxuICAgIGJhY2tncm91bmRSZXBlYXQ6IHRydWVcbiAgfSxcbiAgYmFja2dyb3VuZFBvc2l0aW9uOiB7XG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWDogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25ZOiB0cnVlXG4gIH0sXG4gIGJvcmRlcjoge1xuICAgIGJvcmRlcldpZHRoOiB0cnVlLFxuICAgIGJvcmRlclN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckNvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlckJvdHRvbToge1xuICAgIGJvcmRlckJvdHRvbVdpZHRoOiB0cnVlLFxuICAgIGJvcmRlckJvdHRvbVN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckJvdHRvbUNvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlckxlZnQ6IHtcbiAgICBib3JkZXJMZWZ0V2lkdGg6IHRydWUsXG4gICAgYm9yZGVyTGVmdFN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckxlZnRDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJSaWdodDoge1xuICAgIGJvcmRlclJpZ2h0V2lkdGg6IHRydWUsXG4gICAgYm9yZGVyUmlnaHRTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJSaWdodENvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlclRvcDoge1xuICAgIGJvcmRlclRvcFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlclRvcFN0eWxlOiB0cnVlLFxuICAgIGJvcmRlclRvcENvbG9yOiB0cnVlXG4gIH0sXG4gIGZvbnQ6IHtcbiAgICBmb250U3R5bGU6IHRydWUsXG4gICAgZm9udFZhcmlhbnQ6IHRydWUsXG4gICAgZm9udFdlaWdodDogdHJ1ZSxcbiAgICBmb250U2l6ZTogdHJ1ZSxcbiAgICBsaW5lSGVpZ2h0OiB0cnVlLFxuICAgIGZvbnRGYW1pbHk6IHRydWVcbiAgfSxcbiAgb3V0bGluZToge1xuICAgIG91dGxpbmVXaWR0aDogdHJ1ZSxcbiAgICBvdXRsaW5lU3R5bGU6IHRydWUsXG4gICAgb3V0bGluZUNvbG9yOiB0cnVlXG4gIH1cbn07XG5cbnZhciBDU1NQcm9wZXJ0eSA9IHtcbiAgaXNVbml0bGVzc051bWJlcjogaXNVbml0bGVzc051bWJlcixcbiAgc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zOiBzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1NTUHJvcGVydHk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvQ1NTUHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCBwc2V1ZG8tZXZlbnQgbW9kdWxlIHRvIGhlbHAga2VlcCB0cmFjayBvZiBjb21wb25lbnRzIHdhaXRpbmcgdG9cbiAqIGJlIG5vdGlmaWVkIHdoZW4gdGhlaXIgRE9NIHJlcHJlc2VudGF0aW9ucyBhcmUgYXZhaWxhYmxlIGZvciB1c2UuXG4gKlxuICogVGhpcyBpbXBsZW1lbnRzIGBQb29sZWRDbGFzc2AsIHNvIHlvdSBzaG91bGQgbmV2ZXIgbmVlZCB0byBpbnN0YW50aWF0ZSB0aGlzLlxuICogSW5zdGVhZCwgdXNlIGBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpYC5cbiAqXG4gKiBAY2xhc3MgUmVhY3RNb3VudFJlYWR5XG4gKiBAaW1wbGVtZW50cyBQb29sZWRDbGFzc1xuICogQGludGVybmFsXG4gKi9cblxudmFyIENhbGxiYWNrUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENhbGxiYWNrUXVldWUoYXJnKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhbGxiYWNrUXVldWUpO1xuXG4gICAgdGhpcy5fY2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLl9jb250ZXh0cyA9IG51bGw7XG4gICAgdGhpcy5fYXJnID0gYXJnO1xuICB9XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIGBub3RpZnlBbGxgIGlzIGludm9rZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIEludm9rZWQgd2hlbiBgbm90aWZ5QWxsYCBpcyBpbnZva2VkLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IGNvbnRleHQgQ29udGV4dCB0byBjYWxsIGBjYWxsYmFja2Agd2l0aC5cbiAgICogQGludGVybmFsXG4gICAqL1xuXG5cbiAgQ2FsbGJhY2tRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZSA9IGZ1bmN0aW9uIGVucXVldWUoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwgW107XG4gICAgdGhpcy5fY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIHRoaXMuX2NvbnRleHRzID0gdGhpcy5fY29udGV4dHMgfHwgW107XG4gICAgdGhpcy5fY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgfTtcblxuICAvKipcbiAgICogSW52b2tlcyBhbGwgZW5xdWV1ZWQgY2FsbGJhY2tzIGFuZCBjbGVhcnMgdGhlIHF1ZXVlLiBUaGlzIGlzIGludm9rZWQgYWZ0ZXJcbiAgICogdGhlIERPTSByZXByZXNlbnRhdGlvbiBvZiBhIGNvbXBvbmVudCBoYXMgYmVlbiBjcmVhdGVkIG9yIHVwZGF0ZWQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuXG4gIENhbGxiYWNrUXVldWUucHJvdG90eXBlLm5vdGlmeUFsbCA9IGZ1bmN0aW9uIG5vdGlmeUFsbCgpIHtcbiAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzO1xuICAgIHZhciBjb250ZXh0cyA9IHRoaXMuX2NvbnRleHRzO1xuICAgIHZhciBhcmcgPSB0aGlzLl9hcmc7XG4gICAgaWYgKGNhbGxiYWNrcyAmJiBjb250ZXh0cykge1xuICAgICAgIShjYWxsYmFja3MubGVuZ3RoID09PSBjb250ZXh0cy5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ01pc21hdGNoZWQgbGlzdCBvZiBjb250ZXh0cyBpbiBjYWxsYmFjayBxdWV1ZScpIDogX3Byb2RJbnZhcmlhbnQoJzI0JykgOiB2b2lkIDA7XG4gICAgICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICAgICAgdGhpcy5fY29udGV4dHMgPSBudWxsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbGJhY2tzW2ldLmNhbGwoY29udGV4dHNbaV0sIGFyZyk7XG4gICAgICB9XG4gICAgICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICAgIGNvbnRleHRzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9O1xuXG4gIENhbGxiYWNrUXVldWUucHJvdG90eXBlLmNoZWNrcG9pbnQgPSBmdW5jdGlvbiBjaGVja3BvaW50KCkge1xuICAgIHJldHVybiB0aGlzLl9jYWxsYmFja3MgPyB0aGlzLl9jYWxsYmFja3MubGVuZ3RoIDogMDtcbiAgfTtcblxuICBDYWxsYmFja1F1ZXVlLnByb3RvdHlwZS5yb2xsYmFjayA9IGZ1bmN0aW9uIHJvbGxiYWNrKGxlbikge1xuICAgIGlmICh0aGlzLl9jYWxsYmFja3MgJiYgdGhpcy5fY29udGV4dHMpIHtcbiAgICAgIHRoaXMuX2NhbGxiYWNrcy5sZW5ndGggPSBsZW47XG4gICAgICB0aGlzLl9jb250ZXh0cy5sZW5ndGggPSBsZW47XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIGludGVybmFsIHF1ZXVlLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cblxuICBDYWxsYmFja1F1ZXVlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5fY29udGV4dHMgPSBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLlxuICAgKi9cblxuXG4gIENhbGxiYWNrUXVldWUucHJvdG90eXBlLmRlc3RydWN0b3IgPSBmdW5jdGlvbiBkZXN0cnVjdG9yKCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfTtcblxuICByZXR1cm4gQ2FsbGJhY2tRdWV1ZTtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb29sZWRDbGFzcy5hZGRQb29saW5nVG8oQ2FsbGJhY2tRdWV1ZSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvQ2FsbGJhY2tRdWV1ZS5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG5cbnZhciBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXInKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVggPSBuZXcgUmVnRXhwKCdeWycgKyBET01Qcm9wZXJ0eS5BVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgJ11bJyArIERPTVByb3BlcnR5LkFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xudmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgaWYgKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgJywgYXR0cmlidXRlTmFtZSkgOiB2b2lkIDA7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCBwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlICYmICF2YWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzTnVtZXJpY1ZhbHVlICYmIGlzTmFOKHZhbHVlKSB8fCBwcm9wZXJ0eUluZm8uaGFzUG9zaXRpdmVOdW1lcmljVmFsdWUgJiYgdmFsdWUgPCAxIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSBmYWxzZTtcbn1cblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciBkZWFsaW5nIHdpdGggRE9NIHByb3BlcnRpZXMuXG4gKi9cbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgSUQgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBVbmVzY2FwZWQgSUQuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZy5cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvcklEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gRE9NUHJvcGVydHkuSURfQVRUUklCVVRFX05BTUUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlcihpZCk7XG4gIH0sXG5cbiAgc2V0QXR0cmlidXRlRm9ySUQ6IGZ1bmN0aW9uIChub2RlLCBpZCkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FLCBpZCk7XG4gIH0sXG5cbiAgY3JlYXRlTWFya3VwRm9yUm9vdDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBET01Qcm9wZXJ0eS5ST09UX0FUVFJJQlVURV9OQU1FICsgJz1cIlwiJztcbiAgfSxcblxuICBzZXRBdHRyaWJ1dGVGb3JSb290OiBmdW5jdGlvbiAobm9kZSkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKERPTVByb3BlcnR5LlJPT1RfQVRUUklCVVRFX05BTUUsICcnKTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIGEgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHJldHVybiB7P3N0cmluZ30gTWFya3VwIHN0cmluZywgb3IgbnVsbCBpZiB0aGUgcHJvcGVydHkgd2FzIGludmFsaWQuXG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIHByb3BlcnR5SW5mbyA9IERPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbiAgICBpZiAocHJvcGVydHlJbmZvKSB7XG4gICAgICBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcbiAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVOYW1lICsgJz1cIlwiJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyaWJ1dGVOYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIGEgY3VzdG9tIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZywgb3IgZW1wdHkgc3RyaW5nIGlmIHRoZSBwcm9wZXJ0eSB3YXMgaW52YWxpZC5cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvckN1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICovXG4gIHNldFZhbHVlRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChub2RlLCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gRE9NUHJvcGVydHkucHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgICAgaWYgKG11dGF0aW9uTWV0aG9kKSB7XG4gICAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5kZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHkpIHtcbiAgICAgICAgLy8gQ29udHJhcnkgdG8gYHNldEF0dHJpYnV0ZWAsIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBwcm9wZXJseVxuICAgICAgICAvLyBgdG9TdHJpbmdgZWQgYnkgSUU4LzkuXG4gICAgICAgIG5vZGVbcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlO1xuICAgICAgICAvLyBgc2V0QXR0cmlidXRlYCB3aXRoIG9iamVjdHMgYmVjb21lcyBvbmx5IGBbb2JqZWN0XWAgaW4gSUU4LzksXG4gICAgICAgIC8vICgnJyArIHZhbHVlKSBtYWtlcyBpdCBvdXRwdXQgdGhlIGNvcnJlY3QgdG9TdHJpbmcoKS12YWx1ZS5cbiAgICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHBheWxvYWQgPSB7fTtcbiAgICAgIHBheWxvYWRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICBpbnN0YW5jZUlEOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShub2RlKS5fZGVidWdJRCxcbiAgICAgICAgdHlwZTogJ3VwZGF0ZSBhdHRyaWJ1dGUnLFxuICAgICAgICBwYXlsb2FkOiBwYXlsb2FkXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgc2V0VmFsdWVGb3JBdHRyaWJ1dGU6IGZ1bmN0aW9uIChub2RlLCBuYW1lLCB2YWx1ZSkge1xuICAgIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsICcnICsgdmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcGF5bG9hZCA9IHt9O1xuICAgICAgcGF5bG9hZFtuYW1lXSA9IHZhbHVlO1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgIGluc3RhbmNlSUQ6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELFxuICAgICAgICB0eXBlOiAndXBkYXRlIGF0dHJpYnV0ZScsXG4gICAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhbiBhdHRyaWJ1dGVzIGZyb20gYSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIGRlbGV0ZVZhbHVlRm9yQXR0cmlidXRlOiBmdW5jdGlvbiAobm9kZSwgbmFtZSkge1xuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgICAgaW5zdGFuY2VJRDogUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkuX2RlYnVnSUQsXG4gICAgICAgIHR5cGU6ICdyZW1vdmUgYXR0cmlidXRlJyxcbiAgICAgICAgcGF5bG9hZDogbmFtZVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKi9cbiAgZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5vZGUsIG5hbWUpIHtcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IERPTVByb3BlcnR5LnByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgICBtdXRhdGlvbk1ldGhvZChub2RlLCB1bmRlZmluZWQpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7XG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlKSB7XG4gICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlW3Byb3BOYW1lXSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICBpbnN0YW5jZUlEOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShub2RlKS5fZGVidWdJRCxcbiAgICAgICAgdHlwZTogJ3JlbW92ZSBhdHRyaWJ1dGUnLFxuICAgICAgICBwYXlsb2FkOiBuYW1lXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01Qcm9wZXJ0eU9wZXJhdGlvbnM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvRE9NUHJvcGVydHlPcGVyYXRpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01Db21wb25lbnRGbGFncyA9IHtcbiAgaGFzQ2FjaGVkQ2hpbGROb2RlczogMSA8PCAwXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQ29tcG9uZW50RmxhZ3M7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01Db21wb25lbnRGbGFncy5qc1xuLy8gbW9kdWxlIGlkID0gNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0gcmVxdWlyZSgnLi9MaW5rZWRWYWx1ZVV0aWxzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRpZFdhcm5WYWx1ZUxpbmsgPSBmYWxzZTtcbnZhciBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSBmYWxzZTtcblxuZnVuY3Rpb24gdXBkYXRlT3B0aW9uc0lmUGVuZGluZ1VwZGF0ZUFuZE1vdW50ZWQoKSB7XG4gIGlmICh0aGlzLl9yb290Tm9kZUlEICYmIHRoaXMuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlKSB7XG4gICAgdGhpcy5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUgPSBmYWxzZTtcblxuICAgIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIHVwZGF0ZU9wdGlvbnModGhpcywgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSB7XG4gIGlmIChvd25lcikge1xuICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbnZhciB2YWx1ZVByb3BOYW1lcyA9IFsndmFsdWUnLCAnZGVmYXVsdFZhbHVlJ107XG5cbi8qKlxuICogVmFsaWRhdGlvbiBmdW5jdGlvbiBmb3IgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1NlbGVjdFByb3BUeXBlcyhpbnN0LCBwcm9wcykge1xuICB2YXIgb3duZXIgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gIExpbmtlZFZhbHVlVXRpbHMuY2hlY2tQcm9wVHlwZXMoJ3NlbGVjdCcsIHByb3BzLCBvd25lcik7XG5cbiAgaWYgKHByb3BzLnZhbHVlTGluayAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVMaW5rKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgdmFsdWVMaW5rYCBwcm9wIG9uIGBzZWxlY3RgIGlzIGRlcHJlY2F0ZWQ7IHNldCBgdmFsdWVgIGFuZCBgb25DaGFuZ2VgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gICAgZGlkV2FyblZhbHVlTGluayA9IHRydWU7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlUHJvcE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3BOYW1lID0gdmFsdWVQcm9wTmFtZXNbaV07XG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHByb3BzW3Byb3BOYW1lXSk7XG4gICAgaWYgKHByb3BzLm11bHRpcGxlICYmICFpc0FycmF5KSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhbiBhcnJheSBpZiAnICsgJ2BtdWx0aXBsZWAgaXMgdHJ1ZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpKSA6IHZvaWQgMDtcbiAgICB9IGVsc2UgaWYgKCFwcm9wcy5tdWx0aXBsZSAmJiBpc0FycmF5KSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciAnICsgJ3ZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdERPTUNvbXBvbmVudH0gaW5zdFxuICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBsZVxuICogQHBhcmFtIHsqfSBwcm9wVmFsdWUgQSBzdHJpbmdhYmxlICh3aXRoIGBtdWx0aXBsZWAsIGEgbGlzdCBvZiBzdHJpbmdhYmxlcykuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zKGluc3QsIG11bHRpcGxlLCBwcm9wVmFsdWUpIHtcbiAgdmFyIHNlbGVjdGVkVmFsdWUsIGk7XG4gIHZhciBvcHRpb25zID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCkub3B0aW9ucztcblxuICBpZiAobXVsdGlwbGUpIHtcbiAgICBzZWxlY3RlZFZhbHVlID0ge307XG4gICAgZm9yIChpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgc2VsZWN0ZWRWYWx1ZVsnJyArIHByb3BWYWx1ZVtpXV0gPSB0cnVlO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlbGVjdGVkID0gc2VsZWN0ZWRWYWx1ZS5oYXNPd25Qcm9wZXJ0eShvcHRpb25zW2ldLnZhbHVlKTtcbiAgICAgIGlmIChvcHRpb25zW2ldLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb25zW2ldLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBzZXQgYHNlbGVjdC52YWx1ZWAgYXMgZXhhY3QgYmVoYXZpb3IgaXNuJ3QgY29uc2lzdGVudCBhY3Jvc3MgYWxsXG4gICAgLy8gYnJvd3NlcnMgZm9yIGFsbCBjYXNlcy5cbiAgICBzZWxlY3RlZFZhbHVlID0gJycgKyBwcm9wVmFsdWU7XG4gICAgZm9yIChpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChvcHRpb25zW2ldLnZhbHVlID09PSBzZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgIG9wdGlvbnNbaV0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxlbmd0aCkge1xuICAgICAgb3B0aW9uc1swXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDxzZWxlY3Q+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIG9wdGlvbmFsbHkgc2V0dGluZyB0aGVcbiAqIHByb3BzIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLiBJZiBgbXVsdGlwbGVgIGlzIGZhbHNlLCB0aGUgcHJvcCBtdXN0IGJlIGFcbiAqIHN0cmluZ2FibGUuIElmIGBtdWx0aXBsZWAgaXMgdHJ1ZSwgdGhlIHByb3AgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdhYmxlcy5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBjaGFuZ2UgdGhlXG4gKiBzZWxlY3RlZCBvcHRpb24gd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gKlxuICogSWYgaXQgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgb3B0aW9ucyB3aWxsIG5vdFxuICogdXBkYXRlIGluIHJlc3BvbnNlIHRvIHVzZXIgYWN0aW9ucy4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBvcHRpb25zIHRvIHVwZGF0ZS5cbiAqXG4gKiBJZiBgZGVmYXVsdFZhbHVlYCBpcyBwcm92aWRlZCwgYW55IG9wdGlvbnMgd2l0aCB0aGUgc3VwcGxpZWQgdmFsdWVzIHdpbGwgYmVcbiAqIHNlbGVjdGVkLlxuICovXG52YXIgUmVhY3RET01TZWxlY3QgPSB7XG4gIGdldEhvc3RQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgcmV0dXJuIF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICBvbkNoYW5nZTogaW5zdC5fd3JhcHBlclN0YXRlLm9uQ2hhbmdlLFxuICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgIH0pO1xuICB9LFxuXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNoZWNrU2VsZWN0UHJvcFR5cGVzKGluc3QsIHByb3BzKTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUgPSB7XG4gICAgICBwZW5kaW5nVXBkYXRlOiBmYWxzZSxcbiAgICAgIGluaXRpYWxWYWx1ZTogdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgbGlzdGVuZXJzOiBudWxsLFxuICAgICAgb25DaGFuZ2U6IF9oYW5kbGVDaGFuZ2UuYmluZChpbnN0KSxcbiAgICAgIHdhc011bHRpcGxlOiBCb29sZWFuKHByb3BzLm11bHRpcGxlKVxuICAgIH07XG5cbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1NlbGVjdCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgc2VsZWN0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJykgOiB2b2lkIDA7XG4gICAgICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfSxcblxuICBnZXRTZWxlY3RWYWx1ZUNvbnRleHQ6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgLy8gUmVhY3RET01PcHRpb24gbG9va3MgYXQgdGhpcyBpbml0aWFsIHZhbHVlIHNvIHRoZSBpbml0aWFsIGdlbmVyYXRlZFxuICAgIC8vIG1hcmt1cCBoYXMgY29ycmVjdCBgc2VsZWN0ZWRgIGF0dHJpYnV0ZXNcbiAgICByZXR1cm4gaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZTtcbiAgfSxcblxuICBwb3N0VXBkYXRlV3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIC8vIEFmdGVyIHRoZSBpbml0aWFsIG1vdW50LCB3ZSBjb250cm9sIHNlbGVjdGVkLW5lc3MgbWFudWFsbHkgc28gZG9uJ3QgcGFzc1xuICAgIC8vIHRoaXMgdmFsdWUgZG93blxuICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgICB2YXIgd2FzTXVsdGlwbGUgPSBpbnN0Ll93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGU7XG4gICAgaW5zdC5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlID0gQm9vbGVhbihwcm9wcy5tdWx0aXBsZSk7XG5cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUgPSBmYWxzZTtcbiAgICAgIHVwZGF0ZU9wdGlvbnMoaW5zdCwgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHdhc011bHRpcGxlICE9PSBCb29sZWFuKHByb3BzLm11bHRpcGxlKSkge1xuICAgICAgLy8gRm9yIHNpbXBsaWNpdHksIHJlYXBwbHkgYGRlZmF1bHRWYWx1ZWAgaWYgYG11bHRpcGxlYCBpcyB0b2dnbGVkLlxuICAgICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZU9wdGlvbnMoaW5zdCwgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHByb3BzLmRlZmF1bHRWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXZlcnQgdGhlIHNlbGVjdCBiYWNrIHRvIGl0cyBkZWZhdWx0IHVuc2VsZWN0ZWQgc3RhdGUuXG4gICAgICAgIHVwZGF0ZU9wdGlvbnMoaW5zdCwgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHByb3BzLm11bHRpcGxlID8gW10gOiAnJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICB2YXIgcmV0dXJuVmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmV4ZWN1dGVPbkNoYW5nZShwcm9wcywgZXZlbnQpO1xuXG4gIGlmICh0aGlzLl9yb290Tm9kZUlEKSB7XG4gICAgdGhpcy5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUgPSB0cnVlO1xuICB9XG4gIFJlYWN0VXBkYXRlcy5hc2FwKHVwZGF0ZU9wdGlvbnNJZlBlbmRpbmdVcGRhdGVBbmRNb3VudGVkLCB0aGlzKTtcbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NU2VsZWN0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NU2VsZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlDb21wb25lbnRGYWN0b3J5O1xuXG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudEluamVjdGlvbiA9IHtcbiAgaW5qZWN0RW1wdHlDb21wb25lbnRGYWN0b3J5OiBmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIGVtcHR5Q29tcG9uZW50RmFjdG9yeSA9IGZhY3Rvcnk7XG4gIH1cbn07XG5cbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50ID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uIChpbnN0YW50aWF0ZSkge1xuICAgIHJldHVybiBlbXB0eUNvbXBvbmVudEZhY3RvcnkoaW5zdGFudGlhdGUpO1xuICB9XG59O1xuXG5SZWFjdEVtcHR5Q29tcG9uZW50LmluamVjdGlvbiA9IFJlYWN0RW1wdHlDb21wb25lbnRJbmplY3Rpb247XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbXB0eUNvbXBvbmVudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdEVtcHR5Q29tcG9uZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEZlYXR1cmVGbGFncyA9IHtcbiAgLy8gV2hlbiB0cnVlLCBjYWxsIGNvbnNvbGUudGltZSgpIGJlZm9yZSBhbmQgLnRpbWVFbmQoKSBhZnRlciBlYWNoIHRvcC1sZXZlbFxuICAvLyByZW5kZXIgKGJvdGggaW5pdGlhbCByZW5kZXJzIGFuZCB1cGRhdGVzKS4gVXNlZnVsIHdoZW4gbG9va2luZyBhdCBwcm9kLW1vZGVcbiAgLy8gdGltZWxpbmUgcHJvZmlsZXMgaW4gQ2hyb21lLCBmb3IgZXhhbXBsZS5cbiAgbG9nVG9wTGV2ZWxSZW5kZXJzOiBmYWxzZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEZlYXR1cmVGbGFncztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdEZlYXR1cmVGbGFncy5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBnZW5lcmljQ29tcG9uZW50Q2xhc3MgPSBudWxsO1xuLy8gVGhpcyByZWdpc3RyeSBrZWVwcyB0cmFjayBvZiB3cmFwcGVyIGNsYXNzZXMgYXJvdW5kIGhvc3QgdGFncy5cbnZhciB0YWdUb0NvbXBvbmVudENsYXNzID0ge307XG52YXIgdGV4dENvbXBvbmVudENsYXNzID0gbnVsbDtcblxudmFyIFJlYWN0SG9zdENvbXBvbmVudEluamVjdGlvbiA9IHtcbiAgLy8gVGhpcyBhY2NlcHRzIGEgY2xhc3MgdGhhdCByZWNlaXZlcyB0aGUgdGFnIHN0cmluZy4gVGhpcyBpcyBhIGNhdGNoIGFsbFxuICAvLyB0aGF0IGNhbiByZW5kZXIgYW55IGtpbmQgb2YgdGFnLlxuICBpbmplY3RHZW5lcmljQ29tcG9uZW50Q2xhc3M6IGZ1bmN0aW9uIChjb21wb25lbnRDbGFzcykge1xuICAgIGdlbmVyaWNDb21wb25lbnRDbGFzcyA9IGNvbXBvbmVudENsYXNzO1xuICB9LFxuICAvLyBUaGlzIGFjY2VwdHMgYSB0ZXh0IGNvbXBvbmVudCBjbGFzcyB0aGF0IHRha2VzIHRoZSB0ZXh0IHN0cmluZyB0byBiZVxuICAvLyByZW5kZXJlZCBhcyBwcm9wcy5cbiAgaW5qZWN0VGV4dENvbXBvbmVudENsYXNzOiBmdW5jdGlvbiAoY29tcG9uZW50Q2xhc3MpIHtcbiAgICB0ZXh0Q29tcG9uZW50Q2xhc3MgPSBjb21wb25lbnRDbGFzcztcbiAgfSxcbiAgLy8gVGhpcyBhY2NlcHRzIGEga2V5ZWQgb2JqZWN0IHdpdGggY2xhc3NlcyBhcyB2YWx1ZXMuIEVhY2gga2V5IHJlcHJlc2VudHMgYVxuICAvLyB0YWcuIFRoYXQgcGFydGljdWxhciB0YWcgd2lsbCB1c2UgdGhpcyBjbGFzcyBpbnN0ZWFkIG9mIHRoZSBnZW5lcmljIG9uZS5cbiAgaW5qZWN0Q29tcG9uZW50Q2xhc3NlczogZnVuY3Rpb24gKGNvbXBvbmVudENsYXNzZXMpIHtcbiAgICBfYXNzaWduKHRhZ1RvQ29tcG9uZW50Q2xhc3MsIGNvbXBvbmVudENsYXNzZXMpO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCBhIGhvc3QgaW50ZXJuYWwgY29tcG9uZW50IGNsYXNzIGZvciBhIHNwZWNpZmljIHRhZy5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBjcmVhdGUuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGludGVybmFsIGNsYXNzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnRlcm5hbENvbXBvbmVudChlbGVtZW50KSB7XG4gICFnZW5lcmljQ29tcG9uZW50Q2xhc3MgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVGhlcmUgaXMgbm8gcmVnaXN0ZXJlZCBjb21wb25lbnQgZm9yIHRoZSB0YWcgJXMnLCBlbGVtZW50LnR5cGUpIDogX3Byb2RJbnZhcmlhbnQoJzExMScsIGVsZW1lbnQudHlwZSkgOiB2b2lkIDA7XG4gIHJldHVybiBuZXcgZ2VuZXJpY0NvbXBvbmVudENsYXNzKGVsZW1lbnQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RUZXh0fSB0ZXh0XG4gKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VGb3JUZXh0KHRleHQpIHtcbiAgcmV0dXJuIG5ldyB0ZXh0Q29tcG9uZW50Q2xhc3ModGV4dCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1RleHRDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIHJldHVybiBjb21wb25lbnQgaW5zdGFuY2VvZiB0ZXh0Q29tcG9uZW50Q2xhc3M7XG59XG5cbnZhciBSZWFjdEhvc3RDb21wb25lbnQgPSB7XG4gIGNyZWF0ZUludGVybmFsQ29tcG9uZW50OiBjcmVhdGVJbnRlcm5hbENvbXBvbmVudCxcbiAgY3JlYXRlSW5zdGFuY2VGb3JUZXh0OiBjcmVhdGVJbnN0YW5jZUZvclRleHQsXG4gIGlzVGV4dENvbXBvbmVudDogaXNUZXh0Q29tcG9uZW50LFxuICBpbmplY3Rpb246IFJlYWN0SG9zdENvbXBvbmVudEluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEhvc3RDb21wb25lbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RIb3N0Q29tcG9uZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01TZWxlY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0aW9uJyk7XG5cbnZhciBjb250YWluc05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9jb250YWluc05vZGUnKTtcbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9mb2N1c05vZGUnKTtcbnZhciBnZXRBY3RpdmVFbGVtZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudCcpO1xuXG5mdW5jdGlvbiBpc0luRG9jdW1lbnQobm9kZSkge1xuICByZXR1cm4gY29udGFpbnNOb2RlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgbm9kZSk7XG59XG5cbi8qKlxuICogQFJlYWN0SW5wdXRTZWxlY3Rpb246IFJlYWN0IGlucHV0IHNlbGVjdGlvbiBtb2R1bGUuIEJhc2VkIG9uIFNlbGVjdGlvbi5qcyxcbiAqIGJ1dCBtb2RpZmllZCB0byBiZSBzdWl0YWJsZSBmb3IgcmVhY3QgYW5kIGhhcyBhIGNvdXBsZSBvZiBidWcgZml4ZXMgKGRvZXNuJ3RcbiAqIGFzc3VtZSBidXR0b25zIGhhdmUgcmFuZ2Ugc2VsZWN0aW9ucyBhbGxvd2VkKS5cbiAqIElucHV0IHNlbGVjdGlvbiBtb2R1bGUgZm9yIFJlYWN0LlxuICovXG52YXIgUmVhY3RJbnB1dFNlbGVjdGlvbiA9IHtcblxuICBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXM6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gbm9kZU5hbWUgJiYgKG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gJ3RleHQnIHx8IG5vZGVOYW1lID09PSAndGV4dGFyZWEnIHx8IGVsZW0uY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpO1xuICB9LFxuXG4gIGdldFNlbGVjdGlvbkluZm9ybWF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICAgIHJldHVybiB7XG4gICAgICBmb2N1c2VkRWxlbTogZm9jdXNlZEVsZW0sXG4gICAgICBzZWxlY3Rpb25SYW5nZTogUmVhY3RJbnB1dFNlbGVjdGlvbi5oYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMoZm9jdXNlZEVsZW0pID8gUmVhY3RJbnB1dFNlbGVjdGlvbi5nZXRTZWxlY3Rpb24oZm9jdXNlZEVsZW0pIDogbnVsbFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXN0b3JlU2VsZWN0aW9uOiBJZiBhbnkgc2VsZWN0aW9uIGluZm9ybWF0aW9uIHdhcyBwb3RlbnRpYWxseSBsb3N0LFxuICAgKiByZXN0b3JlIGl0LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHBlcmZvcm1pbmcgb3BlcmF0aW9ucyB0aGF0IGNvdWxkIHJlbW92ZSBkb21cbiAgICogbm9kZXMgYW5kIHBsYWNlIHRoZW0gYmFjayBpbiwgcmVzdWx0aW5nIGluIGZvY3VzIGJlaW5nIGxvc3QuXG4gICAqL1xuICByZXN0b3JlU2VsZWN0aW9uOiBmdW5jdGlvbiAocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbikge1xuICAgIHZhciBjdXJGb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgICB2YXIgcHJpb3JGb2N1c2VkRWxlbSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uZm9jdXNlZEVsZW07XG4gICAgdmFyIHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNlbGVjdGlvblJhbmdlO1xuICAgIGlmIChjdXJGb2N1c2VkRWxlbSAhPT0gcHJpb3JGb2N1c2VkRWxlbSAmJiBpc0luRG9jdW1lbnQocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgIGlmIChSZWFjdElucHV0U2VsZWN0aW9uLmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgICBSZWFjdElucHV0U2VsZWN0aW9uLnNldFNlbGVjdGlvbihwcmlvckZvY3VzZWRFbGVtLCBwcmlvclNlbGVjdGlvblJhbmdlKTtcbiAgICAgIH1cbiAgICAgIGZvY3VzTm9kZShwcmlvckZvY3VzZWRFbGVtKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBnZXRTZWxlY3Rpb246IEdldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSBmb2N1c2VkIHRleHRhcmVhLCBpbnB1dCBvclxuICAgKiBjb250ZW50RWRpdGFibGUgbm9kZS5cbiAgICogLUBpbnB1dDogTG9vayB1cCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXRcbiAgICogLUByZXR1cm4ge3N0YXJ0OiBzZWxlY3Rpb25TdGFydCwgZW5kOiBzZWxlY3Rpb25FbmR9XG4gICAqL1xuICBnZXRTZWxlY3Rpb246IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHZhciBzZWxlY3Rpb247XG5cbiAgICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgICAgLy8gTW9kZXJuIGJyb3dzZXIgd2l0aCBpbnB1dCBvciB0ZXh0YXJlYS5cbiAgICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgICAgc3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICBlbmQ6IGlucHV0LnNlbGVjdGlvbkVuZFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiBpbnB1dC5ub2RlTmFtZSAmJiBpbnB1dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSB7XG4gICAgICAvLyBJRTggaW5wdXQuXG4gICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgIC8vIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSBzZWxlY3Rpb24gcGVyIGRvY3VtZW50IGluIElFLCBzbyBpdCBtdXN0XG4gICAgICAvLyBiZSBpbiBvdXIgZWxlbWVudC5cbiAgICAgIGlmIChyYW5nZS5wYXJlbnRFbGVtZW50KCkgPT09IGlucHV0KSB7XG4gICAgICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgICAgICBzdGFydDogLXJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgLWlucHV0LnZhbHVlLmxlbmd0aCksXG4gICAgICAgICAgZW5kOiAtcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgLWlucHV0LnZhbHVlLmxlbmd0aClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29udGVudCBlZGl0YWJsZSBvciBvbGQgSUUgdGV4dGFyZWEuXG4gICAgICBzZWxlY3Rpb24gPSBSZWFjdERPTVNlbGVjdGlvbi5nZXRPZmZzZXRzKGlucHV0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZWN0aW9uIHx8IHsgc3RhcnQ6IDAsIGVuZDogMCB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAc2V0U2VsZWN0aW9uOiBTZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgdGV4dGFyZWEgb3IgaW5wdXQgYW5kIGZvY3VzZXNcbiAgICogdGhlIGlucHV0LlxuICAgKiAtQGlucHV0ICAgICBTZXQgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0IG9yIHRleHRhcmVhXG4gICAqIC1Ab2Zmc2V0cyAgIE9iamVjdCBvZiBzYW1lIGZvcm0gdGhhdCBpcyByZXR1cm5lZCBmcm9tIGdldCpcbiAgICovXG4gIHNldFNlbGVjdGlvbjogZnVuY3Rpb24gKGlucHV0LCBvZmZzZXRzKSB7XG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQ7XG4gICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbmQgPSBzdGFydDtcbiAgICB9XG5cbiAgICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgICAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICAgIGlucHV0LnNlbGVjdGlvbkVuZCA9IE1hdGgubWluKGVuZCwgaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiBpbnB1dC5ub2RlTmFtZSAmJiBpbnB1dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBpbnB1dC5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBzdGFydCk7XG4gICAgICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQgLSBzdGFydCk7XG4gICAgICByYW5nZS5zZWxlY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3RET01TZWxlY3Rpb24uc2V0T2Zmc2V0cyhpbnB1dCwgb2Zmc2V0cyk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5wdXRTZWxlY3Rpb247XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RJbnB1dFNlbGVjdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Jyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RET01Db250YWluZXJJbmZvID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbnRhaW5lckluZm8nKTtcbnZhciBSZWFjdERPTUZlYXR1cmVGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RET01GZWF0dXJlRmxhZ3MnKTtcbnZhciBSZWFjdEZlYXR1cmVGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RGZWF0dXJlRmxhZ3MnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3RNYXJrdXBDaGVja3N1bSA9IHJlcXVpcmUoJy4vUmVhY3RNYXJrdXBDaGVja3N1bScpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIEFUVFJfTkFNRSA9IERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FO1xudmFyIFJPT1RfQVRUUl9OQU1FID0gRE9NUHJvcGVydHkuUk9PVF9BVFRSSUJVVEVfTkFNRTtcblxudmFyIEVMRU1FTlRfTk9ERV9UWVBFID0gMTtcbnZhciBET0NfTk9ERV9UWVBFID0gOTtcbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUgPSAxMTtcblxudmFyIGluc3RhbmNlc0J5UmVhY3RSb290SUQgPSB7fTtcblxuLyoqXG4gKiBGaW5kcyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGNoYXJhY3RlclxuICogdGhhdCdzIG5vdCBjb21tb24gYmV0d2VlbiB0aGUgdHdvIGdpdmVuIHN0cmluZ3MuXG4gKlxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgaW5kZXggb2YgdGhlIGNoYXJhY3RlciB3aGVyZSB0aGUgc3RyaW5ncyBkaXZlcmdlXG4gKi9cbmZ1bmN0aW9uIGZpcnN0RGlmZmVyZW5jZUluZGV4KHN0cmluZzEsIHN0cmluZzIpIHtcbiAgdmFyIG1pbkxlbiA9IE1hdGgubWluKHN0cmluZzEubGVuZ3RoLCBzdHJpbmcyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWluTGVuOyBpKyspIHtcbiAgICBpZiAoc3RyaW5nMS5jaGFyQXQoaSkgIT09IHN0cmluZzIuY2hhckF0KGkpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cmluZzEubGVuZ3RoID09PSBzdHJpbmcyLmxlbmd0aCA/IC0xIDogbWluTGVuO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01Eb2N1bWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRoYXQgbWF5IGNvbnRhaW5cbiAqIGEgUmVhY3QgY29tcG9uZW50XG4gKiBAcmV0dXJuIHs/Kn0gRE9NIGVsZW1lbnQgdGhhdCBtYXkgaGF2ZSB0aGUgcmVhY3RSb290IElELCBvciBudWxsLlxuICovXG5mdW5jdGlvbiBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKSB7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5maXJzdENoaWxkO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludGVybmFsR2V0SUQobm9kZSkge1xuICAvLyBJZiBub2RlIGlzIHNvbWV0aGluZyBsaWtlIGEgd2luZG93LCBkb2N1bWVudCwgb3IgdGV4dCBub2RlLCBub25lIG9mXG4gIC8vIHdoaWNoIHN1cHBvcnQgYXR0cmlidXRlcyBvciBhIC5nZXRBdHRyaWJ1dGUgbWV0aG9kLCBncmFjZWZ1bGx5IHJldHVyblxuICAvLyB0aGUgZW1wdHkgc3RyaW5nLCBhcyBpZiB0aGUgYXR0cmlidXRlIHdlcmUgbWlzc2luZy5cbiAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSkgfHwgJyc7XG59XG5cbi8qKlxuICogTW91bnRzIHRoaXMgY29tcG9uZW50IGFuZCBpbnNlcnRzIGl0IGludG8gdGhlIERPTS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnRJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gbW91bnQuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byBtb3VudCBpbnRvLlxuICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBJZiB0cnVlLCBkbyBub3QgaW5zZXJ0IG1hcmt1cFxuICovXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudEludG9Ob2RlKHdyYXBwZXJJbnN0YW5jZSwgY29udGFpbmVyLCB0cmFuc2FjdGlvbiwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpIHtcbiAgdmFyIG1hcmtlck5hbWU7XG4gIGlmIChSZWFjdEZlYXR1cmVGbGFncy5sb2dUb3BMZXZlbFJlbmRlcnMpIHtcbiAgICB2YXIgd3JhcHBlZEVsZW1lbnQgPSB3cmFwcGVySW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LnByb3BzLmNoaWxkO1xuICAgIHZhciB0eXBlID0gd3JhcHBlZEVsZW1lbnQudHlwZTtcbiAgICBtYXJrZXJOYW1lID0gJ1JlYWN0IG1vdW50OiAnICsgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHR5cGUgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSk7XG4gICAgY29uc29sZS50aW1lKG1hcmtlck5hbWUpO1xuICB9XG5cbiAgdmFyIG1hcmt1cCA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudCh3cmFwcGVySW5zdGFuY2UsIHRyYW5zYWN0aW9uLCBudWxsLCBSZWFjdERPTUNvbnRhaW5lckluZm8od3JhcHBlckluc3RhbmNlLCBjb250YWluZXIpLCBjb250ZXh0LCAwIC8qIHBhcmVudERlYnVnSUQgKi9cbiAgKTtcblxuICBpZiAobWFya2VyTmFtZSkge1xuICAgIGNvbnNvbGUudGltZUVuZChtYXJrZXJOYW1lKTtcbiAgfVxuXG4gIHdyYXBwZXJJbnN0YW5jZS5fcmVuZGVyZWRDb21wb25lbnQuX3RvcExldmVsV3JhcHBlciA9IHdyYXBwZXJJbnN0YW5jZTtcbiAgUmVhY3RNb3VudC5fbW91bnRJbWFnZUludG9Ob2RlKG1hcmt1cCwgY29udGFpbmVyLCB3cmFwcGVySW5zdGFuY2UsIHNob3VsZFJldXNlTWFya3VwLCB0cmFuc2FjdGlvbik7XG59XG5cbi8qKlxuICogQmF0Y2hlZCBtb3VudC5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnRJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gbW91bnQuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byBtb3VudCBpbnRvLlxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBJZiB0cnVlLCBkbyBub3QgaW5zZXJ0IG1hcmt1cFxuICovXG5mdW5jdGlvbiBiYXRjaGVkTW91bnRDb21wb25lbnRJbnRvTm9kZShjb21wb25lbnRJbnN0YW5jZSwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCkge1xuICB2YXIgdHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5nZXRQb29sZWQoXG4gIC8qIHVzZUNyZWF0ZUVsZW1lbnQgKi9cbiAgIXNob3VsZFJldXNlTWFya3VwICYmIFJlYWN0RE9NRmVhdHVyZUZsYWdzLnVzZUNyZWF0ZUVsZW1lbnQpO1xuICB0cmFuc2FjdGlvbi5wZXJmb3JtKG1vdW50Q29tcG9uZW50SW50b05vZGUsIG51bGwsIGNvbXBvbmVudEluc3RhbmNlLCBjb250YWluZXIsIHRyYW5zYWN0aW9uLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCk7XG4gIFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLnJlbGVhc2UodHJhbnNhY3Rpb24pO1xufVxuXG4vKipcbiAqIFVubW91bnRzIGEgY29tcG9uZW50IGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIERPTS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnN0YW5jZSBSZWFjdCBjb21wb25lbnQgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byB1bm1vdW50IGZyb20uXG4gKiBAZmluYWxcbiAqIEBpbnRlcm5hbFxuICogQHNlZSB7UmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlfVxuICovXG5mdW5jdGlvbiB1bm1vdW50Q29tcG9uZW50RnJvbU5vZGUoaW5zdGFuY2UsIGNvbnRhaW5lciwgc2FmZWx5KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5GbHVzaCgpO1xuICB9XG4gIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KGluc3RhbmNlLCBzYWZlbHkpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZEZsdXNoKCk7XG4gIH1cblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFKSB7XG4gICAgY29udGFpbmVyID0gY29udGFpbmVyLmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2VtcHR5aW5nLWEtbm9kZVxuICB3aGlsZSAoY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIubGFzdENoaWxkKTtcbiAgfVxufVxuXG4vKipcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGhhcyBhIGRpcmVjdCBSZWFjdC1yZW5kZXJlZCBjaGlsZCB0aGF0IGlzXG4gKiBub3QgYSBSZWFjdCByb290IGVsZW1lbnQuIFVzZWZ1bCBmb3Igd2FybmluZyBpbiBgcmVuZGVyYCxcbiAqIGB1bm1vdW50Q29tcG9uZW50QXROb2RlYCwgZXRjLlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBlbGVtZW50IGNvbnRhaW5zIGEgZGlyZWN0IGNoaWxkIHRoYXQgd2FzXG4gKiByZW5kZXJlZCBieSBSZWFjdCBidXQgaXMgbm90IGEgcm9vdCBlbGVtZW50LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGhhc05vblJvb3RSZWFjdENoaWxkKGNvbnRhaW5lcikge1xuICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIGlmIChyb290RWwpIHtcbiAgICB2YXIgaW5zdCA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKHJvb3RFbCk7XG4gICAgcmV0dXJuICEhKGluc3QgJiYgaW5zdC5faG9zdFBhcmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBpcyBhIFJlYWN0IERPTSBlbGVtZW50IGFuZFxuICogaXQgaGFzIGJlZW4gcmVuZGVyZWQgYnkgYW5vdGhlciBjb3B5IG9mIFJlYWN0LlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBoYXMgYmVlbiByZW5kZXJlZCBieSBhbm90aGVyIGNvcHkgb2YgUmVhY3RcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBub2RlSXNSZW5kZXJlZEJ5T3RoZXJJbnN0YW5jZShjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICByZXR1cm4gISEocm9vdEVsICYmIGlzUmVhY3ROb2RlKHJvb3RFbCkgJiYgIVJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKHJvb3RFbCkpO1xufVxuXG4vKipcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGlzIGEgdmFsaWQgbm9kZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBpcyBhIHZhbGlkIERPTSBub2RlLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRDb250YWluZXIobm9kZSkge1xuICByZXR1cm4gISEobm9kZSAmJiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUpKTtcbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBpcyBhIHZhbGlkIFJlYWN0IG5vZGUgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gaXMgYSB2YWxpZCBSZWFjdCBET00gbm9kZS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpc1JlYWN0Tm9kZShub2RlKSB7XG4gIHJldHVybiBpc1ZhbGlkQ29udGFpbmVyKG5vZGUpICYmIChub2RlLmhhc0F0dHJpYnV0ZShST09UX0FUVFJfTkFNRSkgfHwgbm9kZS5oYXNBdHRyaWJ1dGUoQVRUUl9OQU1FKSk7XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RSb290SW5zdGFuY2VJbkNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICB2YXIgcHJldkhvc3RJbnN0YW5jZSA9IHJvb3RFbCAmJiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShyb290RWwpO1xuICByZXR1cm4gcHJldkhvc3RJbnN0YW5jZSAmJiAhcHJldkhvc3RJbnN0YW5jZS5faG9zdFBhcmVudCA/IHByZXZIb3N0SW5zdGFuY2UgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRUb3BMZXZlbFdyYXBwZXJJbkNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgdmFyIHJvb3QgPSBnZXRIb3N0Um9vdEluc3RhbmNlSW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgcmV0dXJuIHJvb3QgPyByb290Ll9ob3N0Q29udGFpbmVySW5mby5fdG9wTGV2ZWxXcmFwcGVyIDogbnVsbDtcbn1cblxuLyoqXG4gKiBUZW1wb3JhcnkgKD8pIGhhY2sgc28gdGhhdCB3ZSBjYW4gc3RvcmUgYWxsIHRvcC1sZXZlbCBwZW5kaW5nIHVwZGF0ZXMgb25cbiAqIGNvbXBvc2l0ZXMgaW5zdGVhZCBvZiBoYXZpbmcgdG8gd29ycnkgYWJvdXQgZGlmZmVyZW50IHR5cGVzIG9mIGNvbXBvbmVudHNcbiAqIGhlcmUuXG4gKi9cbnZhciB0b3BMZXZlbFJvb3RDb3VudGVyID0gMTtcbnZhciBUb3BMZXZlbFdyYXBwZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucm9vdElEID0gdG9wTGV2ZWxSb290Q291bnRlcisrO1xufTtcblRvcExldmVsV3JhcHBlci5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgVG9wTGV2ZWxXcmFwcGVyLmRpc3BsYXlOYW1lID0gJ1RvcExldmVsV3JhcHBlcic7XG59XG5Ub3BMZXZlbFdyYXBwZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGQ7XG59O1xuVG9wTGV2ZWxXcmFwcGVyLmlzUmVhY3RUb3BMZXZlbFdyYXBwZXIgPSB0cnVlO1xuXG4vKipcbiAqIE1vdW50aW5nIGlzIHRoZSBwcm9jZXNzIG9mIGluaXRpYWxpemluZyBhIFJlYWN0IGNvbXBvbmVudCBieSBjcmVhdGluZyBpdHNcbiAqIHJlcHJlc2VudGF0aXZlIERPTSBlbGVtZW50cyBhbmQgaW5zZXJ0aW5nIHRoZW0gaW50byBhIHN1cHBsaWVkIGBjb250YWluZXJgLlxuICogQW55IHByaW9yIGNvbnRlbnQgaW5zaWRlIGBjb250YWluZXJgIGlzIGRlc3Ryb3llZCBpbiB0aGUgcHJvY2Vzcy5cbiAqXG4gKiAgIFJlYWN0TW91bnQucmVuZGVyKFxuICogICAgIGNvbXBvbmVudCxcbiAqICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVyJylcbiAqICAgKTtcbiAqXG4gKiAgIDxkaXYgaWQ9XCJjb250YWluZXJcIj4gICAgICAgICAgICAgICAgICAgPC0tIFN1cHBsaWVkIGBjb250YWluZXJgLlxuICogICAgIDxkaXYgZGF0YS1yZWFjdGlkPVwiLjNcIj4gICAgICAgICAgICAgIDwtLSBSZW5kZXJlZCByZWFjdFJvb3Qgb2YgUmVhY3RcbiAqICAgICAgIC8vIC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5cbiAqICAgICA8L2Rpdj5cbiAqICAgPC9kaXY+XG4gKlxuICogSW5zaWRlIG9mIGBjb250YWluZXJgLCB0aGUgZmlyc3QgZWxlbWVudCByZW5kZXJlZCBpcyB0aGUgXCJyZWFjdFJvb3RcIi5cbiAqL1xudmFyIFJlYWN0TW91bnQgPSB7XG5cbiAgVG9wTGV2ZWxXcmFwcGVyOiBUb3BMZXZlbFdyYXBwZXIsXG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgZGV2dG9vbHMuIFRoZSBrZXlzIGFyZSBub3QgaW1wb3J0YW50LlxuICAgKi9cbiAgX2luc3RhbmNlc0J5UmVhY3RSb290SUQ6IGluc3RhbmNlc0J5UmVhY3RSb290SUQsXG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBob29rIHByb3ZpZGVkIHRvIHN1cHBvcnQgcmVuZGVyaW5nIFJlYWN0IGNvbXBvbmVudHMgd2hpbGVcbiAgICogZW5zdXJpbmcgdGhhdCB0aGUgYXBwYXJlbnQgc2Nyb2xsIHBvc2l0aW9uIG9mIGl0cyBgY29udGFpbmVyYCBkb2VzIG5vdFxuICAgKiBjaGFuZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIFRoZSBgY29udGFpbmVyYCBiZWluZyByZW5kZXJlZCBpbnRvLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSByZW5kZXJDYWxsYmFjayBUaGlzIG11c3QgYmUgY2FsbGVkIG9uY2UgdG8gZG8gdGhlIHJlbmRlci5cbiAgICovXG4gIHNjcm9sbE1vbml0b3I6IGZ1bmN0aW9uIChjb250YWluZXIsIHJlbmRlckNhbGxiYWNrKSB7XG4gICAgcmVuZGVyQ2FsbGJhY2soKTtcbiAgfSxcblxuICAvKipcbiAgICogVGFrZSBhIGNvbXBvbmVudCB0aGF0J3MgYWxyZWFkeSBtb3VudGVkIGludG8gdGhlIERPTSBhbmQgcmVwbGFjZSBpdHMgcHJvcHNcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gcHJldkNvbXBvbmVudCBjb21wb25lbnQgaW5zdGFuY2UgYWxyZWFkeSBpbiB0aGUgRE9NXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBjb21wb25lbnQgaW5zdGFuY2UgdG8gcmVuZGVyXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lciB0byByZW5kZXIgaW50b1xuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICovXG4gIF91cGRhdGVSb290Q29tcG9uZW50OiBmdW5jdGlvbiAocHJldkNvbXBvbmVudCwgbmV4dEVsZW1lbnQsIG5leHRDb250ZXh0LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgUmVhY3RNb3VudC5zY3JvbGxNb25pdG9yKGNvbnRhaW5lciwgZnVuY3Rpb24gKCkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlRWxlbWVudEludGVybmFsKHByZXZDb21wb25lbnQsIG5leHRFbGVtZW50LCBuZXh0Q29udGV4dCk7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlQ2FsbGJhY2tJbnRlcm5hbChwcmV2Q29tcG9uZW50LCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJldkNvbXBvbmVudDtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVyIGEgbmV3IGNvbXBvbmVudCBpbnRvIHRoZSBET00uIEhvb2tlZCBieSBob29rcyFcbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IGVsZW1lbnQgdG8gcmVuZGVyXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lciB0byByZW5kZXIgaW50b1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIGlmIHdlIHNob3VsZCBza2lwIHRoZSBtYXJrdXAgaW5zZXJ0aW9uXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBuZXh0Q29tcG9uZW50XG4gICAqL1xuICBfcmVuZGVyTmV3Um9vdENvbXBvbmVudDogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KSB7XG4gICAgLy8gVmFyaW91cyBwYXJ0cyBvZiBvdXIgY29kZSAoc3VjaCBhcyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdzXG4gICAgLy8gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCkgYXNzdW1lIHRoYXQgY2FsbHMgdG8gcmVuZGVyIGFyZW4ndCBuZXN0ZWQ7XG4gICAgLy8gdmVyaWZ5IHRoYXQgdGhhdCdzIHRoZSBjYXNlLlxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPT0gbnVsbCwgJ19yZW5kZXJOZXdSb290Q29tcG9uZW50KCk6IFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gJyArICdvZiBwcm9wcyBhbmQgc3RhdGU7IHRyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gJyArICdyZW5kZXIgaXMgbm90IGFsbG93ZWQuIElmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuJywgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcblxuICAgICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnX3JlZ2lzdGVyQ29tcG9uZW50KC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzcnKSA6IHZvaWQgMDtcblxuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5lbnN1cmVTY3JvbGxWYWx1ZU1vbml0b3JpbmcoKTtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRFbGVtZW50LCBmYWxzZSk7XG5cbiAgICAvLyBUaGUgaW5pdGlhbCByZW5kZXIgaXMgc3luY2hyb25vdXMgYnV0IGFueSB1cGRhdGVzIHRoYXQgaGFwcGVuIGR1cmluZ1xuICAgIC8vIHJlbmRlcmluZywgaW4gY29tcG9uZW50V2lsbE1vdW50IG9yIGNvbXBvbmVudERpZE1vdW50LCB3aWxsIGJlIGJhdGNoZWRcbiAgICAvLyBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgYmF0Y2hpbmcgc3RyYXRlZ3kuXG5cbiAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMoYmF0Y2hlZE1vdW50Q29tcG9uZW50SW50b05vZGUsIGNvbXBvbmVudEluc3RhbmNlLCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KTtcblxuICAgIHZhciB3cmFwcGVySUQgPSBjb21wb25lbnRJbnN0YW5jZS5faW5zdGFuY2Uucm9vdElEO1xuICAgIGluc3RhbmNlc0J5UmVhY3RSb290SURbd3JhcHBlcklEXSA9IGNvbXBvbmVudEluc3RhbmNlO1xuXG4gICAgcmV0dXJuIGNvbXBvbmVudEluc3RhbmNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgUmVhY3QgY29tcG9uZW50IGludG8gdGhlIERPTSBpbiB0aGUgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gICAqXG4gICAqIElmIHRoZSBSZWFjdCBjb21wb25lbnQgd2FzIHByZXZpb3VzbHkgcmVuZGVyZWQgaW50byBgY29udGFpbmVyYCwgdGhpcyB3aWxsXG4gICAqIHBlcmZvcm0gYW4gdXBkYXRlIG9uIGl0IGFuZCBvbmx5IG11dGF0ZSB0aGUgRE9NIGFzIG5lY2Vzc2FyeSB0byByZWZsZWN0IHRoZVxuICAgKiBsYXRlc3QgUmVhY3QgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBwYXJlbnRDb21wb25lbnQgVGhlIGNvbmNlcHR1YWwgcGFyZW50IG9mIHRoaXMgcmVuZGVyIHRyZWUuXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBDb21wb25lbnQgZWxlbWVudCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IENvbXBvbmVudCBpbnN0YW5jZSByZW5kZXJlZCBpbiBgY29udGFpbmVyYC5cbiAgICovXG4gIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiBmdW5jdGlvbiAocGFyZW50Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgICEocGFyZW50Q29tcG9uZW50ICE9IG51bGwgJiYgUmVhY3RJbnN0YW5jZU1hcC5oYXMocGFyZW50Q29tcG9uZW50KSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncGFyZW50Q29tcG9uZW50IG11c3QgYmUgYSB2YWxpZCBSZWFjdCBDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCczOCcpIDogdm9pZCAwO1xuICAgIHJldHVybiBSZWFjdE1vdW50Ll9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKTtcbiAgfSxcblxuICBfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgUmVhY3RVcGRhdGVRdWV1ZS52YWxpZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCAnUmVhY3RET00ucmVuZGVyJyk7XG4gICAgIVJlYWN0LmlzVmFsaWRFbGVtZW50KG5leHRFbGVtZW50KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTS5yZW5kZXIoKTogSW52YWxpZCBjb21wb25lbnQgZWxlbWVudC4lcycsIHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ3N0cmluZycgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhIHN0cmluZyBsaWtlIFxcJ2RpdlxcJywgcGFzcyAnICsgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQoXFwnZGl2XFwnKSBvciA8ZGl2IC8+LicgOiB0eXBlb2YgbmV4dEVsZW1lbnQgPT09ICdmdW5jdGlvbicgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhIGNsYXNzIGxpa2UgRm9vLCBwYXNzICcgKyAnUmVhY3QuY3JlYXRlRWxlbWVudChGb28pIG9yIDxGb28gLz4uJyA6XG4gICAgLy8gQ2hlY2sgaWYgaXQgcXVhY2tzIGxpa2UgYW4gZWxlbWVudFxuICAgIG5leHRFbGVtZW50ICE9IG51bGwgJiYgbmV4dEVsZW1lbnQucHJvcHMgIT09IHVuZGVmaW5lZCA/ICcgVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHVuaW50ZW50aW9uYWxseSBsb2FkaW5nIHR3byBpbmRlcGVuZGVudCAnICsgJ2NvcGllcyBvZiBSZWFjdC4nIDogJycpIDogX3Byb2RJbnZhcmlhbnQoJzM5JywgdHlwZW9mIG5leHRFbGVtZW50ID09PSAnc3RyaW5nJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgc3RyaW5nIGxpa2UgXFwnZGl2XFwnLCBwYXNzICcgKyAnUmVhY3QuY3JlYXRlRWxlbWVudChcXCdkaXZcXCcpIG9yIDxkaXYgLz4uJyA6IHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ2Z1bmN0aW9uJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgY2xhc3MgbGlrZSBGb28sIHBhc3MgJyArICdSZWFjdC5jcmVhdGVFbGVtZW50KEZvbykgb3IgPEZvbyAvPi4nIDogbmV4dEVsZW1lbnQgIT0gbnVsbCAmJiBuZXh0RWxlbWVudC5wcm9wcyAhPT0gdW5kZWZpbmVkID8gJyBUaGlzIG1heSBiZSBjYXVzZWQgYnkgdW5pbnRlbnRpb25hbGx5IGxvYWRpbmcgdHdvIGluZGVwZW5kZW50ICcgKyAnY29waWVzIG9mIFJlYWN0LicgOiAnJykgOiB2b2lkIDA7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY29udGFpbmVyIHx8ICFjb250YWluZXIudGFnTmFtZSB8fCBjb250YWluZXIudGFnTmFtZS50b1VwcGVyQ2FzZSgpICE9PSAnQk9EWScsICdyZW5kZXIoKTogUmVuZGVyaW5nIGNvbXBvbmVudHMgZGlyZWN0bHkgaW50byBkb2N1bWVudC5ib2R5IGlzICcgKyAnZGlzY291cmFnZWQsIHNpbmNlIGl0cyBjaGlsZHJlbiBhcmUgb2Z0ZW4gbWFuaXB1bGF0ZWQgYnkgdGhpcmQtcGFydHkgJyArICdzY3JpcHRzIGFuZCBicm93c2VyIGV4dGVuc2lvbnMuIFRoaXMgbWF5IGxlYWQgdG8gc3VidGxlICcgKyAncmVjb25jaWxpYXRpb24gaXNzdWVzLiBUcnkgcmVuZGVyaW5nIGludG8gYSBjb250YWluZXIgZWxlbWVudCBjcmVhdGVkICcgKyAnZm9yIHlvdXIgYXBwLicpIDogdm9pZCAwO1xuXG4gICAgdmFyIG5leHRXcmFwcGVkRWxlbWVudCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoVG9wTGV2ZWxXcmFwcGVyLCB7IGNoaWxkOiBuZXh0RWxlbWVudCB9KTtcblxuICAgIHZhciBuZXh0Q29udGV4dDtcbiAgICBpZiAocGFyZW50Q29tcG9uZW50KSB7XG4gICAgICB2YXIgcGFyZW50SW5zdCA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHBhcmVudENvbXBvbmVudCk7XG4gICAgICBuZXh0Q29udGV4dCA9IHBhcmVudEluc3QuX3Byb2Nlc3NDaGlsZENvbnRleHQocGFyZW50SW5zdC5fY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRDb250ZXh0ID0gZW1wdHlPYmplY3Q7XG4gICAgfVxuXG4gICAgdmFyIHByZXZDb21wb25lbnQgPSBnZXRUb3BMZXZlbFdyYXBwZXJJbkNvbnRhaW5lcihjb250YWluZXIpO1xuXG4gICAgaWYgKHByZXZDb21wb25lbnQpIHtcbiAgICAgIHZhciBwcmV2V3JhcHBlZEVsZW1lbnQgPSBwcmV2Q29tcG9uZW50Ll9jdXJyZW50RWxlbWVudDtcbiAgICAgIHZhciBwcmV2RWxlbWVudCA9IHByZXZXcmFwcGVkRWxlbWVudC5wcm9wcy5jaGlsZDtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpKSB7XG4gICAgICAgIHZhciBwdWJsaWNJbnN0ID0gcHJldkNvbXBvbmVudC5fcmVuZGVyZWRDb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICAgICAgdmFyIHVwZGF0ZWRDYWxsYmFjayA9IGNhbGxiYWNrICYmIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYWxsYmFjay5jYWxsKHB1YmxpY0luc3QpO1xuICAgICAgICB9O1xuICAgICAgICBSZWFjdE1vdW50Ll91cGRhdGVSb290Q29tcG9uZW50KHByZXZDb21wb25lbnQsIG5leHRXcmFwcGVkRWxlbWVudCwgbmV4dENvbnRleHQsIGNvbnRhaW5lciwgdXBkYXRlZENhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHB1YmxpY0luc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBSZWFjdE1vdW50LnVubW91bnRDb21wb25lbnRBdE5vZGUoY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVhY3RSb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIHZhciBjb250YWluZXJIYXNSZWFjdE1hcmt1cCA9IHJlYWN0Um9vdEVsZW1lbnQgJiYgISFpbnRlcm5hbEdldElEKHJlYWN0Um9vdEVsZW1lbnQpO1xuICAgIHZhciBjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCA9IGhhc05vblJvb3RSZWFjdENoaWxkKGNvbnRhaW5lcik7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkLCAncmVuZGVyKC4uLik6IFJlcGxhY2luZyBSZWFjdC1yZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgbmV3IHJvb3QgJyArICdjb21wb25lbnQuIElmIHlvdSBpbnRlbmRlZCB0byB1cGRhdGUgdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSwgJyArICd5b3Ugc2hvdWxkIGluc3RlYWQgaGF2ZSB0aGUgZXhpc3RpbmcgY2hpbGRyZW4gdXBkYXRlIHRoZWlyIHN0YXRlICcgKyAnYW5kIHJlbmRlciB0aGUgbmV3IGNvbXBvbmVudHMgaW5zdGVhZCBvZiBjYWxsaW5nIFJlYWN0RE9NLnJlbmRlci4nKSA6IHZvaWQgMDtcblxuICAgICAgaWYgKCFjb250YWluZXJIYXNSZWFjdE1hcmt1cCB8fCByZWFjdFJvb3RFbGVtZW50Lm5leHRTaWJsaW5nKSB7XG4gICAgICAgIHZhciByb290RWxlbWVudFNpYmxpbmcgPSByZWFjdFJvb3RFbGVtZW50O1xuICAgICAgICB3aGlsZSAocm9vdEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgICAgICAgaWYgKGludGVybmFsR2V0SUQocm9vdEVsZW1lbnRTaWJsaW5nKSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdyZW5kZXIoKTogVGFyZ2V0IG5vZGUgaGFzIG1hcmt1cCByZW5kZXJlZCBieSBSZWFjdCwgYnV0IHRoZXJlICcgKyAnYXJlIHVucmVsYXRlZCBub2RlcyBhcyB3ZWxsLiBUaGlzIGlzIG1vc3QgY29tbW9ubHkgY2F1c2VkIGJ5ICcgKyAnd2hpdGUtc3BhY2UgaW5zZXJ0ZWQgYXJvdW5kIHNlcnZlci1yZW5kZXJlZCBtYXJrdXAuJykgOiB2b2lkIDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcm9vdEVsZW1lbnRTaWJsaW5nID0gcm9vdEVsZW1lbnRTaWJsaW5nLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNob3VsZFJldXNlTWFya3VwID0gY29udGFpbmVySGFzUmVhY3RNYXJrdXAgJiYgIXByZXZDb21wb25lbnQgJiYgIWNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkO1xuICAgIHZhciBjb21wb25lbnQgPSBSZWFjdE1vdW50Ll9yZW5kZXJOZXdSb290Q29tcG9uZW50KG5leHRXcmFwcGVkRWxlbWVudCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgbmV4dENvbnRleHQpLl9yZW5kZXJlZENvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2suY2FsbChjb21wb25lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgUmVhY3QgY29tcG9uZW50IGludG8gdGhlIERPTSBpbiB0aGUgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gICAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdGRvbS5yZW5kZXJcbiAgICpcbiAgICogSWYgdGhlIFJlYWN0IGNvbXBvbmVudCB3YXMgcHJldmlvdXNseSByZW5kZXJlZCBpbnRvIGBjb250YWluZXJgLCB0aGlzIHdpbGxcbiAgICogcGVyZm9ybSBhbiB1cGRhdGUgb24gaXQgYW5kIG9ubHkgbXV0YXRlIHRoZSBET00gYXMgbmVjZXNzYXJ5IHRvIHJlZmxlY3QgdGhlXG4gICAqIGxhdGVzdCBSZWFjdCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBDb21wb25lbnQgZWxlbWVudCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IENvbXBvbmVudCBpbnN0YW5jZSByZW5kZXJlZCBpbiBgY29udGFpbmVyYC5cbiAgICovXG4gIHJlbmRlcjogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogVW5tb3VudHMgYW5kIGRlc3Ryb3lzIHRoZSBSZWFjdCBjb21wb25lbnQgcmVuZGVyZWQgaW4gdGhlIGBjb250YWluZXJgLlxuICAgKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3Rkb20udW5tb3VudGNvbXBvbmVudGF0bm9kZVxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCBjb250YWluaW5nIGEgUmVhY3QgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGEgY29tcG9uZW50IHdhcyBmb3VuZCBpbiBhbmQgdW5tb3VudGVkIGZyb21cbiAgICogICAgICAgICAgICAgICAgICAgYGNvbnRhaW5lcmBcbiAgICovXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAvLyBWYXJpb3VzIHBhcnRzIG9mIG91ciBjb2RlIChzdWNoIGFzIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50J3NcbiAgICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgICAvLyB2ZXJpZnkgdGhhdCB0aGF0J3MgdGhlIGNhc2UuIChTdHJpY3RseSBzcGVha2luZywgdW5tb3VudGluZyB3b24ndCBjYXVzZSBhXG4gICAgLy8gcmVuZGVyIGJ1dCB3ZSBzdGlsbCBkb24ndCBleHBlY3QgdG8gYmUgaW4gYSByZW5kZXIgY2FsbCBoZXJlLilcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gJyArICdvZiBwcm9wcyBhbmQgc3RhdGU7IHRyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyICcgKyAnaXMgbm90IGFsbG93ZWQuIElmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuJywgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcblxuICAgICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzQwJykgOiB2b2lkIDA7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIW5vZGVJc1JlbmRlcmVkQnlPdGhlckluc3RhbmNlKGNvbnRhaW5lciksICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCAnICsgJ3dhcyByZW5kZXJlZCBieSBhbm90aGVyIGNvcHkgb2YgUmVhY3QuJykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdmFyIHByZXZDb21wb25lbnQgPSBnZXRUb3BMZXZlbFdyYXBwZXJJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIGlmICghcHJldkNvbXBvbmVudCkge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhlIG5vZGUgYmVpbmcgdW5tb3VudGVkIHdhcyByZW5kZXJlZCBieSBSZWFjdCwgYnV0IGlzbid0IGFcbiAgICAgIC8vIHJvb3Qgbm9kZS5cbiAgICAgIHZhciBjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCA9IGhhc05vblJvb3RSZWFjdENoaWxkKGNvbnRhaW5lcik7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250YWluZXIgaXRzZWxmIGlzIGEgUmVhY3Qgcm9vdCBub2RlLlxuICAgICAgdmFyIGlzQ29udGFpbmVyUmVhY3RSb290ID0gY29udGFpbmVyLm5vZGVUeXBlID09PSAxICYmIGNvbnRhaW5lci5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSX05BTUUpO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCAnICsgJ3dhcyByZW5kZXJlZCBieSBSZWFjdCBhbmQgaXMgbm90IGEgdG9wLWxldmVsIGNvbnRhaW5lci4gJXMnLCBpc0NvbnRhaW5lclJlYWN0Um9vdCA/ICdZb3UgbWF5IGhhdmUgYWNjaWRlbnRhbGx5IHBhc3NlZCBpbiBhIFJlYWN0IHJvb3Qgbm9kZSBpbnN0ZWFkICcgKyAnb2YgaXRzIGNvbnRhaW5lci4nIDogJ0luc3RlYWQsIGhhdmUgdGhlIHBhcmVudCBjb21wb25lbnQgdXBkYXRlIGl0cyBzdGF0ZSBhbmQgJyArICdyZXJlbmRlciBpbiBvcmRlciB0byByZW1vdmUgdGhpcyBjb21wb25lbnQuJykgOiB2b2lkIDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGVsZXRlIGluc3RhbmNlc0J5UmVhY3RSb290SURbcHJldkNvbXBvbmVudC5faW5zdGFuY2Uucm9vdElEXTtcbiAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXModW5tb3VudENvbXBvbmVudEZyb21Ob2RlLCBwcmV2Q29tcG9uZW50LCBjb250YWluZXIsIGZhbHNlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICBfbW91bnRJbWFnZUludG9Ob2RlOiBmdW5jdGlvbiAobWFya3VwLCBjb250YWluZXIsIGluc3RhbmNlLCBzaG91bGRSZXVzZU1hcmt1cCwgdHJhbnNhY3Rpb24pIHtcbiAgICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ21vdW50Q29tcG9uZW50SW50b05vZGUoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgdmFsaWQuJykgOiBfcHJvZEludmFyaWFudCgnNDEnKSA6IHZvaWQgMDtcblxuICAgIGlmIChzaG91bGRSZXVzZU1hcmt1cCkge1xuICAgICAgdmFyIHJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICBpZiAoUmVhY3RNYXJrdXBDaGVja3N1bS5jYW5SZXVzZU1hcmt1cChtYXJrdXAsIHJvb3RFbGVtZW50KSkge1xuICAgICAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUucHJlY2FjaGVOb2RlKGluc3RhbmNlLCByb290RWxlbWVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjaGVja3N1bSA9IHJvb3RFbGVtZW50LmdldEF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSk7XG4gICAgICAgIHJvb3RFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSk7XG5cbiAgICAgICAgdmFyIHJvb3RNYXJrdXAgPSByb290RWxlbWVudC5vdXRlckhUTUw7XG4gICAgICAgIHJvb3RFbGVtZW50LnNldEF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSwgY2hlY2tzdW0pO1xuXG4gICAgICAgIHZhciBub3JtYWxpemVkTWFya3VwID0gbWFya3VwO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIC8vIGJlY2F1c2Ugcm9vdE1hcmt1cCBpcyByZXRyaWV2ZWQgZnJvbSB0aGUgRE9NLCB2YXJpb3VzIG5vcm1hbGl6YXRpb25zXG4gICAgICAgICAgLy8gd2lsbCBoYXZlIG9jY3VycmVkIHdoaWNoIHdpbGwgbm90IGJlIHByZXNlbnQgaW4gYG1hcmt1cGAuIEhlcmUsXG4gICAgICAgICAgLy8gaW5zZXJ0IG1hcmt1cCBpbnRvIGEgPGRpdj4gb3IgPGlmcmFtZT4gZGVwZW5kaW5nIG9uIHRoZSBjb250YWluZXJcbiAgICAgICAgICAvLyB0eXBlIHRvIHBlcmZvcm0gdGhlIHNhbWUgbm9ybWFsaXphdGlvbnMgYmVmb3JlIGNvbXBhcmluZy5cbiAgICAgICAgICB2YXIgbm9ybWFsaXplcjtcbiAgICAgICAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSkge1xuICAgICAgICAgICAgbm9ybWFsaXplciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgbm9ybWFsaXplci5pbm5lckhUTUwgPSBtYXJrdXA7XG4gICAgICAgICAgICBub3JtYWxpemVkTWFya3VwID0gbm9ybWFsaXplci5pbm5lckhUTUw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobm9ybWFsaXplcik7XG4gICAgICAgICAgICBub3JtYWxpemVyLmNvbnRlbnREb2N1bWVudC53cml0ZShtYXJrdXApO1xuICAgICAgICAgICAgbm9ybWFsaXplZE1hcmt1cCA9IG5vcm1hbGl6ZXIuY29udGVudERvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vdXRlckhUTUw7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG5vcm1hbGl6ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaWZmSW5kZXggPSBmaXJzdERpZmZlcmVuY2VJbmRleChub3JtYWxpemVkTWFya3VwLCByb290TWFya3VwKTtcbiAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSAnIChjbGllbnQpICcgKyBub3JtYWxpemVkTWFya3VwLnN1YnN0cmluZyhkaWZmSW5kZXggLSAyMCwgZGlmZkluZGV4ICsgMjApICsgJ1xcbiAoc2VydmVyKSAnICsgcm9vdE1hcmt1cC5zdWJzdHJpbmcoZGlmZkluZGV4IC0gMjAsIGRpZmZJbmRleCArIDIwKTtcblxuICAgICAgICAhKGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRE9DX05PREVfVFlQRSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnWW91XFwncmUgdHJ5aW5nIHRvIHJlbmRlciBhIGNvbXBvbmVudCB0byB0aGUgZG9jdW1lbnQgdXNpbmcgc2VydmVyIHJlbmRlcmluZyBidXQgdGhlIGNoZWNrc3VtIHdhcyBpbnZhbGlkLiBUaGlzIHVzdWFsbHkgbWVhbnMgeW91IHJlbmRlcmVkIGEgZGlmZmVyZW50IGNvbXBvbmVudCB0eXBlIG9yIHByb3BzIG9uIHRoZSBjbGllbnQgZnJvbSB0aGUgb25lIG9uIHRoZSBzZXJ2ZXIsIG9yIHlvdXIgcmVuZGVyKCkgbWV0aG9kcyBhcmUgaW1wdXJlLiBSZWFjdCBjYW5ub3QgaGFuZGxlIHRoaXMgY2FzZSBkdWUgdG8gY3Jvc3MtYnJvd3NlciBxdWlya3MgYnkgcmVuZGVyaW5nIGF0IHRoZSBkb2N1bWVudCByb290LiBZb3Ugc2hvdWxkIGxvb2sgZm9yIGVudmlyb25tZW50IGRlcGVuZGVudCBjb2RlIGluIHlvdXIgY29tcG9uZW50cyBhbmQgZW5zdXJlIHRoZSBwcm9wcyBhcmUgdGhlIHNhbWUgY2xpZW50IGFuZCBzZXJ2ZXIgc2lkZTpcXG4lcycsIGRpZmZlcmVuY2UpIDogX3Byb2RJbnZhcmlhbnQoJzQyJywgZGlmZmVyZW5jZSkgOiB2b2lkIDA7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0IGF0dGVtcHRlZCB0byByZXVzZSBtYXJrdXAgaW4gYSBjb250YWluZXIgYnV0IHRoZSAnICsgJ2NoZWNrc3VtIHdhcyBpbnZhbGlkLiBUaGlzIGdlbmVyYWxseSBtZWFucyB0aGF0IHlvdSBhcmUgJyArICd1c2luZyBzZXJ2ZXIgcmVuZGVyaW5nIGFuZCB0aGUgbWFya3VwIGdlbmVyYXRlZCBvbiB0aGUgJyArICdzZXJ2ZXIgd2FzIG5vdCB3aGF0IHRoZSBjbGllbnQgd2FzIGV4cGVjdGluZy4gUmVhY3QgaW5qZWN0ZWQgJyArICduZXcgbWFya3VwIHRvIGNvbXBlbnNhdGUgd2hpY2ggd29ya3MgYnV0IHlvdSBoYXZlIGxvc3QgbWFueSAnICsgJ29mIHRoZSBiZW5lZml0cyBvZiBzZXJ2ZXIgcmVuZGVyaW5nLiBJbnN0ZWFkLCBmaWd1cmUgb3V0ICcgKyAnd2h5IHRoZSBtYXJrdXAgYmVpbmcgZ2VuZXJhdGVkIGlzIGRpZmZlcmVudCBvbiB0aGUgY2xpZW50ICcgKyAnb3Igc2VydmVyOlxcbiVzJywgZGlmZmVyZW5jZSkgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAhKGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRE9DX05PREVfVFlQRSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnWW91XFwncmUgdHJ5aW5nIHRvIHJlbmRlciBhIGNvbXBvbmVudCB0byB0aGUgZG9jdW1lbnQgYnV0IHlvdSBkaWRuXFwndCB1c2Ugc2VydmVyIHJlbmRlcmluZy4gV2UgY2FuXFwndCBkbyB0aGlzIHdpdGhvdXQgdXNpbmcgc2VydmVyIHJlbmRlcmluZyBkdWUgdG8gY3Jvc3MtYnJvd3NlciBxdWlya3MuIFNlZSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZygpIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLicpIDogX3Byb2RJbnZhcmlhbnQoJzQzJykgOiB2b2lkIDA7XG5cbiAgICBpZiAodHJhbnNhY3Rpb24udXNlQ3JlYXRlRWxlbWVudCkge1xuICAgICAgd2hpbGUgKGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5sYXN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgRE9NTGF6eVRyZWUuaW5zZXJ0VHJlZUJlZm9yZShjb250YWluZXIsIG1hcmt1cCwgbnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldElubmVySFRNTChjb250YWluZXIsIG1hcmt1cCk7XG4gICAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUucHJlY2FjaGVOb2RlKGluc3RhbmNlLCBjb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBob3N0Tm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKGNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICAgIGlmIChob3N0Tm9kZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgICAgICBpbnN0YW5jZUlEOiBob3N0Tm9kZS5fZGVidWdJRCxcbiAgICAgICAgICB0eXBlOiAnbW91bnQnLFxuICAgICAgICAgIHBheWxvYWQ6IG1hcmt1cC50b1N0cmluZygpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1vdW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0TW91bnQuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Tm9kZVR5cGVzID0ge1xuICBIT1NUOiAwLFxuICBDT01QT1NJVEU6IDEsXG4gIEVNUFRZOiAyLFxuXG4gIGdldFR5cGU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBSZWFjdE5vZGVUeXBlcy5FTVBUWTtcbiAgICB9IGVsc2UgaWYgKFJlYWN0LmlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgICBpZiAodHlwZW9mIG5vZGUudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gUmVhY3ROb2RlVHlwZXMuQ09NUE9TSVRFO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0Tm9kZVR5cGVzLkhPU1Q7XG4gICAgICB9XG4gICAgfVxuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmV4cGVjdGVkIG5vZGU6ICVzJywgbm9kZSkgOiBfcHJvZEludmFyaWFudCgnMjYnLCBub2RlKSA6IHZvaWQgMDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE5vZGVUeXBlcztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdE5vZGVUeXBlcy5qc1xuLy8gbW9kdWxlIGlkID0gNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmlld3BvcnRNZXRyaWNzID0ge1xuXG4gIGN1cnJlbnRTY3JvbGxMZWZ0OiAwLFxuXG4gIGN1cnJlbnRTY3JvbGxUb3A6IDAsXG5cbiAgcmVmcmVzaFNjcm9sbFZhbHVlczogZnVuY3Rpb24gKHNjcm9sbFBvc2l0aW9uKSB7XG4gICAgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxMZWZ0ID0gc2Nyb2xsUG9zaXRpb24ueDtcbiAgICBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbFRvcCA9IHNjcm9sbFBvc2l0aW9uLnk7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3cG9ydE1ldHJpY3M7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvVmlld3BvcnRNZXRyaWNzLmpzXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBBY2N1bXVsYXRlcyBpdGVtcyB0aGF0IG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkIGludG8gdGhlIGZpcnN0IG9uZS4gVGhpc1xuICogaXMgdXNlZCB0byBjb25zZXJ2ZSBtZW1vcnkgYnkgYXZvaWRpbmcgYXJyYXkgYWxsb2NhdGlvbnMsIGFuZCB0aHVzIHNhY3JpZmljZXNcbiAqIEFQSSBjbGVhbm5lc3MuIFNpbmNlIGBjdXJyZW50YCBjYW4gYmUgbnVsbCBiZWZvcmUgYmVpbmcgcGFzc2VkIGluIGFuZCBub3RcbiAqIG51bGwgYWZ0ZXIgdGhpcyBmdW5jdGlvbiwgbWFrZSBzdXJlIHRvIGFzc2lnbiBpdCBiYWNrIHRvIGBjdXJyZW50YDpcbiAqXG4gKiBgYSA9IGFjY3VtdWxhdGVJbnRvKGEsIGIpO2BcbiAqXG4gKiBUaGlzIEFQSSBzaG91bGQgYmUgc3BhcmluZ2x5IHVzZWQuIFRyeSBgYWNjdW11bGF0ZWAgZm9yIHNvbWV0aGluZyBjbGVhbmVyLlxuICpcbiAqIEByZXR1cm4geyp8YXJyYXk8Kj59IEFuIGFjY3VtdWxhdGlvbiBvZiBpdGVtcy5cbiAqL1xuXG5mdW5jdGlvbiBhY2N1bXVsYXRlSW50byhjdXJyZW50LCBuZXh0KSB7XG4gICEobmV4dCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdhY2N1bXVsYXRlSW50byguLi4pOiBBY2N1bXVsYXRlZCBpdGVtcyBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC4nKSA6IF9wcm9kSW52YXJpYW50KCczMCcpIDogdm9pZCAwO1xuXG4gIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIC8vIEJvdGggYXJlIG5vdCBlbXB0eS4gV2FybmluZzogTmV2ZXIgY2FsbCB4LmNvbmNhdCh5KSB3aGVuIHlvdSBhcmUgbm90XG4gIC8vIGNlcnRhaW4gdGhhdCB4IGlzIGFuIEFycmF5ICh4IGNvdWxkIGJlIGEgc3RyaW5nIHdpdGggY29uY2F0IG1ldGhvZCkuXG4gIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICAgIGN1cnJlbnQucHVzaC5hcHBseShjdXJyZW50LCBuZXh0KTtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBjdXJyZW50LnB1c2gobmV4dCk7XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgIC8vIEEgYml0IHRvbyBkYW5nZXJvdXMgdG8gbXV0YXRlIGBuZXh0YC5cbiAgICByZXR1cm4gW2N1cnJlbnRdLmNvbmNhdChuZXh0KTtcbiAgfVxuXG4gIHJldHVybiBbY3VycmVudCwgbmV4dF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWNjdW11bGF0ZUludG87XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvYWNjdW11bGF0ZUludG8uanNcbi8vIG1vZHVsZSBpZCA9IDcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAcGFyYW0ge2FycmF5fSBhcnIgYW4gXCJhY2N1bXVsYXRpb25cIiBvZiBpdGVtcyB3aGljaCBpcyBlaXRoZXIgYW4gQXJyYXkgb3JcbiAqIGEgc2luZ2xlIGl0ZW0uIFVzZWZ1bCB3aGVuIHBhaXJlZCB3aXRoIHRoZSBgYWNjdW11bGF0ZWAgbW9kdWxlLiBUaGlzIGlzIGFcbiAqIHNpbXBsZSB1dGlsaXR5IHRoYXQgYWxsb3dzIHVzIHRvIHJlYXNvbiBhYm91dCBhIGNvbGxlY3Rpb24gb2YgaXRlbXMsIGJ1dFxuICogaGFuZGxpbmcgdGhlIGNhc2Ugd2hlbiB0aGVyZSBpcyBleGFjdGx5IG9uZSBpdGVtIChhbmQgd2UgZG8gbm90IG5lZWQgdG9cbiAqIGFsbG9jYXRlIGFuIGFycmF5KS5cbiAqL1xuXG5mdW5jdGlvbiBmb3JFYWNoQWNjdW11bGF0ZWQoYXJyLCBjYiwgc2NvcGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGFyci5mb3JFYWNoKGNiLCBzY29wZSk7XG4gIH0gZWxzZSBpZiAoYXJyKSB7XG4gICAgY2IuY2FsbChzY29wZSwgYXJyKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvckVhY2hBY2N1bXVsYXRlZDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9mb3JFYWNoQWNjdW11bGF0ZWQuanNcbi8vIG1vZHVsZSBpZCA9IDcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdE5vZGVUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3ROb2RlVHlwZXMnKTtcblxuZnVuY3Rpb24gZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUoaW5zdCkge1xuICB2YXIgdHlwZTtcblxuICB3aGlsZSAoKHR5cGUgPSBpbnN0Ll9yZW5kZXJlZE5vZGVUeXBlKSA9PT0gUmVhY3ROb2RlVHlwZXMuQ09NUE9TSVRFKSB7XG4gICAgaW5zdCA9IGluc3QuX3JlbmRlcmVkQ29tcG9uZW50O1xuICB9XG5cbiAgaWYgKHR5cGUgPT09IFJlYWN0Tm9kZVR5cGVzLkhPU1QpIHtcbiAgICByZXR1cm4gaW5zdC5fcmVuZGVyZWRDb21wb25lbnQ7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gUmVhY3ROb2RlVHlwZXMuRU1QVFkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL2dldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgY29udGVudEtleSA9IG51bGw7XG5cbi8qKlxuICogR2V0cyB0aGUga2V5IHVzZWQgdG8gYWNjZXNzIHRleHQgY29udGVudCBvbiBhIERPTSBub2RlLlxuICpcbiAqIEByZXR1cm4gez9zdHJpbmd9IEtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpIHtcbiAgaWYgKCFjb250ZW50S2V5ICYmIEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAgIC8vIFByZWZlciB0ZXh0Q29udGVudCB0byBpbm5lclRleHQgYmVjYXVzZSBtYW55IGJyb3dzZXJzIHN1cHBvcnQgYm90aCBidXRcbiAgICAvLyBTVkcgPHRleHQ+IGVsZW1lbnRzIGRvbid0IHN1cHBvcnQgaW5uZXJUZXh0IGV2ZW4gd2hlbiA8ZGl2PiBkb2VzLlxuICAgIGNvbnRlbnRLZXkgPSAndGV4dENvbnRlbnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA/ICd0ZXh0Q29udGVudCcgOiAnaW5uZXJUZXh0JztcbiAgfVxuICByZXR1cm4gY29udGVudEtleTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUZXh0Q29udGVudEFjY2Vzc29yO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL2dldFRleHRDb250ZW50QWNjZXNzb3IuanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RW1wdHlDb21wb25lbnQnKTtcbnZhciBSZWFjdEhvc3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0SG9zdENvbXBvbmVudCcpO1xuXG52YXIgZ2V0TmV4dERlYnVnSUQgPSByZXF1aXJlKCcuL2dldE5leHREZWJ1Z0lEJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLy8gVG8gYXZvaWQgYSBjeWNsaWMgZGVwZW5kZW5jeSwgd2UgY3JlYXRlIHRoZSBmaW5hbCBjbGFzcyBpbiB0aGlzIG1vZHVsZVxudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlciA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHRoaXMuY29uc3RydWN0KGVsZW1lbnQpO1xufTtcbl9hc3NpZ24oUmVhY3RDb21wb3NpdGVDb21wb25lbnRXcmFwcGVyLnByb3RvdHlwZSwgUmVhY3RDb21wb3NpdGVDb21wb25lbnQsIHtcbiAgX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQ6IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnRcbn0pO1xuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpIHtcbiAgaWYgKG93bmVyKSB7XG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdHlwZSByZWZlcmVuY2UgaXMgYSBrbm93biBpbnRlcm5hbCB0eXBlLiBJLmUuIG5vdCBhIHVzZXJcbiAqIHByb3ZpZGVkIGNvbXBvc2l0ZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHR5cGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGlzIGlzIGEgdmFsaWQgaW50ZXJuYWwgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNJbnRlcm5hbENvbXBvbmVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHR5cGUucHJvdG90eXBlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUubW91bnRDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHR5cGUucHJvdG90eXBlLnJlY2VpdmVDb21wb25lbnQgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBSZWFjdE5vZGUsIGNyZWF0ZSBhbiBpbnN0YW5jZSB0aGF0IHdpbGwgYWN0dWFsbHkgYmUgbW91bnRlZC5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRIYXZlRGVidWdJRFxuICogQHJldHVybiB7b2JqZWN0fSBBIG5ldyBpbnN0YW5jZSBvZiB0aGUgZWxlbWVudCdzIGNvbnN0cnVjdG9yLlxuICogQHByb3RlY3RlZFxuICovXG5mdW5jdGlvbiBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5vZGUsIHNob3VsZEhhdmVEZWJ1Z0lEKSB7XG4gIHZhciBpbnN0YW5jZTtcblxuICBpZiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSBmYWxzZSkge1xuICAgIGluc3RhbmNlID0gUmVhY3RFbXB0eUNvbXBvbmVudC5jcmVhdGUoaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBub2RlO1xuICAgICEoZWxlbWVudCAmJiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCBlbGVtZW50LnR5cGUgPT0gbnVsbCA/IGVsZW1lbnQudHlwZSA6IHR5cGVvZiBlbGVtZW50LnR5cGUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShlbGVtZW50Ll9vd25lcikpIDogX3Byb2RJbnZhcmlhbnQoJzEzMCcsIGVsZW1lbnQudHlwZSA9PSBudWxsID8gZWxlbWVudC50eXBlIDogdHlwZW9mIGVsZW1lbnQudHlwZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGVsZW1lbnQuX293bmVyKSkgOiB2b2lkIDA7XG5cbiAgICAvLyBTcGVjaWFsIGNhc2Ugc3RyaW5nIHZhbHVlc1xuICAgIGlmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgaW5zdGFuY2UgPSBSZWFjdEhvc3RDb21wb25lbnQuY3JlYXRlSW50ZXJuYWxDb21wb25lbnQoZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmIChpc0ludGVybmFsQ29tcG9uZW50VHlwZShlbGVtZW50LnR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIHRlbXBvcmFyaWx5IGF2YWlsYWJsZSBmb3IgY3VzdG9tIGNvbXBvbmVudHMgdGhhdCBhcmUgbm90IHN0cmluZ1xuICAgICAgLy8gcmVwcmVzZW50YXRpb25zLiBJLmUuIEFSVC4gT25jZSB0aG9zZSBhcmUgdXBkYXRlZCB0byB1c2UgdGhlIHN0cmluZ1xuICAgICAgLy8gcmVwcmVzZW50YXRpb24sIHdlIGNhbiBkcm9wIHRoaXMgY29kZSBwYXRoLlxuICAgICAgaW5zdGFuY2UgPSBuZXcgZWxlbWVudC50eXBlKGVsZW1lbnQpO1xuXG4gICAgICAvLyBXZSByZW5hbWVkIHRoaXMuIEFsbG93IHRoZSBvbGQgbmFtZSBmb3IgY29tcGF0LiA6KFxuICAgICAgaWYgKCFpbnN0YW5jZS5nZXRIb3N0Tm9kZSkge1xuICAgICAgICBpbnN0YW5jZS5nZXRIb3N0Tm9kZSA9IGluc3RhbmNlLmdldE5hdGl2ZU5vZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlID0gbmV3IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlcihlbGVtZW50KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBub2RlID09PSAnbnVtYmVyJykge1xuICAgIGluc3RhbmNlID0gUmVhY3RIb3N0Q29tcG9uZW50LmNyZWF0ZUluc3RhbmNlRm9yVGV4dChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRW5jb3VudGVyZWQgaW52YWxpZCBSZWFjdCBub2RlIG9mIHR5cGUgJXMnLCB0eXBlb2Ygbm9kZSkgOiBfcHJvZEludmFyaWFudCgnMTMxJywgdHlwZW9mIG5vZGUpIDogdm9pZCAwO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdGFuY2UubW91bnRDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLnJlY2VpdmVDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmdldEhvc3ROb2RlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS51bm1vdW50Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nLCAnT25seSBSZWFjdCBDb21wb25lbnRzIGNhbiBiZSBtb3VudGVkLicpIDogdm9pZCAwO1xuICB9XG5cbiAgLy8gVGhlc2UgdHdvIGZpZWxkcyBhcmUgdXNlZCBieSB0aGUgRE9NIGFuZCBBUlQgZGlmZmluZyBhbGdvcml0aG1zXG4gIC8vIHJlc3BlY3RpdmVseS4gSW5zdGVhZCBvZiB1c2luZyBleHBhbmRvcyBvbiBjb21wb25lbnRzLCB3ZSBzaG91bGQgYmVcbiAgLy8gc3RvcmluZyB0aGUgc3RhdGUgbmVlZGVkIGJ5IHRoZSBkaWZmaW5nIGFsZ29yaXRobXMgZWxzZXdoZXJlLlxuICBpbnN0YW5jZS5fbW91bnRJbmRleCA9IDA7XG4gIGluc3RhbmNlLl9tb3VudEltYWdlID0gbnVsbDtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGluc3RhbmNlLl9kZWJ1Z0lEID0gc2hvdWxkSGF2ZURlYnVnSUQgPyBnZXROZXh0RGVidWdJRCgpIDogMDtcbiAgfVxuXG4gIC8vIEludGVybmFsIGluc3RhbmNlcyBzaG91bGQgZnVsbHkgY29uc3RydWN0ZWQgYXQgdGhpcyBwb2ludCwgc28gdGhleSBzaG91bGRcbiAgLy8gbm90IGdldCBhbnkgbmV3IGZpZWxkcyBhZGRlZCB0byB0aGVtIGF0IHRoaXMgcG9pbnQuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucykge1xuICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKGluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHNlZSBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtaW5wdXQtZWxlbWVudC5odG1sI2lucHV0LXR5cGUtYXR0ci1zdW1tYXJ5XG4gKi9cblxudmFyIHN1cHBvcnRlZElucHV0VHlwZXMgPSB7XG4gICdjb2xvcic6IHRydWUsXG4gICdkYXRlJzogdHJ1ZSxcbiAgJ2RhdGV0aW1lJzogdHJ1ZSxcbiAgJ2RhdGV0aW1lLWxvY2FsJzogdHJ1ZSxcbiAgJ2VtYWlsJzogdHJ1ZSxcbiAgJ21vbnRoJzogdHJ1ZSxcbiAgJ251bWJlcic6IHRydWUsXG4gICdwYXNzd29yZCc6IHRydWUsXG4gICdyYW5nZSc6IHRydWUsXG4gICdzZWFyY2gnOiB0cnVlLFxuICAndGVsJzogdHJ1ZSxcbiAgJ3RleHQnOiB0cnVlLFxuICAndGltZSc6IHRydWUsXG4gICd1cmwnOiB0cnVlLFxuICAnd2Vlayc6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGlzVGV4dElucHV0RWxlbWVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnaW5wdXQnKSB7XG4gICAgcmV0dXJuICEhc3VwcG9ydGVkSW5wdXRUeXBlc1tlbGVtLnR5cGVdO1xuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAndGV4dGFyZWEnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUZXh0SW5wdXRFbGVtZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL2lzVGV4dElucHV0RWxlbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKCcuL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcicpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XG5cbi8qKlxuICogU2V0IHRoZSB0ZXh0Q29udGVudCBwcm9wZXJ0eSBvZiBhIG5vZGUsIGVuc3VyaW5nIHRoYXQgd2hpdGVzcGFjZSBpcyBwcmVzZXJ2ZWRcbiAqIGV2ZW4gaW4gSUU4LiBpbm5lclRleHQgaXMgYSBwb29yIHN1YnN0aXR1dGUgZm9yIHRleHRDb250ZW50IGFuZCwgYW1vbmcgbWFueVxuICogaXNzdWVzLCBpbnNlcnRzIDxicj4gaW5zdGVhZCBvZiB0aGUgbGl0ZXJhbCBuZXdsaW5lIGNoYXJzLiBpbm5lckhUTUwgYmVoYXZlc1xuICogYXMgaXQgc2hvdWxkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICBpZiAodGV4dCkge1xuICAgIHZhciBmaXJzdENoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuXG4gICAgaWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZCA9PT0gbm9kZS5sYXN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSB0ZXh0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn07XG5cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgaWYgKCEoJ3RleHRDb250ZW50JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgbm9kZS5ub2RlVmFsdWUgPSB0ZXh0O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRJbm5lckhUTUwobm9kZSwgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRleHQpKTtcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VGV4dENvbnRlbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvc2V0VGV4dENvbnRlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50U3ltYm9sJyk7XG5cbnZhciBnZXRJdGVyYXRvckZuID0gcmVxdWlyZSgnLi9nZXRJdGVyYXRvckZuJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgS2V5RXNjYXBlVXRpbHMgPSByZXF1aXJlKCcuL0tleUVzY2FwZVV0aWxzJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG5cbi8qKlxuICogVGhpcyBpcyBpbmxpbmVkIGZyb20gUmVhY3RFbGVtZW50IHNpbmNlIHRoaXMgZmlsZSBpcyBzaGFyZWQgYmV0d2VlblxuICogaXNvbW9ycGhpYyBhbmQgcmVuZGVyZXJzLiBXZSBjb3VsZCBleHRyYWN0IHRoaXMgdG8gYVxuICpcbiAqL1xuXG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBjb21wb25lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gY29tcG9uZW50IEEgY29tcG9uZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudEtleShjb21wb25lbnQsIGluZGV4KSB7XG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuICBpZiAoY29tcG9uZW50ICYmIHR5cGVvZiBjb21wb25lbnQgPT09ICdvYmplY3QnICYmIGNvbXBvbmVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiBLZXlFc2NhcGVVdGlscy5lc2NhcGUoY29tcG9uZW50LmtleSk7XG4gIH1cbiAgLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZVNvRmFyIE5hbWUgb2YgdGhlIGtleSBwYXRoIHNvIGZhci5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2l0aCBlYWNoIGNoaWxkIGZvdW5kLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IFVzZWQgdG8gcGFzcyBpbmZvcm1hdGlvbiB0aHJvdWdob3V0IHRoZSB0cmF2ZXJzYWxcbiAqIHByb2Nlc3MuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sIG5hbWVTb0ZhciwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsIHx8IHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInIHx8XG4gIC8vIFRoZSBmb2xsb3dpbmcgaXMgaW5saW5lZCBmcm9tIFJlYWN0RWxlbWVudC4gVGhpcyBtZWFucyB3ZSBjYW4gb3B0aW1pemVcbiAgLy8gc29tZSBjaGVja3MuIFJlYWN0IEZpYmVyIGFsc28gaW5saW5lcyB0aGlzIGxvZ2ljIGZvciBzaW1pbGFyIHB1cnBvc2VzLlxuICB0eXBlID09PSAnb2JqZWN0JyAmJiBjaGlsZHJlbi4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgY2FsbGJhY2sodHJhdmVyc2VDb250ZXh0LCBjaGlsZHJlbixcbiAgICAvLyBJZiBpdCdzIHRoZSBvbmx5IGNoaWxkLCB0cmVhdCB0aGUgbmFtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBhbiBhcnJheVxuICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3MuXG4gICAgbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZHJlbiwgMCkgOiBuYW1lU29GYXIpO1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGNoaWxkO1xuICB2YXIgbmV4dE5hbWU7XG4gIHZhciBzdWJ0cmVlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBjaGlsZHJlbiBmb3VuZCBpbiB0aGUgY3VycmVudCBzdWJ0cmVlLlxuICB2YXIgbmV4dE5hbWVQcmVmaXggPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SIDogbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpKTtcbiAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoY2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gY2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICB2YXIgaWkgPSAwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHZhciBtYXBzQXNDaGlsZHJlbkFkZGVuZHVtID0gJyc7XG4gICAgICAgICAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHZhciBtYXBzQXNDaGlsZHJlbk93bmVyTmFtZSA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpO1xuICAgICAgICAgICAgaWYgKG1hcHNBc0NoaWxkcmVuT3duZXJOYW1lKSB7XG4gICAgICAgICAgICAgIG1hcHNBc0NoaWxkcmVuQWRkZW5kdW0gPSAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbWFwc0FzQ2hpbGRyZW5Pd25lck5hbWUgKyAnYC4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhkaWRXYXJuQWJvdXRNYXBzLCAnVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3QgeWV0IGZ1bGx5IHN1cHBvcnRlZC4gSXQgaXMgYW4gJyArICdleHBlcmltZW50YWwgZmVhdHVyZSB0aGF0IG1pZ2h0IGJlIHJlbW92ZWQuIENvbnZlcnQgaXQgdG8gYSAnICsgJ3NlcXVlbmNlIC8gaXRlcmFibGUgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLiVzJywgbWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSkgOiB2b2lkIDA7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgY2hpbGQgPSBlbnRyeVsxXTtcbiAgICAgICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBLZXlFc2NhcGVVdGlscy5lc2NhcGUoZW50cnlbMF0pICsgU1VCU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCAwKTtcbiAgICAgICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkIG9yIHdyYXAgdGhlIG9iamVjdCB1c2luZyBjcmVhdGVGcmFnbWVudChvYmplY3QpIGZyb20gdGhlICcgKyAnUmVhY3QgYWRkLW9ucy4nO1xuICAgICAgICBpZiAoY2hpbGRyZW4uX2lzUmVhY3RFbGVtZW50KSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEl0IGxvb2tzIGxpa2UgeW91XFwncmUgdXNpbmcgYW4gZWxlbWVudCBjcmVhdGVkIGJ5IGEgZGlmZmVyZW50ICcgKyAndmVyc2lvbiBvZiBSZWFjdC4gTWFrZSBzdXJlIHRvIHVzZSBvbmx5IG9uZSBjb3B5IG9mIFJlYWN0Lic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpO1xuICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBhZGRlbmR1bSArPSAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSBTdHJpbmcoY2hpbGRyZW4pO1xuICAgICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ09iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogJXMpLiVzJywgY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nLCBhZGRlbmR1bSkgOiBfcHJvZEludmFyaWFudCgnMzEnLCBjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcsIGFkZGVuZHVtKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIFRyYXZlcnNlcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAsIGJ1dFxuICogbWlnaHQgYWxzbyBiZSBzcGVjaWZpZWQgdGhyb3VnaCBhdHRyaWJ1dGVzOlxuICpcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbiwgLi4uKWBcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5sZWZ0UGFuZWxDaGlsZHJlbiwgLi4uKWBcbiAqXG4gKiBUaGUgYHRyYXZlcnNlQ29udGV4dGAgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQgdGhhdCBpcyBwYXNzZWQgdGhyb3VnaCB0aGVcbiAqIGVudGlyZSB0cmF2ZXJzYWwuIEl0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFjY3VtdWxhdGlvbnMgb3IgYW55dGhpbmcgZWxzZSB0aGF0XG4gKiB0aGUgY2FsbGJhY2sgbWlnaHQgZmluZCByZWxldmFudC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIG9iamVjdC5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBUbyBpbnZva2UgdXBvbiB0cmF2ZXJzaW5nIGVhY2ggY2hpbGQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBmb3IgdHJhdmVyc2FsLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgJycsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRyYXZlcnNlQWxsQ2hpbGRyZW47XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvdHJhdmVyc2VBbGxDaGlsZHJlbi5qc1xuLy8gbW9kdWxlIGlkID0gNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBVcHN0cmVhbSB2ZXJzaW9uIG9mIGV2ZW50IGxpc3RlbmVyLiBEb2VzIG5vdCB0YWtlIGludG8gYWNjb3VudCBzcGVjaWZpY1xuICogbmF0dXJlIG9mIHBsYXRmb3JtLlxuICovXG52YXIgRXZlbnRMaXN0ZW5lciA9IHtcbiAgLyoqXG4gICAqIExpc3RlbiB0byBET00gZXZlbnRzIGR1cmluZyB0aGUgYnViYmxlIHBoYXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0YXJnZXQgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgbGlzdGVuZXIgb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgRXZlbnQgdHlwZSwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW92ZXInLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3Qgd2l0aCBhIGByZW1vdmVgIG1ldGhvZC5cbiAgICovXG4gIGxpc3RlbjogZnVuY3Rpb24gbGlzdGVuKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0LmF0dGFjaEV2ZW50KSB7XG4gICAgICB0YXJnZXQuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgdGFyZ2V0LmRldGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIExpc3RlbiB0byBET00gZXZlbnRzIGR1cmluZyB0aGUgY2FwdHVyZSBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2VvdmVyJy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXG4gICAqL1xuICBjYXB0dXJlOiBmdW5jdGlvbiBjYXB0dXJlKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignQXR0ZW1wdGVkIHRvIGxpc3RlbiB0byBldmVudHMgZHVyaW5nIHRoZSBjYXB0dXJlIHBoYXNlIG9uIGEgJyArICdicm93c2VyIHRoYXQgZG9lcyBub3Qgc3VwcG9ydCB0aGUgY2FwdHVyZSBwaGFzZS4gWW91ciBhcHBsaWNhdGlvbiAnICsgJ3dpbGwgbm90IHJlY2VpdmUgc29tZSBldmVudHMuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGVtcHR5RnVuY3Rpb25cbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIHJlZ2lzdGVyRGVmYXVsdDogZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0KCkge31cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRMaXN0ZW5lcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL34vZmJqcy9saWIvRXZlbnRMaXN0ZW5lci5qc1xuLy8gbW9kdWxlIGlkID0gNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlIGlucHV0L3RleHRhcmVhIHRvIGZvY3VzXG4gKi9cblxuZnVuY3Rpb24gZm9jdXNOb2RlKG5vZGUpIHtcbiAgLy8gSUU4IGNhbiB0aHJvdyBcIkNhbid0IG1vdmUgZm9jdXMgdG8gdGhlIGNvbnRyb2wgYmVjYXVzZSBpdCBpcyBpbnZpc2libGUsXG4gIC8vIG5vdCBlbmFibGVkLCBvciBvZiBhIHR5cGUgdGhhdCBkb2VzIG5vdCBhY2NlcHQgdGhlIGZvY3VzLlwiIGZvciBhbGwga2luZHMgb2ZcbiAgLy8gcmVhc29ucyB0aGF0IGFyZSB0b28gZXhwZW5zaXZlIGFuZCBmcmFnaWxlIHRvIHRlc3QuXG4gIHRyeSB7XG4gICAgbm9kZS5mb2N1cygpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvY3VzTm9kZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL34vZmJqcy9saWIvZm9jdXNOb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGZiLXd3dy90eXBlb2YtdW5kZWZpbmVkICovXG5cbi8qKlxuICogU2FtZSBhcyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGJ1dCB3cmFwcyBpbiBhIHRyeS1jYXRjaCBibG9jay4gSW4gSUUgaXQgaXNcbiAqIG5vdCBzYWZlIHRvIGNhbGwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpZiB0aGVyZSBpcyBub3RoaW5nIGZvY3VzZWQuXG4gKlxuICogVGhlIGFjdGl2ZUVsZW1lbnQgd2lsbCBiZSBudWxsIG9ubHkgaWYgdGhlIGRvY3VtZW50IG9yIGRvY3VtZW50IGJvZHkgaXMgbm90XG4gKiB5ZXQgZGVmaW5lZC5cbiAqL1xuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudCgpIC8qP0RPTUVsZW1lbnQqL3tcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50IHx8IGRvY3VtZW50LmJvZHk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFjdGl2ZUVsZW1lbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9+L2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50IHR5cGUuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXSAmJiBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykgfHwgMHhlYWM3O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0RWxlbWVudFN5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbi8qKlxuICogUmVhY3RFbGVtZW50VmFsaWRhdG9yIHByb3ZpZGVzIGEgd3JhcHBlciBhcm91bmQgYSBlbGVtZW50IGZhY3RvcnlcbiAqIHdoaWNoIHZhbGlkYXRlcyB0aGUgcHJvcHMgcGFzc2VkIHRvIHRoZSBlbGVtZW50LiBUaGlzIGlzIGludGVuZGVkIHRvIGJlXG4gKiB1c2VkIG9ubHkgaW4gREVWIGFuZCBjb3VsZCBiZSByZXBsYWNlZCBieSBhIHN0YXRpYyB0eXBlIGNoZWNrZXIgZm9yIGxhbmd1YWdlc1xuICogdGhhdCBzdXBwb3J0IGl0LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xuXG52YXIgY2hlY2tSZWFjdFR5cGVTcGVjID0gcmVxdWlyZSgnLi9jaGVja1JlYWN0VHlwZVNwZWMnKTtcblxudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xudmFyIGdldEl0ZXJhdG9yRm4gPSByZXF1aXJlKCcuL2dldEl0ZXJhdG9yRm4nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcbiAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgaW5mbyA9ICcgQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8JyArIHBhcmVudE5hbWUgKyAnPi4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5mbztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcblxuICB2YXIgbWVtb2l6ZXIgPSBvd25lckhhc0tleVVzZVdhcm5pbmcudW5pcXVlS2V5IHx8IChvd25lckhhc0tleVVzZVdhcm5pbmcudW5pcXVlS2V5ID0ge30pO1xuXG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcbiAgaWYgKG1lbW9pemVyW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG1lbW9pemVyW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cbiAgdmFyIGNoaWxkT3duZXIgPSAnJztcbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gJyBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSAnICsgZWxlbWVudC5fb3duZXIuZ2V0TmFtZSgpICsgJy4nO1xuICB9XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdFYWNoIGNoaWxkIGluIGFuIGFycmF5IG9yIGl0ZXJhdG9yIHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLiVzJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lciwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRDdXJyZW50U3RhY2tBZGRlbmR1bShlbGVtZW50KSkgOiB2b2lkIDA7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG4gICAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG4gICAgLy8gRW50cnkgaXRlcmF0b3JzIHByb3ZpZGUgaW1wbGljaXQga2V5cy5cbiAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB2YXIgY29tcG9uZW50Q2xhc3MgPSBlbGVtZW50LnR5cGU7XG4gIGlmICh0eXBlb2YgY29tcG9uZW50Q2xhc3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5hbWUgPSBjb21wb25lbnRDbGFzcy5kaXNwbGF5TmFtZSB8fCBjb21wb25lbnRDbGFzcy5uYW1lO1xuICBpZiAoY29tcG9uZW50Q2xhc3MucHJvcFR5cGVzKSB7XG4gICAgY2hlY2tSZWFjdFR5cGVTcGVjKGNvbXBvbmVudENsYXNzLnByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50LCBudWxsKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgfVxufVxuXG52YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0ge1xuXG4gIGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgICB2YXIgdmFsaWRUeXBlID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nO1xuICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cbiAgICBpZiAoIXZhbGlkVHlwZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIHNob3VsZCBub3QgYmUgbnVsbCwgdW5kZWZpbmVkLCBib29sZWFuLCBvciAnICsgJ251bWJlci4gSXQgc2hvdWxkIGJlIGEgc3RyaW5nIChmb3IgRE9NIGVsZW1lbnRzKSBvciBhIFJlYWN0Q2xhc3MgJyArICcoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKS4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9LFxuXG4gIGNyZWF0ZUZhY3Rvcnk6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRWxlbWVudC5iaW5kKG51bGwsIHR5cGUpO1xuICAgIC8vIExlZ2FjeSBob29rIFRPRE86IFdhcm4gaWYgdGhpcyBpcyBhY2Nlc3NlZFxuICAgIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpIDogdm9pZCAwO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xuICB9LFxuXG4gIGNsb25lRWxlbWVudDogZnVuY3Rpb24gKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICAgIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gICAgfVxuICAgIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICAgIHJldHVybiBuZXdFbGVtZW50O1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RFbGVtZW50VmFsaWRhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgTmF2IGZyb20gJy4uL3JvdXRlcy9uYXYnXG5pbXBvcnQgSG9tZSBmcm9tICcuLi9zZWN0aW9ucy9ob21lJ1xuaW1wb3J0IEFib3V0IGZyb20gJy4uL3NlY3Rpb25zL2Fib3V0J1xuaW1wb3J0IEZydWl0cyBmcm9tICcuLi9zZWN0aW9ucy9mcnVpdHMnXG5pbXBvcnQgUmVnaXN0ZXIgZnJvbSAnLi4vc2VjdGlvbnMvcmVnaXN0ZXInXG5pbXBvcnQgVGVhbSBmcm9tICcuLi9zZWN0aW9ucy90ZWFtJ1xuaW1wb3J0IGJrSW1nIGZyb20gJy4uL2RhdGEvcGFnZS1waWNzJ1xuaW1wb3J0IGZydWl0c0RhdGEgZnJvbSAnLi4vZGF0YS9mcnVpdHMnXG5pbXBvcnQgdGVhbURhdGEgZnJvbSAnLi4vZGF0YS90ZWFtJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcHAgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgZnJ1aXRzOiB0aGlzLnByb3BzLmZydWl0cyxcbiAgICAgIHRlYW1NZW1zOiB0aGlzLnByb3BzLnRlYW1NZW1zLFxuICAgICAgYmtJbWc6IHRoaXMucHJvcHMuYmtJbWdcbiAgICB9O1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdj5cbiAgICAgICAgPE5hdiAvPlxuICAgICAgICA8SG9tZSBia0ltZz17dGhpcy5zdGF0ZS5ia0ltZ30vPlxuICAgICAgICA8QWJvdXQgYmtJbWc9e3RoaXMuc3RhdGUuYmtJbWd9Lz5cbiAgICAgICAgPEZydWl0cyBmcnVpdHM9e3RoaXMuc3RhdGUuZnJ1aXRzfS8+XG4gICAgICAgIDxSZWdpc3Rlci8+ICAgICAgXG4gICAgICAgIDxUZWFtIHRlYW1NZW1zPXt0aGlzLnN0YXRlLnRlYW1NZW1zfS8+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5BcHAucHJvcFR5cGVzID0ge1xuICBmcnVpdHM6IFJlYWN0LlByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICB0ZWFtTWVtczogUmVhY3QuUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIGJrSW1nOiBSZWFjdC5Qcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZFxufVxuQXBwLmRlZmF1bHRQcm9wcyA9IHtcbiAgZnJ1aXRzOiBmcnVpdHNEYXRhKCksXG4gIHRlYW1NZW1zOiB0ZWFtRGF0YSgpLFxuICBia0ltZzogYmtJbWcoKVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvYXBwLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGcnVpdEl0ZW1zIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHsgXG4gIHJlbmRlcigpIHtcbiAgXHRjb25zdCB7IGlkLCBjbmFtZSwgbG5hbWUsIHByaWNlLCBpbWcsIHNpemUsIGxpbmsgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgbXlTdHlsZTEgPSB7XG4gICAgICBib3JkZXI6IFwiMXB4IGRvdWJsZSBibGFja1wiLFxuICAgICAgYm9yZGVyUmFkaXVzOiAxNSxcbiAgICAgIG1hcmdpbkxlZnQ6IDAsXG4gICAgICBtYXJnaW5SaWdodDogMCxcbiAgICAgIG1hcmdpbkJvdHRvbTogMlxuICAgIH1cbiAgICBjb25zdCBteVN0eWxlMiA9e1xuICAgICAgY29sb3I6IFwiZ3JlZW5cIlxuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzcz1cImNvbC1sZy0zIGNvbC1tZC00IGNvbC1zbS02IHRleHQtY2VudGVyXCIgc3R5bGU9e215U3R5bGUxfT5cbiAgICAgICAgPGg0PntjbmFtZX08L2g0PlxuICAgICAgICA8aDU+PGVtPntsbmFtZX08L2VtPjwvaDU+XG4gICAgICAgIDxoNT5QcmljZTombmJzcDsmbmJzcDske3ByaWNlfTwvaDU+XG4gICAgICAgIDxsYWJlbCBzdHlsZT17bXlTdHlsZTJ9PntzaXplfTxhIGhyZWY9e2xpbmt9PjxpbWcgc3JjPXtpbWd9IGhlaWdodD1cIjE1MHB4XCIgY2xhc3M9XCJ0aHVtYm5haWwgY2VudGVyLWJsb2NrXCIgLz48L2E+PC9sYWJlbD5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cbkZydWl0SXRlbXMucHJvcFR5cGVzID0ge1xuICBpZDogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgY25hbWU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gIGxuYW1lOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICBwcmljZTogUmVhY3QuUHJvcFR5cGVzLm51bWJlcixcbiAgaW1nOiBSZWFjdC5Qcm9wVHlwZXMubm9kZSxcbiAgc2l6ZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgbGluazogUmVhY3QuUHJvcFR5cGVzLm5vZGVcbn1cbkZydWl0SXRlbXMuZGVmYXVsdFByb3BzID0ge1xuICBpZDogMCxcbiAgY25hbWU6ICcnLFxuICBsbmFtZTogJycsXG4gIHByaWNlOiAwLFxuICBpbWc6ICcnLFxuICBzaXplOiAnJyxcbiAgbGluazogJydcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2ZydWl0LWl0ZW1zLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZWFtTWVtcyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7IFxuICByZW5kZXIoKSB7XG4gIFx0Y29uc3QgeyBpZCwgZm5hbWUsIGxuYW1lLCB0aXRsZSwgbGlua2VkaW4sIHBob3RvLCBzaXplIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IG15U3R5bGUxID0ge1xuICAgICAgbWFyZ2luTGVmdDogMCxcbiAgICAgIG1hcmdpblJpZ2h0OiAwLFxuICAgICAgbWFyZ2luQm90dG9tOiAyXG4gICAgfVxuICAgIGNvbnN0IG15U3R5bGUyID0ge1xuICAgICAgY29sb3I6IFwibWFnZW50YVwiXG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzPVwiY29sLWxnLTMgY29sLW1kLTYgY29sLXNtLTYgdGV4dC1jZW50ZXJcIiBzdHlsZT17bXlTdHlsZTF9PlxuICAgICAgICA8YnIgLz5cbiAgICAgICAgPGxhYmVsIHN0eWxlPXtteVN0eWxlMn0+e3NpemV9PGEgaHJlZj17bGlua2VkaW59PjxpbWcgc3JjPXtwaG90b30gaGVpZ2h0PVwiMjAwcHhcIiBjbGFzcz1cInRodW1ibmFpbCBjZW50ZXItYmxvY2tcIiAvPjwvYT48L2xhYmVsPlxuICAgICAgICA8aDQ+e2ZuYW1lfSB7bG5hbWV9PC9oND5cbiAgICAgICAgPGg1PjxlbT57dGl0bGV9PC9lbT48L2g1PlxuICAgICAgICA8YnIgLz5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cblRlYW1NZW1zLnByb3BUeXBlcyA9IHtcbiAgaWQ6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIsXG4gIGZuYW1lOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICBsbmFtZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgdGl0bGU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gIGxpbmtlZGluOiBSZWFjdC5Qcm9wVHlwZXMubm9kZSxcbiAgcGhvdG86IFJlYWN0LlByb3BUeXBlcy5ub2RlLFxuICBzaXplOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nXG59XG5UZWFtTWVtcy5kZWZhdWx0UHJvcHMgPSB7XG4gIGlkOiAwLFxuICBmbmFtZTogJycsXG4gIGxuYW1lOiAnJyxcbiAgdGl0bGU6ICcnLFxuICBsaW5rZWRpbjogJycsXG4gIHBob3RvOiAnJyxcbiAgc2l6ZTogJydcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL3RlYW0tbWVtcy5qcyIsImltcG9ydCBhcHBsZSBmcm9tICcuLi9wdWJsaWMvaW1hZ2VzL2ZydWl0cy9hcHBsZS5qcGVnJ1xuaW1wb3J0IGJhbmFuYSBmcm9tICcuLi9wdWJsaWMvaW1hZ2VzL2ZydWl0cy9iYW5hbmEuanBlZydcbmltcG9ydCBncmFwZXMgZnJvbSAnLi4vcHVibGljL2ltYWdlcy9mcnVpdHMvZ3JhcGVzLmpwZWcnXG5pbXBvcnQgbHljaGVlIGZyb20gJy4uL3B1YmxpYy9pbWFnZXMvZnJ1aXRzL2x5Y2hlZS5qcGVnJ1xuaW1wb3J0IG1hbmdvIGZyb20gJy4uL3B1YmxpYy9pbWFnZXMvZnJ1aXRzL21hbmdvLmpwZWcnXG5pbXBvcnQgb3JhbmdlIGZyb20gJy4uL3B1YmxpYy9pbWFnZXMvZnJ1aXRzL29yYW5nZS5qcGVnJ1xuaW1wb3J0IHJhc3BiZXJyeSBmcm9tICcuLi9wdWJsaWMvaW1hZ2VzL2ZydWl0cy9yYXNwYmVycnkuanBlZydcbmltcG9ydCBwZWFjaCBmcm9tICcuLi9wdWJsaWMvaW1hZ2VzL2ZydWl0cy9wZWFjaC5qcGVnJ1xuaW1wb3J0IHBpbmVhcHBsZSBmcm9tICcuLi9wdWJsaWMvaW1hZ2VzL2ZydWl0cy9waW5lYXBwbGUuanBlZydcbmltcG9ydCBwb21lZ3JhbmF0ZSBmcm9tICcuLi9wdWJsaWMvaW1hZ2VzL2ZydWl0cy9wb21lZ3JhbmF0ZS5qcGVnJ1xuaW1wb3J0IHRvbWF0byBmcm9tICcuLi9wdWJsaWMvaW1hZ2VzL2ZydWl0cy90b21hdG8uanBlZydcbmltcG9ydCBzdHJhd2JlcnJ5IGZyb20gJy4uL3B1YmxpYy9pbWFnZXMvZnJ1aXRzL3N0cmF3YmVycnkuanBlZydcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgaWQ6IDEsXG4gICAgICBjbmFtZTogXCJBcHBsZVwiLFxuICAgICAgbG5hbWU6IFwiUHlydXMgbWFsdXNcIixcbiAgICAgIHByaWNlOiA1LjMxLFxuICAgICAgaXNDaGVja2VkOiBmYWxzZSxcbiAgICAgIGltZzogIGFwcGxlLFxuICAgICAgc2l6ZTogXCI4IEtieXRlXCIsXG4gICAgICBsaW5rOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FwcGxlXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiAyLFxuICAgICAgY25hbWU6IFwiQmFuYW5hXCIsXG4gICAgICBsbmFtZTogXCJNdXNhIHBhcmFkaXNpY3VtXCIsXG4gICAgICBwcmljZTogNC4zOSxcbiAgICAgIGlzQ2hlY2tlZDogZmFsc2UsXG4gICAgICBpbWc6ICBiYW5hbmEsXG4gICAgICBzaXplOiBcIjYgS2J5dGVcIixcbiAgICAgIGxpbms6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFuYW5hXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiAzLFxuICAgICAgY25hbWU6IFwiR3JhcGVzXCIsXG4gICAgICBsbmFtZTogXCJWaXRpcyB2aW5pZmVyYVwiLFxuICAgICAgcHJpY2U6IDQuNzgsXG4gICAgICBpc0NoZWNrZWQ6IGZhbHNlLFxuICAgICAgaW1nOiAgZ3JhcGVzLFxuICAgICAgc2l6ZTogXCI1IEtieXRlXCIsXG4gICAgICBsaW5rOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dyYXBlXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiA0LFxuICAgICAgY25hbWU6IFwiTHljaGVlXCIsXG4gICAgICBsbmFtZTogXCJMaXRjaGkgY2hpbmVuc2lzXCIsXG4gICAgICBwcmljZTogNi4xMixcbiAgICAgIGlzQ2hlY2tlZDogZmFsc2UsXG4gICAgICBpbWc6ICBseWNoZWUsXG4gICAgICBzaXplOiBcIjcgS2J5dGVcIixcbiAgICAgIGxpbms6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTHljaGVlXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiA1LFxuICAgICAgY25hbWU6IFwiTWFuZ29cIixcbiAgICAgIGxuYW1lOiBcIk1hbmdpZmVyYSBpbmRpY2FcIixcbiAgICAgIHByaWNlOiA2LjMyLFxuICAgICAgaXNDaGVja2VkOiBmYWxzZSxcbiAgICAgIGltZzogIG1hbmdvLFxuICAgICAgc2l6ZTogXCI3IEtieXRlXCIsXG4gICAgICBsaW5rOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hbmdvXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiA2LFxuICAgICAgY25hbWU6IFwiT3JhbmdlXCIsXG4gICAgICBsbmFtZTogXCJDaXRydXMgYXVyYW50aXVtXCIsXG4gICAgICBwcmljZTogNC41NixcbiAgICAgIGlzQ2hlY2tlZDogZmFsc2UsXG4gICAgICBpbWc6ICBvcmFuZ2UsXG4gICAgICBzaXplOiBcIjEwIEtieXRlXCIsXG4gICAgICBsaW5rOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL09yYW5nZV8oZnJ1aXQpXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiA3LFxuICAgICAgY25hbWU6IFwiUGVhY2hcIixcbiAgICAgIGxuYW1lOiBcIlBydW51cyBwZXJzaWNhXCIsXG4gICAgICBwcmljZTogNC45NyxcbiAgICAgIGlzQ2hlY2tlZDogZmFsc2UsXG4gICAgICBpbWc6ICBwZWFjaCxcbiAgICAgIHNpemU6IFwiNyBLYnl0ZVwiLFxuICAgICAgbGluazogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QZWFjaFwiXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogOCxcbiAgICAgIGNuYW1lOiBcIlBpbmVhcHBsZVwiLFxuICAgICAgbG5hbWU6IFwiQW5hbnVzIHNhdGl2dXNcIixcbiAgICAgIHByaWNlOiA0Ljk3LFxuICAgICAgaXNDaGVja2VkOiBmYWxzZSxcbiAgICAgIGltZzogIHBpbmVhcHBsZSxcbiAgICAgIHNpemU6IFwiOCBLYnl0ZVwiLFxuICAgICAgbGluazogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QaW5lYXBwbGVcIlxuICAgIH0sXG4gICAge1xuICAgICAgaWQ6IDksXG4gICAgICBjbmFtZTogXCJQb21lZ3JhbmF0ZVwiLFxuICAgICAgbG5hbWU6IFwiUHVuaWNhIGdyYW5hdHVtXCIsXG4gICAgICBwcmljZTogMy45NyxcbiAgICAgIGlzQ2hlY2tlZDogZmFsc2UsXG4gICAgICBpbWc6ICBwb21lZ3JhbmF0ZSxcbiAgICAgIHNpemU6IFwiMTIgS2J5dGVcIixcbiAgICAgIGxpbms6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUG9tZWdyYW5hdGVcIlxuICAgIH0sXG4gICAge1xuICAgICAgaWQ6IDEwLFxuICAgICAgY25hbWU6IFwiUmFzcGJlcnJ5XCIsXG4gICAgICBsbmFtZTogXCJSdWJ1cyBpZGFlb2JhdHVzXCIsXG4gICAgICBwcmljZTogNS4xMyxcbiAgICAgIGlzQ2hlY2tlZDogZmFsc2UsXG4gICAgICBpbWc6ICByYXNwYmVycnksXG4gICAgICBzaXplOiBcIjcgS2J5dGVcIixcbiAgICAgIGxpbms6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmFzcGJlcnJ5XCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiAxMSxcbiAgICAgIGNuYW1lOiBcIlN0cmF3YmVycnlcIixcbiAgICAgIGxuYW1lOiBcIkZyYWdhcmlhIGFuYW5hc3NhXCIsXG4gICAgICBwcmljZTogNS4yNyxcbiAgICAgIGlzQ2hlY2tlZDogZmFsc2UsXG4gICAgICBpbWc6ICBzdHJhd2JlcnJ5LFxuICAgICAgc2l6ZTogXCIxMyBLYnl0ZVwiLFxuICAgICAgbGluazogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdHJhd2JlcnJ5XCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiAxMixcbiAgICAgIGNuYW1lOiBcIlRvbWF0b1wiLFxuICAgICAgbG5hbWU6IFwiU29sYW51bSBseWNvcGVyc2ljdW1cIixcbiAgICAgIHByaWNlOiA0LjM5LFxuICAgICAgaXNDaGVja2VkOiBmYWxzZSxcbiAgICAgIGltZzogIHRvbWF0byxcbiAgICAgIHNpemU6IFwiNyBLYnl0ZVwiLFxuICAgICAgbGluazogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ub21hdG9cIlxuICAgIH1cbiAgXTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9kYXRhL2ZydWl0cy5qcyIsImltcG9ydCBob21lIGZyb20gJy4uL3B1YmxpYy9pbWFnZXMvb3RoZXJzL2hvbWUuanBnJ1xuaW1wb3J0IGFib3V0IGZyb20gJy4uL3B1YmxpYy9pbWFnZXMvb3RoZXJzL2Fib3V0LmpwZydcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgaG9tZUltZzogaG9tZSxcbiAgICAgIHNpemU6IFwiMjcyIEtieXRlXCJcbiAgICB9LCBcbiAgICB7XG4gICAgICBhYm91dEltZzogYWJvdXQsXG4gICAgICBzaXplOiBcIjEwMiBLYnl0ZVwiXG4gICAgfVxuICBdO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2RhdGEvcGFnZS1waWNzLmpzIiwiaW1wb3J0IHJvZEZhcjEgZnJvbSAnLi4vcHVibGljL2ltYWdlcy90ZWFtL3NvbWV3aGVyZS5qcGVnJ1xuaW1wb3J0IHJvZEZhcjIgZnJvbSAnLi4vcHVibGljL2ltYWdlcy90ZWFtL3NvbWV3aGVyZS5qcGVnJ1xuaW1wb3J0IHJvZEZhcjMgZnJvbSAnLi4vcHVibGljL2ltYWdlcy90ZWFtL3NvbWV3aGVyZS5qcGVnJ1xuaW1wb3J0IHJvZEZhcjQgZnJvbSAnLi4vcHVibGljL2ltYWdlcy90ZWFtL3NvbWV3aGVyZS5qcGVnJ1xuaW1wb3J0IHJvZEZhcjUgZnJvbSAnLi4vcHVibGljL2ltYWdlcy90ZWFtL3NvbWV3aGVyZS5qcGVnJ1xuaW1wb3J0IHJvZEZhcjYgZnJvbSAnLi4vcHVibGljL2ltYWdlcy90ZWFtL3NvbWV3aGVyZS5qcGVnJ1xuaW1wb3J0IHJvZEZhcjcgZnJvbSAnLi4vcHVibGljL2ltYWdlcy90ZWFtL3NvbWV3aGVyZS5qcGVnJ1xuaW1wb3J0IHJvZEZhcjggZnJvbSAnLi4vcHVibGljL2ltYWdlcy90ZWFtL3NvbWV3aGVyZS5qcGVnJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFtcbiAgICB7XG4gIFx0ICBpZDogMSxcbiAgXHQgIGZuYW1lOiBcIlJvZFwiLFxuICBcdCAgbG5hbWU6IFwiS2F5XCIsXG4gIFx0ICB0aXRsZTogXCJQcm9qZWN0IE1hbmFnZXJcIixcbiAgXHQgIGxpbmtlZGluOiBcImh0dHBzOi8vd3d3LmxpbmtlZGluLmNvbS9pbi9yb2RrODhcIixcbiAgXHQgIHBob3RvOiByb2RGYXIxLFxuICAgICAgc2l6ZTogXCIxMCBLYnl0ZVwiXG4gICAgfSwgXG4gICAge1xuICBcdCAgaWQ6IDIsXG4gIFx0ICBmbmFtZTogXCJSb2RcIixcbiAgXHQgIGxuYW1lOiBcIktheVwiLFxuICBcdCAgdGl0bGU6IFwiV2ViIERldmVsb3BlclwiLFxuICBcdCAgbGlua2VkaW46IFwiaHR0cHM6Ly93d3cubGlua2VkaW4uY29tL2luL3JvZGs4OFwiLFxuICBcdCAgcGhvdG86IHJvZEZhcjIsXG4gICAgICBzaXplOiBcIjEwIEtieXRlXCJcbiAgICB9LCBcbiAgICB7XG4gIFx0ICBpZDogMyxcbiAgXHQgIGZuYW1lOiBcIlJvZFwiLFxuICBcdCAgbG5hbWU6IFwiS2F5XCIsXG4gIFx0ICB0aXRsZTogXCJCdXNpbmVzcyBEZXZlbG9wZXJcIixcbiAgXHQgIGxpbmtlZGluOiBcImh0dHBzOi8vd3d3LmxpbmtlZGluLmNvbS9pbi9yb2RrODhcIixcbiAgXHQgIHBob3RvOiByb2RGYXIzLFxuICAgICAgc2l6ZTogXCIxMCBLYnl0ZVwiXG4gICAgfSwgXG4gICAge1xuICBcdCAgaWQ6IDQsXG4gIFx0ICBmbmFtZTogXCJSb2RcIixcbiAgXHQgIGxuYW1lOiBcIktheVwiLFxuICBcdCAgdGl0bGU6IFwiSGFyZHdhcmUgQ2lyY3VpdCBFbmdpbmVlclwiLFxuICBcdCAgbGlua2VkaW46IFwiaHR0cHM6Ly93d3cubGlua2VkaW4uY29tL2luL3JvZGs4OFwiLFxuICBcdCAgcGhvdG86IHJvZEZhcjQsXG4gICAgICBzaXplOiBcIjEwIEtieXRlXCJcbiAgICB9LFxuICAgICAgICB7XG4gICAgICBpZDogNSxcbiAgICAgIGZuYW1lOiBcIlJvZFwiLFxuICAgICAgbG5hbWU6IFwiS2F5XCIsXG4gICAgICB0aXRsZTogXCJBc3Npc3RhbnQgIzFcIixcbiAgICAgIGxpbmtlZGluOiBcImh0dHBzOi8vd3d3LmxpbmtlZGluLmNvbS9pbi9yb2RrODhcIixcbiAgICAgIHBob3RvOiByb2RGYXI1LFxuICAgICAgc2l6ZTogXCIxMCBLYnl0ZVwiXG4gICAgfSwgXG4gICAge1xuICAgICAgaWQ6IDYsXG4gICAgICBmbmFtZTogXCJSb2RcIixcbiAgICAgIGxuYW1lOiBcIktheVwiLFxuICAgICAgdGl0bGU6IFwiQXNzaXN0YW50ICMyXCIsXG4gICAgICBsaW5rZWRpbjogXCJodHRwczovL3d3dy5saW5rZWRpbi5jb20vaW4vcm9kazg4XCIsXG4gICAgICBwaG90bzogcm9kRmFyNixcbiAgICAgIHNpemU6IFwiMTAgS2J5dGVcIlxuICAgIH0sIFxuICAgIHtcbiAgICAgIGlkOiA3LFxuICAgICAgZm5hbWU6IFwiUm9kXCIsXG4gICAgICBsbmFtZTogXCJLYXlcIixcbiAgICAgIHRpdGxlOiBcIkFzc2lzdGFudCAjM1wiLFxuICAgICAgbGlua2VkaW46IFwiaHR0cHM6Ly93d3cubGlua2VkaW4uY29tL2luL3JvZGs4OFwiLFxuICAgICAgcGhvdG86IHJvZEZhcjcsXG4gICAgICBzaXplOiBcIjEwIEtieXRlXCJcbiAgICB9LCBcbiAgICB7XG4gICAgICBpZDogOCxcbiAgICAgIGZuYW1lOiBcIlJvZFwiLFxuICAgICAgbG5hbWU6IFwiS2F5XCIsXG4gICAgICB0aXRsZTogXCJBc3Npc3RhbnQgIzRcIixcbiAgICAgIGxpbmtlZGluOiBcImh0dHBzOi8vd3d3LmxpbmtlZGluLmNvbS9pbi9yb2RrODhcIixcbiAgICAgIHBob3RvOiByb2RGYXI4LFxuICAgICAgc2l6ZTogXCIxMCBLYnl0ZVwiXG4gICAgfVxuICBdO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2RhdGEvdGVhbS5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcblxudmFyIG15U3R5bGUxID0ge1xuICAgIGNvbG9yOiAgXCIjZmZmXCIsXG59XG52YXIgbXlTdHlsZTIgPSB7XG4gICAgbWFyZ2luUmlnaHQ6ICBcIjE1cHhcIixcbn1cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gKFxuXG4gIDxuYXYgY2xhc3M9XCJuYXZiYXIgbmF2YmFyLWludmVyc2UgbmF2YmFyLWZpeGVkLXRvcFwiPlxuICAgIDxkaXYgY2xhc3M9XCJjb250YWluZXItZmx1aWRcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJuYXZiYXItaGVhZGVyXCI+XG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwibmF2YmFyLXRvZ2dsZVwiIGRhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIiBkYXRhLXRhcmdldD1cIiNteU5hdmJhclwiPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwiXCIgc3R5bGU9e215U3R5bGUxfT5NRU5VPC9zcGFuPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJjb2xsYXBzZSBuYXZiYXItY29sbGFwc2VcIiBpZD1cIm15TmF2YmFyXCI+XG4gICAgICA8dWwgY2xhc3M9XCJuYXYgbmF2YmFyLW5hdlwiPlxuICAgICAgICA8bGk+PGEgaHJlZj1cIiNob21lXCI+SG9tZTwvYT48L2xpPlxuICAgICAgICA8bGk+PGEgaHJlZj1cIiNhYm91dFwiPkFib3V0PC9hPjwvbGk+XG4gICAgICAgIDxsaT48YSBocmVmPVwiI2ZydWl0c1wiPkZydWl0czwvYT48L2xpPlxuICAgICAgICA8bGk+PGEgaHJlZj1cIiN0ZWFtXCI+VGVhbTwvYT48L2xpPlxuICAgICAgPC91bD5cbiAgICAgIDx1bCBjbGFzcz1cIm5hdiBuYXZiYXItbmF2IG5hdmJhci1yaWdodFwiIHN0eWxlPXtteVN0eWxlMn0+XG4gICAgICAgIDxsaT48YSBocmVmPVwiI3JlZ2lzdGVyXCI+PHNwYW4gY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLXVzZXJcIj48L3NwYW4+Jm5ic3A7U2lnbiBVcDwvYT48L2xpPlxuICAgICAgPC91bD5cbiAgICA8L2Rpdj5cbiAgPC9uYXY+XG5cbik7fX1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3JvdXRlcy9uYXYuanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFib3V0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgcmVuZGVyKCkge1xuICAgIHZhciBteVN0eWxlMSA9IHtcbiAgICAgIGZvbnRGYW1pbHk6IFwiRG9zaXNcIixcbiAgICAgIHBhZGRpbmdUb3A6IFwiNTBweFwiLFxuICAgICAgcGFkZGluZ0JvdHRvbTogXCIyMHB4XCIsXG4gICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgY29sb3I6ICBcIiMwMDBcIixcbiAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjY2MwMDQ0XCIgIFxuICAgIH1cbiAgICB2YXIgbXlTdHlsZTIgPSB7XG4gICAgICBtYXJnaW5SaWdodDogXCIyMHB4XCIsXG4gICAgICBtYXJnaW5Cb3R0b206IFwiMTBweFwiLFxuICAgICAgbWFyZ2luTGVmdDogXCIxNXB4XCJcbiAgICB9XG4gICAgdmFyIG15U3R5bGUzID0ge1xuICAgICAgY29sb3I6IFwib3JhbmdlXCIsXG4gICAgICBtYXJnaW5MZWZ0OiBcIi02cHhcIlxuICAgIH1cbiAgXHRyZXR1cm4gKFxuXG4gICAgICA8ZGl2IGlkPVwiYWJvdXRcIiBjbGFzcz1cImNvbnRhaW5lci1mbHVpZCB0ZXh0LWNlbnRlclwiIHN0eWxlPXtteVN0eWxlMX0+XG4gICAgICAgIDxoMz57JzwnfTxlbT4gZGVtbyA8L2VtPnsnPid9Jm5ic3A7PC9oMz5cbiAgICAgICAgPGgxPmBQcm8tU2VlZGAgaXMgYSBjb252ZW5pZW50IHBsYWNlIHRvIGJ1eSB5b3VyIGZydWl0IHNlZWRzIG9ubGluZSEgJm5ic3A7Jm5ic3A7KE1lbWJlcnMgb25seTogJm5ic3A7Jm5ic3A7UmVnaXN0ZXIgYmVsb3cuKTwvaDE+XG4gICAgICAgIDxwIGNsYXNzPVwidGV4dC1sZWZ0XCIgc3R5bGU9e215U3R5bGUzfT4mZW1zcDsmZW5zcDt7dGhpcy5wcm9wcy5ia0ltZ1sxXS5zaXplfTwvcD5cbiAgICAgICAgPGltZyBzcmM9e3RoaXMucHJvcHMuYmtJbWdbMV0uYWJvdXRJbWd9IHdpZHRoPVwiNjAwcHhcIiBjbGFzcz1cImltZy1yZXNwb25zaXZlIHB1bGwtbGVmdCBnYXAtcmlnaHRcIiBzdHlsZT17bXlTdHlsZTJ9Lz5cbiAgICAgICAgPHA+R29kIHl6YWwgZWh0IHJldm8gc3BtdWogeG9mIG53b3JiIGtjaXVxIGVodC4mbmJzcDsmbmJzcDtUaGUgcXVpY2sgYnJvd24gZm94IGp1bXBzIG92ZXIgdGhlIGxhenkgZG9nLiAmbmJzcDsmbmJzcDtHb2QgeXphbCBlaHQgcmV2byBzcG11aiB4b2YgbndvcmIga2NpdXEgZWh0LiZuYnNwOyZuYnNwO1RoZSBxdWljayBicm93biBmb3gganVtcHMgb3ZlciB0aGUgbGF6eSBkb2cuJm5ic3A7Jm5ic3A7R29kIHl6YWwgZWh0IHJldm8gc3BtdWogeG9mIG53b3JiIGtjaXVxIGVodC4mbmJzcDsmbmJzcDtUaGUgcXVpY2sgYnJvd24gZm94IGp1bXBzIG92ZXIgdGhlIGxhenkgZG9nLiZuYnNwOyZuYnNwO0dvZCB5emFsIGVodCByZXZvIHNwbXVqIHhvZiBud29yYiBrY2l1cSBlaHQuJm5ic3A7Jm5ic3A7VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4mbmJzcDsmbmJzcDtHb2QgeXphbCBlaHQgcmV2byBzcG11aiB4b2YgbndvcmIga2NpdXEgZWh0LiZuYnNwOyZuYnNwO1RoZSBxdWljayBicm93biBmb3gganVtcHMgb3ZlciB0aGUgbGF6eSBkb2cuR29kIHl6YWwgZWh0IHJldm8gc3BtdWogeG9mIG53b3JiIGtjaXVxIGVodC4mbmJzcDsmbmJzcDtUaGUgcXVpY2sgYnJvd24gZm94IGp1bXBzIG92ZXIgdGhlIGxhenkgZG9nLiAmbmJzcDsmbmJzcDtHb2QgeXphbCBlaHQgcmV2byBzcG11aiB4b2YgbndvcmIga2NpdXEgZWh0LiZuYnNwOyZuYnNwO1RoZSBxdWljayBicm93biBmb3gganVtcHMgb3ZlciB0aGUgbGF6eSBkb2cuJm5ic3A7Jm5ic3A7R29kIHl6YWwgZWh0IHJldm8gc3BtdWogeG9mIG53b3JiIGtjaXVxIGVodC4mbmJzcDsmbmJzcDtUaGUgcXVpY2sgYnJvd24gZm94IGp1bXBzIG92ZXIgdGhlIGxhenkgZG9nLiZuYnNwOyZuYnNwO0dvZCB5emFsIGVodCByZXZvIHNwbXVqIHhvZiBud29yYiBrY2l1cSBlaHQuJm5ic3A7Jm5ic3A7VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4mbmJzcDsmbmJzcDtHb2QgeXphbCBlaHQgcmV2byBzcG11aiB4b2YgbndvcmIga2NpdXEgZWh0LiZuYnNwOyZuYnNwO1RoZSBxdWljayBicm93biBmb3gganVtcHMgb3ZlciB0aGUgbGF6eSBkb2cuR29kIHl6YWwgZWh0IHJldm8gc3BtdWogeG9mIG53b3JiIGtjaXVxIGVodC4mbmJzcDsmbmJzcDtUaGUgcXVpY2sgYnJvd24gZm94IGp1bXBzIG92ZXIgdGhlIGxhenkgZG9nLiAmbmJzcDsmbmJzcDtHb2QgeXphbCBlaHQgcmV2byBzcG11aiB4b2YgbndvcmIga2NpdXEgZWh0LiZuYnNwOyZuYnNwO1RoZSBxdWljayBicm93biBmb3gganVtcHMgb3ZlciB0aGUgbGF6eSBkb2cuJm5ic3A7Jm5ic3A7R29kIHl6YWwgZWh0IHJldm8gc3BtdWogeG9mIG53b3JiIGtjaXVxIGVodC4mbmJzcDsmbmJzcDtUaGUgcXVpY2sgYnJvd24gZm94IGp1bXBzIG92ZXIgdGhlIGxhenkgZG9nLiZuYnNwOyZuYnNwO0dvZCB5emFsIGVodCByZXZvIHNwbXVqIHhvZiBud29yYiBrY2l1cSBlaHQuJm5ic3A7Jm5ic3A7VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4mbmJzcDsmbmJzcDtHb2QgeXphbCBlaHQgcmV2byBzcG11aiB4b2YgbndvcmIga2NpdXEgZWh0LiZuYnNwOyZuYnNwO1RoZSBxdWljayBicm93biBmb3gganVtcHMgb3ZlciB0aGUgbGF6eSBkb2cuR29kIHl6YWwgZWh0IHJldm8gc3BtdWogeG9mIG53b3JiIGtjaXVxIGVodC4mbmJzcDsmbmJzcDtUaGUgcXVpY2sgYnJvd24gZm94IGp1bXBzIG92ZXIgdGhlIGxhenkgZG9nLiAmbmJzcDsmbmJzcDtHb2QgeXphbCBlaHQgcmV2byBzcG11aiB4b2YgbndvcmIga2NpdXEgZWh0LiZuYnNwOyZuYnNwO1RoZSBxdWljayBicm93biBmb3gganVtcHMgb3ZlciB0aGUgbGF6eSBkb2cuJm5ic3A7Jm5ic3A7R29kIHl6YWwgZWh0IHJldm8gc3BtdWogeG9mIG53b3JiIGtjaXVxIGVodC4mbmJzcDsmbmJzcDtUaGUgcXVpY2sgYnJvd24gZm94IGp1bXBzIG92ZXIgdGhlIGxhenkgZG9nLiZuYnNwOyZuYnNwO0dvZCB5emFsIGVodCByZXZvIHNwbXVqIHhvZiBud29yYiBrY2l1cSBlaHQuJm5ic3A7Jm5ic3A7VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4mbmJzcDsmbmJzcDtHb2QgeXphbCBlaHQgcmV2byBzcG11aiB4b2YgbndvcmIga2NpdXEgZWh0LiZuYnNwOyZuYnNwO1RoZSBxdWljayBicm93biBmb3gganVtcHMgb3ZlciB0aGUgbGF6eSBkb2cuPC9wPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuQWJvdXQucHJvcFR5cGVzID0ge1xuICBia0ltZzogUmVhY3QuUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWRcbn1cbkFib3V0LmRlZmF1bHRQcm9wcyA9IHtcbiAgYmtJbWc6IFtdXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2VjdGlvbnMvYWJvdXQuanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgRnJ1aXRJdGVtcyBmcm9tICcuLi9jb21wb25lbnRzL2ZydWl0LWl0ZW1zJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGcnVpdHMgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICByZW5kZXIoKSB7XG4gICAgdmFyIG15U3R5bGUgPSB7XG4gICAgICBmb250RmFtaWx5OiBcIkRvc2lzXCIsXG4gICAgICBwYWRkaW5nVG9wOiBcIjUwcHhcIixcbiAgICAgIHBhZGRpbmdCb3R0b206IFwiMjBweFwiLFxuICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgIGNvbG9yOiBcIiMwMDBcIixcbiAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZmZjYzAwXCJcbiAgICB9XG4gICAgY29uc3Qgc2hvd0ZydWl0cyA9IHRoaXMucHJvcHMuZnJ1aXRzLm1hcChmcnVpdCA9PiBcbiAgICAgIDxGcnVpdEl0ZW1zIGtleT17ZnJ1aXQuaWR9IGlkPXtmcnVpdC5pZH0gY25hbWU9e2ZydWl0LmNuYW1lfSBsbmFtZT17ZnJ1aXQubG5hbWV9IHByaWNlPXtmcnVpdC5wcmljZX0gaW1nPXtmcnVpdC5pbWd9IHNpemU9e2ZydWl0LnNpemV9IGxpbms9e2ZydWl0Lmxpbmt9Lz4gKTtcbiAgXHRyZXR1cm4gKFxuICAgICAgPGRpdiBpZD1cImZydWl0c1wiIGNsYXNzPVwiY29udGFpbmVyLWZsdWlkXCIgc3R5bGU9e215U3R5bGV9PlxuICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1sZy0xMlwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRleHQtY2VudGVyXCI+XG4gICAgICAgICAgICAgIDxoMz57JzwnfTxlbT4gZGVtbyA8L2VtPnsnPid9Jm5ic3A7PC9oMz5cbiAgICAgICAgICAgICAgPGgxPkZydWl0IFNlZWRzIExpc3Q8L2gxPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgICAge3Nob3dGcnVpdHN9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuRnJ1aXRzLnByb3BUeXBlcyA9IHtcbiAgZnJ1aXRzOiBSZWFjdC5Qcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZFxufVxuRnJ1aXRzLmRlZmF1bHRQcm9wcyA9IHtcbiAgZnJ1aXRzOiBbXVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2VjdGlvbnMvZnJ1aXRzLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIb21lIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgcmVuZGVyKCkge1xuICAgIHZhciBteVN0eWxlMSA9IHtcbiAgICAgIGZvbnRGYW1pbHk6IFwiRG9zaXNcIixcbiAgICAgIHBhZGRpbmdUb3A6IFwiMjcwcHhcIixcbiAgICAgIGhlaWdodDogXCI3MDBweFwiLFxuICAgICAgY29sb3I6ICBcIiNmZmZcIixcbiAgICAgIGJhY2tncm91bmRJbWFnZTogYHVybCgke3RoaXMucHJvcHMuYmtJbWdbMF0uaG9tZUltZ30pYCxcbiAgICAgIGJhY2tncm91bmRTaXplOiAnY292ZXInXG4gICAgfVxuICAgIHZhciBteVN0eWxlMiA9e1xuICAgICAgcGFkZGluZ1RvcDogXCIyNDBweFwiLFxuICAgICAgY29sb3I6IFwieWVsbG93XCJcbiAgICB9XG4gIFx0cmV0dXJuIChcbiAgICAgIFxuICAgICAgPGRpdiBpZD1cImhvbWVcIiBjbGFzcz1cImNvbnRhaW5lci1mbHVpZCB0ZXh0LWNlbnRlclwiIHN0eWxlPXtteVN0eWxlMX0+XG4gICAgICAgIDxoMT5Qcm8tU2VlZCBhbmQgR3JvdyAhPC9oMT5cbiAgICAgICAgPGgyPnsnPCd9PGVtPiBUaGlzIGlzIGEgZGVtbyBzaXRlLiA8L2VtPnsnPid9Jm5ic3A7PC9oMj5cbiAgICAgICAgPHA+R29kIHl6YWwgZWh0IHJldm8gc3BtdWogeG9mIG53b3JiIGtjaXVxIGVodC4mbmJzcDsmbmJzcDtUaGUgcXVpY2sgYnJvd24gZm94IGp1bXBzIG92ZXIgdGhlIGxhenkgZG9nLjwvcD5cbiAgICAgICAgPGRpdiBzdHlsZT17bXlTdHlsZTJ9PlxuICAgICAgICAgIDxwPnt0aGlzLnByb3BzLmJrSW1nWzBdLnNpemV9PC9wPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cbkhvbWUucHJvcFR5cGVzID0ge1xuICBia0ltZzogUmVhY3QuUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWRcbn1cbkhvbWUuZGVmYXVsdFByb3BzID0ge1xuICBia0ltZzogW11cbn1cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2VjdGlvbnMvaG9tZS5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVnaXN0ZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICByZW5kZXIoKSB7XG4gICAgdmFyIG15U3R5bGUxID0ge1xuICAgICAgZm9udEZhbWlseTogXCJEb3Npc1wiLFxuICAgICAgcGFkZGluZ1RvcDogXCI1MHB4XCIsXG4gICAgICBwYWRkaW5nQm90dG9tOiBcIjIwcHhcIixcbiAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICBjb2xvcjogXCIjMDAwXCIsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzAwOTk3M1wiXG4gICAgfVxuICAgIHZhciBteVN0eWxlMiA9IHtcbiAgICAgIGNvbG9yOiBcIiNmZmZcIixcbiAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIlxuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBpZD1cInJlZ2lzdGVyXCIgY2xhc3M9XCJjb250YWluZXItZmx1aWRcIiBzdHlsZT17bXlTdHlsZTF9PlxuICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1sZy0xMlwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRleHQtY2VudGVyXCI+XG4gICAgICAgICAgICAgIDxoMT5SZWdpc3RlciBmb3IgbWVtYmVyc2hpcDwvaDE+XG4gICAgICAgICAgICAgIDxoNCBzdHlsZT17bXlTdHlsZTJ9PnsnPCd9IE5vdGU6ICZuYnNwOyZuYnNwO1RoaXMgc2lnbnVwIGZvcm0gaXMgbm90IGFjdGl2ZS4geyc+J308L2g0PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJyb3cgY2VudGVyZWQtZm9ybVwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCIgY29sLXhzLTYgY29sLXhzLW9mZnNldC0zIGNvbC1zbS00IGNvbC1zbS1vZmZzZXQtNCBjb2wtbWQtNCBjb2wtbWQtb2Zmc2V0LTRcIj5cbiAgICAgICAgICAgIDxmb3JtIGNsYXNzPVwiZm9ybS1ob3Jpem9udGFsXCIgYWN0aW9uPVwiXCIgbWV0aG9kPVwiUE9TVFwiPlxuICAgICAgICAgICAgPGZpZWxkc2V0PlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udHJvbC1ncm91cFwiPlxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImNvbnRyb2wtbGFiZWxcIiBmb3I9XCJ1c2VybmFtZVwiPlVzZXJuYW1lPC9sYWJlbD5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udHJvbHNcIj5cbiAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGlkPVwidXNlcm5hbWVcIiBuYW1lPVwidXNlcm5hbWVcIiBwbGFjZWhvbGRlcj1cIlwiIGNsYXNzPVwiZm9ybS1jb250cm9sIGlucHV0LWxnXCIgLz5cbiAgICAgICAgICAgICAgICAgIDxwIHN0eWxlPXtteVN0eWxlMn0gY2xhc3M9XCJoZWxwLWJsb2NrXCI+VXNlcm5hbWUgY2FuIGNvbnRhaW4gYW55IGxldHRlcnMgb3IgbnVtYmVycywgd2l0aG91dCBzcGFjZXM8L3A+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sLWdyb3VwXCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiY29udHJvbC1sYWJlbFwiIGZvcj1cImVtYWlsXCI+RS1tYWlsPC9sYWJlbD5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udHJvbHNcIj5cbiAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiZW1haWxcIiBpZD1cImVtYWlsXCIgbmFtZT1cImVtYWlsXCIgcGxhY2Vob2xkZXI9XCJcIiBjbGFzcz1cImZvcm0tY29udHJvbCBpbnB1dC1sZ1wiIC8+XG4gICAgICAgICAgICAgICAgICA8cCBzdHlsZT17bXlTdHlsZTJ9IGNsYXNzPVwiaGVscC1ibG9ja1wiPlBsZWFzZSBwcm92aWRlIHlvdXIgRS1tYWlsPC9wPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgIFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udHJvbC1ncm91cFwiPlxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImNvbnRyb2wtbGFiZWxcIiBmb3I9XCJwYXNzd29yZFwiPlBhc3N3b3JkPC9sYWJlbD5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udHJvbHNcIj5cbiAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwicGFzc3dvcmRcIiBpZD1cInBhc3N3b3JkXCIgbmFtZT1cInBhc3N3b3JkXCIgcGxhY2Vob2xkZXI9XCJcIiBjbGFzcz1cImZvcm0tY29udHJvbCBpbnB1dC1sZ1wiIC8+XG4gICAgICAgICAgICAgICAgICA8cCBzdHlsZT17bXlTdHlsZTJ9IGNsYXNzPVwiaGVscC1ibG9ja1wiPlBhc3N3b3JkIHNob3VsZCBiZSBhdCBsZWFzdCA2IGNoYXJhY3RlcnM8L3A+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sLWdyb3VwXCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiY29udHJvbC1sYWJlbFwiIGZvcj1cInBhc3N3b3JkX2NvbmZpcm1cIj5QYXNzd29yZCAoQ29uZmlybSk8L2xhYmVsPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sc1wiPlxuICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJwYXNzd29yZFwiIGlkPVwicGFzc3dvcmRfY29uZmlybVwiIG5hbWU9XCJwYXNzd29yZF9jb25maXJtXCIgcGxhY2Vob2xkZXI9XCJcIiBjbGFzcz1cImZvcm0tY29udHJvbCBpbnB1dC1sZ1wiIC8+XG4gICAgICAgICAgICAgICAgICA8cCBzdHlsZT17bXlTdHlsZTJ9IGNsYXNzPVwiaGVscC1ibG9ja1wiPlBsZWFzZSBjb25maXJtIHBhc3N3b3JkPC9wPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPGJyIC8+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sLWdyb3VwXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRyb2xzXCI+XG4gICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5IGJ0bi1ibG9ja1wiPjxoND5TdWJtaXQ8L2g0PjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZmllbGRzZXQ+XG4gICAgICAgICAgICA8L2Zvcm0+XG4gICAgICAgICAgPC9kaXY+IFxuICAgICAgICA8L2Rpdj5cblxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2VjdGlvbnMvcmVnaXN0ZXIuanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgVGVhbU1lbXMgZnJvbSAnLi4vY29tcG9uZW50cy90ZWFtLW1lbXMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlYW0gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICByZW5kZXIoKSB7XG4gICAgdmFyIG15U3R5bGUgPSB7XG4gICAgICBmb250RmFtaWx5OiBcIkRvc2lzXCIsXG4gICAgICBwYWRkaW5nVG9wOiBcIjUwcHhcIixcbiAgICAgIHBhZGRpbmdCb3R0b206IFwiNTBweFwiLFxuICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgIGNvbG9yOiBcIiNmZmZcIixcbiAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjNTA1MDUwXCJcbiAgICB9XG4gICAgY29uc3Qgc2hvd1RlYW1NZW1iZXJzID0gdGhpcy5wcm9wcy50ZWFtTWVtcy5tYXAodGVhbU1lbSA9PiBcbiAgICAgIDxUZWFtTWVtcyBrZXk9e3RlYW1NZW0uaWR9IGlkPXt0ZWFtTWVtLmlkfSBmbmFtZT17dGVhbU1lbS5mbmFtZX0gbG5hbWU9e3RlYW1NZW0ubG5hbWV9IHRpdGxlPXt0ZWFtTWVtLnRpdGxlfSBsaW5rZWRpbj17dGVhbU1lbS5saW5rZWRpbn0gcGhvdG89e3RlYW1NZW0ucGhvdG99IHNpemU9e3RlYW1NZW0uc2l6ZX0vPiApO1xuICBcdHJldHVybiAoXG4gICAgICA8ZGl2IGlkPVwidGVhbVwiIGNsYXNzPVwiY29udGFpbmVyLWZsdWlkXCIgc3R5bGU9e215U3R5bGV9PlxuICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1sZy0xMlwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRleHQtY2VudGVyXCI+XG4gICAgICAgICAgICAgIDxoMz57JzwnfTxlbT4gZGVtbyA8L2VtPnsnPid9Jm5ic3A7PC9oMz5cbiAgICAgICAgICAgICAgPGgxPk1lZXQgdGhlIFRlYW08L2gxPlxuICAgICAgICAgICAgICA8YnIgLz48YnIgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInJvd1wiPlxuICAgICAgICB7c2hvd1RlYW1NZW1iZXJzfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGhyIC8+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLWxnLTEyXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGV4dC1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgPGJyIC8+XG4gICAgICAgICAgICAgIDxoMz57JzwnfTxlbT4gZGVtbyA8L2VtPnsnPid9Jm5ic3A7PC9oMz5cbiAgICAgICAgICAgICAgPGgxPkNvbnRhY3QgSW5mbzwvaDE+XG4gICAgICAgICAgICAgIDxiciAvPlxuICAgICAgICAgICAgICA8aDM+UHJvU2VlZCBJbmMuPC9oMz5cbiAgICAgICAgICAgICAgPGg0PjEyLTM0IDU2dGggU3QuIDc4dGggQXZlIEZsciA5MCBTdGUgMTIzNDwvaDQ+XG4gICAgICAgICAgICAgIDxoND5OZXcgWW9yaywgTlkgNTY3ODk8L2g0PlxuICAgICAgICAgICAgICA8aDQ+VGVsOiAmbmJzcDsmbmJzcDsoIDAxMjMgKSA0NTYtNzg5MDwvaDQ+XG4gICAgICAgICAgICAgIDxoND5FbWFpTCAmbmJzcDsmbmJzcDthYmMtMTIzQHByb3NlZWQuY29tPC9oND5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cblRlYW0ucHJvcFR5cGVzID0ge1xuICB0ZWFtTWVtczogUmVhY3QuUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWRcbn1cblRlYW0uZGVmYXVsdFByb3BzID0ge1xuICB0ZWFtTWVtczogW11cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zZWN0aW9ucy90ZWFtLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL1JlYWN0RE9NJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQVJJQURPTVByb3BlcnR5Q29uZmlnID0ge1xuICBQcm9wZXJ0aWVzOiB7XG4gICAgLy8gR2xvYmFsIFN0YXRlcyBhbmQgUHJvcGVydGllc1xuICAgICdhcmlhLWN1cnJlbnQnOiAwLCAvLyBzdGF0ZVxuICAgICdhcmlhLWRldGFpbHMnOiAwLFxuICAgICdhcmlhLWRpc2FibGVkJzogMCwgLy8gc3RhdGVcbiAgICAnYXJpYS1oaWRkZW4nOiAwLCAvLyBzdGF0ZVxuICAgICdhcmlhLWludmFsaWQnOiAwLCAvLyBzdGF0ZVxuICAgICdhcmlhLWtleXNob3J0Y3V0cyc6IDAsXG4gICAgJ2FyaWEtbGFiZWwnOiAwLFxuICAgICdhcmlhLXJvbGVkZXNjcmlwdGlvbic6IDAsXG4gICAgLy8gV2lkZ2V0IEF0dHJpYnV0ZXNcbiAgICAnYXJpYS1hdXRvY29tcGxldGUnOiAwLFxuICAgICdhcmlhLWNoZWNrZWQnOiAwLFxuICAgICdhcmlhLWV4cGFuZGVkJzogMCxcbiAgICAnYXJpYS1oYXNwb3B1cCc6IDAsXG4gICAgJ2FyaWEtbGV2ZWwnOiAwLFxuICAgICdhcmlhLW1vZGFsJzogMCxcbiAgICAnYXJpYS1tdWx0aWxpbmUnOiAwLFxuICAgICdhcmlhLW11bHRpc2VsZWN0YWJsZSc6IDAsXG4gICAgJ2FyaWEtb3JpZW50YXRpb24nOiAwLFxuICAgICdhcmlhLXBsYWNlaG9sZGVyJzogMCxcbiAgICAnYXJpYS1wcmVzc2VkJzogMCxcbiAgICAnYXJpYS1yZWFkb25seSc6IDAsXG4gICAgJ2FyaWEtcmVxdWlyZWQnOiAwLFxuICAgICdhcmlhLXNlbGVjdGVkJzogMCxcbiAgICAnYXJpYS1zb3J0JzogMCxcbiAgICAnYXJpYS12YWx1ZW1heCc6IDAsXG4gICAgJ2FyaWEtdmFsdWVtaW4nOiAwLFxuICAgICdhcmlhLXZhbHVlbm93JzogMCxcbiAgICAnYXJpYS12YWx1ZXRleHQnOiAwLFxuICAgIC8vIExpdmUgUmVnaW9uIEF0dHJpYnV0ZXNcbiAgICAnYXJpYS1hdG9taWMnOiAwLFxuICAgICdhcmlhLWJ1c3knOiAwLFxuICAgICdhcmlhLWxpdmUnOiAwLFxuICAgICdhcmlhLXJlbGV2YW50JzogMCxcbiAgICAvLyBEcmFnLWFuZC1Ecm9wIEF0dHJpYnV0ZXNcbiAgICAnYXJpYS1kcm9wZWZmZWN0JzogMCxcbiAgICAnYXJpYS1ncmFiYmVkJzogMCxcbiAgICAvLyBSZWxhdGlvbnNoaXAgQXR0cmlidXRlc1xuICAgICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOiAwLFxuICAgICdhcmlhLWNvbGNvdW50JzogMCxcbiAgICAnYXJpYS1jb2xpbmRleCc6IDAsXG4gICAgJ2FyaWEtY29sc3Bhbic6IDAsXG4gICAgJ2FyaWEtY29udHJvbHMnOiAwLFxuICAgICdhcmlhLWRlc2NyaWJlZGJ5JzogMCxcbiAgICAnYXJpYS1lcnJvcm1lc3NhZ2UnOiAwLFxuICAgICdhcmlhLWZsb3d0byc6IDAsXG4gICAgJ2FyaWEtbGFiZWxsZWRieSc6IDAsXG4gICAgJ2FyaWEtb3ducyc6IDAsXG4gICAgJ2FyaWEtcG9zaW5zZXQnOiAwLFxuICAgICdhcmlhLXJvd2NvdW50JzogMCxcbiAgICAnYXJpYS1yb3dpbmRleCc6IDAsXG4gICAgJ2FyaWEtcm93c3Bhbic6IDAsXG4gICAgJ2FyaWEtc2V0c2l6ZSc6IDBcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHt9LFxuICBET01Qcm9wZXJ0eU5hbWVzOiB7fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBUklBRE9NUHJvcGVydHlDb25maWc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvQVJJQURPTVByb3BlcnR5Q29uZmlnLmpzXG4vLyBtb2R1bGUgaWQgPSA5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcblxudmFyIGZvY3VzTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2ZvY3VzTm9kZScpO1xuXG52YXIgQXV0b0ZvY3VzVXRpbHMgPSB7XG4gIGZvY3VzRE9NQ29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgZm9jdXNOb2RlKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRoaXMpKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdXRvRm9jdXNVdGlscztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9BdXRvRm9jdXNVdGlscy5qc1xuLy8gbW9kdWxlIGlkID0gMTAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlID0gcmVxdWlyZSgnLi9GYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUnKTtcbnZhciBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50Jyk7XG52YXIgU3ludGhldGljSW5wdXRFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljSW5wdXRFdmVudCcpO1xuXG52YXIgRU5EX0tFWUNPREVTID0gWzksIDEzLCAyNywgMzJdOyAvLyBUYWIsIFJldHVybiwgRXNjLCBTcGFjZVxudmFyIFNUQVJUX0tFWUNPREUgPSAyMjk7XG5cbnZhciBjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdDb21wb3NpdGlvbkV2ZW50JyBpbiB3aW5kb3c7XG5cbnZhciBkb2N1bWVudE1vZGUgPSBudWxsO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkge1xuICBkb2N1bWVudE1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG59XG5cbi8vIFdlYmtpdCBvZmZlcnMgYSB2ZXJ5IHVzZWZ1bCBgdGV4dElucHV0YCBldmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvXG4vLyBkaXJlY3RseSByZXByZXNlbnQgYGJlZm9yZUlucHV0YC4gVGhlIElFIGB0ZXh0aW5wdXRgIGV2ZW50IGlzIG5vdCBhc1xuLy8gdXNlZnVsLCBzbyB3ZSBkb24ndCB1c2UgaXQuXG52YXIgY2FuVXNlVGV4dElucHV0RXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUgJiYgIWlzUHJlc3RvKCk7XG5cbi8vIEluIElFOSssIHdlIGhhdmUgYWNjZXNzIHRvIGNvbXBvc2l0aW9uIGV2ZW50cywgYnV0IHRoZSBkYXRhIHN1cHBsaWVkXG4vLyBieSB0aGUgbmF0aXZlIGNvbXBvc2l0aW9uZW5kIGV2ZW50IG1heSBiZSBpbmNvcnJlY3QuIEphcGFuZXNlIGlkZW9ncmFwaGljXG4vLyBzcGFjZXMsIGZvciBpbnN0YW5jZSAoXFx1MzAwMCkgYXJlIG5vdCByZWNvcmRlZCBjb3JyZWN0bHkuXG52YXIgdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgKCFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IHx8IGRvY3VtZW50TW9kZSAmJiBkb2N1bWVudE1vZGUgPiA4ICYmIGRvY3VtZW50TW9kZSA8PSAxMSk7XG5cbi8qKlxuICogT3BlcmEgPD0gMTIgaW5jbHVkZXMgVGV4dEV2ZW50IGluIHdpbmRvdywgYnV0IGRvZXMgbm90IGZpcmVcbiAqIHRleHQgaW5wdXQgZXZlbnRzLiBSZWx5IG9uIGtleXByZXNzIGluc3RlYWQuXG4gKi9cbmZ1bmN0aW9uIGlzUHJlc3RvKCkge1xuICB2YXIgb3BlcmEgPSB3aW5kb3cub3BlcmE7XG4gIHJldHVybiB0eXBlb2Ygb3BlcmEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcGVyYS52ZXJzaW9uID09PSAnZnVuY3Rpb24nICYmIHBhcnNlSW50KG9wZXJhLnZlcnNpb24oKSwgMTApIDw9IDEyO1xufVxuXG52YXIgU1BBQ0VCQVJfQ09ERSA9IDMyO1xudmFyIFNQQUNFQkFSX0NIQVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFNQQUNFQkFSX0NPREUpO1xuXG4vLyBFdmVudHMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgbmFtZXMuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgYmVmb3JlSW5wdXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQmVmb3JlSW5wdXQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkJlZm9yZUlucHV0Q2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BDb21wb3NpdGlvbkVuZCcsICd0b3BLZXlQcmVzcycsICd0b3BUZXh0SW5wdXQnLCAndG9wUGFzdGUnXVxuICB9LFxuICBjb21wb3NpdGlvbkVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvbkVuZCcsXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25FbmRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29tcG9zaXRpb25FbmQnLCAndG9wS2V5RG93bicsICd0b3BLZXlQcmVzcycsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nXVxuICB9LFxuICBjb21wb3NpdGlvblN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uU3RhcnQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uU3RhcnRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29tcG9zaXRpb25TdGFydCcsICd0b3BLZXlEb3duJywgJ3RvcEtleVByZXNzJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93biddXG4gIH0sXG4gIGNvbXBvc2l0aW9uVXBkYXRlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uVXBkYXRlJyxcbiAgICAgIGNhcHR1cmVkOiAnb25Db21wb3NpdGlvblVwZGF0ZUNhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb21wb3NpdGlvblVwZGF0ZScsICd0b3BLZXlEb3duJywgJ3RvcEtleVByZXNzJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93biddXG4gIH1cbn07XG5cbi8vIFRyYWNrIHdoZXRoZXIgd2UndmUgZXZlciBoYW5kbGVkIGEga2V5cHJlc3Mgb24gdGhlIHNwYWNlIGtleS5cbnZhciBoYXNTcGFjZUtleXByZXNzID0gZmFsc2U7XG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgYSBuYXRpdmUga2V5cHJlc3MgZXZlbnQgaXMgYXNzdW1lZCB0byBiZSBhIGNvbW1hbmQuXG4gKiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgRmlyZWZveCBmaXJlcyBga2V5cHJlc3NgIGV2ZW50cyBmb3Iga2V5IGNvbW1hbmRzXG4gKiAoY3V0LCBjb3B5LCBzZWxlY3QtYWxsLCBldGMuKSBldmVuIHRob3VnaCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiAobmF0aXZlRXZlbnQuY3RybEtleSB8fCBuYXRpdmVFdmVudC5hbHRLZXkgfHwgbmF0aXZlRXZlbnQubWV0YUtleSkgJiZcbiAgLy8gY3RybEtleSAmJiBhbHRLZXkgaXMgZXF1aXZhbGVudCB0byBBbHRHciwgYW5kIGlzIG5vdCBhIGNvbW1hbmQuXG4gICEobmF0aXZlRXZlbnQuY3RybEtleSAmJiBuYXRpdmVFdmVudC5hbHRLZXkpO1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZSBuYXRpdmUgdG9wIGxldmVsIGV2ZW50cyBpbnRvIGV2ZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25TdGFydCc6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uRW5kJzpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uVXBkYXRlJzpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uVXBkYXRlO1xuICB9XG59XG5cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgYmVzdC1ndWVzcyBtb2RlbCB0aGluayB0aGlzIGV2ZW50IHNpZ25pZmllcyB0aGF0XG4gKiBjb21wb3NpdGlvbiBoYXMgYmVndW4/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09ICd0b3BLZXlEb3duJyAmJiBuYXRpdmVFdmVudC5rZXlDb2RlID09PSBTVEFSVF9LRVlDT0RFO1xufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIG1vZGUgdGhpbmsgdGhhdCB0aGlzIGV2ZW50IGlzIHRoZSBlbmQgb2YgY29tcG9zaXRpb24/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcEtleVVwJzpcbiAgICAgIC8vIENvbW1hbmQga2V5cyBpbnNlcnQgb3IgY2xlYXIgSU1FIGlucHV0LlxuICAgICAgcmV0dXJuIEVORF9LRVlDT0RFUy5pbmRleE9mKG5hdGl2ZUV2ZW50LmtleUNvZGUpICE9PSAtMTtcbiAgICBjYXNlICd0b3BLZXlEb3duJzpcbiAgICAgIC8vIEV4cGVjdCBJTUUga2V5Q29kZSBvbiBlYWNoIGtleWRvd24uIElmIHdlIGdldCBhbnkgb3RoZXJcbiAgICAgIC8vIGNvZGUgd2UgbXVzdCBoYXZlIGV4aXRlZCBlYXJsaWVyLlxuICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmtleUNvZGUgIT09IFNUQVJUX0tFWUNPREU7XG4gICAgY2FzZSAndG9wS2V5UHJlc3MnOlxuICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XG4gICAgY2FzZSAndG9wQmx1cic6XG4gICAgICAvLyBFdmVudHMgYXJlIG5vdCBwb3NzaWJsZSB3aXRob3V0IGNhbmNlbGxpbmcgSU1FLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEdvb2dsZSBJbnB1dCBUb29scyBwcm92aWRlcyBjb21wb3NpdGlvbiBkYXRhIHZpYSBhIEN1c3RvbUV2ZW50LFxuICogd2l0aCB0aGUgYGRhdGFgIHByb3BlcnR5IHBvcHVsYXRlZCBpbiB0aGUgYGRldGFpbGAgb2JqZWN0LiBJZiB0aGlzXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIGV2ZW50IG9iamVjdCwgdXNlIGl0LiBJZiBub3QsIHRoaXMgaXMgYSBwbGFpblxuICogY29tcG9zaXRpb24gZXZlbnQgYW5kIHdlIGhhdmUgbm90aGluZyBzcGVjaWFsIHRvIGV4dHJhY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBkZXRhaWwgPSBuYXRpdmVFdmVudC5kZXRhaWw7XG4gIGlmICh0eXBlb2YgZGV0YWlsID09PSAnb2JqZWN0JyAmJiAnZGF0YScgaW4gZGV0YWlsKSB7XG4gICAgcmV0dXJuIGRldGFpbC5kYXRhO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBUcmFjayB0aGUgY3VycmVudCBJTUUgY29tcG9zaXRpb24gZmFsbGJhY2sgb2JqZWN0LCBpZiBhbnkuXG52YXIgY3VycmVudENvbXBvc2l0aW9uID0gbnVsbDtcblxuLyoqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBldmVudFR5cGU7XG4gIHZhciBmYWxsYmFja0RhdGE7XG5cbiAgaWYgKGNhblVzZUNvbXBvc2l0aW9uRXZlbnQpIHtcbiAgICBldmVudFR5cGUgPSBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpO1xuICB9IGVsc2UgaWYgKCFjdXJyZW50Q29tcG9zaXRpb24pIHtcbiAgICBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgfVxuXG4gIGlmICghZXZlbnRUeXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEpIHtcbiAgICAvLyBUaGUgY3VycmVudCBjb21wb3NpdGlvbiBpcyBzdG9yZWQgc3RhdGljYWxseSBhbmQgbXVzdCBub3QgYmVcbiAgICAvLyBvdmVyd3JpdHRlbiB3aGlsZSBjb21wb3NpdGlvbiBjb250aW51ZXMuXG4gICAgaWYgKCFjdXJyZW50Q29tcG9zaXRpb24gJiYgZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQpIHtcbiAgICAgIGN1cnJlbnRDb21wb3NpdGlvbiA9IEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5nZXRQb29sZWQobmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kKSB7XG4gICAgICBpZiAoY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgICAgIGZhbGxiYWNrRGF0YSA9IGN1cnJlbnRDb21wb3NpdGlvbi5nZXREYXRhKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGV2ZW50ID0gU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGlmIChmYWxsYmFja0RhdGEpIHtcbiAgICAvLyBJbmplY3QgZGF0YSBnZW5lcmF0ZWQgZnJvbSBmYWxsYmFjayBwYXRoIGludG8gdGhlIHN5bnRoZXRpYyBldmVudC5cbiAgICAvLyBUaGlzIG1hdGNoZXMgdGhlIHByb3BlcnR5IG9mIG5hdGl2ZSBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlLlxuICAgIGV2ZW50LmRhdGEgPSBmYWxsYmFja0RhdGE7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1c3RvbURhdGEgPSBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBpZiAoY3VzdG9tRGF0YSAhPT0gbnVsbCkge1xuICAgICAgZXZlbnQuZGF0YSA9IGN1c3RvbURhdGE7XG4gICAgfVxuICB9XG5cbiAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBzdHJpbmcgY29ycmVzcG9uZGluZyB0byB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uRW5kJzpcbiAgICAgIHJldHVybiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBjYXNlICd0b3BLZXlQcmVzcyc6XG4gICAgICAvKipcbiAgICAgICAqIElmIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudHMgYXJlIGF2YWlsYWJsZSwgb3VyIGdvYWwgaXMgdG8gbWFrZVxuICAgICAgICogdXNlIG9mIHRoZW0uIEhvd2V2ZXIsIHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlOiB0aGUgc3BhY2ViYXIga2V5LlxuICAgICAgICogSW4gV2Via2l0LCBwcmV2ZW50aW5nIGRlZmF1bHQgb24gYSBzcGFjZWJhciBgdGV4dElucHV0YCBldmVudFxuICAgICAgICogY2FuY2VscyBjaGFyYWN0ZXIgaW5zZXJ0aW9uLCBidXQgaXQgKmFsc28qIGNhdXNlcyB0aGUgYnJvd3NlclxuICAgICAgICogdG8gZmFsbCBiYWNrIHRvIGl0cyBkZWZhdWx0IHNwYWNlYmFyIGJlaGF2aW9yIG9mIHNjcm9sbGluZyB0aGVcbiAgICAgICAqIHBhZ2UuXG4gICAgICAgKlxuICAgICAgICogVHJhY2tpbmcgYXQ6XG4gICAgICAgKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzU1MTAzXG4gICAgICAgKlxuICAgICAgICogVG8gYXZvaWQgdGhpcyBpc3N1ZSwgdXNlIHRoZSBrZXlwcmVzcyBldmVudCBhcyBpZiBubyBgdGV4dElucHV0YFxuICAgICAgICogZXZlbnQgaXMgYXZhaWxhYmxlLlxuICAgICAgICovXG4gICAgICB2YXIgd2hpY2ggPSBuYXRpdmVFdmVudC53aGljaDtcbiAgICAgIGlmICh3aGljaCAhPT0gU1BBQ0VCQVJfQ09ERSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaGFzU3BhY2VLZXlwcmVzcyA9IHRydWU7XG4gICAgICByZXR1cm4gU1BBQ0VCQVJfQ0hBUjtcblxuICAgIGNhc2UgJ3RvcFRleHRJbnB1dCc6XG4gICAgICAvLyBSZWNvcmQgdGhlIGNoYXJhY3RlcnMgdG8gYmUgYWRkZWQgdG8gdGhlIERPTS5cbiAgICAgIHZhciBjaGFycyA9IG5hdGl2ZUV2ZW50LmRhdGE7XG5cbiAgICAgIC8vIElmIGl0J3MgYSBzcGFjZWJhciBjaGFyYWN0ZXIsIGFzc3VtZSB0aGF0IHdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkXG4gICAgICAvLyBpdCBhdCB0aGUga2V5cHJlc3MgbGV2ZWwgYW5kIGJhaWwgaW1tZWRpYXRlbHkuIEFuZHJvaWQgQ2hyb21lXG4gICAgICAvLyBkb2Vzbid0IGdpdmUgdXMga2V5Y29kZXMsIHNvIHdlIG5lZWQgdG8gYmxhY2tsaXN0IGl0LlxuICAgICAgaWYgKGNoYXJzID09PSBTUEFDRUJBUl9DSEFSICYmIGhhc1NwYWNlS2V5cHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFycztcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBGb3Igb3RoZXIgbmF0aXZlIGV2ZW50IHR5cGVzLCBkbyBub3RoaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBGb3IgYnJvd3NlcnMgdGhhdCBkbyBub3QgcHJvdmlkZSB0aGUgYHRleHRJbnB1dGAgZXZlbnQsIGV4dHJhY3QgdGhlXG4gKiBhcHByb3ByaWF0ZSBzdHJpbmcgdG8gdXNlIGZvciBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBmYWxsYmFjayBzdHJpbmcgZm9yIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBjb21wb3NpbmcgKElNRSkgYW5kIHVzaW5nIGEgZmFsbGJhY2sgdG8gZG8gc28sXG4gIC8vIHRyeSB0byBleHRyYWN0IHRoZSBjb21wb3NlZCBjaGFyYWN0ZXJzIGZyb20gdGhlIGZhbGxiYWNrIG9iamVjdC5cbiAgLy8gSWYgY29tcG9zaXRpb24gZXZlbnQgaXMgYXZhaWxhYmxlLCB3ZSBleHRyYWN0IGEgc3RyaW5nIG9ubHkgYXRcbiAgLy8gY29tcG9zaXRpb25ldmVudCwgb3RoZXJ3aXNlIGV4dHJhY3QgaXQgYXQgZmFsbGJhY2sgZXZlbnRzLlxuICBpZiAoY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcENvbXBvc2l0aW9uRW5kJyB8fCAhY2FuVXNlQ29tcG9zaXRpb25FdmVudCAmJiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIHZhciBjaGFycyA9IGN1cnJlbnRDb21wb3NpdGlvbi5nZXREYXRhKCk7XG4gICAgICBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUucmVsZWFzZShjdXJyZW50Q29tcG9zaXRpb24pO1xuICAgICAgY3VycmVudENvbXBvc2l0aW9uID0gbnVsbDtcbiAgICAgIHJldHVybiBjaGFycztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcFBhc3RlJzpcbiAgICAgIC8vIElmIGEgcGFzdGUgZXZlbnQgb2NjdXJzIGFmdGVyIGEga2V5cHJlc3MsIHRocm93IG91dCB0aGUgaW5wdXRcbiAgICAgIC8vIGNoYXJzLiBQYXN0ZSBldmVudHMgc2hvdWxkIG5vdCBsZWFkIHRvIEJlZm9yZUlucHV0IGV2ZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICAgIC8qKlxuICAgICAgICogQXMgb2YgdjI3LCBGaXJlZm94IG1heSBmaXJlIGtleXByZXNzIGV2ZW50cyBldmVuIHdoZW4gbm8gY2hhcmFjdGVyXG4gICAgICAgKiB3aWxsIGJlIGluc2VydGVkLiBBIGZldyBwb3NzaWJpbGl0aWVzOlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyBgMGAuIEFycm93IGtleXMsIEVzYyBrZXksIGV0Yy5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBubyBjaGFyIGlzIGF2YWlsYWJsZS5cbiAgICAgICAqICAgRXg6ICdBbHRHciArIGRgIGluIFBvbGlzaC4gVGhlcmUgaXMgbm8gbW9kaWZpZWQgY2hhcmFjdGVyIGZvclxuICAgICAgICogICB0aGlzIGtleSBjb21iaW5hdGlvbiBhbmQgbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkIGludG8gdGhlXG4gICAgICAgKiAgIGRvY3VtZW50LCBidXQgRkYgZmlyZXMgdGhlIGtleXByZXNzIGZvciBjaGFyIGNvZGUgYDEwMGAgYW55d2F5LlxuICAgICAgICogICBObyBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgYSBjb21tYW5kIGNvbWJpbmF0aW9uIGlzXG4gICAgICAgKiAgIGJlaW5nIHVzZWQuIEV4OiBgQ21kK0NgLiBObyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQsIGFuZCBub1xuICAgICAgICogICBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKi9cbiAgICAgIGlmIChuYXRpdmVFdmVudC53aGljaCAmJiAhaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG5hdGl2ZUV2ZW50LndoaWNoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uRW5kJzpcbiAgICAgIHJldHVybiB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA/IG51bGwgOiBuYXRpdmVFdmVudC5kYXRhO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBTeW50aGV0aWNJbnB1dEV2ZW50IGZvciBgYmVmb3JlSW5wdXRgLCBiYXNlZCBvbiBlaXRoZXIgbmF0aXZlXG4gKiBgdGV4dElucHV0YCBvciBmYWxsYmFjayBiZWhhdmlvci5cbiAqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBjaGFycztcblxuICBpZiAoY2FuVXNlVGV4dElucHV0RXZlbnQpIHtcbiAgICBjaGFycyA9IGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH0gZWxzZSB7XG4gICAgY2hhcnMgPSBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH1cblxuICAvLyBJZiBubyBjaGFyYWN0ZXJzIGFyZSBiZWluZyBpbnNlcnRlZCwgbm8gQmVmb3JlSW5wdXQgZXZlbnQgc2hvdWxkXG4gIC8vIGJlIGZpcmVkLlxuICBpZiAoIWNoYXJzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNJbnB1dEV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmJlZm9yZUlucHV0LCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGV2ZW50LmRhdGEgPSBjaGFycztcbiAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBgb25CZWZvcmVJbnB1dGAgZXZlbnQgdG8gbWF0Y2hcbiAqIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1LyNldmVudHMtaW5wdXRldmVudHMuXG4gKlxuICogVGhpcyBldmVudCBwbHVnaW4gaXMgYmFzZWQgb24gdGhlIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudFxuICogYXZhaWxhYmxlIGluIENocm9tZSwgU2FmYXJpLCBPcGVyYSwgYW5kIElFLiBUaGlzIGV2ZW50IGZpcmVzIGFmdGVyXG4gKiBgb25LZXlQcmVzc2AgYW5kIGBvbkNvbXBvc2l0aW9uRW5kYCwgYnV0IGJlZm9yZSBgb25JbnB1dGAuXG4gKlxuICogYGJlZm9yZUlucHV0YCBpcyBzcGVjJ2QgYnV0IG5vdCBpbXBsZW1lbnRlZCBpbiBhbnkgYnJvd3NlcnMsIGFuZFxuICogdGhlIGBpbnB1dGAgZXZlbnQgZG9lcyBub3QgcHJvdmlkZSBhbnkgdXNlZnVsIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgaGFzXG4gKiBhY3R1YWxseSBiZWVuIGFkZGVkLCBjb250cmFyeSB0byB0aGUgc3BlYy4gVGh1cywgYHRleHRJbnB1dGAgaXMgdGhlIGJlc3RcbiAqIGF2YWlsYWJsZSBldmVudCB0byBpZGVudGlmeSB0aGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYWN0dWFsbHkgYmVlbiBpbnNlcnRlZFxuICogaW50byB0aGUgdGFyZ2V0IG5vZGUuXG4gKlxuICogVGhpcyBwbHVnaW4gaXMgYWxzbyByZXNwb25zaWJsZSBmb3IgZW1pdHRpbmcgYGNvbXBvc2l0aW9uYCBldmVudHMsIHRodXNcbiAqIGFsbG93aW5nIHVzIHRvIHNoYXJlIGNvbXBvc2l0aW9uIGZhbGxiYWNrIGNvZGUgZm9yIGJvdGggYGJlZm9yZUlucHV0YCBhbmRcbiAqIGBjb21wb3NpdGlvbmAgZXZlbnQgdHlwZXMuXG4gKi9cbnZhciBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgcmV0dXJuIFtleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCksIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KV07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmVmb3JlSW5wdXRFdmVudFBsdWdpbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9CZWZvcmVJbnB1dEV2ZW50UGx1Z2luLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENTU1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9DU1NQcm9wZXJ0eScpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcblxudmFyIGNhbWVsaXplU3R5bGVOYW1lID0gcmVxdWlyZSgnZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUnKTtcbnZhciBkYW5nZXJvdXNTdHlsZVZhbHVlID0gcmVxdWlyZSgnLi9kYW5nZXJvdXNTdHlsZVZhbHVlJyk7XG52YXIgaHlwaGVuYXRlU3R5bGVOYW1lID0gcmVxdWlyZSgnZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lJyk7XG52YXIgbWVtb2l6ZVN0cmluZ09ubHkgPSByZXF1aXJlKCdmYmpzL2xpYi9tZW1vaXplU3RyaW5nT25seScpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBwcm9jZXNzU3R5bGVOYW1lID0gbWVtb2l6ZVN0cmluZ09ubHkoZnVuY3Rpb24gKHN0eWxlTmFtZSkge1xuICByZXR1cm4gaHlwaGVuYXRlU3R5bGVOYW1lKHN0eWxlTmFtZSk7XG59KTtcblxudmFyIGhhc1Nob3J0aGFuZFByb3BlcnR5QnVnID0gZmFsc2U7XG52YXIgc3R5bGVGbG9hdEFjY2Vzc29yID0gJ2Nzc0Zsb2F0JztcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgdmFyIHRlbXBTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuICB0cnkge1xuICAgIC8vIElFOCB0aHJvd3MgXCJJbnZhbGlkIGFyZ3VtZW50LlwiIGlmIHJlc2V0dGluZyBzaG9ydGhhbmQgc3R5bGUgcHJvcGVydGllcy5cbiAgICB0ZW1wU3R5bGUuZm9udCA9ICcnO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaGFzU2hvcnRoYW5kUHJvcGVydHlCdWcgPSB0cnVlO1xuICB9XG4gIC8vIElFOCBvbmx5IHN1cHBvcnRzIGFjY2Vzc2luZyBjc3NGbG9hdCAoc3RhbmRhcmQpIGFzIHN0eWxlRmxvYXRcbiAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5jc3NGbG9hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3R5bGVGbG9hdEFjY2Vzc29yID0gJ3N0eWxlRmxvYXQnO1xuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vICdtc1RyYW5zZm9ybScgaXMgY29ycmVjdCwgYnV0IHRoZSBvdGhlciBwcmVmaXhlcyBzaG91bGQgYmUgY2FwaXRhbGl6ZWRcbiAgdmFyIGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiA9IC9eKD86d2Via2l0fG1venxvKVtBLVpdLztcblxuICAvLyBzdHlsZSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb25cbiAgdmFyIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiA9IC87XFxzKiQvO1xuXG4gIHZhciB3YXJuZWRTdHlsZU5hbWVzID0ge307XG4gIHZhciB3YXJuZWRTdHlsZVZhbHVlcyA9IHt9O1xuICB2YXIgd2FybmVkRm9yTmFOVmFsdWUgPSBmYWxzZTtcblxuICB2YXIgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgb3duZXIpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgY2FtZWxpemVTdHlsZU5hbWUobmFtZSksIGNoZWNrUmVuZGVyTWVzc2FnZShvd25lcikpIDogdm9pZCAwO1xuICB9O1xuXG4gIHZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgb3duZXIpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCB2ZW5kb3ItcHJlZml4ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8lcycsIG5hbWUsIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpLCBjaGVja1JlbmRlck1lc3NhZ2Uob3duZXIpKSA6IHZvaWQgMDtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBvd25lcikge1xuICAgIGlmICh3YXJuZWRTdHlsZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgJiYgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1N0eWxlIHByb3BlcnR5IHZhbHVlcyBzaG91bGRuXFwndCBjb250YWluIGEgc2VtaWNvbG9uLiVzICcgKyAnVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4nLCBjaGVja1JlbmRlck1lc3NhZ2Uob3duZXIpLCBuYW1lLCB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpKSA6IHZvaWQgMDtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc05hTiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgb3duZXIpIHtcbiAgICBpZiAod2FybmVkRm9yTmFOVmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JOYU5WYWx1ZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJXMnLCBuYW1lLCBjaGVja1JlbmRlck1lc3NhZ2Uob3duZXIpKSA6IHZvaWQgMDtcbiAgfTtcblxuICB2YXIgY2hlY2tSZW5kZXJNZXNzYWdlID0gZnVuY3Rpb24gKG93bmVyKSB7XG4gICAgaWYgKG93bmVyKSB7XG4gICAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1JlYWN0RE9NQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICovXG4gIHZhciB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgY29tcG9uZW50KSB7XG4gICAgdmFyIG93bmVyO1xuICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgIG93bmVyID0gY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgfVxuICAgIGlmIChuYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZShuYW1lLCBvd25lcik7XG4gICAgfSBlbHNlIGlmIChiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4udGVzdChuYW1lKSkge1xuICAgICAgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lKG5hbWUsIG93bmVyKTtcbiAgICB9IGVsc2UgaWYgKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uKG5hbWUsIHZhbHVlLCBvd25lcik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZUlzTmFOKG5hbWUsIHZhbHVlLCBvd25lcik7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBDU1MgcHJvcGVydGllcy5cbiAqL1xudmFyIENTU1Byb3BlcnR5T3BlcmF0aW9ucyA9IHtcblxuICAvKipcbiAgICogU2VyaWFsaXplcyBhIG1hcHBpbmcgb2Ygc3R5bGUgcHJvcGVydGllcyBmb3IgdXNlIGFzIGlubGluZSBzdHlsZXM6XG4gICAqXG4gICAqICAgPiBjcmVhdGVNYXJrdXBGb3JTdHlsZXMoe3dpZHRoOiAnMjAwcHgnLCBoZWlnaHQ6IDB9KVxuICAgKiAgIFwid2lkdGg6MjAwcHg7aGVpZ2h0OjA7XCJcbiAgICpcbiAgICogVW5kZWZpbmVkIHZhbHVlcyBhcmUgaWdub3JlZCBzbyB0aGF0IGRlY2xhcmF0aXZlIHByb2dyYW1taW5nIGlzIGVhc2llci5cbiAgICogVGhlIHJlc3VsdCBzaG91bGQgYmUgSFRNTC1lc2NhcGVkIGJlZm9yZSBpbnNlcnRpb24gaW50byB0aGUgRE9NLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gICAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfVxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9yU3R5bGVzOiBmdW5jdGlvbiAoc3R5bGVzLCBjb21wb25lbnQpIHtcbiAgICB2YXIgc2VyaWFsaXplZCA9ICcnO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FyblZhbGlkU3R5bGUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBjb21wb25lbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBzZXJpYWxpemVkICs9IHByb2Nlc3NTdHlsZU5hbWUoc3R5bGVOYW1lKSArICc6JztcbiAgICAgICAgc2VyaWFsaXplZCArPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSwgY29tcG9uZW50KSArICc7JztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQgfHwgbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgZm9yIG11bHRpcGxlIHN0eWxlcyBvbiBhIG5vZGUuICBJZiBhIHZhbHVlIGlzIHNwZWNpZmllZCBhc1xuICAgKiAnJyAoZW1wdHkgc3RyaW5nKSwgdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGUgcHJvcGVydHkgd2lsbCBiZSB1bnNldC5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAgICogQHBhcmFtIHtSZWFjdERPTUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqL1xuICBzZXRWYWx1ZUZvclN0eWxlczogZnVuY3Rpb24gKG5vZGUsIHN0eWxlcywgY29tcG9uZW50KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICBpbnN0YW5jZUlEOiBjb21wb25lbnQuX2RlYnVnSUQsXG4gICAgICAgIHR5cGU6ICd1cGRhdGUgc3R5bGVzJyxcbiAgICAgICAgcGF5bG9hZDogc3R5bGVzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGUgPSBub2RlLnN0eWxlO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdLCBjb21wb25lbnQpO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGNvbXBvbmVudCk7XG4gICAgICBpZiAoc3R5bGVOYW1lID09PSAnZmxvYXQnIHx8IHN0eWxlTmFtZSA9PT0gJ2Nzc0Zsb2F0Jykge1xuICAgICAgICBzdHlsZU5hbWUgPSBzdHlsZUZsb2F0QWNjZXNzb3I7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVWYWx1ZSkge1xuICAgICAgICBzdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBleHBhbnNpb24gPSBoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyAmJiBDU1NQcm9wZXJ0eS5zaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnNbc3R5bGVOYW1lXTtcbiAgICAgICAgaWYgKGV4cGFuc2lvbikge1xuICAgICAgICAgIC8vIFNob3J0aGFuZCBwcm9wZXJ0eSB0aGF0IElFOCB3b24ndCBsaWtlIHVuc2V0dGluZywgc28gdW5zZXQgZWFjaFxuICAgICAgICAgIC8vIGNvbXBvbmVudCB0byBwbGFjYXRlIGl0XG4gICAgICAgICAgZm9yICh2YXIgaW5kaXZpZHVhbFN0eWxlTmFtZSBpbiBleHBhbnNpb24pIHtcbiAgICAgICAgICAgIHN0eWxlW2luZGl2aWR1YWxTdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENTU1Byb3BlcnR5T3BlcmF0aW9ucztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9DU1NQcm9wZXJ0eU9wZXJhdGlvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDEwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbnZhciBnZXRFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRUYXJnZXQnKTtcbnZhciBpc0V2ZW50U3VwcG9ydGVkID0gcmVxdWlyZSgnLi9pc0V2ZW50U3VwcG9ydGVkJyk7XG52YXIgaXNUZXh0SW5wdXRFbGVtZW50ID0gcmVxdWlyZSgnLi9pc1RleHRJbnB1dEVsZW1lbnQnKTtcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGNoYW5nZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25DaGFuZ2UnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNoYW5nZUNhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDaGFuZ2UnLCAndG9wQ2xpY2snLCAndG9wRm9jdXMnLCAndG9wSW5wdXQnLCAndG9wS2V5RG93bicsICd0b3BLZXlVcCcsICd0b3BTZWxlY3Rpb25DaGFuZ2UnXVxuICB9XG59O1xuXG4vKipcbiAqIEZvciBJRSBzaGltc1xuICovXG52YXIgYWN0aXZlRWxlbWVudCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudFZhbHVlUHJvcCA9IG51bGw7XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjaGFuZ2VgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNoYW5nZUV2ZW50KGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBub2RlTmFtZSA9PT0gJ3NlbGVjdCcgfHwgbm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgZWxlbS50eXBlID09PSAnZmlsZSc7XG59XG5cbnZhciBkb2VzQ2hhbmdlRXZlbnRCdWJibGUgPSBmYWxzZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gU2VlIGBoYW5kbGVDaGFuZ2VgIGNvbW1lbnQgYmVsb3dcbiAgZG9lc0NoYW5nZUV2ZW50QnViYmxlID0gaXNFdmVudFN1cHBvcnRlZCgnY2hhbmdlJykgJiYgKCFkb2N1bWVudC5kb2N1bWVudE1vZGUgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gOCk7XG59XG5cbmZ1bmN0aW9uIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGV2ZW50ID0gU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuY2hhbmdlLCBhY3RpdmVFbGVtZW50SW5zdCwgbmF0aXZlRXZlbnQsIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KSk7XG4gIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG5cbiAgLy8gSWYgY2hhbmdlIGFuZCBwcm9wZXJ0eWNoYW5nZSBidWJibGVkLCB3ZSdkIGp1c3QgYmluZCB0byBpdCBsaWtlIGFsbCB0aGVcbiAgLy8gb3RoZXIgZXZlbnRzIGFuZCBoYXZlIGl0IGdvIHRocm91Z2ggUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLiBTaW5jZSBpdFxuICAvLyBkb2Vzbid0LCB3ZSBtYW51YWxseSBsaXN0ZW4gZm9yIHRoZSBldmVudHMgYW5kIHNvIHdlIGhhdmUgdG8gZW5xdWV1ZSBhbmRcbiAgLy8gcHJvY2VzcyB0aGUgYWJzdHJhY3QgZXZlbnQgbWFudWFsbHkuXG4gIC8vXG4gIC8vIEJhdGNoaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IGFsbCBldmVudCBoYW5kbGVycyBydW5cbiAgLy8gYmVmb3JlIHRoZSBuZXh0IHJlcmVuZGVyIChpbmNsdWRpbmcgZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQgdG8gYW5jZXN0b3JcbiAgLy8gZWxlbWVudHMgaW5zdGVhZCBvZiBkaXJlY3RseSBvbiB0aGUgaW5wdXQpLiBXaXRob3V0IHRoaXMsIGNvbnRyb2xsZWRcbiAgLy8gY29tcG9uZW50cyBkb24ndCB3b3JrIHByb3Blcmx5IGluIGNvbmp1bmN0aW9uIHdpdGggZXZlbnQgYnViYmxpbmcgYmVjYXVzZVxuICAvLyB0aGUgY29tcG9uZW50IGlzIHJlcmVuZGVyZWQgYW5kIHRoZSB2YWx1ZSByZXZlcnRlZCBiZWZvcmUgYWxsIHRoZSBldmVudFxuICAvLyBoYW5kbGVycyBjYW4gcnVuLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MDguXG4gIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyhydW5FdmVudEluQmF0Y2gsIGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGV2ZW50KSB7XG4gIEV2ZW50UGx1Z2luSHViLmVucXVldWVFdmVudHMoZXZlbnQpO1xuICBFdmVudFBsdWdpbkh1Yi5wcm9jZXNzRXZlbnRRdWV1ZShmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCh0YXJnZXQsIHRhcmdldEluc3QpIHtcbiAgYWN0aXZlRWxlbWVudCA9IHRhcmdldDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSB0YXJnZXRJbnN0O1xuICBhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KCdvbmNoYW5nZScsIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQpO1xufVxuXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFjdGl2ZUVsZW1lbnQuZGV0YWNoRXZlbnQoJ29uY2hhbmdlJywgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCk7XG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcENoYW5nZScpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9yQ2hhbmdlRXZlbnRJRTgodG9wTGV2ZWxUeXBlLCB0YXJnZXQsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcEZvY3VzJykge1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgodGFyZ2V0LCB0YXJnZXRJbnN0KTtcbiAgfSBlbHNlIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BCbHVyJykge1xuICAgIHN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGlucHV0YCBldmVudFxuICovXG52YXIgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gZmFsc2U7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIElFOSBjbGFpbXMgdG8gc3VwcG9ydCB0aGUgaW5wdXQgZXZlbnQgYnV0IGZhaWxzIHRvIHRyaWdnZXIgaXQgd2hlblxuICAvLyBkZWxldGluZyB0ZXh0LCBzbyB3ZSBpZ25vcmUgaXRzIGlucHV0IGV2ZW50cy5cbiAgLy8gSUUxMCsgZmlyZSBpbnB1dCBldmVudHMgdG8gb2Z0ZW4sIHN1Y2ggd2hlbiBhIHBsYWNlaG9sZGVyXG4gIC8vIGNoYW5nZXMgb3Igd2hlbiBhbiBpbnB1dCB3aXRoIGEgcGxhY2Vob2xkZXIgaXMgZm9jdXNlZC5cbiAgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gaXNFdmVudFN1cHBvcnRlZCgnaW5wdXQnKSAmJiAoIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiAxMSk7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTExKSBSZXBsYWNlbWVudCBnZXR0ZXIvc2V0dGVyIGZvciB0aGUgYHZhbHVlYCBwcm9wZXJ0eSB0aGF0IGdldHNcbiAqIHNldCBvbiB0aGUgYWN0aXZlIGVsZW1lbnQuXG4gKi9cbnZhciBuZXdWYWx1ZVByb3AgPSB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhY3RpdmVFbGVtZW50VmFsdWVQcm9wLmdldC5jYWxsKHRoaXMpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAvLyBDYXN0IHRvIGEgc3RyaW5nIHNvIHdlIGNhbiBkbyBlcXVhbGl0eSBjaGVja3MuXG4gICAgYWN0aXZlRWxlbWVudFZhbHVlID0gJycgKyB2YWw7XG4gICAgYWN0aXZlRWxlbWVudFZhbHVlUHJvcC5zZXQuY2FsbCh0aGlzLCB2YWwpO1xuICB9XG59O1xuXG4vKipcbiAqIChGb3IgSUUgPD0xMSkgU3RhcnRzIHRyYWNraW5nIHByb3BlcnR5Y2hhbmdlIGV2ZW50cyBvbiB0aGUgcGFzc2VkLWluIGVsZW1lbnRcbiAqIGFuZCBvdmVycmlkZSB0aGUgdmFsdWUgcHJvcGVydHkgc28gdGhhdCB3ZSBjYW4gZGlzdGluZ3Vpc2ggdXNlciBldmVudHMgZnJvbVxuICogdmFsdWUgY2hhbmdlcyBpbiBKUy5cbiAqL1xuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IHRhcmdldC52YWx1ZTtcbiAgYWN0aXZlRWxlbWVudFZhbHVlUHJvcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgJ3ZhbHVlJyk7XG5cbiAgLy8gTm90IGd1YXJkZWQgaW4gYSBjYW5EZWZpbmVQcm9wZXJ0eSBjaGVjazogSUU4IHN1cHBvcnRzIGRlZmluZVByb3BlcnR5IG9ubHlcbiAgLy8gb24gRE9NIGVsZW1lbnRzXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhY3RpdmVFbGVtZW50LCAndmFsdWUnLCBuZXdWYWx1ZVByb3ApO1xuICBpZiAoYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCkge1xuICAgIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG4gIH0gZWxzZSB7XG4gICAgYWN0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlLCBmYWxzZSk7XG4gIH1cbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9MTEpIFJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBjdXJyZW50bHktdHJhY2tlZCBlbGVtZW50LFxuICogaWYgYW55IGV4aXN0cy5cbiAqL1xuZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKSB7XG4gIGlmICghYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGRlbGV0ZSByZXN0b3JlcyB0aGUgb3JpZ2luYWwgcHJvcGVydHkgZGVmaW5pdGlvblxuICBkZWxldGUgYWN0aXZlRWxlbWVudC52YWx1ZTtcblxuICBpZiAoYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCkge1xuICAgIGFjdGl2ZUVsZW1lbnQuZGV0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG4gIH0gZWxzZSB7XG4gICAgYWN0aXZlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlLCBmYWxzZSk7XG4gIH1cblxuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50VmFsdWUgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50VmFsdWVQcm9wID0gbnVsbDtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9MTEpIEhhbmRsZXMgYSBwcm9wZXJ0eWNoYW5nZSBldmVudCwgc2VuZGluZyBhIGBjaGFuZ2VgIGV2ZW50IGlmXG4gKiB0aGUgdmFsdWUgb2YgdGhlIGFjdGl2ZSBlbGVtZW50IGhhcyBjaGFuZ2VkLlxuICovXG5mdW5jdGlvbiBoYW5kbGVQcm9wZXJ0eUNoYW5nZShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQucHJvcGVydHlOYW1lICE9PSAndmFsdWUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB2YWx1ZSA9IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQudmFsdWU7XG4gIGlmICh2YWx1ZSA9PT0gYWN0aXZlRWxlbWVudFZhbHVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IHZhbHVlO1xuXG4gIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpO1xufVxuXG4vKipcbiAqIElmIGEgYGNoYW5nZWAgZXZlbnQgc2hvdWxkIGJlIGZpcmVkLCByZXR1cm5zIHRoZSB0YXJnZXQncyBJRC5cbiAqL1xuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BJbnB1dCcpIHtcbiAgICAvLyBJbiBtb2Rlcm4gYnJvd3NlcnMgKGkuZS4sIG5vdCBJRTggb3IgSUU5KSwgdGhlIGlucHV0IGV2ZW50IGlzIGV4YWN0bHlcbiAgICAvLyB3aGF0IHdlIHdhbnQgc28gZmFsbCB0aHJvdWdoIGhlcmUgYW5kIHRyaWdnZXIgYW4gYWJzdHJhY3QgZXZlbnRcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50SUUodG9wTGV2ZWxUeXBlLCB0YXJnZXQsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcEZvY3VzJykge1xuICAgIC8vIEluIElFOCwgd2UgY2FuIGNhcHR1cmUgYWxtb3N0IGFsbCAudmFsdWUgY2hhbmdlcyBieSBhZGRpbmcgYVxuICAgIC8vIHByb3BlcnR5Y2hhbmdlIGhhbmRsZXIgYW5kIGxvb2tpbmcgZm9yIGV2ZW50cyB3aXRoIHByb3BlcnR5TmFtZVxuICAgIC8vIGVxdWFsIHRvICd2YWx1ZSdcbiAgICAvLyBJbiBJRTktMTEsIHByb3BlcnR5Y2hhbmdlIGZpcmVzIGZvciBtb3N0IGlucHV0IGV2ZW50cyBidXQgaXMgYnVnZ3kgYW5kXG4gICAgLy8gZG9lc24ndCBmaXJlIHdoZW4gdGV4dCBpcyBkZWxldGVkLCBidXQgY29udmVuaWVudGx5LCBzZWxlY3Rpb25jaGFuZ2VcbiAgICAvLyBhcHBlYXJzIHRvIGZpcmUgaW4gYWxsIG9mIHRoZSByZW1haW5pbmcgY2FzZXMgc28gd2UgY2F0Y2ggdGhvc2UgYW5kXG4gICAgLy8gZm9yd2FyZCB0aGUgZXZlbnQgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkXG4gICAgLy8gSW4gZWl0aGVyIGNhc2UsIHdlIGRvbid0IHdhbnQgdG8gY2FsbCB0aGUgZXZlbnQgaGFuZGxlciBpZiB0aGUgdmFsdWVcbiAgICAvLyBpcyBjaGFuZ2VkIGZyb20gSlMgc28gd2UgcmVkZWZpbmUgYSBzZXR0ZXIgZm9yIGAudmFsdWVgIHRoYXQgdXBkYXRlc1xuICAgIC8vIG91ciBhY3RpdmVFbGVtZW50VmFsdWUgdmFyaWFibGUsIGFsbG93aW5nIHVzIHRvIGlnbm9yZSB0aG9zZSBjaGFuZ2VzXG4gICAgLy9cbiAgICAvLyBzdG9wV2F0Y2hpbmcoKSBzaG91bGQgYmUgYSBub29wIGhlcmUgYnV0IHdlIGNhbGwgaXQganVzdCBpbiBjYXNlIHdlXG4gICAgLy8gbWlzc2VkIGEgYmx1ciBldmVudCBzb21laG93LlxuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gICAgc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCk7XG4gIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQmx1cicpIHtcbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICB9XG59XG5cbi8vIEZvciBJRTggYW5kIElFOS5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50SUUodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BTZWxlY3Rpb25DaGFuZ2UnIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcEtleVVwJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BLZXlEb3duJykge1xuICAgIC8vIE9uIHRoZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnQsIHRoZSB0YXJnZXQgaXMganVzdCBkb2N1bWVudCB3aGljaCBpc24ndFxuICAgIC8vIGhlbHBmdWwgZm9yIHVzIHNvIGp1c3QgY2hlY2sgYWN0aXZlRWxlbWVudCBpbnN0ZWFkLlxuICAgIC8vXG4gICAgLy8gOTklIG9mIHRoZSB0aW1lLCBrZXlkb3duIGFuZCBrZXl1cCBhcmVuJ3QgbmVjZXNzYXJ5LiBJRTggZmFpbHMgdG8gZmlyZVxuICAgIC8vIHByb3BlcnR5Y2hhbmdlIG9uIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhZnRlciBzZXR0aW5nIGB2YWx1ZWAgZnJvbSBhXG4gICAgLy8gc2NyaXB0IGFuZCBmaXJlcyBvbmx5IGtleWRvd24sIGtleXByZXNzLCBrZXl1cC4gQ2F0Y2hpbmcga2V5dXAgdXN1YWxseVxuICAgIC8vIGdldHMgaXQgYW5kIGNhdGNoaW5nIGtleWRvd24gbGV0cyB1cyBmaXJlIGFuIGV2ZW50IGZvciB0aGUgZmlyc3RcbiAgICAvLyBrZXlzdHJva2UgaWYgdXNlciBkb2VzIGEga2V5IHJlcGVhdCAoaXQnbGwgYmUgYSBsaXR0bGUgZGVsYXllZDogcmlnaHRcbiAgICAvLyBiZWZvcmUgdGhlIHNlY29uZCBrZXlzdHJva2UpLiBPdGhlciBpbnB1dCBtZXRob2RzIChlLmcuLCBwYXN0ZSkgc2VlbSB0b1xuICAgIC8vIGZpcmUgc2VsZWN0aW9uY2hhbmdlIG5vcm1hbGx5LlxuICAgIGlmIChhY3RpdmVFbGVtZW50ICYmIGFjdGl2ZUVsZW1lbnQudmFsdWUgIT09IGFjdGl2ZUVsZW1lbnRWYWx1ZSkge1xuICAgICAgYWN0aXZlRWxlbWVudFZhbHVlID0gYWN0aXZlRWxlbWVudC52YWx1ZTtcbiAgICAgIHJldHVybiBhY3RpdmVFbGVtZW50SW5zdDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNsaWNrYCBldmVudFxuICovXG5mdW5jdGlvbiBzaG91bGRVc2VDbGlja0V2ZW50KGVsZW0pIHtcbiAgLy8gVXNlIHRoZSBgY2xpY2tgIGV2ZW50IHRvIGRldGVjdCBjaGFuZ2VzIHRvIGNoZWNrYm94IGFuZCByYWRpbyBpbnB1dHMuXG4gIC8vIFRoaXMgYXBwcm9hY2ggd29ya3MgYWNyb3NzIGFsbCBicm93c2Vycywgd2hlcmVhcyBgY2hhbmdlYCBkb2VzIG5vdCBmaXJlXG4gIC8vIHVudGlsIGBibHVyYCBpbiBJRTguXG4gIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyAmJiAoZWxlbS50eXBlID09PSAnY2hlY2tib3gnIHx8IGVsZW0udHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQ2xpY2snKSB7XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvbkNoYW5nZWAgZXZlbnQgdGhhdCBub3JtYWxpemVzIGNoYW5nZSBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLiBUaGlzIGV2ZW50IGZpcmVzIGF0IGEgdGltZSB3aGVuIGl0J3MgcG9zc2libGUgdG9cbiAqIGNoYW5nZSB0aGUgZWxlbWVudCdzIHZhbHVlIHdpdGhvdXQgc2VlaW5nIGEgZmxpY2tlci5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBzZWxlY3RcbiAqL1xudmFyIENoYW5nZUV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIHRhcmdldE5vZGUgPSB0YXJnZXRJbnN0ID8gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodGFyZ2V0SW5zdCkgOiB3aW5kb3c7XG5cbiAgICB2YXIgZ2V0VGFyZ2V0SW5zdEZ1bmMsIGhhbmRsZUV2ZW50RnVuYztcbiAgICBpZiAoc2hvdWxkVXNlQ2hhbmdlRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGlmIChkb2VzQ2hhbmdlRXZlbnRCdWJibGUpIHtcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JDaGFuZ2VFdmVudElFODtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0YXJnZXROb2RlKSkge1xuICAgICAgaWYgKGlzSW5wdXRFdmVudFN1cHBvcnRlZCkge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudElFO1xuICAgICAgICBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50SUU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzaG91bGRVc2VDbGlja0V2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50O1xuICAgIH1cblxuICAgIGlmIChnZXRUYXJnZXRJbnN0RnVuYykge1xuICAgICAgdmFyIGluc3QgPSBnZXRUYXJnZXRJbnN0RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpO1xuICAgICAgaWYgKGluc3QpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuY2hhbmdlLCBpbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgICBldmVudC50eXBlID0gJ2NoYW5nZSc7XG4gICAgICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlRXZlbnRGdW5jKSB7XG4gICAgICBoYW5kbGVFdmVudEZ1bmModG9wTGV2ZWxUeXBlLCB0YXJnZXROb2RlLCB0YXJnZXRJbnN0KTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaGFuZ2VFdmVudFBsdWdpbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9DaGFuZ2VFdmVudFBsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAgPSByZXF1aXJlKCdmYmpzL2xpYi9jcmVhdGVOb2Rlc0Zyb21NYXJrdXAnKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgRGFuZ2VyID0ge1xuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhIG5vZGUgd2l0aCBhIHN0cmluZyBvZiBtYXJrdXAgYXQgaXRzIGN1cnJlbnQgcG9zaXRpb24gd2l0aGluIGl0c1xuICAgKiBwYXJlbnQuIFRoZSBtYXJrdXAgbXVzdCByZW5kZXIgaW50byBhIHNpbmdsZSByb290IG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gb2xkQ2hpbGQgQ2hpbGQgbm9kZSB0byByZXBsYWNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0byByZW5kZXIgaW4gcGxhY2Ugb2YgdGhlIGNoaWxkIG5vZGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXA6IGZ1bmN0aW9uIChvbGRDaGlsZCwgbWFya3VwKSB7XG4gICAgIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCguLi4pOiBDYW5ub3QgcmVuZGVyIG1hcmt1cCBpbiBhIHdvcmtlciB0aHJlYWQuIE1ha2Ugc3VyZSBgd2luZG93YCBhbmQgYGRvY3VtZW50YCBhcmUgYXZhaWxhYmxlIGdsb2JhbGx5IGJlZm9yZSByZXF1aXJpbmcgUmVhY3Qgd2hlbiB1bml0IHRlc3Rpbmcgb3IgdXNlIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RyaW5nKCkgZm9yIHNlcnZlciByZW5kZXJpbmcuJykgOiBfcHJvZEludmFyaWFudCgnNTYnKSA6IHZvaWQgMDtcbiAgICAhbWFya3VwID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKC4uLik6IE1pc3NpbmcgbWFya3VwLicpIDogX3Byb2RJbnZhcmlhbnQoJzU3JykgOiB2b2lkIDA7XG4gICAgIShvbGRDaGlsZC5ub2RlTmFtZSAhPT0gJ0hUTUwnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCguLi4pOiBDYW5ub3QgcmVwbGFjZSBtYXJrdXAgb2YgdGhlIDxodG1sPiBub2RlLiBUaGlzIGlzIGJlY2F1c2UgYnJvd3NlciBxdWlya3MgbWFrZSB0aGlzIHVucmVsaWFibGUgYW5kL29yIHNsb3cuIElmIHlvdSB3YW50IHRvIHJlbmRlciB0byB0aGUgcm9vdCB5b3UgbXVzdCB1c2Ugc2VydmVyIHJlbmRlcmluZy4gU2VlIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RyaW5nKCkuJykgOiBfcHJvZEludmFyaWFudCgnNTgnKSA6IHZvaWQgMDtcblxuICAgIGlmICh0eXBlb2YgbWFya3VwID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIG5ld0NoaWxkID0gY3JlYXRlTm9kZXNGcm9tTWFya3VwKG1hcmt1cCwgZW1wdHlGdW5jdGlvbilbMF07XG4gICAgICBvbGRDaGlsZC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdDaGlsZCwgb2xkQ2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBET01MYXp5VHJlZS5yZXBsYWNlQ2hpbGRXaXRoVHJlZShvbGRDaGlsZCwgbWFya3VwKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYW5nZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvRGFuZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgdGhhdCBpcyBpbmplY3RhYmxlIGludG8gYEV2ZW50UGx1Z2luSHViYCwgdGhhdCBzcGVjaWZpZXMgYVxuICogZGV0ZXJtaW5pc3RpYyBvcmRlcmluZyBvZiBgRXZlbnRQbHVnaW5gcy4gQSBjb252ZW5pZW50IHdheSB0byByZWFzb24gYWJvdXRcbiAqIHBsdWdpbnMsIHdpdGhvdXQgaGF2aW5nIHRvIHBhY2thZ2UgZXZlcnkgb25lIG9mIHRoZW0uIFRoaXMgaXMgYmV0dGVyIHRoYW5cbiAqIGhhdmluZyBwbHVnaW5zIGJlIG9yZGVyZWQgaW4gdGhlIHNhbWUgb3JkZXIgdGhhdCB0aGV5IGFyZSBpbmplY3RlZCBiZWNhdXNlXG4gKiB0aGF0IG9yZGVyaW5nIHdvdWxkIGJlIGluZmx1ZW5jZWQgYnkgdGhlIHBhY2thZ2luZyBvcmRlci5cbiAqIGBSZXNwb25kZXJFdmVudFBsdWdpbmAgbXVzdCBvY2N1ciBiZWZvcmUgYFNpbXBsZUV2ZW50UGx1Z2luYCBzbyB0aGF0XG4gKiBwcmV2ZW50aW5nIGRlZmF1bHQgb24gZXZlbnRzIGlzIGNvbnZlbmllbnQgaW4gYFNpbXBsZUV2ZW50UGx1Z2luYCBoYW5kbGVycy5cbiAqL1xuXG52YXIgRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIgPSBbJ1Jlc3BvbmRlckV2ZW50UGx1Z2luJywgJ1NpbXBsZUV2ZW50UGx1Z2luJywgJ1RhcEV2ZW50UGx1Z2luJywgJ0VudGVyTGVhdmVFdmVudFBsdWdpbicsICdDaGFuZ2VFdmVudFBsdWdpbicsICdTZWxlY3RFdmVudFBsdWdpbicsICdCZWZvcmVJbnB1dEV2ZW50UGx1Z2luJ107XG5cbm1vZHVsZS5leHBvcnRzID0gRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljTW91c2VFdmVudCcpO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgbW91c2VFbnRlcjoge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6ICdvbk1vdXNlRW50ZXInLFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BNb3VzZU91dCcsICd0b3BNb3VzZU92ZXInXVxuICB9LFxuICBtb3VzZUxlYXZlOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZTogJ29uTW91c2VMZWF2ZScsXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcE1vdXNlT3V0JywgJ3RvcE1vdXNlT3ZlciddXG4gIH1cbn07XG5cbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogRm9yIGFsbW9zdCBldmVyeSBpbnRlcmFjdGlvbiB3ZSBjYXJlIGFib3V0LCB0aGVyZSB3aWxsIGJlIGJvdGggYSB0b3AtbGV2ZWxcbiAgICogYG1vdXNlb3ZlcmAgYW5kIGBtb3VzZW91dGAgZXZlbnQgdGhhdCBvY2N1cnMuIE9ubHkgdXNlIGBtb3VzZW91dGAgc28gdGhhdFxuICAgKiB3ZSBkbyBub3QgZXh0cmFjdCBkdXBsaWNhdGUgZXZlbnRzLiBIb3dldmVyLCBtb3ZpbmcgdGhlIG1vdXNlIGludG8gdGhlXG4gICAqIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHdpbGwgbm90IGZpcmUgYSBgbW91c2VvdXRgIGV2ZW50LiBJbiB0aGlzIGNhc2UsIHdlIHVzZVxuICAgKiB0aGUgYG1vdXNlb3ZlcmAgdG9wLWxldmVsIGV2ZW50LlxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcE1vdXNlT3ZlcicgJiYgKG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQuZnJvbUVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRvcExldmVsVHlwZSAhPT0gJ3RvcE1vdXNlT3V0JyAmJiB0b3BMZXZlbFR5cGUgIT09ICd0b3BNb3VzZU92ZXInKSB7XG4gICAgICAvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIGluIG9yIG1vdXNlIG91dCAtIGlnbm9yaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHdpbjtcbiAgICBpZiAobmF0aXZlRXZlbnRUYXJnZXQud2luZG93ID09PSBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgICAgLy8gYG5hdGl2ZUV2ZW50VGFyZ2V0YCBpcyBwcm9iYWJseSBhIHdpbmRvdyBvYmplY3QuXG4gICAgICB3aW4gPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxuICAgICAgdmFyIGRvYyA9IG5hdGl2ZUV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luID0gd2luZG93O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmcm9tO1xuICAgIHZhciB0bztcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wTW91c2VPdXQnKSB7XG4gICAgICBmcm9tID0gdGFyZ2V0SW5zdDtcbiAgICAgIHZhciByZWxhdGVkID0gbmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC50b0VsZW1lbnQ7XG4gICAgICB0byA9IHJlbGF0ZWQgPyBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUocmVsYXRlZCkgOiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZpbmcgdG8gYSBub2RlIGZyb20gb3V0c2lkZSB0aGUgd2luZG93LlxuICAgICAgZnJvbSA9IG51bGw7XG4gICAgICB0byA9IHRhcmdldEluc3Q7XG4gICAgfVxuXG4gICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAvLyBOb3RoaW5nIHBlcnRhaW5zIHRvIG91ciBtYW5hZ2VkIGNvbXBvbmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgZnJvbU5vZGUgPSBmcm9tID09IG51bGwgPyB3aW4gOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShmcm9tKTtcbiAgICB2YXIgdG9Ob2RlID0gdG8gPT0gbnVsbCA/IHdpbiA6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRvKTtcblxuICAgIHZhciBsZWF2ZSA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMubW91c2VMZWF2ZSwgZnJvbSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBsZWF2ZS50eXBlID0gJ21vdXNlbGVhdmUnO1xuICAgIGxlYXZlLnRhcmdldCA9IGZyb21Ob2RlO1xuICAgIGxlYXZlLnJlbGF0ZWRUYXJnZXQgPSB0b05vZGU7XG5cbiAgICB2YXIgZW50ZXIgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLm1vdXNlRW50ZXIsIHRvLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGVudGVyLnR5cGUgPSAnbW91c2VlbnRlcic7XG4gICAgZW50ZXIudGFyZ2V0ID0gdG9Ob2RlO1xuICAgIGVudGVyLnJlbGF0ZWRUYXJnZXQgPSBmcm9tTm9kZTtcblxuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pO1xuXG4gICAgcmV0dXJuIFtsZWF2ZSwgZW50ZXJdO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRW50ZXJMZWF2ZUV2ZW50UGx1Z2luO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL0VudGVyTGVhdmVFdmVudFBsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG5cbnZhciBnZXRUZXh0Q29udGVudEFjY2Vzc29yID0gcmVxdWlyZSgnLi9nZXRUZXh0Q29udGVudEFjY2Vzc29yJyk7XG5cbi8qKlxuICogVGhpcyBoZWxwZXIgY2xhc3Mgc3RvcmVzIGluZm9ybWF0aW9uIGFib3V0IHRleHQgY29udGVudCBvZiBhIHRhcmdldCBub2RlLFxuICogYWxsb3dpbmcgY29tcGFyaXNvbiBvZiBjb250ZW50IGJlZm9yZSBhbmQgYWZ0ZXIgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBJZGVudGlmeSB0aGUgbm9kZSB3aGVyZSBzZWxlY3Rpb24gY3VycmVudGx5IGJlZ2lucywgdGhlbiBvYnNlcnZlXG4gKiBib3RoIGl0cyB0ZXh0IGNvbnRlbnQgYW5kIGl0cyBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBET00uIFNpbmNlIHRoZVxuICogYnJvd3NlciBtYXkgbmF0aXZlbHkgcmVwbGFjZSB0aGUgdGFyZ2V0IG5vZGUgZHVyaW5nIGNvbXBvc2l0aW9uLCB3ZSBjYW5cbiAqIHVzZSBpdHMgcG9zaXRpb24gdG8gZmluZCBpdHMgcmVwbGFjZW1lbnQuXG4gKlxuICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gcm9vdFxuICovXG5mdW5jdGlvbiBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUocm9vdCkge1xuICB0aGlzLl9yb290ID0gcm9vdDtcbiAgdGhpcy5fc3RhcnRUZXh0ID0gdGhpcy5nZXRUZXh0KCk7XG4gIHRoaXMuX2ZhbGxiYWNrVGV4dCA9IG51bGw7XG59XG5cbl9hc3NpZ24oRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLnByb3RvdHlwZSwge1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgdGhpcy5fc3RhcnRUZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9mYWxsYmFja1RleHQgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCB0ZXh0IG9mIGlucHV0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRUZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCd2YWx1ZScgaW4gdGhpcy5fcm9vdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jvb3QudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yb290W2dldFRleHRDb250ZW50QWNjZXNzb3IoKV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIERldGVybWluZSB0aGUgZGlmZmVyaW5nIHN1YnN0cmluZyBiZXR3ZWVuIHRoZSBpbml0aWFsbHkgc3RvcmVkXG4gICAqIHRleHQgY29udGVudCBhbmQgdGhlIGN1cnJlbnQgY29udGVudC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0RGF0YTogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9mYWxsYmFja1RleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9mYWxsYmFja1RleHQ7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0O1xuICAgIHZhciBzdGFydFZhbHVlID0gdGhpcy5fc3RhcnRUZXh0O1xuICAgIHZhciBzdGFydExlbmd0aCA9IHN0YXJ0VmFsdWUubGVuZ3RoO1xuICAgIHZhciBlbmQ7XG4gICAgdmFyIGVuZFZhbHVlID0gdGhpcy5nZXRUZXh0KCk7XG4gICAgdmFyIGVuZExlbmd0aCA9IGVuZFZhbHVlLmxlbmd0aDtcblxuICAgIGZvciAoc3RhcnQgPSAwOyBzdGFydCA8IHN0YXJ0TGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydF0gIT09IGVuZFZhbHVlW3N0YXJ0XSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbWluRW5kID0gc3RhcnRMZW5ndGggLSBzdGFydDtcbiAgICBmb3IgKGVuZCA9IDE7IGVuZCA8PSBtaW5FbmQ7IGVuZCsrKSB7XG4gICAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydExlbmd0aCAtIGVuZF0gIT09IGVuZFZhbHVlW2VuZExlbmd0aCAtIGVuZF0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNsaWNlVGFpbCA9IGVuZCA+IDEgPyAxIC0gZW5kIDogdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZhbGxiYWNrVGV4dCA9IGVuZFZhbHVlLnNsaWNlKHN0YXJ0LCBzbGljZVRhaWwpO1xuICAgIHJldHVybiB0aGlzLl9mYWxsYmFja1RleHQ7XG4gIH1cbn0pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xuXG52YXIgTVVTVF9VU0VfUFJPUEVSVFkgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFk7XG52YXIgSEFTX0JPT0xFQU5fVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX0JPT0xFQU5fVkFMVUU7XG52YXIgSEFTX05VTUVSSUNfVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX05VTUVSSUNfVkFMVUU7XG52YXIgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUU7XG52YXIgSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFO1xuXG52YXIgSFRNTERPTVByb3BlcnR5Q29uZmlnID0ge1xuICBpc0N1c3RvbUF0dHJpYnV0ZTogUmVnRXhwLnByb3RvdHlwZS50ZXN0LmJpbmQobmV3IFJlZ0V4cCgnXihkYXRhfGFyaWEpLVsnICsgRE9NUHJvcGVydHkuQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKSksXG4gIFByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBTdGFuZGFyZCBQcm9wZXJ0aWVzXG4gICAgICovXG4gICAgYWNjZXB0OiAwLFxuICAgIGFjY2VwdENoYXJzZXQ6IDAsXG4gICAgYWNjZXNzS2V5OiAwLFxuICAgIGFjdGlvbjogMCxcbiAgICBhbGxvd0Z1bGxTY3JlZW46IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGFsbG93VHJhbnNwYXJlbmN5OiAwLFxuICAgIGFsdDogMCxcbiAgICAvLyBzcGVjaWZpZXMgdGFyZ2V0IGNvbnRleHQgZm9yIGxpbmtzIHdpdGggYHByZWxvYWRgIHR5cGVcbiAgICBhczogMCxcbiAgICBhc3luYzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYXV0b0NvbXBsZXRlOiAwLFxuICAgIC8vIGF1dG9Gb2N1cyBpcyBwb2x5ZmlsbGVkL25vcm1hbGl6ZWQgYnkgQXV0b0ZvY3VzVXRpbHNcbiAgICAvLyBhdXRvRm9jdXM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGF1dG9QbGF5OiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjYXB0dXJlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjZWxsUGFkZGluZzogMCxcbiAgICBjZWxsU3BhY2luZzogMCxcbiAgICBjaGFyU2V0OiAwLFxuICAgIGNoYWxsZW5nZTogMCxcbiAgICBjaGVja2VkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNpdGU6IDAsXG4gICAgY2xhc3NJRDogMCxcbiAgICBjbGFzc05hbWU6IDAsXG4gICAgY29sczogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgY29sU3BhbjogMCxcbiAgICBjb250ZW50OiAwLFxuICAgIGNvbnRlbnRFZGl0YWJsZTogMCxcbiAgICBjb250ZXh0TWVudTogMCxcbiAgICBjb250cm9sczogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY29vcmRzOiAwLFxuICAgIGNyb3NzT3JpZ2luOiAwLFxuICAgIGRhdGE6IDAsIC8vIEZvciBgPG9iamVjdCAvPmAgYWN0cyBhcyBgc3JjYC5cbiAgICBkYXRlVGltZTogMCxcbiAgICAnZGVmYXVsdCc6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRlZmVyOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkaXI6IDAsXG4gICAgZGlzYWJsZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRvd25sb2FkOiBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFLFxuICAgIGRyYWdnYWJsZTogMCxcbiAgICBlbmNUeXBlOiAwLFxuICAgIGZvcm06IDAsXG4gICAgZm9ybUFjdGlvbjogMCxcbiAgICBmb3JtRW5jVHlwZTogMCxcbiAgICBmb3JtTWV0aG9kOiAwLFxuICAgIGZvcm1Ob1ZhbGlkYXRlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBmb3JtVGFyZ2V0OiAwLFxuICAgIGZyYW1lQm9yZGVyOiAwLFxuICAgIGhlYWRlcnM6IDAsXG4gICAgaGVpZ2h0OiAwLFxuICAgIGhpZGRlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgaGlnaDogMCxcbiAgICBocmVmOiAwLFxuICAgIGhyZWZMYW5nOiAwLFxuICAgIGh0bWxGb3I6IDAsXG4gICAgaHR0cEVxdWl2OiAwLFxuICAgIGljb246IDAsXG4gICAgaWQ6IDAsXG4gICAgaW5wdXRNb2RlOiAwLFxuICAgIGludGVncml0eTogMCxcbiAgICBpczogMCxcbiAgICBrZXlQYXJhbXM6IDAsXG4gICAga2V5VHlwZTogMCxcbiAgICBraW5kOiAwLFxuICAgIGxhYmVsOiAwLFxuICAgIGxhbmc6IDAsXG4gICAgbGlzdDogMCxcbiAgICBsb29wOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBsb3c6IDAsXG4gICAgbWFuaWZlc3Q6IDAsXG4gICAgbWFyZ2luSGVpZ2h0OiAwLFxuICAgIG1hcmdpbldpZHRoOiAwLFxuICAgIG1heDogMCxcbiAgICBtYXhMZW5ndGg6IDAsXG4gICAgbWVkaWE6IDAsXG4gICAgbWVkaWFHcm91cDogMCxcbiAgICBtZXRob2Q6IDAsXG4gICAgbWluOiAwLFxuICAgIG1pbkxlbmd0aDogMCxcbiAgICAvLyBDYXV0aW9uOyBgb3B0aW9uLnNlbGVjdGVkYCBpcyBub3QgdXBkYXRlZCBpZiBgc2VsZWN0Lm11bHRpcGxlYCBpc1xuICAgIC8vIGRpc2FibGVkIHdpdGggYHJlbW92ZUF0dHJpYnV0ZWAuXG4gICAgbXVsdGlwbGU6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbXV0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbmFtZTogMCxcbiAgICBub25jZTogMCxcbiAgICBub1ZhbGlkYXRlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBvcGVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBvcHRpbXVtOiAwLFxuICAgIHBhdHRlcm46IDAsXG4gICAgcGxhY2Vob2xkZXI6IDAsXG4gICAgcGxheXNJbmxpbmU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHBvc3RlcjogMCxcbiAgICBwcmVsb2FkOiAwLFxuICAgIHByb2ZpbGU6IDAsXG4gICAgcmFkaW9Hcm91cDogMCxcbiAgICByZWFkT25seTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmVmZXJyZXJQb2xpY3k6IDAsXG4gICAgcmVsOiAwLFxuICAgIHJlcXVpcmVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByZXZlcnNlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcm9sZTogMCxcbiAgICByb3dzOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICByb3dTcGFuOiBIQVNfTlVNRVJJQ19WQUxVRSxcbiAgICBzYW5kYm94OiAwLFxuICAgIHNjb3BlOiAwLFxuICAgIHNjb3BlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2Nyb2xsaW5nOiAwLFxuICAgIHNlYW1sZXNzOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBzZWxlY3RlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBzaGFwZTogMCxcbiAgICBzaXplOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBzaXplczogMCxcbiAgICBzcGFuOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBzcGVsbENoZWNrOiAwLFxuICAgIHNyYzogMCxcbiAgICBzcmNEb2M6IDAsXG4gICAgc3JjTGFuZzogMCxcbiAgICBzcmNTZXQ6IDAsXG4gICAgc3RhcnQ6IEhBU19OVU1FUklDX1ZBTFVFLFxuICAgIHN0ZXA6IDAsXG4gICAgc3R5bGU6IDAsXG4gICAgc3VtbWFyeTogMCxcbiAgICB0YWJJbmRleDogMCxcbiAgICB0YXJnZXQ6IDAsXG4gICAgdGl0bGU6IDAsXG4gICAgLy8gU2V0dGluZyAudHlwZSB0aHJvd3Mgb24gbm9uLTxpbnB1dD4gdGFnc1xuICAgIHR5cGU6IDAsXG4gICAgdXNlTWFwOiAwLFxuICAgIHZhbHVlOiAwLFxuICAgIHdpZHRoOiAwLFxuICAgIHdtb2RlOiAwLFxuICAgIHdyYXA6IDAsXG5cbiAgICAvKipcbiAgICAgKiBSREZhIFByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBhYm91dDogMCxcbiAgICBkYXRhdHlwZTogMCxcbiAgICBpbmxpc3Q6IDAsXG4gICAgcHJlZml4OiAwLFxuICAgIC8vIHByb3BlcnR5IGlzIGFsc28gc3VwcG9ydGVkIGZvciBPcGVuR3JhcGggaW4gbWV0YSB0YWdzLlxuICAgIHByb3BlcnR5OiAwLFxuICAgIHJlc291cmNlOiAwLFxuICAgICd0eXBlb2YnOiAwLFxuICAgIHZvY2FiOiAwLFxuXG4gICAgLyoqXG4gICAgICogTm9uLXN0YW5kYXJkIFByb3BlcnRpZXNcbiAgICAgKi9cbiAgICAvLyBhdXRvQ2FwaXRhbGl6ZSBhbmQgYXV0b0NvcnJlY3QgYXJlIHN1cHBvcnRlZCBpbiBNb2JpbGUgU2FmYXJpIGZvclxuICAgIC8vIGtleWJvYXJkIGhpbnRzLlxuICAgIGF1dG9DYXBpdGFsaXplOiAwLFxuICAgIGF1dG9Db3JyZWN0OiAwLFxuICAgIC8vIGF1dG9TYXZlIGFsbG93cyBXZWJLaXQvQmxpbmsgdG8gcGVyc2lzdCB2YWx1ZXMgb2YgaW5wdXQgZmllbGRzIG9uIHBhZ2UgcmVsb2Fkc1xuICAgIGF1dG9TYXZlOiAwLFxuICAgIC8vIGNvbG9yIGlzIGZvciBTYWZhcmkgbWFzay1pY29uIGxpbmtcbiAgICBjb2xvcjogMCxcbiAgICAvLyBpdGVtUHJvcCwgaXRlbVNjb3BlLCBpdGVtVHlwZSBhcmUgZm9yXG4gICAgLy8gTWljcm9kYXRhIHN1cHBvcnQuIFNlZSBodHRwOi8vc2NoZW1hLm9yZy9kb2NzL2dzLmh0bWxcbiAgICBpdGVtUHJvcDogMCxcbiAgICBpdGVtU2NvcGU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGl0ZW1UeXBlOiAwLFxuICAgIC8vIGl0ZW1JRCBhbmQgaXRlbVJlZiBhcmUgZm9yIE1pY3JvZGF0YSBzdXBwb3J0IGFzIHdlbGwgYnV0XG4gICAgLy8gb25seSBzcGVjaWZpZWQgaW4gdGhlIFdIQVRXRyBzcGVjIGRvY3VtZW50LiBTZWVcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9taWNyb2RhdGEuaHRtbCNtaWNyb2RhdGEtZG9tLWFwaVxuICAgIGl0ZW1JRDogMCxcbiAgICBpdGVtUmVmOiAwLFxuICAgIC8vIHJlc3VsdHMgc2hvdyBsb29raW5nIGdsYXNzIGljb24gYW5kIHJlY2VudCBzZWFyY2hlcyBvbiBpbnB1dFxuICAgIC8vIHNlYXJjaCBmaWVsZHMgaW4gV2ViS2l0L0JsaW5rXG4gICAgcmVzdWx0czogMCxcbiAgICAvLyBJRS1vbmx5IGF0dHJpYnV0ZSB0aGF0IHNwZWNpZmllcyBzZWN1cml0eSByZXN0cmljdGlvbnMgb24gYW4gaWZyYW1lXG4gICAgLy8gYXMgYW4gYWx0ZXJuYXRpdmUgdG8gdGhlIHNhbmRib3ggYXR0cmlidXRlIG9uIElFPDEwXG4gICAgc2VjdXJpdHk6IDAsXG4gICAgLy8gSUUtb25seSBhdHRyaWJ1dGUgdGhhdCBjb250cm9scyBmb2N1cyBiZWhhdmlvclxuICAgIHVuc2VsZWN0YWJsZTogMFxuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lczoge1xuICAgIGFjY2VwdENoYXJzZXQ6ICdhY2NlcHQtY2hhcnNldCcsXG4gICAgY2xhc3NOYW1lOiAnY2xhc3MnLFxuICAgIGh0bWxGb3I6ICdmb3InLFxuICAgIGh0dHBFcXVpdjogJ2h0dHAtZXF1aXYnXG4gIH0sXG4gIERPTVByb3BlcnR5TmFtZXM6IHt9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhUTUxET01Qcm9wZXJ0eUNvbmZpZztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9IVE1MRE9NUHJvcGVydHlDb25maWcuanNcbi8vIG1vZHVsZSBpZCA9IDEwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcblxudmFyIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciBLZXlFc2NhcGVVdGlscyA9IHJlcXVpcmUoJy4vS2V5RXNjYXBlVXRpbHMnKTtcbnZhciBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuID0gcmVxdWlyZSgnLi90cmF2ZXJzZUFsbENoaWxkcmVuJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0Jykge1xuICAvLyBUZW1wb3JhcnkgaGFjay5cbiAgLy8gSW5saW5lIHJlcXVpcmVzIGRvbid0IHdvcmsgd2VsbCB3aXRoIEplc3Q6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI0MFxuICAvLyBSZW1vdmUgdGhlIGlubGluZSByZXF1aXJlcyB3aGVuIHdlIGRvbid0IG5lZWQgdGhlbSBhbnltb3JlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MTc4XG4gIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xufVxuXG5mdW5jdGlvbiBpbnN0YW50aWF0ZUNoaWxkKGNoaWxkSW5zdGFuY2VzLCBjaGlsZCwgbmFtZSwgc2VsZkRlYnVnSUQpIHtcbiAgLy8gV2UgZm91bmQgYSBjb21wb25lbnQgaW5zdGFuY2UuXG4gIHZhciBrZXlVbmlxdWUgPSBjaGlsZEluc3RhbmNlc1tuYW1lXSA9PT0gdW5kZWZpbmVkO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmICghUmVhY3RDb21wb25lbnRUcmVlSG9vaykge1xuICAgICAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG4gICAgfVxuICAgIGlmICgha2V5VW5pcXVlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2ZsYXR0ZW5DaGlsZHJlbiguLi4pOiBFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksICcgKyAnYCVzYC4gQ2hpbGQga2V5cyBtdXN0IGJlIHVuaXF1ZTsgd2hlbiB0d28gY2hpbGRyZW4gc2hhcmUgYSBrZXksIG9ubHkgJyArICd0aGUgZmlyc3QgY2hpbGQgd2lsbCBiZSB1c2VkLiVzJywgS2V5RXNjYXBlVXRpbHMudW5lc2NhcGUobmFtZSksIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoc2VsZkRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgaWYgKGNoaWxkICE9IG51bGwgJiYga2V5VW5pcXVlKSB7XG4gICAgY2hpbGRJbnN0YW5jZXNbbmFtZV0gPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KGNoaWxkLCB0cnVlKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlYWN0Q2hpbGRSZWNvbmNpbGVyIHByb3ZpZGVzIGhlbHBlcnMgZm9yIGluaXRpYWxpemluZyBvciB1cGRhdGluZyBhIHNldCBvZlxuICogY2hpbGRyZW4uIEl0cyBvdXRwdXQgaXMgc3VpdGFibGUgZm9yIHBhc3NpbmcgaXQgb250byBSZWFjdE11bHRpQ2hpbGQgd2hpY2hcbiAqIGRvZXMgZGlmZmVkIHJlb3JkZXJpbmcgYW5kIGluc2VydGlvbi5cbiAqL1xudmFyIFJlYWN0Q2hpbGRSZWNvbmNpbGVyID0ge1xuICAvKipcbiAgICogR2VuZXJhdGVzIGEgXCJtb3VudCBpbWFnZVwiIGZvciBlYWNoIG9mIHRoZSBzdXBwbGllZCBjaGlsZHJlbi4gSW4gdGhlIGNhc2VcbiAgICogb2YgYFJlYWN0RE9NQ29tcG9uZW50YCwgYSBtb3VudCBpbWFnZSBpcyBhIHN0cmluZyBvZiBtYXJrdXAuXG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmVzdGVkQ2hpbGROb2RlcyBOZXN0ZWQgY2hpbGQgbWFwcy5cbiAgICogQHJldHVybiB7P29iamVjdH0gQSBzZXQgb2YgY2hpbGQgaW5zdGFuY2VzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGluc3RhbnRpYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXN0ZWRDaGlsZE5vZGVzLCB0cmFuc2FjdGlvbiwgY29udGV4dCwgc2VsZkRlYnVnSUQgLy8gMCBpbiBwcm9kdWN0aW9uIGFuZCBmb3Igcm9vdHNcbiAgKSB7XG4gICAgaWYgKG5lc3RlZENoaWxkTm9kZXMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBjaGlsZEluc3RhbmNlcyA9IHt9O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRyYXZlcnNlQWxsQ2hpbGRyZW4obmVzdGVkQ2hpbGROb2RlcywgZnVuY3Rpb24gKGNoaWxkSW5zdHMsIGNoaWxkLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW50aWF0ZUNoaWxkKGNoaWxkSW5zdHMsIGNoaWxkLCBuYW1lLCBzZWxmRGVidWdJRCk7XG4gICAgICB9LCBjaGlsZEluc3RhbmNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYXZlcnNlQWxsQ2hpbGRyZW4obmVzdGVkQ2hpbGROb2RlcywgaW5zdGFudGlhdGVDaGlsZCwgY2hpbGRJbnN0YW5jZXMpO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRJbnN0YW5jZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHJlbmRlcmVkIGNoaWxkcmVuIGFuZCByZXR1cm5zIGEgbmV3IHNldCBvZiBjaGlsZHJlbi5cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2Q2hpbGRyZW4gUHJldmlvdXNseSBpbml0aWFsaXplZCBzZXQgb2YgY2hpbGRyZW4uXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENoaWxkcmVuIEZsYXQgY2hpbGQgZWxlbWVudCBtYXBzLlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9vYmplY3R9IEEgbmV3IHNldCBvZiBjaGlsZCBpbnN0YW5jZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgbW91bnRJbWFnZXMsIHJlbW92ZWROb2RlcywgdHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBzZWxmRGVidWdJRCAvLyAwIGluIHByb2R1Y3Rpb24gYW5kIGZvciByb290c1xuICApIHtcbiAgICAvLyBXZSBjdXJyZW50bHkgZG9uJ3QgaGF2ZSBhIHdheSB0byB0cmFjayBtb3ZlcyBoZXJlIGJ1dCBpZiB3ZSB1c2UgaXRlcmF0b3JzXG4gICAgLy8gaW5zdGVhZCBvZiBmb3IuLmluIHdlIGNhbiB6aXAgdGhlIGl0ZXJhdG9ycyBhbmQgY2hlY2sgaWYgYW4gaXRlbSBoYXNcbiAgICAvLyBtb3ZlZC5cbiAgICAvLyBUT0RPOiBJZiBub3RoaW5nIGhhcyBjaGFuZ2VkLCByZXR1cm4gdGhlIHByZXZDaGlsZHJlbiBvYmplY3Qgc28gdGhhdCB3ZVxuICAgIC8vIGNhbiBxdWlja2x5IGJhaWxvdXQgaWYgbm90aGluZyBoYXMgY2hhbmdlZC5cbiAgICBpZiAoIW5leHRDaGlsZHJlbiAmJiAhcHJldkNoaWxkcmVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuYW1lO1xuICAgIHZhciBwcmV2Q2hpbGQ7XG4gICAgZm9yIChuYW1lIGluIG5leHRDaGlsZHJlbikge1xuICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRyZW4gJiYgcHJldkNoaWxkcmVuW25hbWVdO1xuICAgICAgdmFyIHByZXZFbGVtZW50ID0gcHJldkNoaWxkICYmIHByZXZDaGlsZC5fY3VycmVudEVsZW1lbnQ7XG4gICAgICB2YXIgbmV4dEVsZW1lbnQgPSBuZXh0Q2hpbGRyZW5bbmFtZV07XG4gICAgICBpZiAocHJldkNoaWxkICE9IG51bGwgJiYgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSkge1xuICAgICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudChwcmV2Q2hpbGQsIG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIG5leHRDaGlsZHJlbltuYW1lXSA9IHByZXZDaGlsZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcmV2Q2hpbGQpIHtcbiAgICAgICAgICByZW1vdmVkTm9kZXNbbmFtZV0gPSBSZWFjdFJlY29uY2lsZXIuZ2V0SG9zdE5vZGUocHJldkNoaWxkKTtcbiAgICAgICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChwcmV2Q2hpbGQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgY2hpbGQgbXVzdCBiZSBpbnN0YW50aWF0ZWQgYmVmb3JlIGl0J3MgbW91bnRlZC5cbiAgICAgICAgdmFyIG5leHRDaGlsZEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChuZXh0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIG5leHRDaGlsZHJlbltuYW1lXSA9IG5leHRDaGlsZEluc3RhbmNlO1xuICAgICAgICAvLyBDcmVhdGluZyBtb3VudCBpbWFnZSBub3cgZW5zdXJlcyByZWZzIGFyZSByZXNvbHZlZCBpbiByaWdodCBvcmRlclxuICAgICAgICAvLyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcxMDEgZm9yIGV4cGxhbmF0aW9uKS5cbiAgICAgICAgdmFyIG5leHRDaGlsZE1vdW50SW1hZ2UgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQobmV4dENoaWxkSW5zdGFuY2UsIHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgc2VsZkRlYnVnSUQpO1xuICAgICAgICBtb3VudEltYWdlcy5wdXNoKG5leHRDaGlsZE1vdW50SW1hZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBVbm1vdW50IGNoaWxkcmVuIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50LlxuICAgIGZvciAobmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIShuZXh0Q2hpbGRyZW4gJiYgbmV4dENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSkge1xuICAgICAgICBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRyZW5bbmFtZV07XG4gICAgICAgIHJlbW92ZWROb2Rlc1tuYW1lXSA9IFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZShwcmV2Q2hpbGQpO1xuICAgICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChwcmV2Q2hpbGQsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVubW91bnRzIGFsbCByZW5kZXJlZCBjaGlsZHJlbi4gVGhpcyBzaG91bGQgYmUgdXNlZCB0byBjbGVhbiB1cCBjaGlsZHJlblxuICAgKiB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSByZW5kZXJlZENoaWxkcmVuIFByZXZpb3VzbHkgaW5pdGlhbGl6ZWQgc2V0IG9mIGNoaWxkcmVuLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDaGlsZHJlbjogZnVuY3Rpb24gKHJlbmRlcmVkQ2hpbGRyZW4sIHNhZmVseSkge1xuICAgIGZvciAodmFyIG5hbWUgaW4gcmVuZGVyZWRDaGlsZHJlbikge1xuICAgICAgaWYgKHJlbmRlcmVkQ2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVkQ2hpbGQgPSByZW5kZXJlZENoaWxkcmVuW25hbWVdO1xuICAgICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChyZW5kZXJlZENoaWxkLCBzYWZlbHkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q2hpbGRSZWNvbmNpbGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0Q2hpbGRSZWNvbmNpbGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTUNoaWxkcmVuT3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NQ2hpbGRyZW5PcGVyYXRpb25zJyk7XG52YXIgUmVhY3RET01JRE9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0RE9NSURPcGVyYXRpb25zJyk7XG5cbi8qKlxuICogQWJzdHJhY3RzIGF3YXkgYWxsIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIHJlY29uY2lsZXIgdGhhdCByZXF1aXJlcyBrbm93bGVkZ2Ugb2ZcbiAqIHRoZSBicm93c2VyIGNvbnRleHQuIFRPRE86IFRoZXNlIGNhbGxlcnMgc2hvdWxkIGJlIHJlZmFjdG9yZWQgdG8gYXZvaWQgdGhlXG4gKiBuZWVkIGZvciB0aGlzIGluamVjdGlvbi5cbiAqL1xudmFyIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50ID0ge1xuXG4gIHByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IFJlYWN0RE9NSURPcGVyYXRpb25zLmRhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyxcblxuICByZXBsYWNlTm9kZVdpdGhNYXJrdXA6IERPTUNoaWxkcmVuT3BlcmF0aW9ucy5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cFxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3QnKTtcbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdEVycm9yVXRpbHMgPSByZXF1aXJlKCcuL1JlYWN0RXJyb3JVdGlscycpO1xudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VNYXAnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcbnZhciBSZWFjdE5vZGVUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3ROb2RlVHlwZXMnKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgY2hlY2tSZWFjdFR5cGVTcGVjID0gcmVxdWlyZSgnLi9jaGVja1JlYWN0VHlwZVNwZWMnKTtcbn1cblxudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBzaGFsbG93RXF1YWwgPSByZXF1aXJlKCdmYmpzL2xpYi9zaGFsbG93RXF1YWwnKTtcbnZhciBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgQ29tcG9zaXRlVHlwZXMgPSB7XG4gIEltcHVyZUNsYXNzOiAwLFxuICBQdXJlQ2xhc3M6IDEsXG4gIFN0YXRlbGVzc0Z1bmN0aW9uYWw6IDJcbn07XG5cbmZ1bmN0aW9uIFN0YXRlbGVzc0NvbXBvbmVudChDb21wb25lbnQpIHt9XG5TdGF0ZWxlc3NDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIENvbXBvbmVudCA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHRoaXMpLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICB2YXIgZWxlbWVudCA9IENvbXBvbmVudCh0aGlzLnByb3BzLCB0aGlzLmNvbnRleHQsIHRoaXMudXBkYXRlcik7XG4gIHdhcm5JZkludmFsaWRFbGVtZW50KENvbXBvbmVudCwgZWxlbWVudCk7XG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuZnVuY3Rpb24gd2FybklmSW52YWxpZEVsZW1lbnQoQ29tcG9uZW50LCBlbGVtZW50KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSBmYWxzZSB8fCBSZWFjdC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSwgJyVzKC4uLik6IEEgdmFsaWQgUmVhY3QgZWxlbWVudCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gWW91IG1heSBoYXZlICcgKyAncmV0dXJuZWQgdW5kZWZpbmVkLCBhbiBhcnJheSBvciBzb21lIG90aGVyIGludmFsaWQgb2JqZWN0LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIUNvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcywgJyVzKC4uLik6IGNoaWxkQ29udGV4dFR5cGVzIGNhbm5vdCBiZSBkZWZpbmVkIG9uIGEgZnVuY3Rpb25hbCBjb21wb25lbnQuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHJldHVybiAhIShDb21wb25lbnQucHJvdG90eXBlICYmIENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGlzUHVyZUNvbXBvbmVudChDb21wb25lbnQpIHtcbiAgcmV0dXJuICEhKENvbXBvbmVudC5wcm90b3R5cGUgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCk7XG59XG5cbi8vIFNlcGFyYXRlZCBpbnRvIGEgZnVuY3Rpb24gdG8gY29udGFpbiBkZW9wdGltaXphdGlvbnMgY2F1c2VkIGJ5IHRyeS9maW5hbGx5LlxuZnVuY3Rpb24gbWVhc3VyZUxpZmVDeWNsZVBlcmYoZm4sIGRlYnVnSUQsIHRpbWVyVHlwZSkge1xuICBpZiAoZGVidWdJRCA9PT0gMCkge1xuICAgIC8vIFRvcC1sZXZlbCB3cmFwcGVycyAoc2VlIFJlYWN0TW91bnQpIGFuZCBlbXB0eSBjb21wb25lbnRzIChzZWVcbiAgICAvLyBSZWFjdERPTUVtcHR5Q29tcG9uZW50KSBhcmUgaW52aXNpYmxlIHRvIGhvb2tzIGFuZCBkZXZ0b29scy5cbiAgICAvLyBCb3RoIGFyZSBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIHRoYXQgc2hvdWxkIGdvIGF3YXkgaW4gdGhlIGZ1dHVyZS5cbiAgICByZXR1cm4gZm4oKTtcbiAgfVxuXG4gIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZm4oKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRMaWZlQ3ljbGVUaW1lcihkZWJ1Z0lELCB0aW1lclR5cGUpO1xuICB9XG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tIFRoZSBMaWZlLUN5Y2xlIG9mIGEgQ29tcG9zaXRlIENvbXBvbmVudCAtLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiAtIGNvbnN0cnVjdG9yOiBJbml0aWFsaXphdGlvbiBvZiBzdGF0ZS4gVGhlIGluc3RhbmNlIGlzIG5vdyByZXRhaW5lZC5cbiAqICAgLSBjb21wb25lbnRXaWxsTW91bnRcbiAqICAgLSByZW5kZXJcbiAqICAgLSBbY2hpbGRyZW4ncyBjb25zdHJ1Y3RvcnNdXG4gKiAgICAgLSBbY2hpbGRyZW4ncyBjb21wb25lbnRXaWxsTW91bnQgYW5kIHJlbmRlcl1cbiAqICAgICAtIFtjaGlsZHJlbidzIGNvbXBvbmVudERpZE1vdW50XVxuICogICAgIC0gY29tcG9uZW50RGlkTW91bnRcbiAqXG4gKiAgICAgICBVcGRhdGUgUGhhc2VzOlxuICogICAgICAgLSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIChvbmx5IGNhbGxlZCBpZiBwYXJlbnQgdXBkYXRlZClcbiAqICAgICAgIC0gc2hvdWxkQ29tcG9uZW50VXBkYXRlXG4gKiAgICAgICAgIC0gY29tcG9uZW50V2lsbFVwZGF0ZVxuICogICAgICAgICAgIC0gcmVuZGVyXG4gKiAgICAgICAgICAgLSBbY2hpbGRyZW4ncyBjb25zdHJ1Y3RvcnMgb3IgcmVjZWl2ZSBwcm9wcyBwaGFzZXNdXG4gKiAgICAgICAgIC0gY29tcG9uZW50RGlkVXBkYXRlXG4gKlxuICogICAgIC0gY29tcG9uZW50V2lsbFVubW91bnRcbiAqICAgICAtIFtjaGlsZHJlbidzIGNvbXBvbmVudFdpbGxVbm1vdW50XVxuICogICAtIFtjaGlsZHJlbiBkZXN0cm95ZWRdXG4gKiAtIChkZXN0cm95ZWQpOiBUaGUgaW5zdGFuY2UgaXMgbm93IGJsYW5rLCByZWxlYXNlZCBieSBSZWFjdCBhbmQgcmVhZHkgZm9yIEdDLlxuICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuLyoqXG4gKiBBbiBpbmNyZW1lbnRpbmcgSUQgYXNzaWduZWQgdG8gZWFjaCBjb21wb25lbnQgd2hlbiBpdCBpcyBtb3VudGVkLiBUaGlzIGlzXG4gKiB1c2VkIHRvIGVuZm9yY2UgdGhlIG9yZGVyIGluIHdoaWNoIGBSZWFjdFVwZGF0ZXNgIHVwZGF0ZXMgZGlydHkgY29tcG9uZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgbmV4dE1vdW50SUQgPSAxO1xuXG4vKipcbiAqIEBsZW5kcyB7UmVhY3RDb21wb3NpdGVDb21wb25lbnQucHJvdG90eXBlfVxuICovXG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgPSB7XG5cbiAgLyoqXG4gICAqIEJhc2UgY29uc3RydWN0b3IgZm9yIGFsbCBjb21wb3NpdGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSAwO1xuICAgIHRoaXMuX2NvbXBvc2l0ZVR5cGUgPSBudWxsO1xuICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICB0aGlzLl9ob3N0UGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLl9ob3N0Q29udGFpbmVySW5mbyA9IG51bGw7XG5cbiAgICAvLyBTZWUgUmVhY3RVcGRhdGVRdWV1ZVxuICAgIHRoaXMuX3VwZGF0ZUJhdGNoTnVtYmVyID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nRWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcblxuICAgIHRoaXMuX3JlbmRlcmVkTm9kZVR5cGUgPSBudWxsO1xuICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gbnVsbDtcbiAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9tb3VudE9yZGVyID0gMDtcbiAgICB0aGlzLl90b3BMZXZlbFdyYXBwZXIgPSBudWxsO1xuXG4gICAgLy8gU2VlIFJlYWN0VXBkYXRlcyBhbmQgUmVhY3RVcGRhdGVRdWV1ZS5cbiAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcblxuICAgIC8vIENvbXBvbmVudFdpbGxVbm1vdW50IHNoYWxsIG9ubHkgYmUgY2FsbGVkIG9uY2VcbiAgICB0aGlzLl9jYWxsZWRDb21wb25lbnRXaWxsVW5tb3VudCA9IGZhbHNlO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRoaXMuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgY29tcG9uZW50LCByZW5kZXJzIG1hcmt1cCwgYW5kIHJlZ2lzdGVycyBldmVudCBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9vYmplY3R9IGhvc3RQYXJlbnRcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBob3N0Q29udGFpbmVySW5mb1xuICAgKiBAcGFyYW0gez9vYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7P3N0cmluZ30gUmVuZGVyZWQgbWFya3VwIHRvIGJlIGluc2VydGVkIGludG8gdGhlIERPTS5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5fbW91bnRPcmRlciA9IG5leHRNb3VudElEKys7XG4gICAgdGhpcy5faG9zdFBhcmVudCA9IGhvc3RQYXJlbnQ7XG4gICAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBob3N0Q29udGFpbmVySW5mbztcblxuICAgIHZhciBwdWJsaWNQcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgIHZhciBwdWJsaWNDb250ZXh0ID0gdGhpcy5fcHJvY2Vzc0NvbnRleHQoY29udGV4dCk7XG5cbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcblxuICAgIHZhciB1cGRhdGVRdWV1ZSA9IHRyYW5zYWN0aW9uLmdldFVwZGF0ZVF1ZXVlKCk7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBwdWJsaWMgY2xhc3NcbiAgICB2YXIgZG9Db25zdHJ1Y3QgPSBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KTtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2NvbnN0cnVjdENvbXBvbmVudChkb0NvbnN0cnVjdCwgcHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcbiAgICB2YXIgcmVuZGVyZWRFbGVtZW50O1xuXG4gICAgLy8gU3VwcG9ydCBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgICBpZiAoIWRvQ29uc3RydWN0ICYmIChpbnN0ID09IG51bGwgfHwgaW5zdC5yZW5kZXIgPT0gbnVsbCkpIHtcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IGluc3Q7XG4gICAgICB3YXJuSWZJbnZhbGlkRWxlbWVudChDb21wb25lbnQsIHJlbmRlcmVkRWxlbWVudCk7XG4gICAgICAhKGluc3QgPT09IG51bGwgfHwgaW5zdCA9PT0gZmFsc2UgfHwgUmVhY3QuaXNWYWxpZEVsZW1lbnQoaW5zdCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzKC4uLik6IEEgdmFsaWQgUmVhY3QgZWxlbWVudCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gWW91IG1heSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZCwgYW4gYXJyYXkgb3Igc29tZSBvdGhlciBpbnZhbGlkIG9iamVjdC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzEwNScsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBpbnN0ID0gbmV3IFN0YXRlbGVzc0NvbXBvbmVudChDb21wb25lbnQpO1xuICAgICAgdGhpcy5fY29tcG9zaXRlVHlwZSA9IENvbXBvc2l0ZVR5cGVzLlN0YXRlbGVzc0Z1bmN0aW9uYWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1B1cmVDb21wb25lbnQoQ29tcG9uZW50KSkge1xuICAgICAgICB0aGlzLl9jb21wb3NpdGVUeXBlID0gQ29tcG9zaXRlVHlwZXMuUHVyZUNsYXNzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY29tcG9zaXRlVHlwZSA9IENvbXBvc2l0ZVR5cGVzLkltcHVyZUNsYXNzO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgbGF0ZXIgaW4gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCwgYnV0IGFkZCBhbiBlYXJseVxuICAgICAgLy8gd2FybmluZyBub3cgdG8gaGVscCBkZWJ1Z2dpbmdcbiAgICAgIGlmIChpbnN0LnJlbmRlciA9PSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb3BzTXV0YXRlZCA9IGluc3QucHJvcHMgIT09IHB1YmxpY1Byb3BzO1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGluc3QucHJvcHMgPT09IHVuZGVmaW5lZCB8fCAhcHJvcHNNdXRhdGVkLCAnJXMoLi4uKTogV2hlbiBjYWxsaW5nIHN1cGVyKCkgaW4gYCVzYCwgbWFrZSBzdXJlIHRvIHBhc3MgJyArICd1cCB0aGUgc2FtZSBwcm9wcyB0aGF0IHlvdXIgY29tcG9uZW50XFwncyBjb25zdHJ1Y3RvciB3YXMgcGFzc2VkLicsIGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudE5hbWUpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIC8vIFRoZXNlIHNob3VsZCBiZSBzZXQgdXAgaW4gdGhlIGNvbnN0cnVjdG9yLCBidXQgYXMgYSBjb252ZW5pZW5jZSBmb3JcbiAgICAvLyBzaW1wbGVyIGNsYXNzIGFic3RyYWN0aW9ucywgd2Ugc2V0IHRoZW0gdXAgYWZ0ZXIgdGhlIGZhY3QuXG4gICAgaW5zdC5wcm9wcyA9IHB1YmxpY1Byb3BzO1xuICAgIGluc3QuY29udGV4dCA9IHB1YmxpY0NvbnRleHQ7XG4gICAgaW5zdC5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgaW5zdC51cGRhdGVyID0gdXBkYXRlUXVldWU7XG5cbiAgICB0aGlzLl9pbnN0YW5jZSA9IGluc3Q7XG5cbiAgICAvLyBTdG9yZSBhIHJlZmVyZW5jZSBmcm9tIHRoZSBpbnN0YW5jZSBiYWNrIHRvIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvblxuICAgIFJlYWN0SW5zdGFuY2VNYXAuc2V0KGluc3QsIHRoaXMpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFNpbmNlIHBsYWluIEpTIGNsYXNzZXMgYXJlIGRlZmluZWQgd2l0aG91dCBhbnkgc3BlY2lhbCBpbml0aWFsaXphdGlvblxuICAgICAgLy8gbG9naWMsIHdlIGNhbiBub3QgY2F0Y2ggY29tbW9uIGVycm9ycyBlYXJseS4gVGhlcmVmb3JlLCB3ZSBoYXZlIHRvXG4gICAgICAvLyBjYXRjaCB0aGVtIGhlcmUsIGF0IGluaXRpYWxpemF0aW9uIHRpbWUsIGluc3RlYWQuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5nZXRJbml0aWFsU3RhdGUgfHwgaW5zdC5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQsICdnZXRJbml0aWFsU3RhdGUgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGRlZmluZSBhIHN0YXRlIHByb3BlcnR5IGluc3RlYWQ/JywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5nZXREZWZhdWx0UHJvcHMgfHwgaW5zdC5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQsICdnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LnByb3BUeXBlcywgJ3Byb3BUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIHByb3BUeXBlcyBpbnN0ZWFkLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QuY29udGV4dFR5cGVzLCAnY29udGV4dFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSAnICsgJ3N0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGVzIGluc3RlYWQuJywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdC5jb21wb25lbnRTaG91bGRVcGRhdGUgIT09ICdmdW5jdGlvbicsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLCB0aGlzLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0LmNvbXBvbmVudERpZFVubW91bnQgIT09ICdmdW5jdGlvbicsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkVW5tb3VudCgpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0RpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsVW5tb3VudCgpPycsIHRoaXMuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIGluc3QuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyAhPT0gJ2Z1bmN0aW9uJywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JywgdGhpcy5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IGluc3Quc3RhdGU7XG4gICAgaWYgKGluaXRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbnN0LnN0YXRlID0gaW5pdGlhbFN0YXRlID0gbnVsbDtcbiAgICB9XG4gICAgISh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpbml0aWFsU3RhdGUpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5zdGF0ZTogbXVzdCBiZSBzZXQgdG8gYW4gb2JqZWN0IG9yIG51bGwnLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCcxMDYnLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcblxuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbiAgICB2YXIgbWFya3VwO1xuICAgIGlmIChpbnN0LnVuc3RhYmxlX2hhbmRsZUVycm9yKSB7XG4gICAgICBtYXJrdXAgPSB0aGlzLnBlcmZvcm1Jbml0aWFsTW91bnRXaXRoRXJyb3JIYW5kbGluZyhyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcmt1cCA9IHRoaXMucGVyZm9ybUluaXRpYWxNb3VudChyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfVxuXG4gICAgaWYgKGluc3QuY29tcG9uZW50RGlkTW91bnQpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0LmNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgICAgICAgfSwgX3RoaXMuX2RlYnVnSUQsICdjb21wb25lbnREaWRNb3VudCcpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoaW5zdC5jb21wb25lbnREaWRNb3VudCwgaW5zdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSxcblxuICBfY29uc3RydWN0Q29tcG9uZW50OiBmdW5jdGlvbiAoZG9Db25zdHJ1Y3QsIHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25zdHJ1Y3RDb21wb25lbnRXaXRob3V0T3duZXIoZG9Db25zdHJ1Y3QsIHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnN0cnVjdENvbXBvbmVudFdpdGhvdXRPd25lcihkb0NvbnN0cnVjdCwgcHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcbiAgICB9XG4gIH0sXG5cbiAgX2NvbnN0cnVjdENvbXBvbmVudFdpdGhvdXRPd25lcjogZnVuY3Rpb24gKGRvQ29uc3RydWN0LCBwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpIHtcbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcblxuICAgIGlmIChkb0NvbnN0cnVjdCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENvbXBvbmVudChwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpO1xuICAgICAgICB9LCB0aGlzLl9kZWJ1Z0lELCAnY3RvcicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb25lbnQocHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGlzIGNhbiBzdGlsbCBiZSBhbiBpbnN0YW5jZSBpbiBjYXNlIG9mIGZhY3RvcnkgY29tcG9uZW50c1xuICAgIC8vIGJ1dCB3ZSdsbCBjb3VudCB0aGlzIGFzIHRpbWUgc3BlbnQgcmVuZGVyaW5nIGFzIHRoZSBtb3JlIGNvbW1vbiBjYXNlLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICByZXR1cm4gbWVhc3VyZUxpZmVDeWNsZVBlcmYoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gQ29tcG9uZW50KHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XG4gICAgICB9LCB0aGlzLl9kZWJ1Z0lELCAncmVuZGVyJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBDb21wb25lbnQocHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcbiAgICB9XG4gIH0sXG5cbiAgcGVyZm9ybUluaXRpYWxNb3VudFdpdGhFcnJvckhhbmRsaW5nOiBmdW5jdGlvbiAocmVuZGVyZWRFbGVtZW50LCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgbWFya3VwO1xuICAgIHZhciBjaGVja3BvaW50ID0gdHJhbnNhY3Rpb24uY2hlY2twb2ludCgpO1xuICAgIHRyeSB7XG4gICAgICBtYXJrdXAgPSB0aGlzLnBlcmZvcm1Jbml0aWFsTW91bnQocmVuZGVyZWRFbGVtZW50LCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIFJvbGwgYmFjayB0byBjaGVja3BvaW50LCBoYW5kbGUgZXJyb3IgKHdoaWNoIG1heSBhZGQgaXRlbXMgdG8gdGhlIHRyYW5zYWN0aW9uKSwgYW5kIHRha2UgYSBuZXcgY2hlY2twb2ludFxuICAgICAgdHJhbnNhY3Rpb24ucm9sbGJhY2soY2hlY2twb2ludCk7XG4gICAgICB0aGlzLl9pbnN0YW5jZS51bnN0YWJsZV9oYW5kbGVFcnJvcihlKTtcbiAgICAgIGlmICh0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSkge1xuICAgICAgICB0aGlzLl9pbnN0YW5jZS5zdGF0ZSA9IHRoaXMuX3Byb2Nlc3NQZW5kaW5nU3RhdGUodGhpcy5faW5zdGFuY2UucHJvcHMsIHRoaXMuX2luc3RhbmNlLmNvbnRleHQpO1xuICAgICAgfVxuICAgICAgY2hlY2twb2ludCA9IHRyYW5zYWN0aW9uLmNoZWNrcG9pbnQoKTtcblxuICAgICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQudW5tb3VudENvbXBvbmVudCh0cnVlKTtcbiAgICAgIHRyYW5zYWN0aW9uLnJvbGxiYWNrKGNoZWNrcG9pbnQpO1xuXG4gICAgICAvLyBUcnkgYWdhaW4gLSB3ZSd2ZSBpbmZvcm1lZCB0aGUgY29tcG9uZW50IGFib3V0IHRoZSBlcnJvciwgc28gdGhleSBjYW4gcmVuZGVyIGFuIGVycm9yIG1lc3NhZ2UgdGhpcyB0aW1lLlxuICAgICAgLy8gSWYgdGhpcyB0aHJvd3MgYWdhaW4sIHRoZSBlcnJvciB3aWxsIGJ1YmJsZSB1cCAoYW5kIGNhbiBiZSBjYXVnaHQgYnkgYSBoaWdoZXIgZXJyb3IgYm91bmRhcnkpLlxuICAgICAgbWFya3VwID0gdGhpcy5wZXJmb3JtSW5pdGlhbE1vdW50KHJlbmRlcmVkRWxlbWVudCwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSxcblxuICBwZXJmb3JtSW5pdGlhbE1vdW50OiBmdW5jdGlvbiAocmVuZGVyZWRFbGVtZW50LCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuXG4gICAgdmFyIGRlYnVnSUQgPSAwO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBkZWJ1Z0lEID0gdGhpcy5fZGVidWdJRDtcbiAgICB9XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsTW91bnQpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gaW5zdC5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgICAgfSwgZGVidWdJRCwgJ2NvbXBvbmVudFdpbGxNb3VudCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdC5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgIH1cbiAgICAgIC8vIFdoZW4gbW91bnRpbmcsIGNhbGxzIHRvIGBzZXRTdGF0ZWAgYnkgYGNvbXBvbmVudFdpbGxNb3VudGAgd2lsbCBzZXRcbiAgICAgIC8vIGB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZWAgd2l0aG91dCB0cmlnZ2VyaW5nIGEgcmUtcmVuZGVyLlxuICAgICAgaWYgKHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlKSB7XG4gICAgICAgIGluc3Quc3RhdGUgPSB0aGlzLl9wcm9jZXNzUGVuZGluZ1N0YXRlKGluc3QucHJvcHMsIGluc3QuY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbm90IGEgc3RhdGVsZXNzIGNvbXBvbmVudCwgd2Ugbm93IHJlbmRlclxuICAgIGlmIChyZW5kZXJlZEVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVuZGVyZWRFbGVtZW50ID0gdGhpcy5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KCk7XG4gICAgfVxuXG4gICAgdmFyIG5vZGVUeXBlID0gUmVhY3ROb2RlVHlwZXMuZ2V0VHlwZShyZW5kZXJlZEVsZW1lbnQpO1xuICAgIHRoaXMuX3JlbmRlcmVkTm9kZVR5cGUgPSBub2RlVHlwZTtcbiAgICB2YXIgY2hpbGQgPSB0aGlzLl9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KHJlbmRlcmVkRWxlbWVudCwgbm9kZVR5cGUgIT09IFJlYWN0Tm9kZVR5cGVzLkVNUFRZIC8qIHNob3VsZEhhdmVEZWJ1Z0lEICovXG4gICAgKTtcbiAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IGNoaWxkO1xuXG4gICAgdmFyIG1hcmt1cCA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChjaGlsZCwgdHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0aGlzLl9wcm9jZXNzQ2hpbGRDb250ZXh0KGNvbnRleHQpLCBkZWJ1Z0lEKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoZGVidWdJRCAhPT0gMCkge1xuICAgICAgICB2YXIgY2hpbGREZWJ1Z0lEcyA9IGNoaWxkLl9kZWJ1Z0lEICE9PSAwID8gW2NoaWxkLl9kZWJ1Z0lEXSA6IFtdO1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRDaGlsZHJlbihkZWJ1Z0lELCBjaGlsZERlYnVnSURzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFya3VwO1xuICB9LFxuXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZSh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIGFueSByZXNvdXJjZXMgYWxsb2NhdGVkIGJ5IGBtb3VudENvbXBvbmVudGAuXG4gICAqXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChzYWZlbHkpIHtcbiAgICBpZiAoIXRoaXMuX3JlbmRlcmVkQ29tcG9uZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcblxuICAgIGlmIChpbnN0LmNvbXBvbmVudFdpbGxVbm1vdW50ICYmICFpbnN0Ll9jYWxsZWRDb21wb25lbnRXaWxsVW5tb3VudCkge1xuICAgICAgaW5zdC5fY2FsbGVkQ29tcG9uZW50V2lsbFVubW91bnQgPSB0cnVlO1xuXG4gICAgICBpZiAoc2FmZWx5KSB7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5nZXROYW1lKCkgKyAnLmNvbXBvbmVudFdpbGxVbm1vdW50KCknO1xuICAgICAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrKG5hbWUsIGluc3QuY29tcG9uZW50V2lsbFVubW91bnQuYmluZChpbnN0KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0LmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gICAgICAgICAgfSwgdGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudFdpbGxVbm1vdW50Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50KSB7XG4gICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudCh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCwgc2FmZWx5KTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkTm9kZVR5cGUgPSBudWxsO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBudWxsO1xuICAgICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFJlc2V0IHBlbmRpbmcgZmllbGRzXG4gICAgLy8gRXZlbiBpZiB0aGlzIGNvbXBvbmVudCBpcyBzY2hlZHVsZWQgZm9yIGFub3RoZXIgdXBkYXRlIGluIFJlYWN0VXBkYXRlcyxcbiAgICAvLyBpdCB3b3VsZCBzdGlsbCBiZSBpZ25vcmVkIGJlY2F1c2UgdGhlc2UgZmllbGRzIGFyZSByZXNldC5cbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdDYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdFbGVtZW50ID0gbnVsbDtcblxuICAgIC8vIFRoZXNlIGZpZWxkcyBkbyBub3QgcmVhbGx5IG5lZWQgdG8gYmUgcmVzZXQgc2luY2UgdGhpcyBvYmplY3QgaXMgbm9cbiAgICAvLyBsb25nZXIgYWNjZXNzaWJsZS5cbiAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gMDtcbiAgICB0aGlzLl90b3BMZXZlbFdyYXBwZXIgPSBudWxsO1xuXG4gICAgLy8gRGVsZXRlIHRoZSByZWZlcmVuY2UgZnJvbSB0aGUgaW5zdGFuY2UgdG8gdGhpcyBpbnRlcm5hbCByZXByZXNlbnRhdGlvblxuICAgIC8vIHdoaWNoIGFsbG93IHRoZSBpbnRlcm5hbHMgdG8gYmUgcHJvcGVybHkgY2xlYW5lZCB1cCBldmVuIGlmIHRoZSB1c2VyXG4gICAgLy8gbGVha3MgYSByZWZlcmVuY2UgdG8gdGhlIHB1YmxpYyBpbnN0YW5jZS5cbiAgICBSZWFjdEluc3RhbmNlTWFwLnJlbW92ZShpbnN0KTtcblxuICAgIC8vIFNvbWUgZXhpc3RpbmcgY29tcG9uZW50cyByZWx5IG9uIGluc3QucHJvcHMgZXZlbiBhZnRlciB0aGV5J3ZlIGJlZW5cbiAgICAvLyBkZXN0cm95ZWQgKGluIGV2ZW50IGhhbmRsZXJzKS5cbiAgICAvLyBUT0RPOiBpbnN0LnByb3BzID0gbnVsbDtcbiAgICAvLyBUT0RPOiBpbnN0LnN0YXRlID0gbnVsbDtcbiAgICAvLyBUT0RPOiBpbnN0LmNvbnRleHQgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaWx0ZXJzIHRoZSBjb250ZXh0IG9iamVjdCB0byBvbmx5IGNvbnRhaW4ga2V5cyBzcGVjaWZpZWQgaW5cbiAgICogYGNvbnRleHRUeXBlc2BcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7P29iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tYXNrQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICB2YXIgY29udGV4dFR5cGVzID0gQ29tcG9uZW50LmNvbnRleHRUeXBlcztcbiAgICBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgICAgcmV0dXJuIGVtcHR5T2JqZWN0O1xuICAgIH1cbiAgICB2YXIgbWFza2VkQ29udGV4dCA9IHt9O1xuICAgIGZvciAodmFyIGNvbnRleHROYW1lIGluIGNvbnRleHRUeXBlcykge1xuICAgICAgbWFza2VkQ29udGV4dFtjb250ZXh0TmFtZV0gPSBjb250ZXh0W2NvbnRleHROYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIG1hc2tlZENvbnRleHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbHRlcnMgdGhlIGNvbnRleHQgb2JqZWN0IHRvIG9ubHkgY29udGFpbiBrZXlzIHNwZWNpZmllZCBpblxuICAgKiBgY29udGV4dFR5cGVzYCwgYW5kIGFzc2VydHMgdGhhdCB0aGV5IGFyZSB2YWxpZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7P29iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wcm9jZXNzQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgbWFza2VkQ29udGV4dCA9IHRoaXMuX21hc2tDb250ZXh0KGNvbnRleHQpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICAgIGlmIChDb21wb25lbnQuY29udGV4dFR5cGVzKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrQ29udGV4dFR5cGVzKENvbXBvbmVudC5jb250ZXh0VHlwZXMsIG1hc2tlZENvbnRleHQsICdjb250ZXh0Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXNrZWRDb250ZXh0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY3VycmVudENvbnRleHRcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NDaGlsZENvbnRleHQ6IGZ1bmN0aW9uIChjdXJyZW50Q29udGV4dCkge1xuICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG4gICAgdmFyIGNoaWxkQ29udGV4dDtcblxuICAgIGlmIChpbnN0LmdldENoaWxkQ29udGV4dCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5Qcm9jZXNzaW5nQ2hpbGRDb250ZXh0KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2hpbGRDb250ZXh0ID0gaW5zdC5nZXRDaGlsZENvbnRleHQoKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRQcm9jZXNzaW5nQ2hpbGRDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkQ29udGV4dCA9IGluc3QuZ2V0Q2hpbGRDb250ZXh0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkQ29udGV4dCkge1xuICAgICAgISh0eXBlb2YgQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzID09PSAnb2JqZWN0JykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byB1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMTA3JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB0aGlzLl9jaGVja0NvbnRleHRUeXBlcyhDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMsIGNoaWxkQ29udGV4dCwgJ2NoaWxkQ29udGV4dCcpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBjaGlsZENvbnRleHQpIHtcbiAgICAgICAgIShuYW1lIGluIENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGtleSBcIiVzXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JywgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnMTA4JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JywgbmFtZSkgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gX2Fzc2lnbih7fSwgY3VycmVudENvbnRleHQsIGNoaWxkQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50Q29udGV4dDtcbiAgfSxcblxuICAvKipcbiAgICogQXNzZXJ0IHRoYXQgdGhlIGNvbnRleHQgdHlwZXMgYXJlIHZhbGlkXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIGNvbnRleHQgZmllbGQgdG8gYSBSZWFjdFByb3BUeXBlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2hlY2tDb250ZXh0VHlwZXM6IGZ1bmN0aW9uICh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24pIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY2hlY2tSZWFjdFR5cGVTcGVjKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgdGhpcy5nZXROYW1lKCksIG51bGwsIHRoaXMuX2RlYnVnSUQpO1xuICAgIH1cbiAgfSxcblxuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBuZXh0Q29udGV4dCkge1xuICAgIHZhciBwcmV2RWxlbWVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50O1xuICAgIHZhciBwcmV2Q29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XG5cbiAgICB0aGlzLl9wZW5kaW5nRWxlbWVudCA9IG51bGw7XG5cbiAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudCh0cmFuc2FjdGlvbiwgcHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBwcmV2Q29udGV4dCwgbmV4dENvbnRleHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBhbnkgb2YgYF9wZW5kaW5nRWxlbWVudGAsIGBfcGVuZGluZ1N0YXRlUXVldWVgLCBvciBgX3BlbmRpbmdGb3JjZVVwZGF0ZWBcbiAgICogaXMgc2V0LCB1cGRhdGUgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeTogZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRoaXMuX3BlbmRpbmdFbGVtZW50ICE9IG51bGwpIHtcbiAgICAgIFJlYWN0UmVjb25jaWxlci5yZWNlaXZlQ29tcG9uZW50KHRoaXMsIHRoaXMuX3BlbmRpbmdFbGVtZW50LCB0cmFuc2FjdGlvbiwgdGhpcy5fY29udGV4dCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSAhPT0gbnVsbCB8fCB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUpIHtcbiAgICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KHRyYW5zYWN0aW9uLCB0aGlzLl9jdXJyZW50RWxlbWVudCwgdGhpcy5fY3VycmVudEVsZW1lbnQsIHRoaXMuX2NvbnRleHQsIHRoaXMuX2NvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl91cGRhdGVCYXRjaE51bWJlciA9IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGFuIHVwZGF0ZSB0byBhIG1vdW50ZWQgY29tcG9uZW50LiBUaGUgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBhbmRcbiAgICogc2hvdWxkQ29tcG9uZW50VXBkYXRlIG1ldGhvZHMgYXJlIGNhbGxlZCwgdGhlbiAoYXNzdW1pbmcgdGhlIHVwZGF0ZSBpc24ndFxuICAgKiBza2lwcGVkKSB0aGUgcmVtYWluaW5nIHVwZGF0ZSBsaWZlY3ljbGUgbWV0aG9kcyBhcmUgY2FsbGVkIGFuZCB0aGUgRE9NXG4gICAqIHJlcHJlc2VudGF0aW9uIGlzIHVwZGF0ZWQuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoaXMgaW1wbGVtZW50cyBSZWFjdCdzIHJlbmRlcmluZyBhbmQgcmVjb25jaWxpYXRpb24gYWxnb3JpdGhtLlxuICAgKiBTb3BoaXN0aWNhdGVkIGNsaWVudHMgbWF5IHdpc2ggdG8gb3ZlcnJpZGUgdGhpcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gcHJldlBhcmVudEVsZW1lbnRcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRQYXJlbnRFbGVtZW50XG4gICAqIEBpbnRlcm5hbFxuICAgKiBAb3ZlcnJpZGFibGVcbiAgICovXG4gIHVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcmV2UGFyZW50RWxlbWVudCwgbmV4dFBhcmVudEVsZW1lbnQsIHByZXZVbm1hc2tlZENvbnRleHQsIG5leHRVbm1hc2tlZENvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgICEoaW5zdCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdBdHRlbXB0ZWQgdG8gdXBkYXRlIGNvbXBvbmVudCBgJXNgIHRoYXQgaGFzIGFscmVhZHkgYmVlbiB1bm1vdW50ZWQgKG9yIGZhaWxlZCB0byBtb3VudCkuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMTM2JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG5cbiAgICB2YXIgd2lsbFJlY2VpdmUgPSBmYWxzZTtcbiAgICB2YXIgbmV4dENvbnRleHQ7XG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIGNvbnRleHQgaGFzIGNoYW5nZWQgb3Igbm90XG4gICAgaWYgKHRoaXMuX2NvbnRleHQgPT09IG5leHRVbm1hc2tlZENvbnRleHQpIHtcbiAgICAgIG5leHRDb250ZXh0ID0gaW5zdC5jb250ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0Q29udGV4dCA9IHRoaXMuX3Byb2Nlc3NDb250ZXh0KG5leHRVbm1hc2tlZENvbnRleHQpO1xuICAgICAgd2lsbFJlY2VpdmUgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBwcmV2UHJvcHMgPSBwcmV2UGFyZW50RWxlbWVudC5wcm9wcztcbiAgICB2YXIgbmV4dFByb3BzID0gbmV4dFBhcmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICAvLyBOb3QgYSBzaW1wbGUgc3RhdGUgdXBkYXRlIGJ1dCBhIHByb3BzIHVwZGF0ZVxuICAgIGlmIChwcmV2UGFyZW50RWxlbWVudCAhPT0gbmV4dFBhcmVudEVsZW1lbnQpIHtcbiAgICAgIHdpbGxSZWNlaXZlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBBbiB1cGRhdGUgaGVyZSB3aWxsIHNjaGVkdWxlIGFuIHVwZGF0ZSBidXQgaW1tZWRpYXRlbHkgc2V0XG4gICAgLy8gX3BlbmRpbmdTdGF0ZVF1ZXVlIHdoaWNoIHdpbGwgZW5zdXJlIHRoYXQgYW55IHN0YXRlIHVwZGF0ZXMgZ2V0c1xuICAgIC8vIGltbWVkaWF0ZWx5IHJlY29uY2lsZWQgaW5zdGVhZCBvZiB3YWl0aW5nIGZvciB0aGUgbmV4dCBiYXRjaC5cbiAgICBpZiAod2lsbFJlY2VpdmUgJiYgaW5zdC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGluc3QuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICAgICAgfSwgdGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3QuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmV4dFN0YXRlID0gdGhpcy5fcHJvY2Vzc1BlbmRpbmdTdGF0ZShuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gdHJ1ZTtcblxuICAgIGlmICghdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlKSB7XG4gICAgICBpZiAoaW5zdC5zaG91bGRDb21wb25lbnRVcGRhdGUpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBzaG91bGRVcGRhdGUgPSBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdC5zaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICAgICAgICB9LCB0aGlzLl9kZWJ1Z0lELCAnc2hvdWxkQ29tcG9uZW50VXBkYXRlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2hvdWxkVXBkYXRlID0gaW5zdC5zaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbXBvc2l0ZVR5cGUgPT09IENvbXBvc2l0ZVR5cGVzLlB1cmVDbGFzcykge1xuICAgICAgICAgIHNob3VsZFVwZGF0ZSA9ICFzaGFsbG93RXF1YWwocHJldlByb3BzLCBuZXh0UHJvcHMpIHx8ICFzaGFsbG93RXF1YWwoaW5zdC5zdGF0ZSwgbmV4dFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhzaG91bGRVcGRhdGUgIT09IHVuZGVmaW5lZCwgJyVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhICcgKyAnYm9vbGVhbiB2YWx1ZS4gTWFrZSBzdXJlIHRvIHJldHVybiB0cnVlIG9yIGZhbHNlLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUJhdGNoTnVtYmVyID0gbnVsbDtcbiAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcbiAgICAgIC8vIFdpbGwgc2V0IGB0aGlzLnByb3BzYCwgYHRoaXMuc3RhdGVgIGFuZCBgdGhpcy5jb250ZXh0YC5cbiAgICAgIHRoaXMuX3BlcmZvcm1Db21wb25lbnRVcGRhdGUobmV4dFBhcmVudEVsZW1lbnQsIG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCwgdHJhbnNhY3Rpb24sIG5leHRVbm1hc2tlZENvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBpdCdzIGRldGVybWluZWQgdGhhdCBhIGNvbXBvbmVudCBzaG91bGQgbm90IHVwZGF0ZSwgd2Ugc3RpbGwgd2FudFxuICAgICAgLy8gdG8gc2V0IHByb3BzIGFuZCBzdGF0ZSBidXQgd2Ugc2hvcnRjdXQgdGhlIHJlc3Qgb2YgdGhlIHVwZGF0ZS5cbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dFBhcmVudEVsZW1lbnQ7XG4gICAgICB0aGlzLl9jb250ZXh0ID0gbmV4dFVubWFza2VkQ29udGV4dDtcbiAgICAgIGluc3QucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgICBpbnN0LnN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgaW5zdC5jb250ZXh0ID0gbmV4dENvbnRleHQ7XG4gICAgfVxuICB9LFxuXG4gIF9wcm9jZXNzUGVuZGluZ1N0YXRlOiBmdW5jdGlvbiAocHJvcHMsIGNvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlO1xuICAgIHZhciByZXBsYWNlID0gdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZTtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuXG4gICAgaWYgKCFxdWV1ZSkge1xuICAgICAgcmV0dXJuIGluc3Quc3RhdGU7XG4gICAgfVxuXG4gICAgaWYgKHJlcGxhY2UgJiYgcXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gcXVldWVbMF07XG4gICAgfVxuXG4gICAgdmFyIG5leHRTdGF0ZSA9IF9hc3NpZ24oe30sIHJlcGxhY2UgPyBxdWV1ZVswXSA6IGluc3Quc3RhdGUpO1xuICAgIGZvciAodmFyIGkgPSByZXBsYWNlID8gMSA6IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBhcnRpYWwgPSBxdWV1ZVtpXTtcbiAgICAgIF9hc3NpZ24obmV4dFN0YXRlLCB0eXBlb2YgcGFydGlhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcnRpYWwuY2FsbChpbnN0LCBuZXh0U3RhdGUsIHByb3BzLCBjb250ZXh0KSA6IHBhcnRpYWwpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0U3RhdGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1lcmdlcyBuZXcgcHJvcHMgYW5kIHN0YXRlLCBub3RpZmllcyBkZWxlZ2F0ZSBtZXRob2RzIG9mIHVwZGF0ZSBhbmRcbiAgICogcGVyZm9ybXMgdXBkYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgTmV4dCBlbGVtZW50XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHMgTmV4dCBwdWJsaWMgb2JqZWN0IHRvIHNldCBhcyBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZSBOZXh0IG9iamVjdCB0byBzZXQgYXMgc3RhdGUuXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHQgTmV4dCBwdWJsaWMgb2JqZWN0IHRvIHNldCBhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7P29iamVjdH0gdW5tYXNrZWRDb250ZXh0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcGVyZm9ybUNvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQsIHRyYW5zYWN0aW9uLCB1bm1hc2tlZENvbnRleHQpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG5cbiAgICB2YXIgaGFzQ29tcG9uZW50RGlkVXBkYXRlID0gQm9vbGVhbihpbnN0LmNvbXBvbmVudERpZFVwZGF0ZSk7XG4gICAgdmFyIHByZXZQcm9wcztcbiAgICB2YXIgcHJldlN0YXRlO1xuICAgIHZhciBwcmV2Q29udGV4dDtcbiAgICBpZiAoaGFzQ29tcG9uZW50RGlkVXBkYXRlKSB7XG4gICAgICBwcmV2UHJvcHMgPSBpbnN0LnByb3BzO1xuICAgICAgcHJldlN0YXRlID0gaW5zdC5zdGF0ZTtcbiAgICAgIHByZXZDb250ZXh0ID0gaW5zdC5jb250ZXh0O1xuICAgIH1cblxuICAgIGlmIChpbnN0LmNvbXBvbmVudFdpbGxVcGRhdGUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gaW5zdC5jb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICAgIH0sIHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnRXaWxsVXBkYXRlJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0LmNvbXBvbmVudFdpbGxVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRFbGVtZW50O1xuICAgIHRoaXMuX2NvbnRleHQgPSB1bm1hc2tlZENvbnRleHQ7XG4gICAgaW5zdC5wcm9wcyA9IG5leHRQcm9wcztcbiAgICBpbnN0LnN0YXRlID0gbmV4dFN0YXRlO1xuICAgIGluc3QuY29udGV4dCA9IG5leHRDb250ZXh0O1xuXG4gICAgdGhpcy5fdXBkYXRlUmVuZGVyZWRDb21wb25lbnQodHJhbnNhY3Rpb24sIHVubWFza2VkQ29udGV4dCk7XG5cbiAgICBpZiAoaGFzQ29tcG9uZW50RGlkVXBkYXRlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBtZWFzdXJlTGlmZUN5Y2xlUGVyZihpbnN0LmNvbXBvbmVudERpZFVwZGF0ZS5iaW5kKGluc3QsIHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2Q29udGV4dCksIF90aGlzMi5fZGVidWdJRCwgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoaW5zdC5jb21wb25lbnREaWRVcGRhdGUuYmluZChpbnN0LCBwcmV2UHJvcHMsIHByZXZTdGF0ZSwgcHJldkNvbnRleHQpLCBpbnN0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGwgdGhlIGNvbXBvbmVudCdzIGByZW5kZXJgIG1ldGhvZCBhbmQgdXBkYXRlIHRoZSBET00gYWNjb3JkaW5nbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICBfdXBkYXRlUmVuZGVyZWRDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBwcmV2Q29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLl9yZW5kZXJlZENvbXBvbmVudDtcbiAgICB2YXIgcHJldlJlbmRlcmVkRWxlbWVudCA9IHByZXZDb21wb25lbnRJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQ7XG4gICAgdmFyIG5leHRSZW5kZXJlZEVsZW1lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQoKTtcblxuICAgIHZhciBkZWJ1Z0lEID0gMDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZGVidWdJRCA9IHRoaXMuX2RlYnVnSUQ7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZSZW5kZXJlZEVsZW1lbnQsIG5leHRSZW5kZXJlZEVsZW1lbnQpKSB7XG4gICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudChwcmV2Q29tcG9uZW50SW5zdGFuY2UsIG5leHRSZW5kZXJlZEVsZW1lbnQsIHRyYW5zYWN0aW9uLCB0aGlzLl9wcm9jZXNzQ2hpbGRDb250ZXh0KGNvbnRleHQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9sZEhvc3ROb2RlID0gUmVhY3RSZWNvbmNpbGVyLmdldEhvc3ROb2RlKHByZXZDb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChwcmV2Q29tcG9uZW50SW5zdGFuY2UsIGZhbHNlKTtcblxuICAgICAgdmFyIG5vZGVUeXBlID0gUmVhY3ROb2RlVHlwZXMuZ2V0VHlwZShuZXh0UmVuZGVyZWRFbGVtZW50KTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkTm9kZVR5cGUgPSBub2RlVHlwZTtcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobmV4dFJlbmRlcmVkRWxlbWVudCwgbm9kZVR5cGUgIT09IFJlYWN0Tm9kZVR5cGVzLkVNUFRZIC8qIHNob3VsZEhhdmVEZWJ1Z0lEICovXG4gICAgICApO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBjaGlsZDtcblxuICAgICAgdmFyIG5leHRNYXJrdXAgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQoY2hpbGQsIHRyYW5zYWN0aW9uLCB0aGlzLl9ob3N0UGFyZW50LCB0aGlzLl9ob3N0Q29udGFpbmVySW5mbywgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSwgZGVidWdJRCk7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChkZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgdmFyIGNoaWxkRGVidWdJRHMgPSBjaGlsZC5fZGVidWdJRCAhPT0gMCA/IFtjaGlsZC5fZGVidWdJRF0gOiBbXTtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRDaGlsZHJlbihkZWJ1Z0lELCBjaGlsZERlYnVnSURzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZXBsYWNlTm9kZVdpdGhNYXJrdXAob2xkSG9zdE5vZGUsIG5leHRNYXJrdXAsIHByZXZDb21wb25lbnRJbnN0YW5jZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZGVuIGluIHNoYWxsb3cgcmVuZGVyaW5nLlxuICAgKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfcmVwbGFjZU5vZGVXaXRoTWFya3VwOiBmdW5jdGlvbiAob2xkSG9zdE5vZGUsIG5leHRNYXJrdXAsIHByZXZJbnN0YW5jZSkge1xuICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwKG9sZEhvc3ROb2RlLCBuZXh0TWFya3VwLCBwcmV2SW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50V2l0aG91dE93bmVyT3JDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICB2YXIgcmVuZGVyZWRFbGVtZW50O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGluc3QucmVuZGVyKCk7XG4gICAgICB9LCB0aGlzLl9kZWJ1Z0lELCAncmVuZGVyJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IGluc3QucmVuZGVyKCk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFdlIGFsbG93IGF1dG8tbW9ja3MgdG8gcHJvY2VlZCBhcyBpZiB0aGV5J3JlIHJldHVybmluZyBudWxsLlxuICAgICAgaWYgKHJlbmRlcmVkRWxlbWVudCA9PT0gdW5kZWZpbmVkICYmIGluc3QucmVuZGVyLl9pc01vY2tGdW5jdGlvbikge1xuICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGJhZCBwcmFjdGljZS4gQ29uc2lkZXIgd2FybmluZyBoZXJlIGFuZFxuICAgICAgICAvLyBkZXByZWNhdGluZyB0aGlzIGNvbnZlbmllbmNlLlxuICAgICAgICByZW5kZXJlZEVsZW1lbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZW5kZXJlZEVsZW1lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlbmRlcmVkRWxlbWVudDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyB8fCB0aGlzLl9jb21wb3NpdGVUeXBlICE9PSBDb21wb3NpdGVUeXBlcy5TdGF0ZWxlc3NGdW5jdGlvbmFsKSB7XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlbmRlcmVkRWxlbWVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dCgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dCgpO1xuICAgIH1cbiAgICAhKFxuICAgIC8vIFRPRE86IEFuIGBpc1ZhbGlkTm9kZWAgZnVuY3Rpb24gd291bGQgcHJvYmFibHkgYmUgbW9yZSBhcHByb3ByaWF0ZVxuICAgIHJlbmRlcmVkRWxlbWVudCA9PT0gbnVsbCB8fCByZW5kZXJlZEVsZW1lbnQgPT09IGZhbHNlIHx8IFJlYWN0LmlzVmFsaWRFbGVtZW50KHJlbmRlcmVkRWxlbWVudCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLnJlbmRlcigpOiBBIHZhbGlkIFJlYWN0IGVsZW1lbnQgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBtYXkgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQsIGFuIGFycmF5IG9yIHNvbWUgb3RoZXIgaW52YWxpZCBvYmplY3QuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMTA5JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG5cbiAgICByZXR1cm4gcmVuZGVyZWRFbGVtZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBMYXppbHkgYWxsb2NhdGVzIHRoZSByZWZzIG9iamVjdCBhbmQgc3RvcmVzIGBjb21wb25lbnRgIGFzIGByZWZgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIFJlZmVyZW5jZSBuYW1lLlxuICAgKiBAcGFyYW0ge2NvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0byBzdG9yZSBhcyBgcmVmYC5cbiAgICogQGZpbmFsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhdHRhY2hSZWY6IGZ1bmN0aW9uIChyZWYsIGNvbXBvbmVudCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgICEoaW5zdCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdTdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgaGF2ZSByZWZzLicpIDogX3Byb2RJbnZhcmlhbnQoJzExMCcpIDogdm9pZCAwO1xuICAgIHZhciBwdWJsaWNDb21wb25lbnRJbnN0YW5jZSA9IGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudCAmJiBjb21wb25lbnQuZ2V0TmFtZSA/IGNvbXBvbmVudC5nZXROYW1lKCkgOiAnYSBjb21wb25lbnQnO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHVibGljQ29tcG9uZW50SW5zdGFuY2UgIT0gbnVsbCB8fCBjb21wb25lbnQuX2NvbXBvc2l0ZVR5cGUgIT09IENvbXBvc2l0ZVR5cGVzLlN0YXRlbGVzc0Z1bmN0aW9uYWwsICdTdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgYmUgZ2l2ZW4gcmVmcyAnICsgJyhTZWUgcmVmIFwiJXNcIiBpbiAlcyBjcmVhdGVkIGJ5ICVzKS4gJyArICdBdHRlbXB0cyB0byBhY2Nlc3MgdGhpcyByZWYgd2lsbCBmYWlsLicsIHJlZiwgY29tcG9uZW50TmFtZSwgdGhpcy5nZXROYW1lKCkpIDogdm9pZCAwO1xuICAgIH1cbiAgICB2YXIgcmVmcyA9IGluc3QucmVmcyA9PT0gZW1wdHlPYmplY3QgPyBpbnN0LnJlZnMgPSB7fSA6IGluc3QucmVmcztcbiAgICByZWZzW3JlZl0gPSBwdWJsaWNDb21wb25lbnRJbnN0YW5jZTtcbiAgfSxcblxuICAvKipcbiAgICogRGV0YWNoZXMgYSByZWZlcmVuY2UgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBOYW1lIHRvIGRlcmVmZXJlbmNlLlxuICAgKiBAZmluYWxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRldGFjaFJlZjogZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciByZWZzID0gdGhpcy5nZXRQdWJsaWNJbnN0YW5jZSgpLnJlZnM7XG4gICAgZGVsZXRlIHJlZnNbcmVmXTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGEgdGV4dCBkZXNjcmlwdGlvbiBvZiB0aGUgY29tcG9uZW50IHRoYXQgY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnkgaXRcbiAgICogaW4gZXJyb3IgbWVzc2FnZXMuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG5hbWUgb3IgbnVsbC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXROYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHR5cGUgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHRoaXMuX2luc3RhbmNlICYmIHRoaXMuX2luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yICYmIGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBjb25zdHJ1Y3RvciAmJiBjb25zdHJ1Y3Rvci5uYW1lIHx8IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHVibGljbHkgYWNjZXNzaWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbXBvbmVudCAtIGkuZS4gd2hhdFxuICAgKiBpcyBleHBvc2VkIGJ5IHJlZnMgYW5kIHJldHVybmVkIGJ5IHJlbmRlci4gQ2FuIGJlIG51bGwgZm9yIHN0YXRlbGVzc1xuICAgKiBjb21wb25lbnRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gdGhlIHB1YmxpYyBjb21wb25lbnQgaW5zdGFuY2UuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0UHVibGljSW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIGlmICh0aGlzLl9jb21wb3NpdGVUeXBlID09PSBDb21wb3NpdGVUeXBlcy5TdGF0ZWxlc3NGdW5jdGlvbmFsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGluc3Q7XG4gIH0sXG5cbiAgLy8gU3R1YlxuICBfaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDogbnVsbFxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbi8qIGdsb2JhbHMgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdERlZmF1bHRJbmplY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0RGVmYXVsdEluamVjdGlvbicpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG52YXIgUmVhY3RWZXJzaW9uID0gcmVxdWlyZSgnLi9SZWFjdFZlcnNpb24nKTtcblxudmFyIGZpbmRET01Ob2RlID0gcmVxdWlyZSgnLi9maW5kRE9NTm9kZScpO1xudmFyIGdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlID0gcmVxdWlyZSgnLi9nZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZScpO1xudmFyIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyID0gcmVxdWlyZSgnLi9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cblJlYWN0RGVmYXVsdEluamVjdGlvbi5pbmplY3QoKTtcblxudmFyIFJlYWN0RE9NID0ge1xuICBmaW5kRE9NTm9kZTogZmluZERPTU5vZGUsXG4gIHJlbmRlcjogUmVhY3RNb3VudC5yZW5kZXIsXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IFJlYWN0TW91bnQudW5tb3VudENvbXBvbmVudEF0Tm9kZSxcbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczogUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzLFxuICB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogcmVuZGVyU3VidHJlZUludG9Db250YWluZXJcbn07XG5cbi8vIEluamVjdCB0aGUgcnVudGltZSBpbnRvIGEgZGV2dG9vbHMgZ2xvYmFsIGhvb2sgcmVnYXJkbGVzcyBvZiBicm93c2VyLlxuLy8gQWxsb3dzIGZvciBkZWJ1Z2dpbmcgd2hlbiB0aGUgaG9vayBpcyBpbmplY3RlZCBvbiB0aGUgcGFnZS5cbmlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmluamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uaW5qZWN0KHtcbiAgICBDb21wb25lbnRUcmVlOiB7XG4gICAgICBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZTogUmVhY3RET01Db21wb25lbnRUcmVlLmdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLFxuICAgICAgZ2V0Tm9kZUZyb21JbnN0YW5jZTogZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgICAgLy8gaW5zdCBpcyBhbiBpbnRlcm5hbCBpbnN0YW5jZSAoYnV0IGNvdWxkIGJlIGEgY29tcG9zaXRlKVxuICAgICAgICBpZiAoaW5zdC5fcmVuZGVyZWRDb21wb25lbnQpIHtcbiAgICAgICAgICBpbnN0ID0gZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUoaW5zdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc3QpIHtcbiAgICAgICAgICByZXR1cm4gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIE1vdW50OiBSZWFjdE1vdW50LFxuICAgIFJlY29uY2lsZXI6IFJlYWN0UmVjb25jaWxlclxuICB9KTtcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbiAgaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiB3aW5kb3cudG9wID09PSB3aW5kb3cuc2VsZikge1xuXG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgZGV2dG9vbHMgaXMgbm90IGluc3RhbGxlZFxuICAgIGlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gSWYgd2UncmUgaW4gQ2hyb21lIG9yIEZpcmVmb3gsIHByb3ZpZGUgYSBkb3dubG9hZCBsaW5rIGlmIG5vdCBpbnN0YWxsZWQuXG4gICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSA+IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRWRnZScpID09PSAtMSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+IC0xKSB7XG4gICAgICAgIC8vIEZpcmVmb3ggZG9lcyBub3QgaGF2ZSB0aGUgaXNzdWUgd2l0aCBkZXZ0b29scyBsb2FkZWQgb3ZlciBmaWxlOi8vXG4gICAgICAgIHZhciBzaG93RmlsZVVybE1lc3NhZ2UgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZignaHR0cCcpID09PSAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA9PT0gLTE7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ0Rvd25sb2FkIHRoZSBSZWFjdCBEZXZUb29scyAnICsgKHNob3dGaWxlVXJsTWVzc2FnZSA/ICdhbmQgdXNlIGFuIEhUVFAgc2VydmVyIChpbnN0ZWFkIG9mIGEgZmlsZTogVVJMKSAnIDogJycpICsgJ2ZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZGV2dG9vbHMnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdGVzdEZ1bmMgPSBmdW5jdGlvbiB0ZXN0Rm4oKSB7fTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZygodGVzdEZ1bmMubmFtZSB8fCB0ZXN0RnVuYy50b1N0cmluZygpKS5pbmRleE9mKCd0ZXN0Rm4nKSAhPT0gLTEsICdJdCBsb29rcyBsaWtlIHlvdVxcJ3JlIHVzaW5nIGEgbWluaWZpZWQgY29weSBvZiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQgJyArICdvZiBSZWFjdC4gV2hlbiBkZXBsb3lpbmcgUmVhY3QgYXBwcyB0byBwcm9kdWN0aW9uLCBtYWtlIHN1cmUgdG8gdXNlICcgKyAndGhlIHByb2R1Y3Rpb24gYnVpbGQgd2hpY2ggc2tpcHMgZGV2ZWxvcG1lbnQgd2FybmluZ3MgYW5kIGlzIGZhc3Rlci4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1taW5pZmljYXRpb24gZm9yIG1vcmUgZGV0YWlscy4nKSA6IHZvaWQgMDtcblxuICAgIC8vIElmIHdlJ3JlIGluIElFOCwgY2hlY2sgdG8gc2VlIGlmIHdlIGFyZSBpbiBjb21wYXRpYmlsaXR5IG1vZGUgYW5kIHByb3ZpZGVcbiAgICAvLyBpbmZvcm1hdGlvbiBvbiBwcmV2ZW50aW5nIGNvbXBhdGliaWxpdHkgbW9kZVxuICAgIHZhciBpZUNvbXBhdGliaWxpdHlNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8IDg7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaWVDb21wYXRpYmlsaXR5TW9kZSwgJ0ludGVybmV0IEV4cGxvcmVyIGlzIHJ1bm5pbmcgaW4gY29tcGF0aWJpbGl0eSBtb2RlOyBwbGVhc2UgYWRkIHRoZSAnICsgJ2ZvbGxvd2luZyB0YWcgdG8geW91ciBIVE1MIHRvIHByZXZlbnQgdGhpcyBmcm9tIGhhcHBlbmluZzogJyArICc8bWV0YSBodHRwLWVxdWl2PVwiWC1VQS1Db21wYXRpYmxlXCIgY29udGVudD1cIklFPWVkZ2VcIiAvPicpIDogdm9pZCAwO1xuXG4gICAgdmFyIGV4cGVjdGVkRmVhdHVyZXMgPSBbXG4gICAgLy8gc2hpbXNcbiAgICBBcnJheS5pc0FycmF5LCBBcnJheS5wcm90b3R5cGUuZXZlcnksIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiwgQXJyYXkucHJvdG90eXBlLm1hcCwgRGF0ZS5ub3csIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLCBPYmplY3Qua2V5cywgU3RyaW5nLnByb3RvdHlwZS50cmltXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRGZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFleHBlY3RlZEZlYXR1cmVzW2ldKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnT25lIG9yIG1vcmUgRVM1IHNoaW1zIGV4cGVjdGVkIGJ5IFJlYWN0IGFyZSBub3QgYXZhaWxhYmxlOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1wb2x5ZmlsbHMnKSA6IHZvaWQgMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcbiAgdmFyIFJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vayA9IHJlcXVpcmUoJy4vUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rJyk7XG4gIHZhciBSZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2sgPSByZXF1aXJlKCcuL1JlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vaycpO1xuICB2YXIgUmVhY3RET01JbnZhbGlkQVJJQUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0RE9NSW52YWxpZEFSSUFIb29rJyk7XG5cbiAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLmFkZEhvb2soUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rKTtcbiAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLmFkZEhvb2soUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rKTtcbiAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLmFkZEhvb2soUmVhY3RET01JbnZhbGlkQVJJQUhvb2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbi8qIGdsb2JhbCBoYXNPd25Qcm9wZXJ0eTp0cnVlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgQXV0b0ZvY3VzVXRpbHMgPSByZXF1aXJlKCcuL0F1dG9Gb2N1c1V0aWxzJyk7XG52YXIgQ1NTUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9DU1NQcm9wZXJ0eU9wZXJhdGlvbnMnKTtcbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBET01OYW1lc3BhY2VzID0gcmVxdWlyZSgnLi9ET01OYW1lc3BhY2VzJyk7XG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMnKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblJlZ2lzdHJ5Jyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudEZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudEZsYWdzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdERPTUlucHV0ID0gcmVxdWlyZSgnLi9SZWFjdERPTUlucHV0Jyk7XG52YXIgUmVhY3RET01PcHRpb24gPSByZXF1aXJlKCcuL1JlYWN0RE9NT3B0aW9uJyk7XG52YXIgUmVhY3RET01TZWxlY3QgPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0Jyk7XG52YXIgUmVhY3RET01UZXh0YXJlYSA9IHJlcXVpcmUoJy4vUmVhY3RET01UZXh0YXJlYScpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0TXVsdGlDaGlsZCA9IHJlcXVpcmUoJy4vUmVhY3RNdWx0aUNoaWxkJyk7XG52YXIgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbicpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKCcuL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIGlzRXZlbnRTdXBwb3J0ZWQgPSByZXF1aXJlKCcuL2lzRXZlbnRTdXBwb3J0ZWQnKTtcbnZhciBzaGFsbG93RXF1YWwgPSByZXF1aXJlKCdmYmpzL2xpYi9zaGFsbG93RXF1YWwnKTtcbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKCcuL3ZhbGlkYXRlRE9NTmVzdGluZycpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBGbGFncyA9IFJlYWN0RE9NQ29tcG9uZW50RmxhZ3M7XG52YXIgZGVsZXRlTGlzdGVuZXIgPSBFdmVudFBsdWdpbkh1Yi5kZWxldGVMaXN0ZW5lcjtcbnZhciBnZXROb2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2U7XG52YXIgbGlzdGVuVG8gPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIubGlzdGVuVG87XG52YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzO1xuXG4vLyBGb3IgcXVpY2tseSBtYXRjaGluZyBjaGlsZHJlbiB0eXBlLCB0byB0ZXN0IGlmIGNhbiBiZSB0cmVhdGVkIGFzIGNvbnRlbnQuXG52YXIgQ09OVEVOVF9UWVBFUyA9IHsgJ3N0cmluZyc6IHRydWUsICdudW1iZXInOiB0cnVlIH07XG5cbnZhciBTVFlMRSA9ICdzdHlsZSc7XG52YXIgSFRNTCA9ICdfX2h0bWwnO1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBjaGlsZHJlbjogbnVsbCxcbiAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IG51bGwsXG4gIHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZzogbnVsbFxufTtcblxuLy8gTm9kZSB0eXBlIGZvciBkb2N1bWVudCBmcmFnbWVudHMgKE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkuXG52YXIgRE9DX0ZSQUdNRU5UX1RZUEUgPSAxMTtcblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGludGVybmFsSW5zdGFuY2UpIHtcbiAgaWYgKGludGVybmFsSW5zdGFuY2UpIHtcbiAgICB2YXIgb3duZXIgPSBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXIgfHwgbnVsbDtcbiAgICBpZiAob3duZXIpIHtcbiAgICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICcgVGhpcyBET00gbm9kZSB3YXMgcmVuZGVyZWQgYnkgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBmcmllbmRseVN0cmluZ2lmeShvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgcmV0dXJuICdbJyArIG9iai5tYXAoZnJpZW5kbHlTdHJpbmdpZnkpLmpvaW4oJywgJykgKyAnXSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYWlycyA9IFtdO1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgIHZhciBrZXlFc2NhcGVkID0gL15bYS16JF9dW1xcdyRfXSokL2kudGVzdChrZXkpID8ga2V5IDogSlNPTi5zdHJpbmdpZnkoa2V5KTtcbiAgICAgICAgICBwYWlycy5wdXNoKGtleUVzY2FwZWQgKyAnOiAnICsgZnJpZW5kbHlTdHJpbmdpZnkob2JqW2tleV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICd7JyArIHBhaXJzLmpvaW4oJywgJykgKyAnfSc7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiAnW2Z1bmN0aW9uIG9iamVjdF0nO1xuICB9XG4gIC8vIERpZmZlcnMgZnJvbSBKU09OLnN0cmluZ2lmeSBpbiB0aGF0IHVuZGVmaW5lZCBiZWNhdXNlIHVuZGVmaW5lZCBhbmQgdGhhdFxuICAvLyBpbmYgYW5kIG5hbiBkb24ndCBiZWNvbWUgbnVsbFxuICByZXR1cm4gU3RyaW5nKG9iaik7XG59XG5cbnZhciBzdHlsZU11dGF0aW9uV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBjaGVja0FuZFdhcm5Gb3JNdXRhdGVkU3R5bGUoc3R5bGUxLCBzdHlsZTIsIGNvbXBvbmVudCkge1xuICBpZiAoc3R5bGUxID09IG51bGwgfHwgc3R5bGUyID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHNoYWxsb3dFcXVhbChzdHlsZTEsIHN0eWxlMikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5fdGFnO1xuICB2YXIgb3duZXIgPSBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgdmFyIG93bmVyTmFtZTtcbiAgaWYgKG93bmVyKSB7XG4gICAgb3duZXJOYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICB9XG5cbiAgdmFyIGhhc2ggPSBvd25lck5hbWUgKyAnfCcgKyBjb21wb25lbnROYW1lO1xuXG4gIGlmIChzdHlsZU11dGF0aW9uV2FybmluZy5oYXNPd25Qcm9wZXJ0eShoYXNoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0eWxlTXV0YXRpb25XYXJuaW5nW2hhc2hdID0gdHJ1ZTtcblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2Alc2Agd2FzIHBhc3NlZCBhIHN0eWxlIG9iamVjdCB0aGF0IGhhcyBwcmV2aW91c2x5IGJlZW4gbXV0YXRlZC4gJyArICdNdXRhdGluZyBgc3R5bGVgIGlzIGRlcHJlY2F0ZWQuIENvbnNpZGVyIGNsb25pbmcgaXQgYmVmb3JlaGFuZC4gQ2hlY2sgJyArICd0aGUgYHJlbmRlcmAgJXMuIFByZXZpb3VzIHN0eWxlOiAlcy4gTXV0YXRlZCBzdHlsZTogJXMuJywgY29tcG9uZW50TmFtZSwgb3duZXIgPyAnb2YgYCcgKyBvd25lck5hbWUgKyAnYCcgOiAndXNpbmcgPCcgKyBjb21wb25lbnROYW1lICsgJz4nLCBmcmllbmRseVN0cmluZ2lmeShzdHlsZTEpLCBmcmllbmRseVN0cmluZ2lmeShzdHlsZTIpKSA6IHZvaWQgMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IHByb3BzXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFZhbGlkUHJvcHMoY29tcG9uZW50LCBwcm9wcykge1xuICBpZiAoIXByb3BzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIE5vdGUgdGhlIHVzZSBvZiBgPT1gIHdoaWNoIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWQuXG4gIGlmICh2b2lkRWxlbWVudFRhZ3NbY29tcG9uZW50Ll90YWddKSB7XG4gICAgIShwcm9wcy5jaGlsZHJlbiA9PSBudWxsICYmIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzIGlzIGEgdm9pZCBlbGVtZW50IHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJXMnLCBjb21wb25lbnQuX3RhZywgY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXIgPyAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICcgKyBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lci5nZXROYW1lKCkgKyAnLicgOiAnJykgOiBfcHJvZEludmFyaWFudCgnMTM3JywgY29tcG9uZW50Ll90YWcsIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyID8gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAnICsgY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXIuZ2V0TmFtZSgpICsgJy4nIDogJycpIDogdm9pZCAwO1xuICB9XG4gIGlmIChwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPSBudWxsKSB7XG4gICAgIShwcm9wcy5jaGlsZHJlbiA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKSA6IF9wcm9kSW52YXJpYW50KCc2MCcpIDogdm9pZCAwO1xuICAgICEodHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBIVE1MIGluIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9mYi5tZS9yZWFjdC1pbnZhcmlhbnQtZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgZm9yIG1vcmUgaW5mb3JtYXRpb24uJykgOiBfcHJvZEludmFyaWFudCgnNjEnKSA6IHZvaWQgMDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHByb3BzLmlubmVySFRNTCA9PSBudWxsLCAnRGlyZWN0bHkgc2V0dGluZyBwcm9wZXJ0eSBgaW5uZXJIVE1MYCBpcyBub3QgcGVybWl0dGVkLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBsb29rdXAgZG9jdW1lbnRhdGlvbiBvbiBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpIDogdm9pZCAwO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHByb3BzLnN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyB8fCAhcHJvcHMuY29udGVudEVkaXRhYmxlIHx8IHByb3BzLmNoaWxkcmVuID09IG51bGwsICdBIGNvbXBvbmVudCBpcyBgY29udGVudEVkaXRhYmxlYCBhbmQgY29udGFpbnMgYGNoaWxkcmVuYCBtYW5hZ2VkIGJ5ICcgKyAnUmVhY3QuIEl0IGlzIG5vdyB5b3VyIHJlc3BvbnNpYmlsaXR5IHRvIGd1YXJhbnRlZSB0aGF0IG5vbmUgb2YgJyArICd0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgJyArICdwcm9iYWJseSBub3QgaW50ZW50aW9uYWwuJykgOiB2b2lkIDA7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHJvcHMub25Gb2N1c0luID09IG51bGwgJiYgcHJvcHMub25Gb2N1c091dCA9PSBudWxsLCAnUmVhY3QgdXNlcyBvbkZvY3VzIGFuZCBvbkJsdXIgaW5zdGVhZCBvZiBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQuICcgKyAnQWxsIFJlYWN0IGV2ZW50cyBhcmUgbm9ybWFsaXplZCB0byBidWJibGUsIHNvIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dCAnICsgJ2FyZSBub3QgbmVlZGVkL3N1cHBvcnRlZCBieSBSZWFjdC4nKSA6IHZvaWQgMDtcbiAgfVxuICAhKHByb3BzLnN0eWxlID09IG51bGwgfHwgdHlwZW9mIHByb3BzLnN0eWxlID09PSAnb2JqZWN0JykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVGhlIGBzdHlsZWAgcHJvcCBleHBlY3RzIGEgbWFwcGluZyBmcm9tIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLCBub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgXFwnZW1cXCd9fSB3aGVuIHVzaW5nIEpTWC4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IF9wcm9kSW52YXJpYW50KCc2MicsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gZW5xdWV1ZVB1dExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyLCB0cmFuc2FjdGlvbikge1xuICBpZiAodHJhbnNhY3Rpb24gaW5zdGFuY2VvZiBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gSUU4IGhhcyBubyBBUEkgZm9yIGV2ZW50IGNhcHR1cmluZyBhbmQgdGhlIGBvblNjcm9sbGAgZXZlbnQgZG9lc24ndFxuICAgIC8vIGJ1YmJsZS5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhyZWdpc3RyYXRpb25OYW1lICE9PSAnb25TY3JvbGwnIHx8IGlzRXZlbnRTdXBwb3J0ZWQoJ3Njcm9sbCcsIHRydWUpLCAnVGhpcyBicm93c2VyIGRvZXNuXFwndCBzdXBwb3J0IHRoZSBgb25TY3JvbGxgIGV2ZW50JykgOiB2b2lkIDA7XG4gIH1cbiAgdmFyIGNvbnRhaW5lckluZm8gPSBpbnN0Ll9ob3N0Q29udGFpbmVySW5mbztcbiAgdmFyIGlzRG9jdW1lbnRGcmFnbWVudCA9IGNvbnRhaW5lckluZm8uX25vZGUgJiYgY29udGFpbmVySW5mby5fbm9kZS5ub2RlVHlwZSA9PT0gRE9DX0ZSQUdNRU5UX1RZUEU7XG4gIHZhciBkb2MgPSBpc0RvY3VtZW50RnJhZ21lbnQgPyBjb250YWluZXJJbmZvLl9ub2RlIDogY29udGFpbmVySW5mby5fb3duZXJEb2N1bWVudDtcbiAgbGlzdGVuVG8ocmVnaXN0cmF0aW9uTmFtZSwgZG9jKTtcbiAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShwdXRMaXN0ZW5lciwge1xuICAgIGluc3Q6IGluc3QsXG4gICAgcmVnaXN0cmF0aW9uTmFtZTogcmVnaXN0cmF0aW9uTmFtZSxcbiAgICBsaXN0ZW5lcjogbGlzdGVuZXJcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHB1dExpc3RlbmVyKCkge1xuICB2YXIgbGlzdGVuZXJUb1B1dCA9IHRoaXM7XG4gIEV2ZW50UGx1Z2luSHViLnB1dExpc3RlbmVyKGxpc3RlbmVyVG9QdXQuaW5zdCwgbGlzdGVuZXJUb1B1dC5yZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lclRvUHV0Lmxpc3RlbmVyKTtcbn1cblxuZnVuY3Rpb24gaW5wdXRQb3N0TW91bnQoKSB7XG4gIHZhciBpbnN0ID0gdGhpcztcbiAgUmVhY3RET01JbnB1dC5wb3N0TW91bnRXcmFwcGVyKGluc3QpO1xufVxuXG5mdW5jdGlvbiB0ZXh0YXJlYVBvc3RNb3VudCgpIHtcbiAgdmFyIGluc3QgPSB0aGlzO1xuICBSZWFjdERPTVRleHRhcmVhLnBvc3RNb3VudFdyYXBwZXIoaW5zdCk7XG59XG5cbmZ1bmN0aW9uIG9wdGlvblBvc3RNb3VudCgpIHtcbiAgdmFyIGluc3QgPSB0aGlzO1xuICBSZWFjdERPTU9wdGlvbi5wb3N0TW91bnRXcmFwcGVyKGluc3QpO1xufVxuXG52YXIgc2V0QW5kVmFsaWRhdGVDb250ZW50Q2hpbGREZXYgPSBlbXB0eUZ1bmN0aW9uO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgc2V0QW5kVmFsaWRhdGVDb250ZW50Q2hpbGREZXYgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgIHZhciBoYXNFeGlzdGluZ0NvbnRlbnQgPSB0aGlzLl9jb250ZW50RGVidWdJRCAhPSBudWxsO1xuICAgIHZhciBkZWJ1Z0lEID0gdGhpcy5fZGVidWdJRDtcbiAgICAvLyBUaGlzIElEIHJlcHJlc2VudHMgdGhlIGlubGluZWQgY2hpbGQgdGhhdCBoYXMgbm8gYmFja2luZyBpbnN0YW5jZTpcbiAgICB2YXIgY29udGVudERlYnVnSUQgPSAtZGVidWdJRDtcblxuICAgIGlmIChjb250ZW50ID09IG51bGwpIHtcbiAgICAgIGlmIChoYXNFeGlzdGluZ0NvbnRlbnQpIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVW5tb3VudENvbXBvbmVudCh0aGlzLl9jb250ZW50RGVidWdJRCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jb250ZW50RGVidWdJRCA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFsaWRhdGVET01OZXN0aW5nKG51bGwsIFN0cmluZyhjb250ZW50KSwgdGhpcywgdGhpcy5fYW5jZXN0b3JJbmZvKTtcbiAgICB0aGlzLl9jb250ZW50RGVidWdJRCA9IGNvbnRlbnREZWJ1Z0lEO1xuICAgIGlmIChoYXNFeGlzdGluZ0NvbnRlbnQpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZm9yZVVwZGF0ZUNvbXBvbmVudChjb250ZW50RGVidWdJRCwgY29udGVudCk7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25VcGRhdGVDb21wb25lbnQoY29udGVudERlYnVnSUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVNb3VudENvbXBvbmVudChjb250ZW50RGVidWdJRCwgY29udGVudCwgZGVidWdJRCk7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Nb3VudENvbXBvbmVudChjb250ZW50RGVidWdJRCk7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRDaGlsZHJlbihkZWJ1Z0lELCBbY29udGVudERlYnVnSURdKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIFRoZXJlIGFyZSBzbyBtYW55IG1lZGlhIGV2ZW50cywgaXQgbWFrZXMgc2Vuc2UgdG8ganVzdFxuLy8gbWFpbnRhaW4gYSBsaXN0IHJhdGhlciB0aGFuIGNyZWF0ZSBhIGB0cmFwQnViYmxlZEV2ZW50YCBmb3IgZWFjaFxudmFyIG1lZGlhRXZlbnRzID0ge1xuICB0b3BBYm9ydDogJ2Fib3J0JyxcbiAgdG9wQ2FuUGxheTogJ2NhbnBsYXknLFxuICB0b3BDYW5QbGF5VGhyb3VnaDogJ2NhbnBsYXl0aHJvdWdoJyxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6ICdkdXJhdGlvbmNoYW5nZScsXG4gIHRvcEVtcHRpZWQ6ICdlbXB0aWVkJyxcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcbiAgdG9wRW5kZWQ6ICdlbmRlZCcsXG4gIHRvcEVycm9yOiAnZXJyb3InLFxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXG4gIHRvcExvYWRlZE1ldGFkYXRhOiAnbG9hZGVkbWV0YWRhdGEnLFxuICB0b3BMb2FkU3RhcnQ6ICdsb2Fkc3RhcnQnLFxuICB0b3BQYXVzZTogJ3BhdXNlJyxcbiAgdG9wUGxheTogJ3BsYXknLFxuICB0b3BQbGF5aW5nOiAncGxheWluZycsXG4gIHRvcFByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICB0b3BSYXRlQ2hhbmdlOiAncmF0ZWNoYW5nZScsXG4gIHRvcFNlZWtlZDogJ3NlZWtlZCcsXG4gIHRvcFNlZWtpbmc6ICdzZWVraW5nJyxcbiAgdG9wU3RhbGxlZDogJ3N0YWxsZWQnLFxuICB0b3BTdXNwZW5kOiAnc3VzcGVuZCcsXG4gIHRvcFRpbWVVcGRhdGU6ICd0aW1ldXBkYXRlJyxcbiAgdG9wVm9sdW1lQ2hhbmdlOiAndm9sdW1lY2hhbmdlJyxcbiAgdG9wV2FpdGluZzogJ3dhaXRpbmcnXG59O1xuXG5mdW5jdGlvbiB0cmFwQnViYmxlZEV2ZW50c0xvY2FsKCkge1xuICB2YXIgaW5zdCA9IHRoaXM7XG4gIC8vIElmIGEgY29tcG9uZW50IHJlbmRlcnMgdG8gbnVsbCBvciBpZiBhbm90aGVyIGNvbXBvbmVudCBmYXRhbHMgYW5kIGNhdXNlc1xuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHRyZWUgdG8gYmUgY29ycnVwdGVkLCBgbm9kZWAgaGVyZSBjYW4gYmUgbnVsbC5cbiAgIWluc3QuX3Jvb3ROb2RlSUQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTXVzdCBiZSBtb3VudGVkIHRvIHRyYXAgZXZlbnRzJykgOiBfcHJvZEludmFyaWFudCgnNjMnKSA6IHZvaWQgMDtcbiAgdmFyIG5vZGUgPSBnZXROb2RlKGluc3QpO1xuICAhbm9kZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0cmFwQnViYmxlZEV2ZW50KC4uLik6IFJlcXVpcmVzIG5vZGUgdG8gYmUgcmVuZGVyZWQuJykgOiBfcHJvZEludmFyaWFudCgnNjQnKSA6IHZvaWQgMDtcblxuICBzd2l0Y2ggKGluc3QuX3RhZykge1xuICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcExvYWQnLCAnbG9hZCcsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICBjYXNlICdhdWRpbyc6XG5cbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbXTtcbiAgICAgIC8vIENyZWF0ZSBsaXN0ZW5lciBmb3IgZWFjaCBtZWRpYSBldmVudFxuICAgICAgZm9yICh2YXIgZXZlbnQgaW4gbWVkaWFFdmVudHMpIHtcbiAgICAgICAgaWYgKG1lZGlhRXZlbnRzLmhhc093blByb3BlcnR5KGV2ZW50KSkge1xuICAgICAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMucHVzaChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChldmVudCwgbWVkaWFFdmVudHNbZXZlbnRdLCBub2RlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KCd0b3BFcnJvcicsICdlcnJvcicsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltZyc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KCd0b3BFcnJvcicsICdlcnJvcicsIG5vZGUpLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wTG9hZCcsICdsb2FkJywgbm9kZSldO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KCd0b3BSZXNldCcsICdyZXNldCcsIG5vZGUpLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wU3VibWl0JywgJ3N1Ym1pdCcsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RVcGRhdGVTZWxlY3RXcmFwcGVyKCkge1xuICBSZWFjdERPTVNlbGVjdC5wb3N0VXBkYXRlV3JhcHBlcih0aGlzKTtcbn1cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSB3aGl0ZWxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsLWNhc2UgdGFncy5cblxudmFyIG9taXR0ZWRDbG9zZVRhZ3MgPSB7XG4gICdhcmVhJzogdHJ1ZSxcbiAgJ2Jhc2UnOiB0cnVlLFxuICAnYnInOiB0cnVlLFxuICAnY29sJzogdHJ1ZSxcbiAgJ2VtYmVkJzogdHJ1ZSxcbiAgJ2hyJzogdHJ1ZSxcbiAgJ2ltZyc6IHRydWUsXG4gICdpbnB1dCc6IHRydWUsXG4gICdrZXlnZW4nOiB0cnVlLFxuICAnbGluayc6IHRydWUsXG4gICdtZXRhJzogdHJ1ZSxcbiAgJ3BhcmFtJzogdHJ1ZSxcbiAgJ3NvdXJjZSc6IHRydWUsXG4gICd0cmFjayc6IHRydWUsXG4gICd3YnInOiB0cnVlXG59O1xuXG52YXIgbmV3bGluZUVhdGluZ1RhZ3MgPSB7XG4gICdsaXN0aW5nJzogdHJ1ZSxcbiAgJ3ByZSc6IHRydWUsXG4gICd0ZXh0YXJlYSc6IHRydWVcbn07XG5cbi8vIEZvciBIVE1MLCBjZXJ0YWluIHRhZ3MgY2Fubm90IGhhdmUgY2hpbGRyZW4uIFRoaXMgaGFzIHRoZSBzYW1lIHB1cnBvc2UgYXNcbi8vIGBvbWl0dGVkQ2xvc2VUYWdzYCBleGNlcHQgdGhhdCBgbWVudWl0ZW1gIHNob3VsZCBzdGlsbCBoYXZlIGl0cyBjbG9zaW5nIHRhZy5cblxudmFyIHZvaWRFbGVtZW50VGFncyA9IF9hc3NpZ24oe1xuICAnbWVudWl0ZW0nOiB0cnVlXG59LCBvbWl0dGVkQ2xvc2VUYWdzKTtcblxuLy8gV2UgYWNjZXB0IGFueSB0YWcgdG8gYmUgcmVuZGVyZWQgYnV0IHNpbmNlIHRoaXMgZ2V0cyBpbmplY3RlZCBpbnRvIGFyYml0cmFyeVxuLy8gSFRNTCwgd2Ugd2FudCB0byBtYWtlIHN1cmUgdGhhdCBpdCdzIGEgc2FmZSB0YWcuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9SRUMteG1sLyNOVC1OYW1lXG5cbnZhciBWQUxJRF9UQUdfUkVHRVggPSAvXlthLXpBLVpdW2EtekEtWjpfXFwuXFwtXFxkXSokLzsgLy8gU2ltcGxpZmllZCBzdWJzZXRcbnZhciB2YWxpZGF0ZWRUYWdDYWNoZSA9IHt9O1xudmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRGFuZ2Vyb3VzVGFnKHRhZykge1xuICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwodmFsaWRhdGVkVGFnQ2FjaGUsIHRhZykpIHtcbiAgICAhVkFMSURfVEFHX1JFR0VYLnRlc3QodGFnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIHRhZzogJXMnLCB0YWcpIDogX3Byb2RJbnZhcmlhbnQoJzY1JywgdGFnKSA6IHZvaWQgMDtcbiAgICB2YWxpZGF0ZWRUYWdDYWNoZVt0YWddID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0N1c3RvbUNvbXBvbmVudCh0YWdOYW1lLCBwcm9wcykge1xuICByZXR1cm4gdGFnTmFtZS5pbmRleE9mKCctJykgPj0gMCB8fCBwcm9wcy5pcyAhPSBudWxsO1xufVxuXG52YXIgZ2xvYmFsSWRDb3VudGVyID0gMTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFJlYWN0IGNsYXNzIHRoYXQgaXMgaWRlbXBvdGVudCBhbmQgY2FwYWJsZSBvZiBjb250YWluaW5nIG90aGVyXG4gKiBSZWFjdCBjb21wb25lbnRzLiBJdCBhY2NlcHRzIGV2ZW50IGxpc3RlbmVycyBhbmQgRE9NIHByb3BlcnRpZXMgdGhhdCBhcmVcbiAqIHZhbGlkIGFjY29yZGluZyB0byBgRE9NUHJvcGVydHlgLlxuICpcbiAqICAtIEV2ZW50IGxpc3RlbmVyczogYG9uQ2xpY2tgLCBgb25Nb3VzZURvd25gLCBldGMuXG4gKiAgLSBET00gcHJvcGVydGllczogYGNsYXNzTmFtZWAsIGBuYW1lYCwgYHRpdGxlYCwgZXRjLlxuICpcbiAqIFRoZSBgc3R5bGVgIHByb3BlcnR5IGZ1bmN0aW9ucyBkaWZmZXJlbnRseSBmcm9tIHRoZSBET00gQVBJLiBJdCBhY2NlcHRzIGFuXG4gKiBvYmplY3QgbWFwcGluZyBvZiBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcy5cbiAqXG4gKiBAY29uc3RydWN0b3IgUmVhY3RET01Db21wb25lbnRcbiAqIEBleHRlbmRzIFJlYWN0TXVsdGlDaGlsZFxuICovXG5mdW5jdGlvbiBSZWFjdERPTUNvbXBvbmVudChlbGVtZW50KSB7XG4gIHZhciB0YWcgPSBlbGVtZW50LnR5cGU7XG4gIHZhbGlkYXRlRGFuZ2Vyb3VzVGFnKHRhZyk7XG4gIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gZWxlbWVudDtcbiAgdGhpcy5fdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIHRoaXMuX25hbWVzcGFjZVVSSSA9IG51bGw7XG4gIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBudWxsO1xuICB0aGlzLl9wcmV2aW91c1N0eWxlID0gbnVsbDtcbiAgdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBudWxsO1xuICB0aGlzLl9ob3N0Tm9kZSA9IG51bGw7XG4gIHRoaXMuX2hvc3RQYXJlbnQgPSBudWxsO1xuICB0aGlzLl9yb290Tm9kZUlEID0gMDtcbiAgdGhpcy5fZG9tSUQgPSAwO1xuICB0aGlzLl9ob3N0Q29udGFpbmVySW5mbyA9IG51bGw7XG4gIHRoaXMuX3dyYXBwZXJTdGF0ZSA9IG51bGw7XG4gIHRoaXMuX3RvcExldmVsV3JhcHBlciA9IG51bGw7XG4gIHRoaXMuX2ZsYWdzID0gMDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB0aGlzLl9hbmNlc3RvckluZm8gPSBudWxsO1xuICAgIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2LmNhbGwodGhpcywgbnVsbCk7XG4gIH1cbn1cblxuUmVhY3RET01Db21wb25lbnQuZGlzcGxheU5hbWUgPSAnUmVhY3RET01Db21wb25lbnQnO1xuXG5SZWFjdERPTUNvbXBvbmVudC5NaXhpbiA9IHtcblxuICAvKipcbiAgICogR2VuZXJhdGVzIHJvb3QgdGFnIG1hcmt1cCB0aGVuIHJlY3Vyc2VzLiBUaGlzIG1ldGhvZCBoYXMgc2lkZSBlZmZlY3RzIGFuZFxuICAgKiBpcyBub3QgaWRlbXBvdGVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9SZWFjdERPTUNvbXBvbmVudH0gdGhlIHBhcmVudCBjb21wb25lbnQgaW5zdGFuY2VcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBpbmZvIGFib3V0IHRoZSBob3N0IGNvbnRhaW5lclxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjb21wdXRlZCBtYXJrdXAuXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCkge1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSBnbG9iYWxJZENvdW50ZXIrKztcbiAgICB0aGlzLl9kb21JRCA9IGhvc3RDb250YWluZXJJbmZvLl9pZENvdW50ZXIrKztcbiAgICB0aGlzLl9ob3N0UGFyZW50ID0gaG9zdFBhcmVudDtcbiAgICB0aGlzLl9ob3N0Q29udGFpbmVySW5mbyA9IGhvc3RDb250YWluZXJJbmZvO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnYXVkaW8nOlxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICBjYXNlICdpZnJhbWUnOlxuICAgICAgY2FzZSAnaW1nJzpcbiAgICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICBjYXNlICd2aWRlbyc6XG4gICAgICAgIHRoaXMuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgICAgICBsaXN0ZW5lcnM6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZSh0cmFwQnViYmxlZEV2ZW50c0xvY2FsLCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgIFJlYWN0RE9NSW5wdXQubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBob3N0UGFyZW50KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTUlucHV0LmdldEhvc3RQcm9wcyh0aGlzLCBwcm9wcyk7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodHJhcEJ1YmJsZWRFdmVudHNMb2NhbCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgUmVhY3RET01PcHRpb24ubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBob3N0UGFyZW50KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXRIb3N0UHJvcHModGhpcywgcHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIFJlYWN0RE9NU2VsZWN0Lm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgaG9zdFBhcmVudCk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01TZWxlY3QuZ2V0SG9zdFByb3BzKHRoaXMsIHByb3BzKTtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZSh0cmFwQnViYmxlZEV2ZW50c0xvY2FsLCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIFJlYWN0RE9NVGV4dGFyZWEubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBob3N0UGFyZW50KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTVRleHRhcmVhLmdldEhvc3RQcm9wcyh0aGlzLCBwcm9wcyk7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodHJhcEJ1YmJsZWRFdmVudHNMb2NhbCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGFzc2VydFZhbGlkUHJvcHModGhpcywgcHJvcHMpO1xuXG4gICAgLy8gV2UgY3JlYXRlIHRhZ3MgaW4gdGhlIG5hbWVzcGFjZSBvZiB0aGVpciBwYXJlbnQgY29udGFpbmVyLCBleGNlcHQgSFRNTFxuICAgIC8vIHRhZ3MgZ2V0IG5vIG5hbWVzcGFjZS5cbiAgICB2YXIgbmFtZXNwYWNlVVJJO1xuICAgIHZhciBwYXJlbnRUYWc7XG4gICAgaWYgKGhvc3RQYXJlbnQgIT0gbnVsbCkge1xuICAgICAgbmFtZXNwYWNlVVJJID0gaG9zdFBhcmVudC5fbmFtZXNwYWNlVVJJO1xuICAgICAgcGFyZW50VGFnID0gaG9zdFBhcmVudC5fdGFnO1xuICAgIH0gZWxzZSBpZiAoaG9zdENvbnRhaW5lckluZm8uX3RhZykge1xuICAgICAgbmFtZXNwYWNlVVJJID0gaG9zdENvbnRhaW5lckluZm8uX25hbWVzcGFjZVVSSTtcbiAgICAgIHBhcmVudFRhZyA9IGhvc3RDb250YWluZXJJbmZvLl90YWc7XG4gICAgfVxuICAgIGlmIChuYW1lc3BhY2VVUkkgPT0gbnVsbCB8fCBuYW1lc3BhY2VVUkkgPT09IERPTU5hbWVzcGFjZXMuc3ZnICYmIHBhcmVudFRhZyA9PT0gJ2ZvcmVpZ25vYmplY3QnKSB7XG4gICAgICBuYW1lc3BhY2VVUkkgPSBET01OYW1lc3BhY2VzLmh0bWw7XG4gICAgfVxuICAgIGlmIChuYW1lc3BhY2VVUkkgPT09IERPTU5hbWVzcGFjZXMuaHRtbCkge1xuICAgICAgaWYgKHRoaXMuX3RhZyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgbmFtZXNwYWNlVVJJID0gRE9NTmFtZXNwYWNlcy5zdmc7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3RhZyA9PT0gJ21hdGgnKSB7XG4gICAgICAgIG5hbWVzcGFjZVVSSSA9IERPTU5hbWVzcGFjZXMubWF0aG1sO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9uYW1lc3BhY2VVUkkgPSBuYW1lc3BhY2VVUkk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHBhcmVudEluZm87XG4gICAgICBpZiAoaG9zdFBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIHBhcmVudEluZm8gPSBob3N0UGFyZW50Ll9hbmNlc3RvckluZm87XG4gICAgICB9IGVsc2UgaWYgKGhvc3RDb250YWluZXJJbmZvLl90YWcpIHtcbiAgICAgICAgcGFyZW50SW5mbyA9IGhvc3RDb250YWluZXJJbmZvLl9hbmNlc3RvckluZm87XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50SW5mbykge1xuICAgICAgICAvLyBwYXJlbnRJbmZvIHNob3VsZCBhbHdheXMgYmUgcHJlc2VudCBleGNlcHQgZm9yIHRoZSB0b3AtbGV2ZWxcbiAgICAgICAgLy8gY29tcG9uZW50IHdoZW4gc2VydmVyIHJlbmRlcmluZ1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmcodGhpcy5fdGFnLCBudWxsLCB0aGlzLCBwYXJlbnRJbmZvKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FuY2VzdG9ySW5mbyA9IHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvKHBhcmVudEluZm8sIHRoaXMuX3RhZywgdGhpcyk7XG4gICAgfVxuXG4gICAgdmFyIG1vdW50SW1hZ2U7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lckRvY3VtZW50ID0gaG9zdENvbnRhaW5lckluZm8uX293bmVyRG9jdW1lbnQ7XG4gICAgICB2YXIgZWw7XG4gICAgICBpZiAobmFtZXNwYWNlVVJJID09PSBET01OYW1lc3BhY2VzLmh0bWwpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RhZyA9PT0gJ3NjcmlwdCcpIHtcbiAgICAgICAgICAvLyBDcmVhdGUgdGhlIHNjcmlwdCB2aWEgLmlubmVySFRNTCBzbyBpdHMgXCJwYXJzZXItaW5zZXJ0ZWRcIiBmbGFnIGlzXG4gICAgICAgICAgLy8gc2V0IHRvIHRydWUgYW5kIGl0IGRvZXMgbm90IGV4ZWN1dGVcbiAgICAgICAgICB2YXIgZGl2ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgICAgICAgZGl2LmlubmVySFRNTCA9ICc8JyArIHR5cGUgKyAnPjwvJyArIHR5cGUgKyAnPic7XG4gICAgICAgICAgZWwgPSBkaXYucmVtb3ZlQ2hpbGQoZGl2LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BzLmlzKSB7XG4gICAgICAgICAgZWwgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSwgcHJvcHMuaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFNlcGFyYXRlIGVsc2UgYnJhbmNoIGluc3RlYWQgb2YgdXNpbmcgYHByb3BzLmlzIHx8IHVuZGVmaW5lZGAgYWJvdmUgYmVjdWFzZSBvZiBhIEZpcmVmb3ggYnVnLlxuICAgICAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzY4OTZcbiAgICAgICAgICAvLyBhbmQgZGlzY3Vzc2lvbiBpbiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjc2MjQwXG4gICAgICAgICAgZWwgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlKTtcbiAgICAgIH1cbiAgICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5wcmVjYWNoZU5vZGUodGhpcywgZWwpO1xuICAgICAgdGhpcy5fZmxhZ3MgfD0gRmxhZ3MuaGFzQ2FjaGVkQ2hpbGROb2RlcztcbiAgICAgIGlmICghdGhpcy5faG9zdFBhcmVudCkge1xuICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0QXR0cmlidXRlRm9yUm9vdChlbCk7XG4gICAgICB9XG4gICAgICB0aGlzLl91cGRhdGVET01Qcm9wZXJ0aWVzKG51bGwsIHByb3BzLCB0cmFuc2FjdGlvbik7XG4gICAgICB2YXIgbGF6eVRyZWUgPSBET01MYXp5VHJlZShlbCk7XG4gICAgICB0aGlzLl9jcmVhdGVJbml0aWFsQ2hpbGRyZW4odHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0LCBsYXp5VHJlZSk7XG4gICAgICBtb3VudEltYWdlID0gbGF6eVRyZWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0YWdPcGVuID0gdGhpcy5fY3JlYXRlT3BlblRhZ01hcmt1cEFuZFB1dExpc3RlbmVycyh0cmFuc2FjdGlvbiwgcHJvcHMpO1xuICAgICAgdmFyIHRhZ0NvbnRlbnQgPSB0aGlzLl9jcmVhdGVDb250ZW50TWFya3VwKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCk7XG4gICAgICBpZiAoIXRhZ0NvbnRlbnQgJiYgb21pdHRlZENsb3NlVGFnc1t0aGlzLl90YWddKSB7XG4gICAgICAgIG1vdW50SW1hZ2UgPSB0YWdPcGVuICsgJy8+JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vdW50SW1hZ2UgPSB0YWdPcGVuICsgJz4nICsgdGFnQ29udGVudCArICc8LycgKyB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlICsgJz4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoaW5wdXRQb3N0TW91bnQsIHRoaXMpO1xuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodGV4dGFyZWFQb3N0TW91bnQsIHRoaXMpO1xuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKG9wdGlvblBvc3RNb3VudCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBtb3VudEltYWdlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgdGhlIG9wZW4gdGFnIGFuZCBhbGwgYXR0cmlidXRlcy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaGFzIHNpZGUgZWZmZWN0cyBiZWNhdXNlIGV2ZW50cyBnZXQgcmVnaXN0ZXJlZC5cbiAgICpcbiAgICogSXRlcmF0aW5nIG92ZXIgb2JqZWN0IHByb3BlcnRpZXMgaXMgZmFzdGVyIHRoYW4gaXRlcmF0aW5nIG92ZXIgYXJyYXlzLlxuICAgKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL29iai12cy1hcnItaXRlcmF0aW9uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgb2Ygb3BlbmluZyB0YWcuXG4gICAqL1xuICBfY3JlYXRlT3BlblRhZ01hcmt1cEFuZFB1dExpc3RlbmVyczogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcm9wcykge1xuICAgIHZhciByZXQgPSAnPCcgKyB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuXG4gICAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBpZiAocHJvcFZhbHVlKSB7XG4gICAgICAgICAgZW5xdWV1ZVB1dExpc3RlbmVyKHRoaXMsIHByb3BLZXksIHByb3BWYWx1ZSwgdHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgICBpZiAocHJvcFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAvLyBTZWUgYF91cGRhdGVET01Qcm9wZXJ0aWVzYC4gc3R5bGUgYmxvY2tcbiAgICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3BWYWx1ZSA9IHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gX2Fzc2lnbih7fSwgcHJvcHMuc3R5bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcm9wVmFsdWUgPSBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9yU3R5bGVzKHByb3BWYWx1ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hcmt1cCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl90YWcgIT0gbnVsbCAmJiBpc0N1c3RvbUNvbXBvbmVudCh0aGlzLl90YWcsIHByb3BzKSkge1xuICAgICAgICAgIGlmICghUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgICAgIG1hcmt1cCA9IERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JDdXN0b21BdHRyaWJ1dGUocHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFya3VwID0gRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclByb3BlcnR5KHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmt1cCkge1xuICAgICAgICAgIHJldCArPSAnICcgKyBtYXJrdXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGb3Igc3RhdGljIHBhZ2VzLCBubyBuZWVkIHRvIHB1dCBSZWFjdCBJRCBhbmQgY2hlY2tzdW0uIFNhdmVzIGxvdHMgb2ZcbiAgICAvLyBieXRlcy5cbiAgICBpZiAodHJhbnNhY3Rpb24ucmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9ob3N0UGFyZW50KSB7XG4gICAgICByZXQgKz0gJyAnICsgRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclJvb3QoKTtcbiAgICB9XG4gICAgcmV0ICs9ICcgJyArIERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JJRCh0aGlzLl9kb21JRCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIHRoZSBjb250ZW50IGJldHdlZW4gdGhlIHRhZ3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7c3RyaW5nfSBDb250ZW50IG1hcmt1cC5cbiAgICovXG4gIF9jcmVhdGVDb250ZW50TWFya3VwOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIHJldCA9ICcnO1xuXG4gICAgLy8gSW50ZW50aW9uYWwgdXNlIG9mICE9IHRvIGF2b2lkIGNhdGNoaW5nIHplcm8vZmFsc2UuXG4gICAgdmFyIGlubmVySFRNTCA9IHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MO1xuICAgIGlmIChpbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICAgaWYgKGlubmVySFRNTC5fX2h0bWwgIT0gbnVsbCkge1xuICAgICAgICByZXQgPSBpbm5lckhUTUwuX19odG1sO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29udGVudFRvVXNlID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgcHJvcHMuY2hpbGRyZW5dID8gcHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuICAgICAgdmFyIGNoaWxkcmVuVG9Vc2UgPSBjb250ZW50VG9Vc2UgIT0gbnVsbCA/IG51bGwgOiBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIGlmIChjb250ZW50VG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBWYWxpZGF0ZSB0aGF0IHRleHQgaXMgYWxsb3dlZCBhcyBhIGNoaWxkIG9mIHRoaXMgbm9kZVxuICAgICAgICByZXQgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIoY29udGVudFRvVXNlKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldi5jYWxsKHRoaXMsIGNvbnRlbnRUb1VzZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5Ub1VzZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBtb3VudEltYWdlcyA9IHRoaXMubW91bnRDaGlsZHJlbihjaGlsZHJlblRvVXNlLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIHJldCA9IG1vdW50SW1hZ2VzLmpvaW4oJycpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV3bGluZUVhdGluZ1RhZ3NbdGhpcy5fdGFnXSAmJiByZXQuY2hhckF0KDApID09PSAnXFxuJykge1xuICAgICAgLy8gdGV4dC9odG1sIGlnbm9yZXMgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGVzZSB0YWdzIGlmIGl0J3MgYSBuZXdsaW5lXG4gICAgICAvLyBQcmVmZXIgdG8gYnJlYWsgYXBwbGljYXRpb24veG1sIG92ZXIgdGV4dC9odG1sIChmb3Igbm93KSBieSBhZGRpbmdcbiAgICAgIC8vIGEgbmV3bGluZSBzcGVjaWZpY2FsbHkgdG8gZ2V0IGVhdGVuIGJ5IHRoZSBwYXJzZXIuIChBbHRlcm5hdGVseSBmb3JcbiAgICAgIC8vIHRleHRhcmVhcywgcmVwbGFjaW5nIFwiXlxcblwiIHdpdGggXCJcXHJcXG5cIiBkb2Vzbid0IGdldCBlYXRlbiwgYW5kIHRoZSBmaXJzdFxuICAgICAgLy8gXFxyIGlzIG5vcm1hbGl6ZWQgb3V0IGJ5IEhUTUxUZXh0QXJlYUVsZW1lbnQjdmFsdWUuKVxuICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbC1wb2x5Z2xvdC8jbmV3bGluZXMtaW4tdGV4dGFyZWEtYW5kLXByZT5cbiAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI2VsZW1lbnQtcmVzdHJpY3Rpb25zPlxuICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjbmV3bGluZXM+XG4gICAgICAvLyBTZWU6IFBhcnNpbmcgb2YgXCJ0ZXh0YXJlYVwiIFwibGlzdGluZ1wiIGFuZCBcInByZVwiIGVsZW1lbnRzXG4gICAgICAvLyAgZnJvbSA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keT5cbiAgICAgIHJldHVybiAnXFxuJyArIHJldDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sXG5cbiAgX2NyZWF0ZUluaXRpYWxDaGlsZHJlbjogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCwgbGF6eVRyZWUpIHtcbiAgICAvLyBJbnRlbnRpb25hbCB1c2Ugb2YgIT0gdG8gYXZvaWQgY2F0Y2hpbmcgemVyby9mYWxzZS5cbiAgICB2YXIgaW5uZXJIVE1MID0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG4gICAgaWYgKGlubmVySFRNTCAhPSBudWxsKSB7XG4gICAgICBpZiAoaW5uZXJIVE1MLl9faHRtbCAhPSBudWxsKSB7XG4gICAgICAgIERPTUxhenlUcmVlLnF1ZXVlSFRNTChsYXp5VHJlZSwgaW5uZXJIVE1MLl9faHRtbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250ZW50VG9Vc2UgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBwcm9wcy5jaGlsZHJlbl0gPyBwcm9wcy5jaGlsZHJlbiA6IG51bGw7XG4gICAgICB2YXIgY2hpbGRyZW5Ub1VzZSA9IGNvbnRlbnRUb1VzZSAhPSBudWxsID8gbnVsbCA6IHByb3BzLmNoaWxkcmVuO1xuICAgICAgaWYgKGNvbnRlbnRUb1VzZSAhPSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFZhbGlkYXRlIHRoYXQgdGV4dCBpcyBhbGxvd2VkIGFzIGEgY2hpbGQgb2YgdGhpcyBub2RlXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgc2V0QW5kVmFsaWRhdGVDb250ZW50Q2hpbGREZXYuY2FsbCh0aGlzLCBjb250ZW50VG9Vc2UpO1xuICAgICAgICB9XG4gICAgICAgIERPTUxhenlUcmVlLnF1ZXVlVGV4dChsYXp5VHJlZSwgY29udGVudFRvVXNlKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5Ub1VzZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBtb3VudEltYWdlcyA9IHRoaXMubW91bnRDaGlsZHJlbihjaGlsZHJlblRvVXNlLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW91bnRJbWFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBET01MYXp5VHJlZS5xdWV1ZUNoaWxkKGxhenlUcmVlLCBtb3VudEltYWdlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlY2VpdmVzIGEgbmV4dCBlbGVtZW50IGFuZCB1cGRhdGVzIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnRcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqL1xuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHByZXZFbGVtZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQ7XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0RWxlbWVudDtcbiAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudCh0cmFuc2FjdGlvbiwgcHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBjb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyBhIERPTSBjb21wb25lbnQgYWZ0ZXIgaXQgaGFzIGFscmVhZHkgYmVlbiBhbGxvY2F0ZWQgYW5kXG4gICAqIGF0dGFjaGVkIHRvIHRoZSBET00uIFJlY29uY2lsZXMgdGhlIHJvb3QgRE9NIG5vZGUsIHRoZW4gcmVjdXJzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IHByZXZFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAaW50ZXJuYWxcbiAgICogQG92ZXJyaWRhYmxlXG4gICAqL1xuICB1cGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBjb250ZXh0KSB7XG4gICAgdmFyIGxhc3RQcm9wcyA9IHByZXZFbGVtZW50LnByb3BzO1xuICAgIHZhciBuZXh0UHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NSW5wdXQuZ2V0SG9zdFByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NSW5wdXQuZ2V0SG9zdFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgbGFzdFByb3BzID0gUmVhY3RET01PcHRpb24uZ2V0SG9zdFByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NT3B0aW9uLmdldEhvc3RQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NU2VsZWN0LmdldEhvc3RQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTVNlbGVjdC5nZXRIb3N0UHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NVGV4dGFyZWEuZ2V0SG9zdFByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NVGV4dGFyZWEuZ2V0SG9zdFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGFzc2VydFZhbGlkUHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICB0aGlzLl91cGRhdGVET01Qcm9wZXJ0aWVzKGxhc3RQcm9wcywgbmV4dFByb3BzLCB0cmFuc2FjdGlvbik7XG4gICAgdGhpcy5fdXBkYXRlRE9NQ2hpbGRyZW4obGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcblxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgd3JhcHBlciBhcm91bmQgaW5wdXRzICphZnRlciogdXBkYXRpbmcgcHJvcHMuIFRoaXMgaGFzIHRvXG4gICAgICAgIC8vIGhhcHBlbiBhZnRlciBgX3VwZGF0ZURPTVByb3BlcnRpZXNgLiBPdGhlcndpc2UgSFRNTDUgaW5wdXQgdmFsaWRhdGlvbnNcbiAgICAgICAgLy8gcmFpc2Ugd2FybmluZ3MgYW5kIHByZXZlbnQgdGhlIG5ldyB2YWx1ZSBmcm9tIGJlaW5nIGFzc2lnbmVkLlxuICAgICAgICBSZWFjdERPTUlucHV0LnVwZGF0ZVdyYXBwZXIodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICBSZWFjdERPTVRleHRhcmVhLnVwZGF0ZVdyYXBwZXIodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgLy8gPHNlbGVjdD4gdmFsdWUgdXBkYXRlIG5lZWRzIHRvIG9jY3VyIGFmdGVyIDxvcHRpb24+IGNoaWxkcmVuXG4gICAgICAgIC8vIHJlY29uY2lsaWF0aW9uXG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUocG9zdFVwZGF0ZVNlbGVjdFdyYXBwZXIsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlY29uY2lsZXMgdGhlIHByb3BlcnRpZXMgYnkgZGV0ZWN0aW5nIGRpZmZlcmVuY2VzIGluIHByb3BlcnR5IHZhbHVlcyBhbmRcbiAgICogdXBkYXRpbmcgdGhlIERPTSBhcyBuZWNlc3NhcnkuIFRoaXMgZnVuY3Rpb24gaXMgcHJvYmFibHkgdGhlIHNpbmdsZSBtb3N0XG4gICAqIGNyaXRpY2FsIHBhdGggZm9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbi5cbiAgICpcbiAgICogVE9ETzogQmVuY2htYXJrIHdoZXRoZXIgY2hlY2tpbmcgZm9yIGNoYW5nZWQgdmFsdWVzIGluIG1lbW9yeSBhY3R1YWxseVxuICAgKiAgICAgICBpbXByb3ZlcyBwZXJmb3JtYW5jZSAoZXNwZWNpYWxseSBzdGF0aWNhbGx5IHBvc2l0aW9uZWQgZWxlbWVudHMpLlxuICAgKiBUT0RPOiBCZW5jaG1hcmsgdGhlIGVmZmVjdHMgb2YgcHV0dGluZyB0aGlzIGF0IHRoZSB0b3Agc2luY2UgOTklIG9mIHByb3BzXG4gICAqICAgICAgIGRvIG5vdCBjaGFuZ2UgZm9yIGEgZ2l2ZW4gcmVjb25jaWxpYXRpb24uXG4gICAqIFRPRE86IEJlbmNobWFyayBhcmVhcyB0aGF0IGNhbiBiZSBpbXByb3ZlZCB3aXRoIGNhY2hpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBsYXN0UHJvcHNcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlXG4gICAqL1xuICBfdXBkYXRlRE9NUHJvcGVydGllczogZnVuY3Rpb24gKGxhc3RQcm9wcywgbmV4dFByb3BzLCB0cmFuc2FjdGlvbikge1xuICAgIHZhciBwcm9wS2V5O1xuICAgIHZhciBzdHlsZU5hbWU7XG4gICAgdmFyIHN0eWxlVXBkYXRlcztcbiAgICBmb3IgKHByb3BLZXkgaW4gbGFzdFByb3BzKSB7XG4gICAgICBpZiAobmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8ICFsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbGFzdFByb3BzW3Byb3BLZXldID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgdmFyIGxhc3RTdHlsZSA9IHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5O1xuICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0U3R5bGUpIHtcbiAgICAgICAgICBpZiAobGFzdFN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHN0eWxlVXBkYXRlcyB8fCB7fTtcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgaWYgKGxhc3RQcm9wc1twcm9wS2V5XSkge1xuICAgICAgICAgIC8vIE9ubHkgY2FsbCBkZWxldGVMaXN0ZW5lciBpZiB0aGVyZSB3YXMgYSBsaXN0ZW5lciBwcmV2aW91c2x5IG9yXG4gICAgICAgICAgLy8gZWxzZSB3aWxsRGVsZXRlTGlzdGVuZXIgZ2V0cyBjYWxsZWQgd2hlbiB0aGVyZSB3YXNuJ3QgYWN0dWFsbHkgYVxuICAgICAgICAgIC8vIGxpc3RlbmVyIChlLmcuLCBvbkNsaWNrPXtudWxsfSlcbiAgICAgICAgICBkZWxldGVMaXN0ZW5lcih0aGlzLCBwcm9wS2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0aGlzLl90YWcsIGxhc3RQcm9wcykpIHtcbiAgICAgICAgaWYgKCFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5kZWxldGVWYWx1ZUZvckF0dHJpYnV0ZShnZXROb2RlKHRoaXMpLCBwcm9wS2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW3Byb3BLZXldIHx8IERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKHByb3BLZXkpKSB7XG4gICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5kZWxldGVWYWx1ZUZvclByb3BlcnR5KGdldE5vZGUodGhpcyksIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHByb3BLZXkgaW4gbmV4dFByb3BzKSB7XG4gICAgICB2YXIgbmV4dFByb3AgPSBuZXh0UHJvcHNbcHJvcEtleV07XG4gICAgICB2YXIgbGFzdFByb3AgPSBwcm9wS2V5ID09PSBTVFlMRSA/IHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5IDogbGFzdFByb3BzICE9IG51bGwgPyBsYXN0UHJvcHNbcHJvcEtleV0gOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBuZXh0UHJvcCA9PT0gbGFzdFByb3AgfHwgbmV4dFByb3AgPT0gbnVsbCAmJiBsYXN0UHJvcCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBjaGVja0FuZFdhcm5Gb3JNdXRhdGVkU3R5bGUodGhpcy5fcHJldmlvdXNTdHlsZUNvcHksIHRoaXMuX3ByZXZpb3VzU3R5bGUsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZSA9IG5leHRQcm9wO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0UHJvcCA9IHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gX2Fzc2lnbih7fSwgbmV4dFByb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdFByb3ApIHtcbiAgICAgICAgICAvLyBVbnNldCBzdHlsZXMgb24gYGxhc3RQcm9wYCBidXQgbm90IG9uIGBuZXh0UHJvcGAuXG4gICAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFByb3ApIHtcbiAgICAgICAgICAgIGlmIChsYXN0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmICghbmV4dFByb3AgfHwgIW5leHRQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHN0eWxlVXBkYXRlcyB8fCB7fTtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVXBkYXRlIHN0eWxlcyB0aGF0IGNoYW5nZWQgc2luY2UgYGxhc3RQcm9wYC5cbiAgICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBuZXh0UHJvcCkge1xuICAgICAgICAgICAgaWYgKG5leHRQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgbGFzdFByb3Bbc3R5bGVOYW1lXSAhPT0gbmV4dFByb3Bbc3R5bGVOYW1lXSkge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBzdHlsZVVwZGF0ZXMgfHwge307XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gbmV4dFByb3Bbc3R5bGVOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVsaWVzIG9uIGB1cGRhdGVTdHlsZXNCeUlEYCBub3QgbXV0YXRpbmcgYHN0eWxlVXBkYXRlc2AuXG4gICAgICAgICAgc3R5bGVVcGRhdGVzID0gbmV4dFByb3A7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgZW5xdWV1ZVB1dExpc3RlbmVyKHRoaXMsIHByb3BLZXksIG5leHRQcm9wLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdFByb3ApIHtcbiAgICAgICAgICBkZWxldGVMaXN0ZW5lcih0aGlzLCBwcm9wS2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0aGlzLl90YWcsIG5leHRQcm9wcykpIHtcbiAgICAgICAgaWYgKCFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvckF0dHJpYnV0ZShnZXROb2RlKHRoaXMpLCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkucHJvcGVydGllc1twcm9wS2V5XSB8fCBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShwcm9wS2V5KSkge1xuICAgICAgICB2YXIgbm9kZSA9IGdldE5vZGUodGhpcyk7XG4gICAgICAgIC8vIElmIHdlJ3JlIHVwZGF0aW5nIHRvIG51bGwgb3IgdW5kZWZpbmVkLCB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBwcm9wZXJ0eVxuICAgICAgICAvLyBmcm9tIHRoZSBET00gbm9kZSBpbnN0ZWFkIG9mIGluYWR2ZXJ0ZW50bHkgc2V0dGluZyB0byBhIHN0cmluZy4gVGhpc1xuICAgICAgICAvLyBicmluZ3MgdXMgaW4gbGluZSB3aXRoIHRoZSBzYW1lIGJlaGF2aW9yIHdlIGhhdmUgb24gaW5pdGlhbCByZW5kZXIuXG4gICAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5kZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIHByb3BLZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdHlsZVVwZGF0ZXMpIHtcbiAgICAgIENTU1Byb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvclN0eWxlcyhnZXROb2RlKHRoaXMpLCBzdHlsZVVwZGF0ZXMsIHRoaXMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVjb25jaWxlcyB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgdmFyaW91cyBwcm9wZXJ0aWVzIHRoYXQgYWZmZWN0IHRoZVxuICAgKiBjaGlsZHJlbiBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbGFzdFByb3BzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKi9cbiAgX3VwZGF0ZURPTUNoaWxkcmVuOiBmdW5jdGlvbiAobGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIGxhc3RDb250ZW50ID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgbGFzdFByb3BzLmNoaWxkcmVuXSA/IGxhc3RQcm9wcy5jaGlsZHJlbiA6IG51bGw7XG4gICAgdmFyIG5leHRDb250ZW50ID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgbmV4dFByb3BzLmNoaWxkcmVuXSA/IG5leHRQcm9wcy5jaGlsZHJlbiA6IG51bGw7XG5cbiAgICB2YXIgbGFzdEh0bWwgPSBsYXN0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgJiYgbGFzdFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbDtcbiAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgJiYgbmV4dFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbDtcblxuICAgIC8vIE5vdGUgdGhlIHVzZSBvZiBgIT1gIHdoaWNoIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWQuXG4gICAgdmFyIGxhc3RDaGlsZHJlbiA9IGxhc3RDb250ZW50ICE9IG51bGwgPyBudWxsIDogbGFzdFByb3BzLmNoaWxkcmVuO1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0Q29udGVudCAhPSBudWxsID8gbnVsbCA6IG5leHRQcm9wcy5jaGlsZHJlbjtcblxuICAgIC8vIElmIHdlJ3JlIHN3aXRjaGluZyBmcm9tIGNoaWxkcmVuIHRvIGNvbnRlbnQvaHRtbCBvciB2aWNlIHZlcnNhLCByZW1vdmVcbiAgICAvLyB0aGUgb2xkIGNvbnRlbnRcbiAgICB2YXIgbGFzdEhhc0NvbnRlbnRPckh0bWwgPSBsYXN0Q29udGVudCAhPSBudWxsIHx8IGxhc3RIdG1sICE9IG51bGw7XG4gICAgdmFyIG5leHRIYXNDb250ZW50T3JIdG1sID0gbmV4dENvbnRlbnQgIT0gbnVsbCB8fCBuZXh0SHRtbCAhPSBudWxsO1xuICAgIGlmIChsYXN0Q2hpbGRyZW4gIT0gbnVsbCAmJiBuZXh0Q2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgdGhpcy51cGRhdGVDaGlsZHJlbihudWxsLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChsYXN0SGFzQ29udGVudE9ySHRtbCAmJiAhbmV4dEhhc0NvbnRlbnRPckh0bWwpIHtcbiAgICAgIHRoaXMudXBkYXRlVGV4dENvbnRlbnQoJycpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4odGhpcy5fZGVidWdJRCwgW10pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZXh0Q29udGVudCAhPSBudWxsKSB7XG4gICAgICBpZiAobGFzdENvbnRlbnQgIT09IG5leHRDb250ZW50KSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGV4dENvbnRlbnQoJycgKyBuZXh0Q29udGVudCk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgc2V0QW5kVmFsaWRhdGVDb250ZW50Q2hpbGREZXYuY2FsbCh0aGlzLCBuZXh0Q29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgIGlmIChsYXN0SHRtbCAhPT0gbmV4dEh0bWwpIHtcbiAgICAgICAgdGhpcy51cGRhdGVNYXJrdXAoJycgKyBuZXh0SHRtbCk7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRDaGlsZHJlbih0aGlzLl9kZWJ1Z0lELCBbXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0Q2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgc2V0QW5kVmFsaWRhdGVDb250ZW50Q2hpbGREZXYuY2FsbCh0aGlzLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVDaGlsZHJlbihuZXh0Q2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0SG9zdE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0Tm9kZSh0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICogRGVzdHJveXMgYWxsIGV2ZW50IHJlZ2lzdHJhdGlvbnMgZm9yIHRoaXMgaW5zdGFuY2UuIERvZXMgbm90IHJlbW92ZSBmcm9tXG4gICAqIHRoZSBET00uIFRoYXQgbXVzdCBiZSBkb25lIGJ5IHRoZSBwYXJlbnQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHNhZmVseSkge1xuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdhdWRpbyc6XG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgICBjYXNlICdpbWcnOlxuICAgICAgY2FzZSAnbGluayc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnM7XG4gICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGlzdGVuZXJzW2ldLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICBjYXNlICdib2R5JzpcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBvbmVudHMgbGlrZSA8aHRtbD4gPGhlYWQ+IGFuZCA8Ym9keT4gY2FuJ3QgYmUgcmVtb3ZlZCBvciBhZGRlZFxuICAgICAgICAgKiBlYXNpbHkgaW4gYSBjcm9zcy1icm93c2VyIHdheSwgaG93ZXZlciBpdCdzIHZhbHVhYmxlIHRvIGJlIGFibGUgdG9cbiAgICAgICAgICogdGFrZSBhZHZhbnRhZ2Ugb2YgUmVhY3QncyByZWNvbmNpbGlhdGlvbiBmb3Igc3R5bGluZyBhbmQgPHRpdGxlPlxuICAgICAgICAgKiBtYW5hZ2VtZW50LiBTbyB3ZSBqdXN0IGRvY3VtZW50IGl0IGFuZCB0aHJvdyBpbiBkYW5nZXJvdXMgY2FzZXMuXG4gICAgICAgICAqL1xuICAgICAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnPCVzPiB0cmllZCB0byB1bm1vdW50LiBCZWNhdXNlIG9mIGNyb3NzLWJyb3dzZXIgcXVpcmtzIGl0IGlzIGltcG9zc2libGUgdG8gdW5tb3VudCBzb21lIHRvcC1sZXZlbCBjb21wb25lbnRzIChlZyA8aHRtbD4sIDxoZWFkPiwgYW5kIDxib2R5PikgcmVsaWFibHkgYW5kIGVmZmljaWVudGx5LiBUbyBmaXggdGhpcywgaGF2ZSBhIHNpbmdsZSB0b3AtbGV2ZWwgY29tcG9uZW50IHRoYXQgbmV2ZXIgdW5tb3VudHMgcmVuZGVyIHRoZXNlIGVsZW1lbnRzLicsIHRoaXMuX3RhZykgOiBfcHJvZEludmFyaWFudCgnNjYnLCB0aGlzLl90YWcpIDogdm9pZCAwO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLnVubW91bnRDaGlsZHJlbihzYWZlbHkpO1xuICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS51bmNhY2hlTm9kZSh0aGlzKTtcbiAgICBFdmVudFBsdWdpbkh1Yi5kZWxldGVBbGxMaXN0ZW5lcnModGhpcyk7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IDA7XG4gICAgdGhpcy5fZG9tSUQgPSAwO1xuICAgIHRoaXMuX3dyYXBwZXJTdGF0ZSA9IG51bGw7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgc2V0QW5kVmFsaWRhdGVDb250ZW50Q2hpbGREZXYuY2FsbCh0aGlzLCBudWxsKTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0UHVibGljSW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0Tm9kZSh0aGlzKTtcbiAgfVxuXG59O1xuXG5fYXNzaWduKFJlYWN0RE9NQ29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RET01Db21wb25lbnQuTWl4aW4sIFJlYWN0TXVsdGlDaGlsZC5NaXhpbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01Db21wb25lbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01Db21wb25lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDExM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gcmVxdWlyZSgnLi92YWxpZGF0ZURPTU5lc3RpbmcnKTtcblxudmFyIERPQ19OT0RFX1RZUEUgPSA5O1xuXG5mdW5jdGlvbiBSZWFjdERPTUNvbnRhaW5lckluZm8odG9wTGV2ZWxXcmFwcGVyLCBub2RlKSB7XG4gIHZhciBpbmZvID0ge1xuICAgIF90b3BMZXZlbFdyYXBwZXI6IHRvcExldmVsV3JhcHBlcixcbiAgICBfaWRDb3VudGVyOiAxLFxuICAgIF9vd25lckRvY3VtZW50OiBub2RlID8gbm9kZS5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSA/IG5vZGUgOiBub2RlLm93bmVyRG9jdW1lbnQgOiBudWxsLFxuICAgIF9ub2RlOiBub2RlLFxuICAgIF90YWc6IG5vZGUgPyBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgOiBudWxsLFxuICAgIF9uYW1lc3BhY2VVUkk6IG5vZGUgPyBub2RlLm5hbWVzcGFjZVVSSSA6IG51bGxcbiAgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpbmZvLl9hbmNlc3RvckluZm8gPSBub2RlID8gdmFsaWRhdGVET01OZXN0aW5nLnVwZGF0ZWRBbmNlc3RvckluZm8obnVsbCwgaW5mby5fdGFnLCBudWxsKSA6IG51bGw7XG4gIH1cbiAgcmV0dXJuIGluZm87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01Db250YWluZXJJbmZvO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NQ29udGFpbmVySW5mby5qc1xuLy8gbW9kdWxlIGlkID0gMTE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcblxudmFyIFJlYWN0RE9NRW1wdHlDb21wb25lbnQgPSBmdW5jdGlvbiAoaW5zdGFudGlhdGUpIHtcbiAgLy8gUmVhY3RDb21wb3NpdGVDb21wb25lbnQgdXNlcyB0aGlzOlxuICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG51bGw7XG4gIC8vIFJlYWN0RE9NQ29tcG9uZW50VHJlZSB1c2VzIHRoZXNlOlxuICB0aGlzLl9ob3N0Tm9kZSA9IG51bGw7XG4gIHRoaXMuX2hvc3RQYXJlbnQgPSBudWxsO1xuICB0aGlzLl9ob3N0Q29udGFpbmVySW5mbyA9IG51bGw7XG4gIHRoaXMuX2RvbUlEID0gMDtcbn07XG5fYXNzaWduKFJlYWN0RE9NRW1wdHlDb21wb25lbnQucHJvdG90eXBlLCB7XG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0KSB7XG4gICAgdmFyIGRvbUlEID0gaG9zdENvbnRhaW5lckluZm8uX2lkQ291bnRlcisrO1xuICAgIHRoaXMuX2RvbUlEID0gZG9tSUQ7XG4gICAgdGhpcy5faG9zdFBhcmVudCA9IGhvc3RQYXJlbnQ7XG4gICAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBob3N0Q29udGFpbmVySW5mbztcblxuICAgIHZhciBub2RlVmFsdWUgPSAnIHJlYWN0LWVtcHR5OiAnICsgdGhpcy5fZG9tSUQgKyAnICc7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lckRvY3VtZW50ID0gaG9zdENvbnRhaW5lckluZm8uX293bmVyRG9jdW1lbnQ7XG4gICAgICB2YXIgbm9kZSA9IG93bmVyRG9jdW1lbnQuY3JlYXRlQ29tbWVudChub2RlVmFsdWUpO1xuICAgICAgUmVhY3RET01Db21wb25lbnRUcmVlLnByZWNhY2hlTm9kZSh0aGlzLCBub2RlKTtcbiAgICAgIHJldHVybiBET01MYXp5VHJlZShub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRyYW5zYWN0aW9uLnJlbmRlclRvU3RhdGljTWFya3VwKSB7XG4gICAgICAgIC8vIE5vcm1hbGx5IHdlJ2QgaW5zZXJ0IGEgY29tbWVudCBub2RlLCBidXQgc2luY2UgdGhpcyBpcyBhIHNpdHVhdGlvblxuICAgICAgICAvLyB3aGVyZSBSZWFjdCB3b24ndCB0YWtlIG92ZXIgKHN0YXRpYyBwYWdlcyksIHdlIGNhbiBzaW1wbHkgcmV0dXJuXG4gICAgICAgIC8vIG5vdGhpbmcuXG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnPCEtLScgKyBub2RlVmFsdWUgKyAnLS0+JztcbiAgICB9XG4gIH0sXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHt9LFxuICBnZXRIb3N0Tm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0aGlzKTtcbiAgfSxcbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS51bmNhY2hlTm9kZSh0aGlzKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01FbXB0eUNvbXBvbmVudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTUVtcHR5Q29tcG9uZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NRmVhdHVyZUZsYWdzID0ge1xuICB1c2VDcmVhdGVFbGVtZW50OiB0cnVlLFxuICB1c2VGaWJlcjogZmFsc2Vcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01GZWF0dXJlRmxhZ3M7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01GZWF0dXJlRmxhZ3MuanNcbi8vIG1vZHVsZSBpZCA9IDExNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01DaGlsZHJlbk9wZXJhdGlvbnMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xuXG4vKipcbiAqIE9wZXJhdGlvbnMgdXNlZCB0byBwcm9jZXNzIHVwZGF0ZXMgdG8gRE9NIG5vZGVzLlxuICovXG52YXIgUmVhY3RET01JRE9wZXJhdGlvbnMgPSB7XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBjb21wb25lbnQncyBjaGlsZHJlbiBieSBwcm9jZXNzaW5nIGEgc2VyaWVzIG9mIHVwZGF0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXk8b2JqZWN0Pn0gdXBkYXRlcyBMaXN0IG9mIHVwZGF0ZSBjb25maWd1cmF0aW9ucy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBkYW5nZXJvdXNseVByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IGZ1bmN0aW9uIChwYXJlbnRJbnN0LCB1cGRhdGVzKSB7XG4gICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShwYXJlbnRJbnN0KTtcbiAgICBET01DaGlsZHJlbk9wZXJhdGlvbnMucHJvY2Vzc1VwZGF0ZXMobm9kZSwgdXBkYXRlcyk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01JRE9wZXJhdGlvbnM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01JRE9wZXJhdGlvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDExN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5T3BlcmF0aW9ucycpO1xudmFyIExpbmtlZFZhbHVlVXRpbHMgPSByZXF1aXJlKCcuL0xpbmtlZFZhbHVlVXRpbHMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgZGlkV2FyblZhbHVlTGluayA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkTGluayA9IGZhbHNlO1xudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gZmFsc2U7XG52YXIgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmb3JjZVVwZGF0ZUlmTW91bnRlZCgpIHtcbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQpIHtcbiAgICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICAgIFJlYWN0RE9NSW5wdXQudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0NvbnRyb2xsZWQocHJvcHMpIHtcbiAgdmFyIHVzZXNDaGVja2VkID0gcHJvcHMudHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBwcm9wcy50eXBlID09PSAncmFkaW8nO1xuICByZXR1cm4gdXNlc0NoZWNrZWQgPyBwcm9wcy5jaGVja2VkICE9IG51bGwgOiBwcm9wcy52YWx1ZSAhPSBudWxsO1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPGlucHV0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIHRoZXNlIG9wdGlvbmFsXG4gKiBwcm9wczogYGNoZWNrZWRgLCBgdmFsdWVgLCBgZGVmYXVsdENoZWNrZWRgLCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKlxuICogSWYgYGNoZWNrZWRgIG9yIGB2YWx1ZWAgYXJlIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnNcbiAqIHRoYXQgYWZmZWN0IHRoZSBjaGVja2VkIHN0YXRlIG9yIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIHRoZXkgYXJlIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBub3RcbiAqIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIHByb3BzIG11c3QgY2hhbmdlIGluIG9yZGVyIGZvclxuICogdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIGFzIHVuY2hlY2tlZCAob3IgYGRlZmF1bHRDaGVja2VkYClcbiAqIHdpdGggYW4gZW1wdHkgdmFsdWUgKG9yIGBkZWZhdWx0VmFsdWVgKS5cbiAqXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTIvV0QtaHRtbDUtMjAxMjEwMjUvdGhlLWlucHV0LWVsZW1lbnQuaHRtbFxuICovXG52YXIgUmVhY3RET01JbnB1dCA9IHtcbiAgZ2V0SG9zdFByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICB2YXIgY2hlY2tlZCA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0Q2hlY2tlZChwcm9wcyk7XG5cbiAgICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7XG4gICAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC50eXBlIGJlZm9yZSBhbnkgb3RoZXIgcHJvcGVydGllcyAoc2V0dGluZyAudmFsdWVcbiAgICAgIC8vIGJlZm9yZSAudHlwZSBtZWFucyAudmFsdWUgaXMgbG9zdCBpbiBJRTExIGFuZCBiZWxvdylcbiAgICAgIHR5cGU6IHVuZGVmaW5lZCxcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLnN0ZXAgYmVmb3JlIC52YWx1ZSAoc2V0dGluZyAudmFsdWUgYmVmb3JlIC5zdGVwXG4gICAgICAvLyBtZWFucyAudmFsdWUgaXMgcm91bmRlZCBvbiBtb3VudCwgYmFzZWQgdXBvbiBzdGVwIHByZWNpc2lvbilcbiAgICAgIHN0ZXA6IHVuZGVmaW5lZCxcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLm1pbiAmIC5tYXggYmVmb3JlIC52YWx1ZSAodG8gZW5zdXJlIHByb3BlciBvcmRlclxuICAgICAgLy8gaW4gY29ybmVyIGNhc2VzIHN1Y2ggYXMgbWluIG9yIG1heCBkZXJpdmluZyBmcm9tIHZhbHVlLCBlLmcuIElzc3VlICM3MTcwKVxuICAgICAgbWluOiB1bmRlZmluZWQsXG4gICAgICBtYXg6IHVuZGVmaW5lZFxuICAgIH0sIHByb3BzLCB7XG4gICAgICBkZWZhdWx0Q2hlY2tlZDogdW5kZWZpbmVkLFxuICAgICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgICB2YWx1ZTogdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSxcbiAgICAgIGNoZWNrZWQ6IGNoZWNrZWQgIT0gbnVsbCA/IGNoZWNrZWQgOiBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWQsXG4gICAgICBvbkNoYW5nZTogaW5zdC5fd3JhcHBlclN0YXRlLm9uQ2hhbmdlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gaG9zdFByb3BzO1xuICB9LFxuXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIExpbmtlZFZhbHVlVXRpbHMuY2hlY2tQcm9wVHlwZXMoJ2lucHV0JywgcHJvcHMsIGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcik7XG5cbiAgICAgIHZhciBvd25lciA9IGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcblxuICAgICAgaWYgKHByb3BzLnZhbHVlTGluayAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVMaW5rKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlTGlua2AgcHJvcCBvbiBgaW5wdXRgIGlzIGRlcHJlY2F0ZWQ7IHNldCBgdmFsdWVgIGFuZCBgb25DaGFuZ2VgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5WYWx1ZUxpbmsgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLmNoZWNrZWRMaW5rICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkTGluaykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2BjaGVja2VkTGlua2AgcHJvcCBvbiBgaW5wdXRgIGlzIGRlcHJlY2F0ZWQ7IHNldCBgdmFsdWVgIGFuZCBgb25DaGFuZ2VgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5DaGVja2VkTGluayA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgY2hlY2tlZCBwcm9wLCBvciB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIG93bmVyICYmIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgIGluaXRpYWxDaGVja2VkOiBwcm9wcy5jaGVja2VkICE9IG51bGwgPyBwcm9wcy5jaGVja2VkIDogcHJvcHMuZGVmYXVsdENoZWNrZWQsXG4gICAgICBpbml0aWFsVmFsdWU6IHByb3BzLnZhbHVlICE9IG51bGwgPyBwcm9wcy52YWx1ZSA6IGRlZmF1bHRWYWx1ZSxcbiAgICAgIGxpc3RlbmVyczogbnVsbCxcbiAgICAgIG9uQ2hhbmdlOiBfaGFuZGxlQ2hhbmdlLmJpbmQoaW5zdClcbiAgICB9O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkID0gaXNDb250cm9sbGVkKHByb3BzKTtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlV3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgY29udHJvbGxlZCA9IGlzQ29udHJvbGxlZChwcm9wcyk7XG4gICAgICB2YXIgb3duZXIgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG5cbiAgICAgIGlmICghaW5zdC5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgY29udHJvbGxlZCAmJiAhZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzIGlzIGNoYW5naW5nIGFuIHVuY29udHJvbGxlZCBpbnB1dCBvZiB0eXBlICVzIHRvIGJlIGNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSB1bmNvbnRyb2xsZWQgdG8gY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpbnN0Ll93cmFwcGVyU3RhdGUuY29udHJvbGxlZCAmJiAhY29udHJvbGxlZCAmJiAhZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzIGlzIGNoYW5naW5nIGEgY29udHJvbGxlZCBpbnB1dCBvZiB0eXBlICVzIHRvIGJlIHVuY29udHJvbGxlZC4gJyArICdJbnB1dCBlbGVtZW50cyBzaG91bGQgbm90IHN3aXRjaCBmcm9tIGNvbnRyb2xsZWQgdG8gdW5jb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gJyArICdEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBvd25lciAmJiBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSkgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IFNob3VsZG4ndCB0aGlzIGJlIGdldENoZWNrZWQocHJvcHMpP1xuICAgIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcbiAgICBpZiAoY2hlY2tlZCAhPSBudWxsKSB7XG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JQcm9wZXJ0eShSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KSwgJ2NoZWNrZWQnLCBjaGVja2VkIHx8IGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG5cbiAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICB2YXIgbmV3VmFsdWUgPSAnJyArIHZhbHVlO1xuXG4gICAgICAvLyBUbyBhdm9pZCBzaWRlIGVmZmVjdHMgKHN1Y2ggYXMgbG9zaW5nIHRleHQgc2VsZWN0aW9uKSwgb25seSBzZXQgdmFsdWUgaWYgY2hhbmdlZFxuICAgICAgaWYgKG5ld1ZhbHVlICE9PSBub2RlLnZhbHVlKSB7XG4gICAgICAgIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BzLnZhbHVlID09IG51bGwgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSAnJyArIHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy5jaGVja2VkID09IG51bGwgJiYgcHJvcHMuZGVmYXVsdENoZWNrZWQgIT0gbnVsbCkge1xuICAgICAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gISFwcm9wcy5kZWZhdWx0Q2hlY2tlZDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgcG9zdE1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIC8vIFRoaXMgaXMgaW4gcG9zdE1vdW50IGJlY2F1c2Ugd2UgbmVlZCBhY2Nlc3MgdG8gdGhlIERPTSBub2RlLCB3aGljaCBpcyBub3RcbiAgICAvLyBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgbW91bnRlZC5cbiAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuXG4gICAgLy8gRGV0YWNoIHZhbHVlIGZyb20gZGVmYXVsdFZhbHVlLiBXZSB3b24ndCBkbyBhbnl0aGluZyBpZiB3ZSdyZSB3b3JraW5nIG9uXG4gICAgLy8gc3VibWl0IG9yIHJlc2V0IGlucHV0cyBhcyB0aG9zZSB2YWx1ZXMgJiBkZWZhdWx0VmFsdWVzIGFyZSBsaW5rZWQuIFRoZXlcbiAgICAvLyBhcmUgbm90IHJlc2V0YWJsZSBub2RlcyBzbyB0aGlzIG9wZXJhdGlvbiBkb2Vzbid0IG1hdHRlciBhbmQgYWN0dWFsbHlcbiAgICAvLyByZW1vdmVzIGJyb3dzZXItZGVmYXVsdCB2YWx1ZXMgKGVnIFwiU3VibWl0IFF1ZXJ5XCIpIHdoZW4gbm8gdmFsdWUgaXNcbiAgICAvLyBwcm92aWRlZC5cblxuICAgIHN3aXRjaCAocHJvcHMudHlwZSkge1xuICAgICAgY2FzZSAnc3VibWl0JzpcbiAgICAgIGNhc2UgJ3Jlc2V0JzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjb2xvcic6XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ2RhdGV0aW1lJzpcbiAgICAgIGNhc2UgJ2RhdGV0aW1lLWxvY2FsJzpcbiAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgIGNhc2UgJ3RpbWUnOlxuICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgIC8vIFRoaXMgZml4ZXMgdGhlIG5vLXNob3cgaXNzdWUgb24gaU9TIFNhZmFyaSBhbmQgQW5kcm9pZCBDaHJvbWU6XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzIzM1xuICAgICAgICBub2RlLnZhbHVlID0gJyc7XG4gICAgICAgIG5vZGUudmFsdWUgPSBub2RlLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBub2RlLnZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gTm9ybWFsbHksIHdlJ2QganVzdCBkbyBgbm9kZS5jaGVja2VkID0gbm9kZS5jaGVja2VkYCB1cG9uIGluaXRpYWwgbW91bnQsIGxlc3MgdGhpcyBidWdcbiAgICAvLyB0aGlzIGlzIG5lZWRlZCB0byB3b3JrIGFyb3VuZCBhIGNocm9tZSBidWcgd2hlcmUgc2V0dGluZyBkZWZhdWx0Q2hlY2tlZFxuICAgIC8vIHdpbGwgc29tZXRpbWVzIGluZmx1ZW5jZSB0aGUgdmFsdWUgb2YgY2hlY2tlZCAoZXZlbiBhZnRlciBkZXRhY2htZW50KS5cbiAgICAvLyBSZWZlcmVuY2U6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTYwODQxNlxuICAgIC8vIFdlIG5lZWQgdG8gdGVtcG9yYXJpbHkgdW5zZXQgbmFtZSB0byBhdm9pZCBkaXNydXB0aW5nIHJhZGlvIGJ1dHRvbiBncm91cHMuXG4gICAgdmFyIG5hbWUgPSBub2RlLm5hbWU7XG4gICAgaWYgKG5hbWUgIT09ICcnKSB7XG4gICAgICBub2RlLm5hbWUgPSAnJztcbiAgICB9XG4gICAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICFub2RlLmRlZmF1bHRDaGVja2VkO1xuICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhbm9kZS5kZWZhdWx0Q2hlY2tlZDtcbiAgICBpZiAobmFtZSAhPT0gJycpIHtcbiAgICAgIG5vZGUubmFtZSA9IG5hbWU7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gIHZhciByZXR1cm5WYWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZXhlY3V0ZU9uQ2hhbmdlKHByb3BzLCBldmVudCk7XG5cbiAgLy8gSGVyZSB3ZSB1c2UgYXNhcCB0byB3YWl0IHVudGlsIGFsbCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZCwgd2hpY2hcbiAgLy8gaXMgaW1wb3J0YW50IHdoZW4gdXNpbmcgY29udHJvbGxlZCBjb21wb25lbnRzIHdpdGhpbiBsYXllcnM6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY5OFxuICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgdGhpcyk7XG5cbiAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xuICBpZiAocHJvcHMudHlwZSA9PT0gJ3JhZGlvJyAmJiBuYW1lICE9IG51bGwpIHtcbiAgICB2YXIgcm9vdE5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0aGlzKTtcbiAgICB2YXIgcXVlcnlSb290ID0gcm9vdE5vZGU7XG5cbiAgICB3aGlsZSAocXVlcnlSb290LnBhcmVudE5vZGUpIHtcbiAgICAgIHF1ZXJ5Um9vdCA9IHF1ZXJ5Um9vdC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIC8vIElmIGByb290Tm9kZS5mb3JtYCB3YXMgbm9uLW51bGwsIHRoZW4gd2UgY291bGQgdHJ5IGBmb3JtLmVsZW1lbnRzYCxcbiAgICAvLyBidXQgdGhhdCBzb21ldGltZXMgYmVoYXZlcyBzdHJhbmdlbHkgaW4gSUU4LiBXZSBjb3VsZCBhbHNvIHRyeSB1c2luZ1xuICAgIC8vIGBmb3JtLmdldEVsZW1lbnRzQnlOYW1lYCwgYnV0IHRoYXQgd2lsbCBvbmx5IHJldHVybiBkaXJlY3QgY2hpbGRyZW5cbiAgICAvLyBhbmQgd29uJ3QgaW5jbHVkZSBpbnB1dHMgdGhhdCB1c2UgdGhlIEhUTUw1IGBmb3JtPWAgYXR0cmlidXRlLiBTaW5jZVxuICAgIC8vIHRoZSBpbnB1dCBtaWdodCBub3QgZXZlbiBiZSBpbiBhIGZvcm0sIGxldCdzIGp1c3QgdXNlIHRoZSBnbG9iYWxcbiAgICAvLyBgcXVlcnlTZWxlY3RvckFsbGAgdG8gZW5zdXJlIHdlIGRvbid0IG1pc3MgYW55dGhpbmcuXG4gICAgdmFyIGdyb3VwID0gcXVlcnlSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W25hbWU9JyArIEpTT04uc3RyaW5naWZ5KCcnICsgbmFtZSkgKyAnXVt0eXBlPVwicmFkaW9cIl0nKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdGhlck5vZGUgPSBncm91cFtpXTtcbiAgICAgIGlmIChvdGhlck5vZGUgPT09IHJvb3ROb2RlIHx8IG90aGVyTm9kZS5mb3JtICE9PSByb290Tm9kZS5mb3JtKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIHJhZGlvIGJ1dHRvbnMgcmVuZGVyZWQgYnkgZGlmZmVyZW50IGNvcGllcyBvZiBSZWFjdFxuICAgICAgLy8gYW5kIHRoZSBzYW1lIG5hbWUgYXJlIHJlbmRlcmVkIGludG8gdGhlIHNhbWUgZm9ybSAoc2FtZSBhcyAjMTkzOSkuXG4gICAgICAvLyBUaGF0J3MgcHJvYmFibHkgb2theTsgd2UgZG9uJ3Qgc3VwcG9ydCBpdCBqdXN0IGFzIHdlIGRvbid0IHN1cHBvcnRcbiAgICAgIC8vIG1peGluZyBSZWFjdCByYWRpbyBidXR0b25zIHdpdGggbm9uLVJlYWN0IG9uZXMuXG4gICAgICB2YXIgb3RoZXJJbnN0YW5jZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG90aGVyTm9kZSk7XG4gICAgICAhb3RoZXJJbnN0YW5jZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTUlucHV0OiBNaXhpbmcgUmVhY3QgYW5kIG5vbi1SZWFjdCByYWRpbyBpbnB1dHMgd2l0aCB0aGUgc2FtZSBgbmFtZWAgaXMgbm90IHN1cHBvcnRlZC4nKSA6IF9wcm9kSW52YXJpYW50KCc5MCcpIDogdm9pZCAwO1xuICAgICAgLy8gSWYgdGhpcyBpcyBhIGNvbnRyb2xsZWQgcmFkaW8gYnV0dG9uIGdyb3VwLCBmb3JjaW5nIHRoZSBpbnB1dCB0aGF0XG4gICAgICAvLyB3YXMgcHJldmlvdXNseSBjaGVja2VkIHRvIHVwZGF0ZSB3aWxsIGNhdXNlIGl0IHRvIGJlIGNvbWUgcmUtY2hlY2tlZFxuICAgICAgLy8gYXMgYXBwcm9wcmlhdGUuXG4gICAgICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgb3RoZXJJbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NSW5wdXQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01JbnB1dC5qc1xuLy8gbW9kdWxlIGlkID0gMTE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciB3YXJuZWRQcm9wZXJ0aWVzID0ge307XG52YXIgckFSSUEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgRE9NUHJvcGVydHkuQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eSh0YWdOYW1lLCBuYW1lLCBkZWJ1Z0lEKSB7XG4gIGlmICh3YXJuZWRQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChyQVJJQS50ZXN0KG5hbWUpKSB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBzdGFuZGFyZE5hbWUgPSBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZS5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVtsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xuXG4gICAgLy8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4gICAgLy8gRE9NIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYW4gaW52YWxpZCBhcmlhLSogYXR0cmlidXRlLlxuICAgIGlmIChzdGFuZGFyZE5hbWUgPT0gbnVsbCkge1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuICAgIGlmIChuYW1lICE9PSBzdGFuZGFyZE5hbWUpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5rbm93biBBUklBIGF0dHJpYnV0ZSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgc3RhbmRhcmROYW1lLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdhcm5JbnZhbGlkQVJJQVByb3BzKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgdmFyIGludmFsaWRQcm9wcyA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBlbGVtZW50LnByb3BzKSB7XG4gICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5KGVsZW1lbnQudHlwZSwga2V5LCBkZWJ1Z0lEKTtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIGludmFsaWRQcm9wcy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gaW52YWxpZFByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICB9KS5qb2luKCcsICcpO1xuXG4gIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyaWEgcHJvcCAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvaW52YWxpZC1hcmlhLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCBlbGVtZW50LnR5cGUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuICB9IGVsc2UgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyaWEgcHJvcHMgJXMgb24gPCVzPiB0YWcuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL2ludmFsaWQtYXJpYS1wcm9wJXMnLCB1bmtub3duUHJvcFN0cmluZywgZWxlbWVudC50eXBlLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCB8fCB0eXBlb2YgZWxlbWVudC50eXBlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbWVudC50eXBlLmluZGV4T2YoJy0nKSA+PSAwIHx8IGVsZW1lbnQucHJvcHMuaXMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB3YXJuSW52YWxpZEFSSUFQcm9wcyhkZWJ1Z0lELCBlbGVtZW50KTtcbn1cblxudmFyIFJlYWN0RE9NSW52YWxpZEFSSUFIb29rID0ge1xuICBvbkJlZm9yZU1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICAgIH1cbiAgfSxcbiAgb25CZWZvcmVVcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NSW52YWxpZEFSSUFIb29rO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NSW52YWxpZEFSSUFIb29rLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRpZFdhcm5WYWx1ZU51bGwgPSBmYWxzZTtcblxuZnVuY3Rpb24gaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVsZW1lbnQudHlwZSAhPT0gJ2lucHV0JyAmJiBlbGVtZW50LnR5cGUgIT09ICd0ZXh0YXJlYScgJiYgZWxlbWVudC50eXBlICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbWVudC5wcm9wcyAhPSBudWxsICYmIGVsZW1lbnQucHJvcHMudmFsdWUgPT09IG51bGwgJiYgIWRpZFdhcm5WYWx1ZU51bGwpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyB0aGUgZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgJyArICdmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJXMnLCBlbGVtZW50LnR5cGUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuXG4gICAgZGlkV2FyblZhbHVlTnVsbCA9IHRydWU7XG4gIH1cbn1cblxudmFyIFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vayA9IHtcbiAgb25CZWZvcmVNb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICB9LFxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vaztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2suanNcbi8vIG1vZHVsZSBpZCA9IDEyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Jyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdERPTVNlbGVjdCA9IHJlcXVpcmUoJy4vUmVhY3RET01TZWxlY3QnKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgdmFyIGNvbnRlbnQgPSAnJztcblxuICAvLyBGbGF0dGVuIGNoaWxkcmVuIGFuZCB3YXJuIGlmIHRoZXkgYXJlbid0IHN0cmluZ3Mgb3IgbnVtYmVycztcbiAgLy8gaW52YWxpZCB0eXBlcyBhcmUgaWdub3JlZC5cbiAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgY29udGVudCArPSBjaGlsZDtcbiAgICB9IGVsc2UgaWYgKCFkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuKSB7XG4gICAgICBkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnT25seSBzdHJpbmdzIGFuZCBudW1iZXJzIGFyZSBzdXBwb3J0ZWQgYXMgPG9wdGlvbj4gY2hpbGRyZW4uJykgOiB2b2lkIDA7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY29udGVudDtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxvcHRpb24+IGhvc3QgY29tcG9uZW50IHRoYXQgd2FybnMgd2hlbiBgc2VsZWN0ZWRgIGlzIHNldC5cbiAqL1xudmFyIFJlYWN0RE9NT3B0aW9uID0ge1xuICBtb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcywgaG9zdFBhcmVudCkge1xuICAgIC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBgc2VsZWN0ZWRgIGluIDxvcHRpb24+LlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5zZWxlY3RlZCA9PSBudWxsLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIG9uIDxzZWxlY3Q+IGluc3RlYWQgb2YgJyArICdzZXR0aW5nIGBzZWxlY3RlZGAgb24gPG9wdGlvbj4uJykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgLy8gTG9vayB1cCB3aGV0aGVyIHRoaXMgb3B0aW9uIGlzICdzZWxlY3RlZCdcbiAgICB2YXIgc2VsZWN0VmFsdWUgPSBudWxsO1xuICAgIGlmIChob3N0UGFyZW50ICE9IG51bGwpIHtcbiAgICAgIHZhciBzZWxlY3RQYXJlbnQgPSBob3N0UGFyZW50O1xuXG4gICAgICBpZiAoc2VsZWN0UGFyZW50Ll90YWcgPT09ICdvcHRncm91cCcpIHtcbiAgICAgICAgc2VsZWN0UGFyZW50ID0gc2VsZWN0UGFyZW50Ll9ob3N0UGFyZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0UGFyZW50ICE9IG51bGwgJiYgc2VsZWN0UGFyZW50Ll90YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgIHNlbGVjdFZhbHVlID0gUmVhY3RET01TZWxlY3QuZ2V0U2VsZWN0VmFsdWVDb250ZXh0KHNlbGVjdFBhcmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHZhbHVlIGlzIG51bGwgKGUuZy4sIG5vIHNwZWNpZmllZCB2YWx1ZSBvciBhZnRlciBpbml0aWFsIG1vdW50KVxuICAgIC8vIG9yIG1pc3NpbmcgKGUuZy4sIGZvciA8ZGF0YWxpc3Q+KSwgd2UgZG9uJ3QgY2hhbmdlIHByb3BzLnNlbGVjdGVkXG4gICAgdmFyIHNlbGVjdGVkID0gbnVsbDtcbiAgICBpZiAoc2VsZWN0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgaWYgKHByb3BzLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdmFsdWUgPSBwcm9wcy52YWx1ZSArICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBmbGF0dGVuQ2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4pO1xuICAgICAgfVxuICAgICAgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlbGVjdFZhbHVlKSkge1xuICAgICAgICAvLyBtdWx0aXBsZVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCcnICsgc2VsZWN0VmFsdWVbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGVjdGVkID0gJycgKyBzZWxlY3RWYWx1ZSA9PT0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0geyBzZWxlY3RlZDogc2VsZWN0ZWQgfTtcbiAgfSxcblxuICBwb3N0TW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIC8vIHZhbHVlPVwiXCIgc2hvdWxkIG1ha2UgYSB2YWx1ZSBhdHRyaWJ1dGUgKCM2MjE5KVxuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgIGlmIChwcm9wcy52YWx1ZSAhPSBudWxsKSB7XG4gICAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgcHJvcHMudmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICBnZXRIb3N0UHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHsgc2VsZWN0ZWQ6IHVuZGVmaW5lZCwgY2hpbGRyZW46IHVuZGVmaW5lZCB9LCBwcm9wcyk7XG5cbiAgICAvLyBSZWFkIHN0YXRlIG9ubHkgZnJvbSBpbml0aWFsIG1vdW50IGJlY2F1c2UgPHNlbGVjdD4gdXBkYXRlcyB2YWx1ZVxuICAgIC8vIG1hbnVhbGx5OyB3ZSBuZWVkIHRoZSBpbml0aWFsIHN0YXRlIG9ubHkgZm9yIHNlcnZlciByZW5kZXJpbmdcbiAgICBpZiAoaW5zdC5fd3JhcHBlclN0YXRlLnNlbGVjdGVkICE9IG51bGwpIHtcbiAgICAgIGhvc3RQcm9wcy5zZWxlY3RlZCA9IGluc3QuX3dyYXBwZXJTdGF0ZS5zZWxlY3RlZDtcbiAgICB9XG5cbiAgICB2YXIgY29udGVudCA9IGZsYXR0ZW5DaGlsZHJlbihwcm9wcy5jaGlsZHJlbik7XG5cbiAgICBpZiAoY29udGVudCkge1xuICAgICAgaG9zdFByb3BzLmNoaWxkcmVuID0gY29udGVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gaG9zdFByb3BzO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01PcHRpb247XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01PcHRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDEyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldCA9IHJlcXVpcmUoJy4vZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldCcpO1xudmFyIGdldFRleHRDb250ZW50QWNjZXNzb3IgPSByZXF1aXJlKCcuL2dldFRleHRDb250ZW50QWNjZXNzb3InKTtcblxuLyoqXG4gKiBXaGlsZSBgaXNDb2xsYXBzZWRgIGlzIGF2YWlsYWJsZSBvbiB0aGUgU2VsZWN0aW9uIG9iamVjdCBhbmQgYGNvbGxhcHNlZGBcbiAqIGlzIGF2YWlsYWJsZSBvbiB0aGUgUmFuZ2Ugb2JqZWN0LCBJRTExIHNvbWV0aW1lcyBnZXRzIHRoZW0gd3JvbmcuXG4gKiBJZiB0aGUgYW5jaG9yL2ZvY3VzIG5vZGVzIGFuZCBvZmZzZXRzIGFyZSB0aGUgc2FtZSwgdGhlIHJhbmdlIGlzIGNvbGxhcHNlZC5cbiAqL1xuZnVuY3Rpb24gaXNDb2xsYXBzZWQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KSB7XG4gIHJldHVybiBhbmNob3JOb2RlID09PSBmb2N1c05vZGUgJiYgYW5jaG9yT2Zmc2V0ID09PSBmb2N1c09mZnNldDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGFwcHJvcHJpYXRlIGFuY2hvciBhbmQgZm9jdXMgbm9kZS9vZmZzZXQgcGFpcnMgZm9yIElFLlxuICpcbiAqIFRoZSBjYXRjaCBoZXJlIGlzIHRoYXQgSUUncyBzZWxlY3Rpb24gQVBJIGRvZXNuJ3QgcHJvdmlkZSBpbmZvcm1hdGlvblxuICogYWJvdXQgd2hldGhlciB0aGUgc2VsZWN0aW9uIGlzIGZvcndhcmQgb3IgYmFja3dhcmQsIHNvIHdlIGhhdmUgdG9cbiAqIGJlaGF2ZSBhcyB0aG91Z2ggaXQncyBhbHdheXMgZm9yd2FyZC5cbiAqXG4gKiBJRSB0ZXh0IGRpZmZlcnMgZnJvbSBtb2Rlcm4gc2VsZWN0aW9uIGluIHRoYXQgaXQgYmVoYXZlcyBhcyB0aG91Z2hcbiAqIGJsb2NrIGVsZW1lbnRzIGVuZCB3aXRoIGEgbmV3IGxpbmUuIFRoaXMgbWVhbnMgY2hhcmFjdGVyIG9mZnNldHMgd2lsbFxuICogZGlmZmVyIGJldHdlZW4gdGhlIHR3byBBUElzLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRJRU9mZnNldHMobm9kZSkge1xuICB2YXIgc2VsZWN0aW9uID0gZG9jdW1lbnQuc2VsZWN0aW9uO1xuICB2YXIgc2VsZWN0ZWRSYW5nZSA9IHNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICB2YXIgc2VsZWN0ZWRMZW5ndGggPSBzZWxlY3RlZFJhbmdlLnRleHQubGVuZ3RoO1xuXG4gIC8vIER1cGxpY2F0ZSBzZWxlY3Rpb24gc28gd2UgY2FuIG1vdmUgcmFuZ2Ugd2l0aG91dCBicmVha2luZyB1c2VyIHNlbGVjdGlvbi5cbiAgdmFyIGZyb21TdGFydCA9IHNlbGVjdGVkUmFuZ2UuZHVwbGljYXRlKCk7XG4gIGZyb21TdGFydC5tb3ZlVG9FbGVtZW50VGV4dChub2RlKTtcbiAgZnJvbVN0YXJ0LnNldEVuZFBvaW50KCdFbmRUb1N0YXJ0Jywgc2VsZWN0ZWRSYW5nZSk7XG5cbiAgdmFyIHN0YXJ0T2Zmc2V0ID0gZnJvbVN0YXJ0LnRleHQubGVuZ3RoO1xuICB2YXIgZW5kT2Zmc2V0ID0gc3RhcnRPZmZzZXQgKyBzZWxlY3RlZExlbmd0aDtcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydE9mZnNldCxcbiAgICBlbmQ6IGVuZE9mZnNldFxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0TW9kZXJuT2Zmc2V0cyhub2RlKSB7XG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uICYmIHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yTm9kZTtcbiAgdmFyIGFuY2hvck9mZnNldCA9IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQ7XG4gIHZhciBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXNOb2RlO1xuICB2YXIgZm9jdXNPZmZzZXQgPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG5cbiAgdmFyIGN1cnJlbnRSYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuXG4gIC8vIEluIEZpcmVmb3gsIHJhbmdlLnN0YXJ0Q29udGFpbmVyIGFuZCByYW5nZS5lbmRDb250YWluZXIgY2FuIGJlIFwiYW5vbnltb3VzXG4gIC8vIGRpdnNcIiwgZS5nLiB0aGUgdXAvZG93biBidXR0b25zIG9uIGFuIDxpbnB1dCB0eXBlPVwibnVtYmVyXCI+LiBBbm9ueW1vdXNcbiAgLy8gZGl2cyBkbyBub3Qgc2VlbSB0byBleHBvc2UgcHJvcGVydGllcywgdHJpZ2dlcmluZyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcbiAgLy8gZXJyb3JcIiBpZiBhbnkgb2YgaXRzIHByb3BlcnRpZXMgYXJlIGFjY2Vzc2VkLiBUaGUgb25seSBzZWVtaW5nbHkgcG9zc2libGVcbiAgLy8gd2F5IHRvIGF2b2lkIGVycm9yaW5nIGlzIHRvIGFjY2VzcyBhIHByb3BlcnR5IHRoYXQgdHlwaWNhbGx5IHdvcmtzIGZvclxuICAvLyBub24tYW5vbnltb3VzIGRpdnMgYW5kIGNhdGNoIGFueSBlcnJvciB0aGF0IG1heSBvdGhlcndpc2UgYXJpc2UuIFNlZVxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDg0MjdcbiAgdHJ5IHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgICBjdXJyZW50UmFuZ2Uuc3RhcnRDb250YWluZXIubm9kZVR5cGU7XG4gICAgY3VycmVudFJhbmdlLmVuZENvbnRhaW5lci5ub2RlVHlwZTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBJZiB0aGUgbm9kZSBhbmQgb2Zmc2V0IHZhbHVlcyBhcmUgdGhlIHNhbWUsIHRoZSBzZWxlY3Rpb24gaXMgY29sbGFwc2VkLlxuICAvLyBgU2VsZWN0aW9uLmlzQ29sbGFwc2VkYCBpcyBhdmFpbGFibGUgbmF0aXZlbHksIGJ1dCBJRSBzb21ldGltZXMgZ2V0c1xuICAvLyB0aGlzIHZhbHVlIHdyb25nLlxuICB2YXIgaXNTZWxlY3Rpb25Db2xsYXBzZWQgPSBpc0NvbGxhcHNlZChzZWxlY3Rpb24uYW5jaG9yTm9kZSwgc2VsZWN0aW9uLmFuY2hvck9mZnNldCwgc2VsZWN0aW9uLmZvY3VzTm9kZSwgc2VsZWN0aW9uLmZvY3VzT2Zmc2V0KTtcblxuICB2YXIgcmFuZ2VMZW5ndGggPSBpc1NlbGVjdGlvbkNvbGxhcHNlZCA/IDAgOiBjdXJyZW50UmFuZ2UudG9TdHJpbmcoKS5sZW5ndGg7XG5cbiAgdmFyIHRlbXBSYW5nZSA9IGN1cnJlbnRSYW5nZS5jbG9uZVJhbmdlKCk7XG4gIHRlbXBSYW5nZS5zZWxlY3ROb2RlQ29udGVudHMobm9kZSk7XG4gIHRlbXBSYW5nZS5zZXRFbmQoY3VycmVudFJhbmdlLnN0YXJ0Q29udGFpbmVyLCBjdXJyZW50UmFuZ2Uuc3RhcnRPZmZzZXQpO1xuXG4gIHZhciBpc1RlbXBSYW5nZUNvbGxhcHNlZCA9IGlzQ29sbGFwc2VkKHRlbXBSYW5nZS5zdGFydENvbnRhaW5lciwgdGVtcFJhbmdlLnN0YXJ0T2Zmc2V0LCB0ZW1wUmFuZ2UuZW5kQ29udGFpbmVyLCB0ZW1wUmFuZ2UuZW5kT2Zmc2V0KTtcblxuICB2YXIgc3RhcnQgPSBpc1RlbXBSYW5nZUNvbGxhcHNlZCA/IDAgOiB0ZW1wUmFuZ2UudG9TdHJpbmcoKS5sZW5ndGg7XG4gIHZhciBlbmQgPSBzdGFydCArIHJhbmdlTGVuZ3RoO1xuXG4gIC8vIERldGVjdCB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gaXMgYmFja3dhcmQuXG4gIHZhciBkZXRlY3Rpb25SYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIGRldGVjdGlvblJhbmdlLnNldFN0YXJ0KGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCk7XG4gIGRldGVjdGlvblJhbmdlLnNldEVuZChmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KTtcbiAgdmFyIGlzQmFja3dhcmQgPSBkZXRlY3Rpb25SYW5nZS5jb2xsYXBzZWQ7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogaXNCYWNrd2FyZCA/IGVuZCA6IHN0YXJ0LFxuICAgIGVuZDogaXNCYWNrd2FyZCA/IHN0YXJ0IDogZW5kXG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICovXG5mdW5jdGlvbiBzZXRJRU9mZnNldHMobm9kZSwgb2Zmc2V0cykge1xuICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKS5kdXBsaWNhdGUoKTtcbiAgdmFyIHN0YXJ0LCBlbmQ7XG5cbiAgaWYgKG9mZnNldHMuZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IG9mZnNldHMuc3RhcnQ7XG4gICAgZW5kID0gc3RhcnQ7XG4gIH0gZWxzZSBpZiAob2Zmc2V0cy5zdGFydCA+IG9mZnNldHMuZW5kKSB7XG4gICAgc3RhcnQgPSBvZmZzZXRzLmVuZDtcbiAgICBlbmQgPSBvZmZzZXRzLnN0YXJ0O1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgICBlbmQgPSBvZmZzZXRzLmVuZDtcbiAgfVxuXG4gIHJhbmdlLm1vdmVUb0VsZW1lbnRUZXh0KG5vZGUpO1xuICByYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIHN0YXJ0KTtcbiAgcmFuZ2Uuc2V0RW5kUG9pbnQoJ0VuZFRvU3RhcnQnLCByYW5nZSk7XG4gIHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIGVuZCAtIHN0YXJ0KTtcbiAgcmFuZ2Uuc2VsZWN0KCk7XG59XG5cbi8qKlxuICogSW4gbW9kZXJuIG5vbi1JRSBicm93c2Vycywgd2UgY2FuIHN1cHBvcnQgYm90aCBmb3J3YXJkIGFuZCBiYWNrd2FyZFxuICogc2VsZWN0aW9ucy5cbiAqXG4gKiBOb3RlOiBJRTEwKyBzdXBwb3J0cyB0aGUgU2VsZWN0aW9uIG9iamVjdCwgYnV0IGl0IGRvZXMgbm90IHN1cHBvcnRcbiAqIHRoZSBgZXh0ZW5kYCBtZXRob2QsIHdoaWNoIG1lYW5zIHRoYXQgZXZlbiBpbiBtb2Rlcm4gSUUsIGl0J3Mgbm90IHBvc3NpYmxlXG4gKiB0byBwcm9ncmFtbWF0aWNhbGx5IGNyZWF0ZSBhIGJhY2t3YXJkIHNlbGVjdGlvbi4gVGh1cywgZm9yIGFsbCBJRVxuICogdmVyc2lvbnMsIHdlIHVzZSB0aGUgb2xkIElFIEFQSSB0byBjcmVhdGUgb3VyIHNlbGVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICovXG5mdW5jdGlvbiBzZXRNb2Rlcm5PZmZzZXRzKG5vZGUsIG9mZnNldHMpIHtcbiAgaWYgKCF3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgdmFyIGxlbmd0aCA9IG5vZGVbZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpXS5sZW5ndGg7XG4gIHZhciBzdGFydCA9IE1hdGgubWluKG9mZnNldHMuc3RhcnQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBvZmZzZXRzLmVuZCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgOiBNYXRoLm1pbihvZmZzZXRzLmVuZCwgbGVuZ3RoKTtcblxuICAvLyBJRSAxMSB1c2VzIG1vZGVybiBzZWxlY3Rpb24sIGJ1dCBkb2Vzbid0IHN1cHBvcnQgdGhlIGV4dGVuZCBtZXRob2QuXG4gIC8vIEZsaXAgYmFja3dhcmQgc2VsZWN0aW9ucywgc28gd2UgY2FuIHNldCB3aXRoIGEgc2luZ2xlIHJhbmdlLlxuICBpZiAoIXNlbGVjdGlvbi5leHRlbmQgJiYgc3RhcnQgPiBlbmQpIHtcbiAgICB2YXIgdGVtcCA9IGVuZDtcbiAgICBlbmQgPSBzdGFydDtcbiAgICBzdGFydCA9IHRlbXA7XG4gIH1cblxuICB2YXIgc3RhcnRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIHN0YXJ0KTtcbiAgdmFyIGVuZE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgZW5kKTtcblxuICBpZiAoc3RhcnRNYXJrZXIgJiYgZW5kTWFya2VyKSB7XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZXRTdGFydChzdGFydE1hcmtlci5ub2RlLCBzdGFydE1hcmtlci5vZmZzZXQpO1xuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcblxuICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgIHNlbGVjdGlvbi5leHRlbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZS5zZXRFbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHVzZUlFT2Zmc2V0cyA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnc2VsZWN0aW9uJyBpbiBkb2N1bWVudCAmJiAhKCdnZXRTZWxlY3Rpb24nIGluIHdpbmRvdyk7XG5cbnZhciBSZWFjdERPTVNlbGVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKi9cbiAgZ2V0T2Zmc2V0czogdXNlSUVPZmZzZXRzID8gZ2V0SUVPZmZzZXRzIDogZ2V0TW9kZXJuT2Zmc2V0cyxcblxuICAvKipcbiAgICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gICAqL1xuICBzZXRPZmZzZXRzOiB1c2VJRU9mZnNldHMgPyBzZXRJRU9mZnNldHMgOiBzZXRNb2Rlcm5PZmZzZXRzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NU2VsZWN0aW9uO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NU2VsZWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01DaGlsZHJlbk9wZXJhdGlvbnMnKTtcbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xuXG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKCcuL3ZhbGlkYXRlRE9NTmVzdGluZycpO1xuXG4vKipcbiAqIFRleHQgbm9kZXMgdmlvbGF0ZSBhIGNvdXBsZSBhc3N1bXB0aW9ucyB0aGF0IFJlYWN0IG1ha2VzIGFib3V0IGNvbXBvbmVudHM6XG4gKlxuICogIC0gV2hlbiBtb3VudGluZyB0ZXh0IGludG8gdGhlIERPTSwgYWRqYWNlbnQgdGV4dCBub2RlcyBhcmUgbWVyZ2VkLlxuICogIC0gVGV4dCBub2RlcyBjYW5ub3QgYmUgYXNzaWduZWQgYSBSZWFjdCByb290IElELlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGlzIHVzZWQgdG8gd3JhcCBzdHJpbmdzIGJldHdlZW4gY29tbWVudCBub2RlcyBzbyB0aGF0IHRoZXlcbiAqIGNhbiB1bmRlcmdvIHRoZSBzYW1lIHJlY29uY2lsaWF0aW9uIHRoYXQgaXMgYXBwbGllZCB0byBlbGVtZW50cy5cbiAqXG4gKiBUT0RPOiBJbnZlc3RpZ2F0ZSByZXByZXNlbnRpbmcgUmVhY3QgY29tcG9uZW50cyBpbiB0aGUgRE9NIHdpdGggdGV4dCBub2Rlcy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RET01UZXh0Q29tcG9uZW50XG4gKiBAZXh0ZW5kcyBSZWFjdENvbXBvbmVudFxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdERPTVRleHRDb21wb25lbnQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAvLyBUT0RPOiBUaGlzIGlzIHJlYWxseSBhIFJlYWN0VGV4dCAoUmVhY3ROb2RlKSwgbm90IGEgUmVhY3RFbGVtZW50XG4gIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gdGV4dDtcbiAgdGhpcy5fc3RyaW5nVGV4dCA9ICcnICsgdGV4dDtcbiAgLy8gUmVhY3RET01Db21wb25lbnRUcmVlIHVzZXMgdGhlc2U6XG4gIHRoaXMuX2hvc3ROb2RlID0gbnVsbDtcbiAgdGhpcy5faG9zdFBhcmVudCA9IG51bGw7XG5cbiAgLy8gUHJvcGVydGllc1xuICB0aGlzLl9kb21JRCA9IDA7XG4gIHRoaXMuX21vdW50SW5kZXggPSAwO1xuICB0aGlzLl9jbG9zaW5nQ29tbWVudCA9IG51bGw7XG4gIHRoaXMuX2NvbW1lbnROb2RlcyA9IG51bGw7XG59O1xuXG5fYXNzaWduKFJlYWN0RE9NVGV4dENvbXBvbmVudC5wcm90b3R5cGUsIHtcblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgbWFya3VwIGZvciB0aGlzIHRleHQgbm9kZS4gVGhpcyBub2RlIGlzIG5vdCBpbnRlbmRlZCB0byBoYXZlXG4gICAqIGFueSBmZWF0dXJlcyBiZXNpZGVzIGNvbnRhaW5pbmcgdGV4dCBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgZm9yIHRoaXMgdGV4dCBub2RlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwYXJlbnRJbmZvO1xuICAgICAgaWYgKGhvc3RQYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRJbmZvID0gaG9zdFBhcmVudC5fYW5jZXN0b3JJbmZvO1xuICAgICAgfSBlbHNlIGlmIChob3N0Q29udGFpbmVySW5mbyAhPSBudWxsKSB7XG4gICAgICAgIHBhcmVudEluZm8gPSBob3N0Q29udGFpbmVySW5mby5fYW5jZXN0b3JJbmZvO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudEluZm8pIHtcbiAgICAgICAgLy8gcGFyZW50SW5mbyBzaG91bGQgYWx3YXlzIGJlIHByZXNlbnQgZXhjZXB0IGZvciB0aGUgdG9wLWxldmVsXG4gICAgICAgIC8vIGNvbXBvbmVudCB3aGVuIHNlcnZlciByZW5kZXJpbmdcbiAgICAgICAgdmFsaWRhdGVET01OZXN0aW5nKG51bGwsIHRoaXMuX3N0cmluZ1RleHQsIHRoaXMsIHBhcmVudEluZm8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkb21JRCA9IGhvc3RDb250YWluZXJJbmZvLl9pZENvdW50ZXIrKztcbiAgICB2YXIgb3BlbmluZ1ZhbHVlID0gJyByZWFjdC10ZXh0OiAnICsgZG9tSUQgKyAnICc7XG4gICAgdmFyIGNsb3NpbmdWYWx1ZSA9ICcgL3JlYWN0LXRleHQgJztcbiAgICB0aGlzLl9kb21JRCA9IGRvbUlEO1xuICAgIHRoaXMuX2hvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGhvc3RDb250YWluZXJJbmZvLl9vd25lckRvY3VtZW50O1xuICAgICAgdmFyIG9wZW5pbmdDb21tZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVDb21tZW50KG9wZW5pbmdWYWx1ZSk7XG4gICAgICB2YXIgY2xvc2luZ0NvbW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoY2xvc2luZ1ZhbHVlKTtcbiAgICAgIHZhciBsYXp5VHJlZSA9IERPTUxhenlUcmVlKG93bmVyRG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpKTtcbiAgICAgIERPTUxhenlUcmVlLnF1ZXVlQ2hpbGQobGF6eVRyZWUsIERPTUxhenlUcmVlKG9wZW5pbmdDb21tZW50KSk7XG4gICAgICBpZiAodGhpcy5fc3RyaW5nVGV4dCkge1xuICAgICAgICBET01MYXp5VHJlZS5xdWV1ZUNoaWxkKGxhenlUcmVlLCBET01MYXp5VHJlZShvd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMuX3N0cmluZ1RleHQpKSk7XG4gICAgICB9XG4gICAgICBET01MYXp5VHJlZS5xdWV1ZUNoaWxkKGxhenlUcmVlLCBET01MYXp5VHJlZShjbG9zaW5nQ29tbWVudCkpO1xuICAgICAgUmVhY3RET01Db21wb25lbnRUcmVlLnByZWNhY2hlTm9kZSh0aGlzLCBvcGVuaW5nQ29tbWVudCk7XG4gICAgICB0aGlzLl9jbG9zaW5nQ29tbWVudCA9IGNsb3NpbmdDb21tZW50O1xuICAgICAgcmV0dXJuIGxhenlUcmVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXNjYXBlZFRleHQgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodGhpcy5fc3RyaW5nVGV4dCk7XG5cbiAgICAgIGlmICh0cmFuc2FjdGlvbi5yZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICAgICAgICAvLyBOb3JtYWxseSB3ZSdkIHdyYXAgdGhpcyBiZXR3ZWVuIGNvbW1lbnQgbm9kZXMgZm9yIHRoZSByZWFzb25zIHN0YXRlZFxuICAgICAgICAvLyBhYm92ZSwgYnV0IHNpbmNlIHRoaXMgaXMgYSBzaXR1YXRpb24gd2hlcmUgUmVhY3Qgd29uJ3QgdGFrZSBvdmVyXG4gICAgICAgIC8vIChzdGF0aWMgcGFnZXMpLCB3ZSBjYW4gc2ltcGx5IHJldHVybiB0aGUgdGV4dCBhcyBpdCBpcy5cbiAgICAgICAgcmV0dXJuIGVzY2FwZWRUZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJzwhLS0nICsgb3BlbmluZ1ZhbHVlICsgJy0tPicgKyBlc2NhcGVkVGV4dCArICc8IS0tJyArIGNsb3NpbmdWYWx1ZSArICctLT4nO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIGNvbXBvbmVudCBieSB1cGRhdGluZyB0aGUgdGV4dCBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0VGV4dH0gbmV4dFRleHQgVGhlIG5leHQgdGV4dCBjb250ZW50XG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAobmV4dFRleHQsIHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKG5leHRUZXh0ICE9PSB0aGlzLl9jdXJyZW50RWxlbWVudCkge1xuICAgICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0VGV4dDtcbiAgICAgIHZhciBuZXh0U3RyaW5nVGV4dCA9ICcnICsgbmV4dFRleHQ7XG4gICAgICBpZiAobmV4dFN0cmluZ1RleHQgIT09IHRoaXMuX3N0cmluZ1RleHQpIHtcbiAgICAgICAgLy8gVE9ETzogU2F2ZSB0aGlzIGFzIHBlbmRpbmcgcHJvcHMgYW5kIHVzZSBwZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnlcbiAgICAgICAgLy8gYW5kL29yIHVwZGF0ZUNvbXBvbmVudCB0byBkbyB0aGUgYWN0dWFsIHVwZGF0ZSBmb3IgY29uc2lzdGVuY3kgd2l0aFxuICAgICAgICAvLyBvdGhlciBjb21wb25lbnQgdHlwZXM/XG4gICAgICAgIHRoaXMuX3N0cmluZ1RleHQgPSBuZXh0U3RyaW5nVGV4dDtcbiAgICAgICAgdmFyIGNvbW1lbnROb2RlcyA9IHRoaXMuZ2V0SG9zdE5vZGUoKTtcbiAgICAgICAgRE9NQ2hpbGRyZW5PcGVyYXRpb25zLnJlcGxhY2VEZWxpbWl0ZWRUZXh0KGNvbW1lbnROb2Rlc1swXSwgY29tbWVudE5vZGVzWzFdLCBuZXh0U3RyaW5nVGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhvc3ROb2RlID0gdGhpcy5fY29tbWVudE5vZGVzO1xuICAgIGlmIChob3N0Tm9kZSkge1xuICAgICAgcmV0dXJuIGhvc3ROb2RlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2Nsb3NpbmdDb21tZW50KSB7XG4gICAgICB2YXIgb3BlbmluZ0NvbW1lbnQgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0aGlzKTtcbiAgICAgIHZhciBub2RlID0gb3BlbmluZ0NvbW1lbnQubmV4dFNpYmxpbmc7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAhKG5vZGUgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTWlzc2luZyBjbG9zaW5nIGNvbW1lbnQgZm9yIHRleHQgY29tcG9uZW50ICVzJywgdGhpcy5fZG9tSUQpIDogX3Byb2RJbnZhcmlhbnQoJzY3JywgdGhpcy5fZG9tSUQpIDogdm9pZCAwO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAmJiBub2RlLm5vZGVWYWx1ZSA9PT0gJyAvcmVhY3QtdGV4dCAnKSB7XG4gICAgICAgICAgdGhpcy5fY2xvc2luZ0NvbW1lbnQgPSBub2RlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgICBob3N0Tm9kZSA9IFt0aGlzLl9ob3N0Tm9kZSwgdGhpcy5fY2xvc2luZ0NvbW1lbnRdO1xuICAgIHRoaXMuX2NvbW1lbnROb2RlcyA9IGhvc3ROb2RlO1xuICAgIHJldHVybiBob3N0Tm9kZTtcbiAgfSxcblxuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2xvc2luZ0NvbW1lbnQgPSBudWxsO1xuICAgIHRoaXMuX2NvbW1lbnROb2RlcyA9IG51bGw7XG4gICAgUmVhY3RET01Db21wb25lbnRUcmVlLnVuY2FjaGVOb2RlKHRoaXMpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NVGV4dENvbXBvbmVudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTVRleHRDb21wb25lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDEyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0gcmVxdWlyZSgnLi9MaW5rZWRWYWx1ZVV0aWxzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRpZFdhcm5WYWx1ZUxpbmsgPSBmYWxzZTtcbnZhciBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmb3JjZVVwZGF0ZUlmTW91bnRlZCgpIHtcbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQpIHtcbiAgICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICAgIFJlYWN0RE9NVGV4dGFyZWEudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8dGV4dGFyZWE+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgYHZhbHVlYCwgYW5kXG4gKiBgZGVmYXVsdFZhbHVlYC4gVGhpcyBkaWZmZXJzIGZyb20gdGhlIHRyYWRpdGlvbmFsIERPTSBBUEkgYmVjYXVzZSB2YWx1ZSBpc1xuICogdXN1YWxseSBzZXQgYXMgUENEQVRBIGNoaWxkcmVuLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGFmZmVjdCB0aGVcbiAqIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsXG4gKiBub3QgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIHdpdGggYW4gZW1wdHkgdmFsdWUsIHRoZSBwcm9wXG4gKiBgZGVmYXVsdFZhbHVlYCBpZiBzcGVjaWZpZWQsIG9yIHRoZSBjaGlsZHJlbiBjb250ZW50IChkZXByZWNhdGVkKS5cbiAqL1xudmFyIFJlYWN0RE9NVGV4dGFyZWEgPSB7XG4gIGdldEhvc3RQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgIShwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi4nKSA6IF9wcm9kSW52YXJpYW50KCc5MScpIDogdm9pZCAwO1xuXG4gICAgLy8gQWx3YXlzIHNldCBjaGlsZHJlbiB0byB0aGUgc2FtZSB0aGluZy4gSW4gSUU5LCB0aGUgc2VsZWN0aW9uIHJhbmdlIHdpbGxcbiAgICAvLyBnZXQgcmVzZXQgaWYgYHRleHRDb250ZW50YCBpcyBtdXRhdGVkLiAgV2UgY291bGQgYWRkIGEgY2hlY2sgaW4gc2V0VGV4dENvbnRlbnRcbiAgICAvLyB0byBvbmx5IHNldCB0aGUgdmFsdWUgaWYvd2hlbiB0aGUgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBub2RlIHZhbHVlICh3aGljaCB3b3VsZFxuICAgIC8vIGNvbXBsZXRlbHkgc29sdmUgdGhpcyBJRTkgYnVnKSwgYnV0IFNlYmFzdGlhbitCZW4gc2VlbWVkIHRvIGxpa2UgdGhpcyBzb2x1dGlvbi5cbiAgICAvLyBUaGUgdmFsdWUgY2FuIGJlIGEgYm9vbGVhbiBvciBvYmplY3Qgc28gdGhhdCdzIHdoeSBpdCdzIGZvcmNlZCB0byBiZSBhIHN0cmluZy5cbiAgICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIGNoaWxkcmVuOiAnJyArIGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUsXG4gICAgICBvbkNoYW5nZTogaW5zdC5fd3JhcHBlclN0YXRlLm9uQ2hhbmdlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gaG9zdFByb3BzO1xuICB9LFxuXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIExpbmtlZFZhbHVlVXRpbHMuY2hlY2tQcm9wVHlwZXMoJ3RleHRhcmVhJywgcHJvcHMsIGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcik7XG4gICAgICBpZiAocHJvcHMudmFsdWVMaW5rICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZUxpbmspIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgdmFsdWVMaW5rYCBwcm9wIG9uIGB0ZXh0YXJlYWAgaXMgZGVwcmVjYXRlZDsgc2V0IGB2YWx1ZWAgYW5kIGBvbkNoYW5nZWAgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FyblZhbHVlTGluayA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbERlZmF1bHRWYWwpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdUZXh0YXJlYSBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgdGV4dGFyZWEgJyArICdhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJykgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5WYWxEZWZhdWx0VmFsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICB2YXIgaW5pdGlhbFZhbHVlID0gdmFsdWU7XG5cbiAgICAvLyBPbmx5IGJvdGhlciBmZXRjaGluZyBkZWZhdWx0IHZhbHVlIGlmIHdlJ3JlIGdvaW5nIHRvIHVzZSBpdFxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICAgICAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBpbnN0ZWFkIG9mIHNldHRpbmcgJyArICdjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LicpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgICEoZGVmYXVsdFZhbHVlID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0lmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi4nKSA6IF9wcm9kSW52YXJpYW50KCc5MicpIDogdm9pZCAwO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAhKGNoaWxkcmVuLmxlbmd0aCA8PSAxKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICc8dGV4dGFyZWE+IGNhbiBvbmx5IGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuJykgOiBfcHJvZEludmFyaWFudCgnOTMnKSA6IHZvaWQgMDtcbiAgICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdFZhbHVlID0gJycgKyBjaGlsZHJlbjtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBkZWZhdWx0VmFsdWUgPSAnJztcbiAgICAgIH1cbiAgICAgIGluaXRpYWxWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG5cbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUgPSB7XG4gICAgICBpbml0aWFsVmFsdWU6ICcnICsgaW5pdGlhbFZhbHVlLFxuICAgICAgbGlzdGVuZXJzOiBudWxsLFxuICAgICAgb25DaGFuZ2U6IF9oYW5kbGVDaGFuZ2UuYmluZChpbnN0KVxuICAgIH07XG4gIH0sXG5cbiAgdXBkYXRlV3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICB2YXIgbmV3VmFsdWUgPSAnJyArIHZhbHVlO1xuXG4gICAgICAvLyBUbyBhdm9pZCBzaWRlIGVmZmVjdHMgKHN1Y2ggYXMgbG9zaW5nIHRleHQgc2VsZWN0aW9uKSwgb25seSBzZXQgdmFsdWUgaWYgY2hhbmdlZFxuICAgICAgaWYgKG5ld1ZhbHVlICE9PSBub2RlLnZhbHVlKSB7XG4gICAgICAgIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgfSxcblxuICBwb3N0TW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIC8vIFRoaXMgaXMgaW4gcG9zdE1vdW50IGJlY2F1c2Ugd2UgbmVlZCBhY2Nlc3MgdG8gdGhlIERPTSBub2RlLCB3aGljaCBpcyBub3RcbiAgICAvLyBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgbW91bnRlZC5cbiAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuXG4gICAgLy8gV2FybmluZzogbm9kZS52YWx1ZSBtYXkgYmUgdGhlIGVtcHR5IHN0cmluZyBhdCB0aGlzIHBvaW50IChJRTExKSBpZiBwbGFjZWhvbGRlciBpcyBzZXQuXG4gICAgbm9kZS52YWx1ZSA9IG5vZGUudGV4dENvbnRlbnQ7IC8vIERldGFjaCB2YWx1ZSBmcm9tIGRlZmF1bHRWYWx1ZVxuICB9XG59O1xuXG5mdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICB2YXIgcmV0dXJuVmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmV4ZWN1dGVPbkNoYW5nZShwcm9wcywgZXZlbnQpO1xuICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgdGhpcyk7XG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVRleHRhcmVhO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NVGV4dGFyZWEuanNcbi8vIG1vZHVsZSBpZCA9IDEyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsb3dlc3QgY29tbW9uIGFuY2VzdG9yIG9mIEEgYW5kIEIsIG9yIG51bGwgaWYgdGhleSBhcmUgaW5cbiAqIGRpZmZlcmVudCB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoaW5zdEEsIGluc3RCKSB7XG4gICEoJ19ob3N0Tm9kZScgaW4gaW5zdEEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2dldE5vZGVGcm9tSW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzMnKSA6IHZvaWQgMDtcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0QikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZ2V0Tm9kZUZyb21JbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczMycpIDogdm9pZCAwO1xuXG4gIHZhciBkZXB0aEEgPSAwO1xuICBmb3IgKHZhciB0ZW1wQSA9IGluc3RBOyB0ZW1wQTsgdGVtcEEgPSB0ZW1wQS5faG9zdFBhcmVudCkge1xuICAgIGRlcHRoQSsrO1xuICB9XG4gIHZhciBkZXB0aEIgPSAwO1xuICBmb3IgKHZhciB0ZW1wQiA9IGluc3RCOyB0ZW1wQjsgdGVtcEIgPSB0ZW1wQi5faG9zdFBhcmVudCkge1xuICAgIGRlcHRoQisrO1xuICB9XG5cbiAgLy8gSWYgQSBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuICB3aGlsZSAoZGVwdGhBIC0gZGVwdGhCID4gMCkge1xuICAgIGluc3RBID0gaW5zdEEuX2hvc3RQYXJlbnQ7XG4gICAgZGVwdGhBLS07XG4gIH1cblxuICAvLyBJZiBCIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG4gIHdoaWxlIChkZXB0aEIgLSBkZXB0aEEgPiAwKSB7XG4gICAgaW5zdEIgPSBpbnN0Qi5faG9zdFBhcmVudDtcbiAgICBkZXB0aEItLTtcbiAgfVxuXG4gIC8vIFdhbGsgaW4gbG9ja3N0ZXAgdW50aWwgd2UgZmluZCBhIG1hdGNoLlxuICB2YXIgZGVwdGggPSBkZXB0aEE7XG4gIHdoaWxlIChkZXB0aC0tKSB7XG4gICAgaWYgKGluc3RBID09PSBpbnN0Qikge1xuICAgICAgcmV0dXJuIGluc3RBO1xuICAgIH1cbiAgICBpbnN0QSA9IGluc3RBLl9ob3N0UGFyZW50O1xuICAgIGluc3RCID0gaW5zdEIuX2hvc3RQYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJuIGlmIEEgaXMgYW4gYW5jZXN0b3Igb2YgQi5cbiAqL1xuZnVuY3Rpb24gaXNBbmNlc3RvcihpbnN0QSwgaW5zdEIpIHtcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0QSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnaXNBbmNlc3RvcjogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczNScpIDogdm9pZCAwO1xuICAhKCdfaG9zdE5vZGUnIGluIGluc3RCKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdpc0FuY2VzdG9yOiBJbnZhbGlkIGFyZ3VtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzM1JykgOiB2b2lkIDA7XG5cbiAgd2hpbGUgKGluc3RCKSB7XG4gICAgaWYgKGluc3RCID09PSBpbnN0QSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGluc3RCID0gaW5zdEIuX2hvc3RQYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgcGFyZW50IGluc3RhbmNlIG9mIHRoZSBwYXNzZWQtaW4gaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudEluc3RhbmNlKGluc3QpIHtcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXRQYXJlbnRJbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczNicpIDogdm9pZCAwO1xuXG4gIHJldHVybiBpbnN0Ll9ob3N0UGFyZW50O1xufVxuXG4vKipcbiAqIFNpbXVsYXRlcyB0aGUgdHJhdmVyc2FsIG9mIGEgdHdvLXBoYXNlLCBjYXB0dXJlL2J1YmJsZSBldmVudCBkaXNwYXRjaC5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VUd29QaGFzZShpbnN0LCBmbiwgYXJnKSB7XG4gIHZhciBwYXRoID0gW107XG4gIHdoaWxlIChpbnN0KSB7XG4gICAgcGF0aC5wdXNoKGluc3QpO1xuICAgIGluc3QgPSBpbnN0Ll9ob3N0UGFyZW50O1xuICB9XG4gIHZhciBpO1xuICBmb3IgKGkgPSBwYXRoLmxlbmd0aDsgaS0tID4gMDspIHtcbiAgICBmbihwYXRoW2ldLCAnY2FwdHVyZWQnLCBhcmcpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aFtpXSwgJ2J1YmJsZWQnLCBhcmcpO1xuICB9XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIHRoZSBJRCBoaWVyYXJjaHkgYW5kIGludm9rZXMgdGhlIHN1cHBsaWVkIGBjYmAgb24gYW55IElEcyB0aGF0XG4gKiBzaG91bGQgd291bGQgcmVjZWl2ZSBhIGBtb3VzZUVudGVyYCBvciBgbW91c2VMZWF2ZWAgZXZlbnQuXG4gKlxuICogRG9lcyBub3QgaW52b2tlIHRoZSBjYWxsYmFjayBvbiB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgYmVjYXVzZSBub3RoaW5nXG4gKiBcImVudGVyZWRcIiBvciBcImxlZnRcIiB0aGF0IGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgZm4sIGFyZ0Zyb20sIGFyZ1RvKSB7XG4gIHZhciBjb21tb24gPSBmcm9tICYmIHRvID8gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoZnJvbSwgdG8pIDogbnVsbDtcbiAgdmFyIHBhdGhGcm9tID0gW107XG4gIHdoaWxlIChmcm9tICYmIGZyb20gIT09IGNvbW1vbikge1xuICAgIHBhdGhGcm9tLnB1c2goZnJvbSk7XG4gICAgZnJvbSA9IGZyb20uX2hvc3RQYXJlbnQ7XG4gIH1cbiAgdmFyIHBhdGhUbyA9IFtdO1xuICB3aGlsZSAodG8gJiYgdG8gIT09IGNvbW1vbikge1xuICAgIHBhdGhUby5wdXNoKHRvKTtcbiAgICB0byA9IHRvLl9ob3N0UGFyZW50O1xuICB9XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgcGF0aEZyb20ubGVuZ3RoOyBpKyspIHtcbiAgICBmbihwYXRoRnJvbVtpXSwgJ2J1YmJsZWQnLCBhcmdGcm9tKTtcbiAgfVxuICBmb3IgKGkgPSBwYXRoVG8ubGVuZ3RoOyBpLS0gPiAwOykge1xuICAgIGZuKHBhdGhUb1tpXSwgJ2NhcHR1cmVkJywgYXJnVG8pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FuY2VzdG9yOiBpc0FuY2VzdG9yLFxuICBnZXRMb3dlc3RDb21tb25BbmNlc3RvcjogZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IsXG4gIGdldFBhcmVudEluc3RhbmNlOiBnZXRQYXJlbnRJbnN0YW5jZSxcbiAgdHJhdmVyc2VUd29QaGFzZTogdHJhdmVyc2VUd29QaGFzZSxcbiAgdHJhdmVyc2VFbnRlckxlYXZlOiB0cmF2ZXJzZUVudGVyTGVhdmVcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01UcmVlVHJhdmVyc2FsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luUmVnaXN0cnknKTtcbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciByZWFjdFByb3BzID0ge1xuICAgIGNoaWxkcmVuOiB0cnVlLFxuICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB0cnVlLFxuICAgIGtleTogdHJ1ZSxcbiAgICByZWY6IHRydWUsXG5cbiAgICBhdXRvRm9jdXM6IHRydWUsXG4gICAgZGVmYXVsdFZhbHVlOiB0cnVlLFxuICAgIHZhbHVlTGluazogdHJ1ZSxcbiAgICBkZWZhdWx0Q2hlY2tlZDogdHJ1ZSxcbiAgICBjaGVja2VkTGluazogdHJ1ZSxcbiAgICBpbm5lckhUTUw6IHRydWUsXG4gICAgc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nOiB0cnVlLFxuICAgIG9uRm9jdXNJbjogdHJ1ZSxcbiAgICBvbkZvY3VzT3V0OiB0cnVlXG4gIH07XG4gIHZhciB3YXJuZWRQcm9wZXJ0aWVzID0ge307XG5cbiAgdmFyIHZhbGlkYXRlUHJvcGVydHkgPSBmdW5jdGlvbiAodGFnTmFtZSwgbmFtZSwgZGVidWdJRCkge1xuICAgIGlmIChET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpIHx8IERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHJlYWN0UHJvcHMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgcmVhY3RQcm9wc1tuYW1lXSB8fCB3YXJuZWRQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIGRhdGEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXG4gICAgdmFyIHN0YW5kYXJkTmFtZSA9IERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKGxvd2VyQ2FzZWROYW1lKSA/IGxvd2VyQ2FzZWROYW1lIDogRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWUuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWVbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcblxuICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IEV2ZW50UGx1Z2luUmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xuXG4gICAgaWYgKHN0YW5kYXJkTmFtZSAhPSBudWxsKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vua25vd24gRE9NIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JXMnLCBuYW1lLCBzdGFuZGFyZE5hbWUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lICE9IG51bGwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5rbm93biBldmVudCBoYW5kbGVyIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIHdlcmUgdW5hYmxlIHRvIGd1ZXNzIHdoaWNoIHByb3AgdGhlIHVzZXIgaW50ZW5kZWQuXG4gICAgICAvLyBJdCBpcyBsaWtlbHkgdGhhdCB0aGUgdXNlciB3YXMganVzdCBibGluZGx5IHNwcmVhZGluZy9mb3J3YXJkaW5nIHByb3BzXG4gICAgICAvLyBDb21wb25lbnRzIHNob3VsZCBiZSBjYXJlZnVsIHRvIG9ubHkgcmVuZGVyIHZhbGlkIHByb3BzL2F0dHJpYnV0ZXMuXG4gICAgICAvLyBXYXJuaW5nIHdpbGwgYmUgaW52b2tlZCBpbiB3YXJuVW5rbm93blByb3BlcnRpZXMgdG8gYWxsb3cgZ3JvdXBpbmcuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xufVxuXG52YXIgd2FyblVua25vd25Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgdmFyIHVua25vd25Qcm9wcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gZWxlbWVudC5wcm9wcykge1xuICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eShlbGVtZW50LnR5cGUsIGtleSwgZGVidWdJRCk7XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICB1bmtub3duUHJvcHMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1bmtub3duUHJvcFN0cmluZyA9IHVua25vd25Qcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgfSkuam9pbignLCAnKTtcblxuICBpZiAodW5rbm93blByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5rbm93biBwcm9wICVzIG9uIDwlcz4gdGFnLiBSZW1vdmUgdGhpcyBwcm9wIGZyb20gdGhlIGVsZW1lbnQuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXVua25vd24tcHJvcCVzJywgdW5rbm93blByb3BTdHJpbmcsIGVsZW1lbnQudHlwZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XG4gIH0gZWxzZSBpZiAodW5rbm93blByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vua25vd24gcHJvcHMgJXMgb24gPCVzPiB0YWcuIFJlbW92ZSB0aGVzZSBwcm9wcyBmcm9tIHRoZSBlbGVtZW50LiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC11bmtub3duLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCBlbGVtZW50LnR5cGUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuICB9XG59O1xuXG5mdW5jdGlvbiBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCB8fCB0eXBlb2YgZWxlbWVudC50eXBlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbWVudC50eXBlLmluZGV4T2YoJy0nKSA+PSAwIHx8IGVsZW1lbnQucHJvcHMuaXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2FyblVua25vd25Qcm9wZXJ0aWVzKGRlYnVnSUQsIGVsZW1lbnQpO1xufVxuXG52YXIgUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rID0ge1xuICBvbkJlZm9yZU1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xuICAgIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCk7XG4gIH0sXG4gIG9uQmVmb3JlVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xuICAgIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vay5qc1xuLy8gbW9kdWxlIGlkID0gMTI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2sgPSByZXF1aXJlKCcuL1JlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2snKTtcbnZhciBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vayA9IHJlcXVpcmUoJy4vUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2snKTtcbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBwZXJmb3JtYW5jZU5vdyA9IHJlcXVpcmUoJ2ZianMvbGliL3BlcmZvcm1hbmNlTm93Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGhvb2tzID0gW107XG52YXIgZGlkSG9va1Rocm93Rm9yRXZlbnQgPSB7fTtcblxuZnVuY3Rpb24gY2FsbEhvb2soZXZlbnQsIGZuLCBjb250ZXh0LCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KSB7XG4gIHRyeSB7XG4gICAgZm4uY2FsbChjb250ZXh0LCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRpZEhvb2tUaHJvd0ZvckV2ZW50W2V2ZW50XSwgJ0V4Y2VwdGlvbiB0aHJvd24gYnkgaG9vayB3aGlsZSBoYW5kbGluZyAlczogJXMnLCBldmVudCwgZSArICdcXG4nICsgZS5zdGFjaykgOiB2b2lkIDA7XG4gICAgZGlkSG9va1Rocm93Rm9yRXZlbnRbZXZlbnRdID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXZlbnQoZXZlbnQsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBob29rID0gaG9va3NbaV07XG4gICAgdmFyIGZuID0gaG9va1tldmVudF07XG4gICAgaWYgKGZuKSB7XG4gICAgICBjYWxsSG9vayhldmVudCwgZm4sIGhvb2ssIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgaXNQcm9maWxpbmcgPSBmYWxzZTtcbnZhciBmbHVzaEhpc3RvcnkgPSBbXTtcbnZhciBsaWZlQ3ljbGVUaW1lclN0YWNrID0gW107XG52YXIgY3VycmVudEZsdXNoTmVzdGluZyA9IDA7XG52YXIgY3VycmVudEZsdXNoTWVhc3VyZW1lbnRzID0gW107XG52YXIgY3VycmVudEZsdXNoU3RhcnRUaW1lID0gMDtcbnZhciBjdXJyZW50VGltZXJEZWJ1Z0lEID0gbnVsbDtcbnZhciBjdXJyZW50VGltZXJTdGFydFRpbWUgPSAwO1xudmFyIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb24gPSAwO1xudmFyIGN1cnJlbnRUaW1lclR5cGUgPSBudWxsO1xuXG52YXIgbGlmZUN5Y2xlVGltZXJIYXNXYXJuZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gY2xlYXJIaXN0b3J5KCkge1xuICBSZWFjdENvbXBvbmVudFRyZWVIb29rLnB1cmdlVW5tb3VudGVkQ29tcG9uZW50cygpO1xuICBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vay5jbGVhckhpc3RvcnkoKTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJlZVNuYXBzaG90KHJlZ2lzdGVyZWRJRHMpIHtcbiAgcmV0dXJuIHJlZ2lzdGVyZWRJRHMucmVkdWNlKGZ1bmN0aW9uICh0cmVlLCBpZCkge1xuICAgIHZhciBvd25lcklEID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRPd25lcklEKGlkKTtcbiAgICB2YXIgcGFyZW50SUQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFBhcmVudElEKGlkKTtcbiAgICB0cmVlW2lkXSA9IHtcbiAgICAgIGRpc3BsYXlOYW1lOiBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldERpc3BsYXlOYW1lKGlkKSxcbiAgICAgIHRleHQ6IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0VGV4dChpZCksXG4gICAgICB1cGRhdGVDb3VudDogUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRVcGRhdGVDb3VudChpZCksXG4gICAgICBjaGlsZElEczogUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRDaGlsZElEcyhpZCksXG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUgb3duZXJzIGJ1dCB0aGlzIGlzIGNsb3NlIGVub3VnaC5cbiAgICAgIG93bmVySUQ6IG93bmVySUQgfHwgcGFyZW50SUQgJiYgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRPd25lcklEKHBhcmVudElEKSB8fCAwLFxuICAgICAgcGFyZW50SUQ6IHBhcmVudElEXG4gICAgfTtcbiAgICByZXR1cm4gdHJlZTtcbiAgfSwge30pO1xufVxuXG5mdW5jdGlvbiByZXNldE1lYXN1cmVtZW50cygpIHtcbiAgdmFyIHByZXZpb3VzU3RhcnRUaW1lID0gY3VycmVudEZsdXNoU3RhcnRUaW1lO1xuICB2YXIgcHJldmlvdXNNZWFzdXJlbWVudHMgPSBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHM7XG4gIHZhciBwcmV2aW91c09wZXJhdGlvbnMgPSBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vay5nZXRIaXN0b3J5KCk7XG5cbiAgaWYgKGN1cnJlbnRGbHVzaE5lc3RpbmcgPT09IDApIHtcbiAgICBjdXJyZW50Rmx1c2hTdGFydFRpbWUgPSAwO1xuICAgIGN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cyA9IFtdO1xuICAgIGNsZWFySGlzdG9yeSgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChwcmV2aW91c01lYXN1cmVtZW50cy5sZW5ndGggfHwgcHJldmlvdXNPcGVyYXRpb25zLmxlbmd0aCkge1xuICAgIHZhciByZWdpc3RlcmVkSURzID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRSZWdpc3RlcmVkSURzKCk7XG4gICAgZmx1c2hIaXN0b3J5LnB1c2goe1xuICAgICAgZHVyYXRpb246IHBlcmZvcm1hbmNlTm93KCkgLSBwcmV2aW91c1N0YXJ0VGltZSxcbiAgICAgIG1lYXN1cmVtZW50czogcHJldmlvdXNNZWFzdXJlbWVudHMgfHwgW10sXG4gICAgICBvcGVyYXRpb25zOiBwcmV2aW91c09wZXJhdGlvbnMgfHwgW10sXG4gICAgICB0cmVlU25hcHNob3Q6IGdldFRyZWVTbmFwc2hvdChyZWdpc3RlcmVkSURzKVxuICAgIH0pO1xuICB9XG5cbiAgY2xlYXJIaXN0b3J5KCk7XG4gIGN1cnJlbnRGbHVzaFN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG4gIGN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cyA9IFtdO1xufVxuXG5mdW5jdGlvbiBjaGVja0RlYnVnSUQoZGVidWdJRCkge1xuICB2YXIgYWxsb3dSb290ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICBpZiAoYWxsb3dSb290ICYmIGRlYnVnSUQgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFkZWJ1Z0lEKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdERlYnVnVG9vbDogZGVidWdJRCBtYXkgbm90IGJlIGVtcHR5LicpIDogdm9pZCAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJlZ2luTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKSB7XG4gIGlmIChjdXJyZW50Rmx1c2hOZXN0aW5nID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChjdXJyZW50VGltZXJUeXBlICYmICFsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVGhlcmUgaXMgYW4gaW50ZXJuYWwgZXJyb3IgaW4gdGhlIFJlYWN0IHBlcmZvcm1hbmNlIG1lYXN1cmVtZW50IGNvZGUuICcgKyAnRGlkIG5vdCBleHBlY3QgJXMgdGltZXIgdG8gc3RhcnQgd2hpbGUgJXMgdGltZXIgaXMgc3RpbGwgaW4gJyArICdwcm9ncmVzcyBmb3IgJXMgaW5zdGFuY2UuJywgdGltZXJUeXBlLCBjdXJyZW50VGltZXJUeXBlIHx8ICdubycsIGRlYnVnSUQgPT09IGN1cnJlbnRUaW1lckRlYnVnSUQgPyAndGhlIHNhbWUnIDogJ2Fub3RoZXInKSA6IHZvaWQgMDtcbiAgICBsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCA9IHRydWU7XG4gIH1cbiAgY3VycmVudFRpbWVyU3RhcnRUaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiA9IDA7XG4gIGN1cnJlbnRUaW1lckRlYnVnSUQgPSBkZWJ1Z0lEO1xuICBjdXJyZW50VGltZXJUeXBlID0gdGltZXJUeXBlO1xufVxuXG5mdW5jdGlvbiBlbmRMaWZlQ3ljbGVUaW1lcihkZWJ1Z0lELCB0aW1lclR5cGUpIHtcbiAgaWYgKGN1cnJlbnRGbHVzaE5lc3RpbmcgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGN1cnJlbnRUaW1lclR5cGUgIT09IHRpbWVyVHlwZSAmJiAhbGlmZUN5Y2xlVGltZXJIYXNXYXJuZWQpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1RoZXJlIGlzIGFuIGludGVybmFsIGVycm9yIGluIHRoZSBSZWFjdCBwZXJmb3JtYW5jZSBtZWFzdXJlbWVudCBjb2RlLiAnICsgJ1dlIGRpZCBub3QgZXhwZWN0ICVzIHRpbWVyIHRvIHN0b3Agd2hpbGUgJXMgdGltZXIgaXMgc3RpbGwgaW4gJyArICdwcm9ncmVzcyBmb3IgJXMgaW5zdGFuY2UuIFBsZWFzZSByZXBvcnQgdGhpcyBhcyBhIGJ1ZyBpbiBSZWFjdC4nLCB0aW1lclR5cGUsIGN1cnJlbnRUaW1lclR5cGUgfHwgJ25vJywgZGVidWdJRCA9PT0gY3VycmVudFRpbWVyRGVidWdJRCA/ICd0aGUgc2FtZScgOiAnYW5vdGhlcicpIDogdm9pZCAwO1xuICAgIGxpZmVDeWNsZVRpbWVySGFzV2FybmVkID0gdHJ1ZTtcbiAgfVxuICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHMucHVzaCh7XG4gICAgICB0aW1lclR5cGU6IHRpbWVyVHlwZSxcbiAgICAgIGluc3RhbmNlSUQ6IGRlYnVnSUQsXG4gICAgICBkdXJhdGlvbjogcGVyZm9ybWFuY2VOb3coKSAtIGN1cnJlbnRUaW1lclN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb25cbiAgICB9KTtcbiAgfVxuICBjdXJyZW50VGltZXJTdGFydFRpbWUgPSAwO1xuICBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uID0gMDtcbiAgY3VycmVudFRpbWVyRGVidWdJRCA9IG51bGw7XG4gIGN1cnJlbnRUaW1lclR5cGUgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBwYXVzZUN1cnJlbnRMaWZlQ3ljbGVUaW1lcigpIHtcbiAgdmFyIGN1cnJlbnRUaW1lciA9IHtcbiAgICBzdGFydFRpbWU6IGN1cnJlbnRUaW1lclN0YXJ0VGltZSxcbiAgICBuZXN0ZWRGbHVzaFN0YXJ0VGltZTogcGVyZm9ybWFuY2VOb3coKSxcbiAgICBkZWJ1Z0lEOiBjdXJyZW50VGltZXJEZWJ1Z0lELFxuICAgIHRpbWVyVHlwZTogY3VycmVudFRpbWVyVHlwZVxuICB9O1xuICBsaWZlQ3ljbGVUaW1lclN0YWNrLnB1c2goY3VycmVudFRpbWVyKTtcbiAgY3VycmVudFRpbWVyU3RhcnRUaW1lID0gMDtcbiAgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiA9IDA7XG4gIGN1cnJlbnRUaW1lckRlYnVnSUQgPSBudWxsO1xuICBjdXJyZW50VGltZXJUeXBlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVzdW1lQ3VycmVudExpZmVDeWNsZVRpbWVyKCkge1xuICB2YXIgX2xpZmVDeWNsZVRpbWVyU3RhY2skID0gbGlmZUN5Y2xlVGltZXJTdGFjay5wb3AoKSxcbiAgICAgIHN0YXJ0VGltZSA9IF9saWZlQ3ljbGVUaW1lclN0YWNrJC5zdGFydFRpbWUsXG4gICAgICBuZXN0ZWRGbHVzaFN0YXJ0VGltZSA9IF9saWZlQ3ljbGVUaW1lclN0YWNrJC5uZXN0ZWRGbHVzaFN0YXJ0VGltZSxcbiAgICAgIGRlYnVnSUQgPSBfbGlmZUN5Y2xlVGltZXJTdGFjayQuZGVidWdJRCxcbiAgICAgIHRpbWVyVHlwZSA9IF9saWZlQ3ljbGVUaW1lclN0YWNrJC50aW1lclR5cGU7XG5cbiAgdmFyIG5lc3RlZEZsdXNoRHVyYXRpb24gPSBwZXJmb3JtYW5jZU5vdygpIC0gbmVzdGVkRmx1c2hTdGFydFRpbWU7XG4gIGN1cnJlbnRUaW1lclN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiArPSBuZXN0ZWRGbHVzaER1cmF0aW9uO1xuICBjdXJyZW50VGltZXJEZWJ1Z0lEID0gZGVidWdJRDtcbiAgY3VycmVudFRpbWVyVHlwZSA9IHRpbWVyVHlwZTtcbn1cblxudmFyIGxhc3RNYXJrVGltZVN0YW1wID0gMDtcbnZhciBjYW5Vc2VQZXJmb3JtYW5jZU1lYXN1cmUgPVxuLy8gJEZsb3dGaXhNZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjM0NVxudHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UubWFyayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UubWVhc3VyZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcyA9PT0gJ2Z1bmN0aW9uJztcblxuZnVuY3Rpb24gc2hvdWxkTWFyayhkZWJ1Z0lEKSB7XG4gIGlmICghaXNQcm9maWxpbmcgfHwgIWNhblVzZVBlcmZvcm1hbmNlTWVhc3VyZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChkZWJ1Z0lEKTtcbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCB8fCB0eXBlb2YgZWxlbWVudCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGlzSG9zdEVsZW1lbnQgPSB0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJztcbiAgaWYgKGlzSG9zdEVsZW1lbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG1hcmtCZWdpbihkZWJ1Z0lELCBtYXJrVHlwZSkge1xuICBpZiAoIXNob3VsZE1hcmsoZGVidWdJRCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbWFya05hbWUgPSBkZWJ1Z0lEICsgJzo6JyArIG1hcmtUeXBlO1xuICBsYXN0TWFya1RpbWVTdGFtcCA9IHBlcmZvcm1hbmNlTm93KCk7XG4gIHBlcmZvcm1hbmNlLm1hcmsobWFya05hbWUpO1xufVxuXG5mdW5jdGlvbiBtYXJrRW5kKGRlYnVnSUQsIG1hcmtUeXBlKSB7XG4gIGlmICghc2hvdWxkTWFyayhkZWJ1Z0lEKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBtYXJrTmFtZSA9IGRlYnVnSUQgKyAnOjonICsgbWFya1R5cGU7XG4gIHZhciBkaXNwbGF5TmFtZSA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RGlzcGxheU5hbWUoZGVidWdJRCkgfHwgJ1Vua25vd24nO1xuXG4gIC8vIENocm9tZSBoYXMgYW4gaXNzdWUgb2YgZHJvcHBpbmcgbWFya2VycyByZWNvcmRlZCB0b28gZmFzdDpcbiAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NjQwNjUyXG4gIC8vIFRvIHdvcmsgYXJvdW5kIHRoaXMsIHdlIHdpbGwgbm90IHJlcG9ydCB2ZXJ5IHNtYWxsIG1lYXN1cmVtZW50cy5cbiAgLy8gSSBkZXRlcm1pbmVkIHRoZSBtYWdpYyBudW1iZXIgYnkgdHdlYWtpbmcgaXQgYmFjayBhbmQgZm9ydGguXG4gIC8vIDAuMDVtcyB3YXMgZW5vdWdoIHRvIHByZXZlbnQgdGhlIGlzc3VlLCBidXQgSSBzZXQgaXQgdG8gMC4xbXMgdG8gYmUgc2FmZS5cbiAgLy8gV2hlbiB0aGUgYnVnIGlzIGZpeGVkLCB3ZSBjYW4gYG1lYXN1cmUoKWAgdW5jb25kaXRpb25hbGx5IGlmIHdlIHdhbnQgdG8uXG4gIHZhciB0aW1lU3RhbXAgPSBwZXJmb3JtYW5jZU5vdygpO1xuICBpZiAodGltZVN0YW1wIC0gbGFzdE1hcmtUaW1lU3RhbXAgPiAwLjEpIHtcbiAgICB2YXIgbWVhc3VyZW1lbnROYW1lID0gZGlzcGxheU5hbWUgKyAnIFsnICsgbWFya1R5cGUgKyAnXSc7XG4gICAgcGVyZm9ybWFuY2UubWVhc3VyZShtZWFzdXJlbWVudE5hbWUsIG1hcmtOYW1lKTtcbiAgfVxuXG4gIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MobWFya05hbWUpO1xuICBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKG1lYXN1cmVtZW50TmFtZSk7XG59XG5cbnZhciBSZWFjdERlYnVnVG9vbCA9IHtcbiAgYWRkSG9vazogZnVuY3Rpb24gKGhvb2spIHtcbiAgICBob29rcy5wdXNoKGhvb2spO1xuICB9LFxuICByZW1vdmVIb29rOiBmdW5jdGlvbiAoaG9vaykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChob29rc1tpXSA9PT0gaG9vaykge1xuICAgICAgICBob29rcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGlzUHJvZmlsaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzUHJvZmlsaW5nO1xuICB9LFxuICBiZWdpblByb2ZpbGluZzogZnVuY3Rpb24gKCkge1xuICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlzUHJvZmlsaW5nID0gdHJ1ZTtcbiAgICBmbHVzaEhpc3RvcnkubGVuZ3RoID0gMDtcbiAgICByZXNldE1lYXN1cmVtZW50cygpO1xuICAgIFJlYWN0RGVidWdUb29sLmFkZEhvb2soUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2spO1xuICB9LFxuICBlbmRQcm9maWxpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWlzUHJvZmlsaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaXNQcm9maWxpbmcgPSBmYWxzZTtcbiAgICByZXNldE1lYXN1cmVtZW50cygpO1xuICAgIFJlYWN0RGVidWdUb29sLnJlbW92ZUhvb2soUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2spO1xuICB9LFxuICBnZXRGbHVzaEhpc3Rvcnk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmx1c2hIaXN0b3J5O1xuICB9LFxuICBvbkJlZ2luRmx1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICBjdXJyZW50Rmx1c2hOZXN0aW5nKys7XG4gICAgcmVzZXRNZWFzdXJlbWVudHMoKTtcbiAgICBwYXVzZUN1cnJlbnRMaWZlQ3ljbGVUaW1lcigpO1xuICAgIGVtaXRFdmVudCgnb25CZWdpbkZsdXNoJyk7XG4gIH0sXG4gIG9uRW5kRmx1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICByZXNldE1lYXN1cmVtZW50cygpO1xuICAgIGN1cnJlbnRGbHVzaE5lc3RpbmctLTtcbiAgICByZXN1bWVDdXJyZW50TGlmZUN5Y2xlVGltZXIoKTtcbiAgICBlbWl0RXZlbnQoJ29uRW5kRmx1c2gnKTtcbiAgfSxcbiAgb25CZWdpbkxpZmVDeWNsZVRpbWVyOiBmdW5jdGlvbiAoZGVidWdJRCwgdGltZXJUeXBlKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGVtaXRFdmVudCgnb25CZWdpbkxpZmVDeWNsZVRpbWVyJywgZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgICBtYXJrQmVnaW4oZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgICBiZWdpbkxpZmVDeWNsZVRpbWVyKGRlYnVnSUQsIHRpbWVyVHlwZSk7XG4gIH0sXG4gIG9uRW5kTGlmZUN5Y2xlVGltZXI6IGZ1bmN0aW9uIChkZWJ1Z0lELCB0aW1lclR5cGUpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgZW5kTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgICBtYXJrRW5kKGRlYnVnSUQsIHRpbWVyVHlwZSk7XG4gICAgZW1pdEV2ZW50KCdvbkVuZExpZmVDeWNsZVRpbWVyJywgZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgfSxcbiAgb25CZWdpblByb2Nlc3NpbmdDaGlsZENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICBlbWl0RXZlbnQoJ29uQmVnaW5Qcm9jZXNzaW5nQ2hpbGRDb250ZXh0Jyk7XG4gIH0sXG4gIG9uRW5kUHJvY2Vzc2luZ0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIGVtaXRFdmVudCgnb25FbmRQcm9jZXNzaW5nQ2hpbGRDb250ZXh0Jyk7XG4gIH0sXG4gIG9uSG9zdE9wZXJhdGlvbjogZnVuY3Rpb24gKG9wZXJhdGlvbikge1xuICAgIGNoZWNrRGVidWdJRChvcGVyYXRpb24uaW5zdGFuY2VJRCk7XG4gICAgZW1pdEV2ZW50KCdvbkhvc3RPcGVyYXRpb24nLCBvcGVyYXRpb24pO1xuICB9LFxuICBvblNldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgZW1pdEV2ZW50KCdvblNldFN0YXRlJyk7XG4gIH0sXG4gIG9uU2V0Q2hpbGRyZW46IGZ1bmN0aW9uIChkZWJ1Z0lELCBjaGlsZERlYnVnSURzKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGNoaWxkRGVidWdJRHMuZm9yRWFjaChjaGVja0RlYnVnSUQpO1xuICAgIGVtaXRFdmVudCgnb25TZXRDaGlsZHJlbicsIGRlYnVnSUQsIGNoaWxkRGVidWdJRHMpO1xuICB9LFxuICBvbkJlZm9yZU1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCwgcGFyZW50RGVidWdJRCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBjaGVja0RlYnVnSUQocGFyZW50RGVidWdJRCwgdHJ1ZSk7XG4gICAgZW1pdEV2ZW50KCdvbkJlZm9yZU1vdW50Q29tcG9uZW50JywgZGVidWdJRCwgZWxlbWVudCwgcGFyZW50RGVidWdJRCk7XG4gICAgbWFya0JlZ2luKGRlYnVnSUQsICdtb3VudCcpO1xuICB9LFxuICBvbk1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBtYXJrRW5kKGRlYnVnSUQsICdtb3VudCcpO1xuICAgIGVtaXRFdmVudCgnb25Nb3VudENvbXBvbmVudCcsIGRlYnVnSUQpO1xuICB9LFxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgZW1pdEV2ZW50KCdvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudCcsIGRlYnVnSUQsIGVsZW1lbnQpO1xuICAgIG1hcmtCZWdpbihkZWJ1Z0lELCAndXBkYXRlJyk7XG4gIH0sXG4gIG9uVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBtYXJrRW5kKGRlYnVnSUQsICd1cGRhdGUnKTtcbiAgICBlbWl0RXZlbnQoJ29uVXBkYXRlQ29tcG9uZW50JywgZGVidWdJRCk7XG4gIH0sXG4gIG9uQmVmb3JlVW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgZW1pdEV2ZW50KCdvbkJlZm9yZVVubW91bnRDb21wb25lbnQnLCBkZWJ1Z0lEKTtcbiAgICBtYXJrQmVnaW4oZGVidWdJRCwgJ3VubW91bnQnKTtcbiAgfSxcbiAgb25Vbm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBtYXJrRW5kKGRlYnVnSUQsICd1bm1vdW50Jyk7XG4gICAgZW1pdEV2ZW50KCdvblVubW91bnRDb21wb25lbnQnLCBkZWJ1Z0lEKTtcbiAgfSxcbiAgb25UZXN0RXZlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBlbWl0RXZlbnQoJ29uVGVzdEV2ZW50Jyk7XG4gIH1cbn07XG5cbi8vIFRPRE8gcmVtb3ZlIHRoZXNlIHdoZW4gUk4vd3d3IGdldHMgdXBkYXRlZFxuUmVhY3REZWJ1Z1Rvb2wuYWRkRGV2dG9vbCA9IFJlYWN0RGVidWdUb29sLmFkZEhvb2s7XG5SZWFjdERlYnVnVG9vbC5yZW1vdmVEZXZ0b29sID0gUmVhY3REZWJ1Z1Rvb2wucmVtb3ZlSG9vaztcblxuUmVhY3REZWJ1Z1Rvb2wuYWRkSG9vayhSZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rKTtcblJlYWN0RGVidWdUb29sLmFkZEhvb2soUmVhY3RDb21wb25lbnRUcmVlSG9vayk7XG52YXIgdXJsID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHdpbmRvdy5sb2NhdGlvbi5ocmVmIHx8ICcnO1xuaWYgKC9bPyZdcmVhY3RfcGVyZlxcYi8udGVzdCh1cmwpKSB7XG4gIFJlYWN0RGVidWdUb29sLmJlZ2luUHJvZmlsaW5nKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3REZWJ1Z1Rvb2w7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3REZWJ1Z1Rvb2wuanNcbi8vIG1vZHVsZSBpZCA9IDEyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xuXG52YXIgUkVTRVRfQkFUQ0hFRF9VUERBVEVTID0ge1xuICBpbml0aWFsaXplOiBlbXB0eUZ1bmN0aW9uLFxuICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcbiAgfVxufTtcblxudmFyIEZMVVNIX0JBVENIRURfVVBEQVRFUyA9IHtcbiAgaW5pdGlhbGl6ZTogZW1wdHlGdW5jdGlvbixcbiAgY2xvc2U6IFJlYWN0VXBkYXRlcy5mbHVzaEJhdGNoZWRVcGRhdGVzLmJpbmQoUmVhY3RVcGRhdGVzKVxufTtcblxudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW0ZMVVNIX0JBVENIRURfVVBEQVRFUywgUkVTRVRfQkFUQ0hFRF9VUERBVEVTXTtcblxuZnVuY3Rpb24gUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uKCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG59XG5cbl9hc3NpZ24oUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24sIHtcbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfVxufSk7XG5cbnZhciB0cmFuc2FjdGlvbiA9IG5ldyBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24oKTtcblxudmFyIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kgPSB7XG4gIGlzQmF0Y2hpbmdVcGRhdGVzOiBmYWxzZSxcblxuICAvKipcbiAgICogQ2FsbCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gaW4gYSBjb250ZXh0IHdpdGhpbiB3aGljaCBjYWxscyB0byBgc2V0U3RhdGVgXG4gICAqIGFuZCBmcmllbmRzIGFyZSBiYXRjaGVkIHN1Y2ggdGhhdCBjb21wb25lbnRzIGFyZW4ndCB1cGRhdGVkIHVubmVjZXNzYXJpbHkuXG4gICAqL1xuICBiYXRjaGVkVXBkYXRlczogZnVuY3Rpb24gKGNhbGxiYWNrLCBhLCBiLCBjLCBkLCBlKSB7XG4gICAgdmFyIGFscmVhZHlCYXRjaGluZ1VwZGF0ZXMgPSBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzO1xuXG4gICAgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG5cbiAgICAvLyBUaGUgY29kZSBpcyB3cml0dGVuIHRoaXMgd2F5IHRvIGF2b2lkIGV4dHJhIGFsbG9jYXRpb25zXG4gICAgaWYgKGFscmVhZHlCYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhhLCBiLCBjLCBkLCBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uLnBlcmZvcm0oY2FsbGJhY2ssIG51bGwsIGEsIGIsIGMsIGQsIGUpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuanNcbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQVJJQURPTVByb3BlcnR5Q29uZmlnID0gcmVxdWlyZSgnLi9BUklBRE9NUHJvcGVydHlDb25maWcnKTtcbnZhciBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9CZWZvcmVJbnB1dEV2ZW50UGx1Z2luJyk7XG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL0NoYW5nZUV2ZW50UGx1Z2luJyk7XG52YXIgRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIgPSByZXF1aXJlKCcuL0RlZmF1bHRFdmVudFBsdWdpbk9yZGVyJyk7XG52YXIgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9FbnRlckxlYXZlRXZlbnRQbHVnaW4nKTtcbnZhciBIVE1MRE9NUHJvcGVydHlDb25maWcgPSByZXF1aXJlKCcuL0hUTUxET01Qcm9wZXJ0eUNvbmZpZycpO1xudmFyIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudCcpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RET01FbXB0eUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RET01FbXB0eUNvbXBvbmVudCcpO1xudmFyIFJlYWN0RE9NVHJlZVRyYXZlcnNhbCA9IHJlcXVpcmUoJy4vUmVhY3RET01UcmVlVHJhdmVyc2FsJyk7XG52YXIgUmVhY3RET01UZXh0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdERPTVRleHRDb21wb25lbnQnKTtcbnZhciBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5ID0gcmVxdWlyZSgnLi9SZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5Jyk7XG52YXIgUmVhY3RFdmVudExpc3RlbmVyID0gcmVxdWlyZSgnLi9SZWFjdEV2ZW50TGlzdGVuZXInKTtcbnZhciBSZWFjdEluamVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbmplY3Rpb24nKTtcbnZhciBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uJyk7XG52YXIgU1ZHRE9NUHJvcGVydHlDb25maWcgPSByZXF1aXJlKCcuL1NWR0RPTVByb3BlcnR5Q29uZmlnJyk7XG52YXIgU2VsZWN0RXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL1NlbGVjdEV2ZW50UGx1Z2luJyk7XG52YXIgU2ltcGxlRXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL1NpbXBsZUV2ZW50UGx1Z2luJyk7XG5cbnZhciBhbHJlYWR5SW5qZWN0ZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaW5qZWN0KCkge1xuICBpZiAoYWxyZWFkeUluamVjdGVkKSB7XG4gICAgLy8gVE9ETzogVGhpcyBpcyBjdXJyZW50bHkgdHJ1ZSBiZWNhdXNlIHRoZXNlIGluamVjdGlvbnMgYXJlIHNoYXJlZCBiZXR3ZWVuXG4gICAgLy8gdGhlIGNsaWVudCBhbmQgdGhlIHNlcnZlciBwYWNrYWdlLiBUaGV5IHNob3VsZCBiZSBidWlsdCBpbmRlcGVuZGVudGx5XG4gICAgLy8gYW5kIG5vdCBzaGFyZSBhbnkgaW5qZWN0aW9uIHN0YXRlLiBUaGVuIHRoaXMgcHJvYmxlbSB3aWxsIGJlIHNvbHZlZC5cbiAgICByZXR1cm47XG4gIH1cbiAgYWxyZWFkeUluamVjdGVkID0gdHJ1ZTtcblxuICBSZWFjdEluamVjdGlvbi5FdmVudEVtaXR0ZXIuaW5qZWN0UmVhY3RFdmVudExpc3RlbmVyKFJlYWN0RXZlbnRMaXN0ZW5lcik7XG5cbiAgLyoqXG4gICAqIEluamVjdCBtb2R1bGVzIGZvciByZXNvbHZpbmcgRE9NIGhpZXJhcmNoeSBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICAgKi9cbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0RXZlbnRQbHVnaW5PcmRlcihEZWZhdWx0RXZlbnRQbHVnaW5PcmRlcik7XG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luVXRpbHMuaW5qZWN0Q29tcG9uZW50VHJlZShSZWFjdERPTUNvbXBvbmVudFRyZWUpO1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpblV0aWxzLmluamVjdFRyZWVUcmF2ZXJzYWwoUmVhY3RET01UcmVlVHJhdmVyc2FsKTtcblxuICAvKipcbiAgICogU29tZSBpbXBvcnRhbnQgZXZlbnQgcGx1Z2lucyBpbmNsdWRlZCBieSBkZWZhdWx0ICh3aXRob3V0IGhhdmluZyB0byByZXF1aXJlXG4gICAqIHRoZW0pLlxuICAgKi9cbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtcbiAgICBTaW1wbGVFdmVudFBsdWdpbjogU2ltcGxlRXZlbnRQbHVnaW4sXG4gICAgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOiBFbnRlckxlYXZlRXZlbnRQbHVnaW4sXG4gICAgQ2hhbmdlRXZlbnRQbHVnaW46IENoYW5nZUV2ZW50UGx1Z2luLFxuICAgIFNlbGVjdEV2ZW50UGx1Z2luOiBTZWxlY3RFdmVudFBsdWdpbixcbiAgICBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luOiBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXG4gIH0pO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkhvc3RDb21wb25lbnQuaW5qZWN0R2VuZXJpY0NvbXBvbmVudENsYXNzKFJlYWN0RE9NQ29tcG9uZW50KTtcblxuICBSZWFjdEluamVjdGlvbi5Ib3N0Q29tcG9uZW50LmluamVjdFRleHRDb21wb25lbnRDbGFzcyhSZWFjdERPTVRleHRDb21wb25lbnQpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkRPTVByb3BlcnR5LmluamVjdERPTVByb3BlcnR5Q29uZmlnKEFSSUFET01Qcm9wZXJ0eUNvbmZpZyk7XG4gIFJlYWN0SW5qZWN0aW9uLkRPTVByb3BlcnR5LmluamVjdERPTVByb3BlcnR5Q29uZmlnKEhUTUxET01Qcm9wZXJ0eUNvbmZpZyk7XG4gIFJlYWN0SW5qZWN0aW9uLkRPTVByb3BlcnR5LmluamVjdERPTVByb3BlcnR5Q29uZmlnKFNWR0RPTVByb3BlcnR5Q29uZmlnKTtcblxuICBSZWFjdEluamVjdGlvbi5FbXB0eUNvbXBvbmVudC5pbmplY3RFbXB0eUNvbXBvbmVudEZhY3RvcnkoZnVuY3Rpb24gKGluc3RhbnRpYXRlKSB7XG4gICAgcmV0dXJuIG5ldyBSZWFjdERPTUVtcHR5Q29tcG9uZW50KGluc3RhbnRpYXRlKTtcbiAgfSk7XG5cbiAgUmVhY3RJbmplY3Rpb24uVXBkYXRlcy5pbmplY3RSZWNvbmNpbGVUcmFuc2FjdGlvbihSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uKTtcbiAgUmVhY3RJbmplY3Rpb24uVXBkYXRlcy5pbmplY3RCYXRjaGluZ1N0cmF0ZWd5KFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkNvbXBvbmVudC5pbmplY3RFbnZpcm9ubWVudChSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpbmplY3Q6IGluamVjdFxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdERlZmF1bHRJbmplY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDEyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XG5cbmZ1bmN0aW9uIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cykge1xuICBFdmVudFBsdWdpbkh1Yi5lbnF1ZXVlRXZlbnRzKGV2ZW50cyk7XG4gIEV2ZW50UGx1Z2luSHViLnByb2Nlc3NFdmVudFF1ZXVlKGZhbHNlKTtcbn1cblxudmFyIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIFN0cmVhbXMgYSBmaXJlZCB0b3AtbGV2ZWwgZXZlbnQgdG8gYEV2ZW50UGx1Z2luSHViYCB3aGVyZSBwbHVnaW5zIGhhdmUgdGhlXG4gICAqIG9wcG9ydHVuaXR5IHRvIGNyZWF0ZSBgUmVhY3RFdmVudGBzIHRvIGJlIGRpc3BhdGNoZWQuXG4gICAqL1xuICBoYW5kbGVUb3BMZXZlbDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGV2ZW50cyA9IEV2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cyk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFdmVudEVtaXR0ZXJNaXhpbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdEV2ZW50RW1pdHRlck1peGluLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBFdmVudExpc3RlbmVyID0gcmVxdWlyZSgnZmJqcy9saWIvRXZlbnRMaXN0ZW5lcicpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBnZXRFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRUYXJnZXQnKTtcbnZhciBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2dldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uJyk7XG5cbi8qKlxuICogRmluZCB0aGUgZGVlcGVzdCBSZWFjdCBjb21wb25lbnQgY29tcGxldGVseSBjb250YWluaW5nIHRoZSByb290IG9mIHRoZVxuICogcGFzc2VkLWluIGluc3RhbmNlIChmb3IgdXNlIHdoZW4gZW50aXJlIFJlYWN0IHRyZWVzIGFyZSBuZXN0ZWQgd2l0aGluIGVhY2hcbiAqIG90aGVyKS4gSWYgUmVhY3QgdHJlZXMgYXJlIG5vdCBuZXN0ZWQsIHJldHVybnMgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZmluZFBhcmVudChpbnN0KSB7XG4gIC8vIFRPRE86IEl0IG1heSBiZSBhIGdvb2QgaWRlYSB0byBjYWNoZSB0aGlzIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgRE9NXG4gIC8vIHRyYXZlcnNhbCwgYnV0IGNhY2hpbmcgaXMgZGlmZmljdWx0IHRvIGRvIGNvcnJlY3RseSB3aXRob3V0IHVzaW5nIGFcbiAgLy8gbXV0YXRpb24gb2JzZXJ2ZXIgdG8gbGlzdGVuIGZvciBhbGwgRE9NIGNoYW5nZXMuXG4gIHdoaWxlIChpbnN0Ll9ob3N0UGFyZW50KSB7XG4gICAgaW5zdCA9IGluc3QuX2hvc3RQYXJlbnQ7XG4gIH1cbiAgdmFyIHJvb3ROb2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gIHZhciBjb250YWluZXIgPSByb290Tm9kZS5wYXJlbnROb2RlO1xuICByZXR1cm4gUmVhY3RET01Db21wb25lbnRUcmVlLmdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKGNvbnRhaW5lcik7XG59XG5cbi8vIFVzZWQgdG8gc3RvcmUgYW5jZXN0b3IgaGllcmFyY2h5IGluIHRvcCBsZXZlbCBjYWxsYmFja1xuZnVuY3Rpb24gVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgdGhpcy50b3BMZXZlbFR5cGUgPSB0b3BMZXZlbFR5cGU7XG4gIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgdGhpcy5hbmNlc3RvcnMgPSBbXTtcbn1cbl9hc3NpZ24oVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLnByb3RvdHlwZSwge1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50b3BMZXZlbFR5cGUgPSBudWxsO1xuICAgIHRoaXMubmF0aXZlRXZlbnQgPSBudWxsO1xuICAgIHRoaXMuYW5jZXN0b3JzLmxlbmd0aCA9IDA7XG4gIH1cbn0pO1xuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZywgUG9vbGVkQ2xhc3MudHdvQXJndW1lbnRQb29sZXIpO1xuXG5mdW5jdGlvbiBoYW5kbGVUb3BMZXZlbEltcGwoYm9va0tlZXBpbmcpIHtcbiAgdmFyIG5hdGl2ZUV2ZW50VGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpO1xuICB2YXIgdGFyZ2V0SW5zdCA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgLy8gTG9vcCB0aHJvdWdoIHRoZSBoaWVyYXJjaHksIGluIGNhc2UgdGhlcmUncyBhbnkgbmVzdGVkIGNvbXBvbmVudHMuXG4gIC8vIEl0J3MgaW1wb3J0YW50IHRoYXQgd2UgYnVpbGQgdGhlIGFycmF5IG9mIGFuY2VzdG9ycyBiZWZvcmUgY2FsbGluZyBhbnlcbiAgLy8gZXZlbnQgaGFuZGxlcnMsIGJlY2F1c2UgZXZlbnQgaGFuZGxlcnMgY2FuIG1vZGlmeSB0aGUgRE9NLCBsZWFkaW5nIHRvXG4gIC8vIGluY29uc2lzdGVuY2llcyB3aXRoIFJlYWN0TW91bnQncyBub2RlIGNhY2hlLiBTZWUgIzExMDUuXG4gIHZhciBhbmNlc3RvciA9IHRhcmdldEluc3Q7XG4gIGRvIHtcbiAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChhbmNlc3Rvcik7XG4gICAgYW5jZXN0b3IgPSBhbmNlc3RvciAmJiBmaW5kUGFyZW50KGFuY2VzdG9yKTtcbiAgfSB3aGlsZSAoYW5jZXN0b3IpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYm9va0tlZXBpbmcuYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFyZ2V0SW5zdCA9IGJvb2tLZWVwaW5nLmFuY2VzdG9yc1tpXTtcbiAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2hhbmRsZVRvcExldmVsKGJvb2tLZWVwaW5nLnRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgYm9va0tlZXBpbmcubmF0aXZlRXZlbnQsIGdldEV2ZW50VGFyZ2V0KGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50KSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2Nyb2xsVmFsdWVNb25pdG9yKGNiKSB7XG4gIHZhciBzY3JvbGxQb3NpdGlvbiA9IGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uKHdpbmRvdyk7XG4gIGNiKHNjcm9sbFBvc2l0aW9uKTtcbn1cblxudmFyIFJlYWN0RXZlbnRMaXN0ZW5lciA9IHtcbiAgX2VuYWJsZWQ6IHRydWUsXG4gIF9oYW5kbGVUb3BMZXZlbDogbnVsbCxcblxuICBXSU5ET1dfSEFORExFOiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyB3aW5kb3cgOiBudWxsLFxuXG4gIHNldEhhbmRsZVRvcExldmVsOiBmdW5jdGlvbiAoaGFuZGxlVG9wTGV2ZWwpIHtcbiAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2hhbmRsZVRvcExldmVsID0gaGFuZGxlVG9wTGV2ZWw7XG4gIH0sXG5cbiAgc2V0RW5hYmxlZDogZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2VuYWJsZWQgPSAhIWVuYWJsZWQ7XG4gIH0sXG5cbiAgaXNFbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0RXZlbnRMaXN0ZW5lci5fZW5hYmxlZDtcbiAgfSxcblxuICAvKipcbiAgICogVHJhcHMgdG9wLWxldmVsIGV2ZW50cyBieSB1c2luZyBldmVudCBidWJibGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlckJhc2VOYW1lIEV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKS5cbiAgICogQHBhcmFtIHtvYmplY3R9IGVsZW1lbnQgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICAgKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhcEJ1YmJsZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEV2ZW50TGlzdGVuZXIubGlzdGVuKGVsZW1lbnQsIGhhbmRsZXJCYXNlTmFtZSwgUmVhY3RFdmVudExpc3RlbmVyLmRpc3BhdGNoRXZlbnQuYmluZChudWxsLCB0b3BMZXZlbFR5cGUpKTtcbiAgfSxcblxuICAvKipcbiAgICogVHJhcHMgYSB0b3AtbGV2ZWwgZXZlbnQgYnkgdXNpbmcgZXZlbnQgY2FwdHVyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBoYW5kbGVyQmFzZU5hbWUgRXZlbnQgbmFtZSAoZS5nLiBcImNsaWNrXCIpLlxuICAgKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudCBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAgICogQHJldHVybiB7P29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XG4gICAqICAgICAgICAgICAgICAgICAgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB0cmFwQ2FwdHVyZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEV2ZW50TGlzdGVuZXIuY2FwdHVyZShlbGVtZW50LCBoYW5kbGVyQmFzZU5hbWUsIFJlYWN0RXZlbnRMaXN0ZW5lci5kaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG4gIH0sXG5cbiAgbW9uaXRvclNjcm9sbFZhbHVlOiBmdW5jdGlvbiAocmVmcmVzaCkge1xuICAgIHZhciBjYWxsYmFjayA9IHNjcm9sbFZhbHVlTW9uaXRvci5iaW5kKG51bGwsIHJlZnJlc2gpO1xuICAgIEV2ZW50TGlzdGVuZXIubGlzdGVuKHdpbmRvdywgJ3Njcm9sbCcsIGNhbGxiYWNrKTtcbiAgfSxcblxuICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICAgIGlmICghUmVhY3RFdmVudExpc3RlbmVyLl9lbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJvb2tLZWVwaW5nID0gVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLmdldFBvb2xlZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgICB0cnkge1xuICAgICAgLy8gRXZlbnQgcXVldWUgYmVpbmcgcHJvY2Vzc2VkIGluIHRoZSBzYW1lIGN5Y2xlIGFsbG93c1xuICAgICAgLy8gYHByZXZlbnREZWZhdWx0YC5cbiAgICAgIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyhoYW5kbGVUb3BMZXZlbEltcGwsIGJvb2tLZWVwaW5nKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLnJlbGVhc2UoYm9va0tlZXBpbmcpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEV2ZW50TGlzdGVuZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RFdmVudExpc3RlbmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGlzdG9yeSA9IFtdO1xuXG52YXIgUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2sgPSB7XG4gIG9uSG9zdE9wZXJhdGlvbjogZnVuY3Rpb24gKG9wZXJhdGlvbikge1xuICAgIGhpc3RvcnkucHVzaChvcGVyYXRpb24pO1xuICB9LFxuICBjbGVhckhpc3Rvcnk6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2suX3ByZXZlbnRDbGVhcmluZykge1xuICAgICAgLy8gU2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgdGVzdHMuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaGlzdG9yeSA9IFtdO1xuICB9LFxuICBnZXRIaXN0b3J5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGhpc3Rvcnk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2s7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2suanNcbi8vIG1vZHVsZSBpZCA9IDEzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XG52YXIgRXZlbnRQbHVnaW5VdGlscyA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5VdGlscycpO1xudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVtcHR5Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdEhvc3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0SG9zdENvbXBvbmVudCcpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBSZWFjdEluamVjdGlvbiA9IHtcbiAgQ29tcG9uZW50OiBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LmluamVjdGlvbixcbiAgRE9NUHJvcGVydHk6IERPTVByb3BlcnR5LmluamVjdGlvbixcbiAgRW1wdHlDb21wb25lbnQ6IFJlYWN0RW1wdHlDb21wb25lbnQuaW5qZWN0aW9uLFxuICBFdmVudFBsdWdpbkh1YjogRXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLFxuICBFdmVudFBsdWdpblV0aWxzOiBFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbixcbiAgRXZlbnRFbWl0dGVyOiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaW5qZWN0aW9uLFxuICBIb3N0Q29tcG9uZW50OiBSZWFjdEhvc3RDb21wb25lbnQuaW5qZWN0aW9uLFxuICBVcGRhdGVzOiBSZWFjdFVwZGF0ZXMuaW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5qZWN0aW9uO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0SW5qZWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHByb2Nlc3NpbmdDaGlsZENvbnRleHQgPSBmYWxzZTtcblxuICB2YXIgd2FybkludmFsaWRTZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghcHJvY2Vzc2luZ0NoaWxkQ29udGV4dCwgJ3NldFN0YXRlKC4uLik6IENhbm5vdCBjYWxsIHNldFN0YXRlKCkgaW5zaWRlIGdldENoaWxkQ29udGV4dCgpJykgOiB2b2lkIDA7XG4gIH07XG59XG5cbnZhciBSZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rID0ge1xuICBvbkJlZ2luUHJvY2Vzc2luZ0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3NpbmdDaGlsZENvbnRleHQgPSB0cnVlO1xuICB9LFxuICBvbkVuZFByb2Nlc3NpbmdDaGlsZENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzaW5nQ2hpbGRDb250ZXh0ID0gZmFsc2U7XG4gIH0sXG4gIG9uU2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB3YXJuSW52YWxpZFNldFN0YXRlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vaztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFkbGVyMzIgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcblxudmFyIFRBR19FTkQgPSAvXFwvPz4vO1xudmFyIENPTU1FTlRfU1RBUlQgPSAvXjxcXCFcXC1cXC0vO1xuXG52YXIgUmVhY3RNYXJrdXBDaGVja3N1bSA9IHtcbiAgQ0hFQ0tTVU1fQVRUUl9OQU1FOiAnZGF0YS1yZWFjdC1jaGVja3N1bScsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBzdHJpbmcgd2l0aCBjaGVja3N1bSBhdHRyaWJ1dGUgYXR0YWNoZWRcbiAgICovXG4gIGFkZENoZWNrc3VtVG9NYXJrdXA6IGZ1bmN0aW9uIChtYXJrdXApIHtcbiAgICB2YXIgY2hlY2tzdW0gPSBhZGxlcjMyKG1hcmt1cCk7XG5cbiAgICAvLyBBZGQgY2hlY2tzdW0gKGhhbmRsZSBib3RoIHBhcmVudCB0YWdzLCBjb21tZW50cyBhbmQgc2VsZi1jbG9zaW5nIHRhZ3MpXG4gICAgaWYgKENPTU1FTlRfU1RBUlQudGVzdChtYXJrdXApKSB7XG4gICAgICByZXR1cm4gbWFya3VwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWFya3VwLnJlcGxhY2UoVEFHX0VORCwgJyAnICsgUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUgKyAnPVwiJyArIGNoZWNrc3VtICsgJ1wiJCYnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgdG8gdXNlXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCByb290IFJlYWN0IGVsZW1lbnRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRoZSBtYXJrdXAgaXMgdGhlIHNhbWVcbiAgICovXG4gIGNhblJldXNlTWFya3VwOiBmdW5jdGlvbiAobWFya3VwLCBlbGVtZW50KSB7XG4gICAgdmFyIGV4aXN0aW5nQ2hlY2tzdW0gPSBlbGVtZW50LmdldEF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSk7XG4gICAgZXhpc3RpbmdDaGVja3N1bSA9IGV4aXN0aW5nQ2hlY2tzdW0gJiYgcGFyc2VJbnQoZXhpc3RpbmdDaGVja3N1bSwgMTApO1xuICAgIHZhciBtYXJrdXBDaGVja3N1bSA9IGFkbGVyMzIobWFya3VwKTtcbiAgICByZXR1cm4gbWFya3VwQ2hlY2tzdW0gPT09IGV4aXN0aW5nQ2hlY2tzdW07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNYXJrdXBDaGVja3N1bTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdE1hcmt1cENoZWNrc3VtLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RDaGlsZFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0Q2hpbGRSZWNvbmNpbGVyJyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGZsYXR0ZW5DaGlsZHJlbiA9IHJlcXVpcmUoJy4vZmxhdHRlbkNoaWxkcmVuJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogTWFrZSBhbiB1cGRhdGUgZm9yIG1hcmt1cCB0byBiZSByZW5kZXJlZCBhbmQgaW5zZXJ0ZWQgYXQgYSBzdXBwbGllZCBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0aGF0IHJlbmRlcnMgaW50byBhbiBlbGVtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggRGVzdGluYXRpb24gaW5kZXguXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlSW5zZXJ0TWFya3VwKG1hcmt1cCwgYWZ0ZXJOb2RlLCB0b0luZGV4KSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnSU5TRVJUX01BUktVUCcsXG4gICAgY29udGVudDogbWFya3VwLFxuICAgIGZyb21JbmRleDogbnVsbCxcbiAgICBmcm9tTm9kZTogbnVsbCxcbiAgICB0b0luZGV4OiB0b0luZGV4LFxuICAgIGFmdGVyTm9kZTogYWZ0ZXJOb2RlXG4gIH07XG59XG5cbi8qKlxuICogTWFrZSBhbiB1cGRhdGUgZm9yIG1vdmluZyBhbiBleGlzdGluZyBlbGVtZW50IHRvIGFub3RoZXIgaW5kZXguXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBTb3VyY2UgaW5kZXggb2YgdGhlIGV4aXN0aW5nIGVsZW1lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBEZXN0aW5hdGlvbiBpbmRleCBvZiB0aGUgZWxlbWVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1ha2VNb3ZlKGNoaWxkLCBhZnRlck5vZGUsIHRvSW5kZXgpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdNT1ZFX0VYSVNUSU5HJyxcbiAgICBjb250ZW50OiBudWxsLFxuICAgIGZyb21JbmRleDogY2hpbGQuX21vdW50SW5kZXgsXG4gICAgZnJvbU5vZGU6IFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZShjaGlsZCksXG4gICAgdG9JbmRleDogdG9JbmRleCxcbiAgICBhZnRlck5vZGU6IGFmdGVyTm9kZVxuICB9O1xufVxuXG4vKipcbiAqIE1ha2UgYW4gdXBkYXRlIGZvciByZW1vdmluZyBhbiBlbGVtZW50IGF0IGFuIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggSW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmVtb3ZlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFrZVJlbW92ZShjaGlsZCwgbm9kZSkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ1JFTU9WRV9OT0RFJyxcbiAgICBjb250ZW50OiBudWxsLFxuICAgIGZyb21JbmRleDogY2hpbGQuX21vdW50SW5kZXgsXG4gICAgZnJvbU5vZGU6IG5vZGUsXG4gICAgdG9JbmRleDogbnVsbCxcbiAgICBhZnRlck5vZGU6IG51bGxcbiAgfTtcbn1cblxuLyoqXG4gKiBNYWtlIGFuIHVwZGF0ZSBmb3Igc2V0dGluZyB0aGUgbWFya3VwIG9mIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0aGF0IHJlbmRlcnMgaW50byBhbiBlbGVtZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFrZVNldE1hcmt1cChtYXJrdXApIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdTRVRfTUFSS1VQJyxcbiAgICBjb250ZW50OiBtYXJrdXAsXG4gICAgZnJvbUluZGV4OiBudWxsLFxuICAgIGZyb21Ob2RlOiBudWxsLFxuICAgIHRvSW5kZXg6IG51bGwsXG4gICAgYWZ0ZXJOb2RlOiBudWxsXG4gIH07XG59XG5cbi8qKlxuICogTWFrZSBhbiB1cGRhdGUgZm9yIHNldHRpbmcgdGhlIHRleHQgY29udGVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dENvbnRlbnQgVGV4dCBjb250ZW50IHRvIHNldC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1ha2VUZXh0Q29udGVudCh0ZXh0Q29udGVudCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ1RFWFRfQ09OVEVOVCcsXG4gICAgY29udGVudDogdGV4dENvbnRlbnQsXG4gICAgZnJvbUluZGV4OiBudWxsLFxuICAgIGZyb21Ob2RlOiBudWxsLFxuICAgIHRvSW5kZXg6IG51bGwsXG4gICAgYWZ0ZXJOb2RlOiBudWxsXG4gIH07XG59XG5cbi8qKlxuICogUHVzaCBhbiB1cGRhdGUsIGlmIGFueSwgb250byB0aGUgcXVldWUuIENyZWF0ZXMgYSBuZXcgcXVldWUgaWYgbm9uZSBpc1xuICogcGFzc2VkIGFuZCBhbHdheXMgcmV0dXJucyB0aGUgcXVldWUuIE11dGF0aXZlLlxuICovXG5mdW5jdGlvbiBlbnF1ZXVlKHF1ZXVlLCB1cGRhdGUpIHtcbiAgaWYgKHVwZGF0ZSkge1xuICAgIHF1ZXVlID0gcXVldWUgfHwgW107XG4gICAgcXVldWUucHVzaCh1cGRhdGUpO1xuICB9XG4gIHJldHVybiBxdWV1ZTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzZXMgYW55IGVucXVldWVkIHVwZGF0ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc1F1ZXVlKGluc3QsIHVwZGF0ZVF1ZXVlKSB7XG4gIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyhpbnN0LCB1cGRhdGVRdWV1ZSk7XG59XG5cbnZhciBzZXRDaGlsZHJlbkZvckluc3RydW1lbnRhdGlvbiA9IGVtcHR5RnVuY3Rpb247XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgZ2V0RGVidWdJRCA9IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgaWYgKCFpbnN0Ll9kZWJ1Z0lEKSB7XG4gICAgICAvLyBDaGVjayBmb3IgQVJULWxpa2UgaW5zdGFuY2VzLiBUT0RPOiBUaGlzIGlzIHNpbGx5L2dyb3NzLlxuICAgICAgdmFyIGludGVybmFsO1xuICAgICAgaWYgKGludGVybmFsID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQoaW5zdCkpIHtcbiAgICAgICAgaW5zdCA9IGludGVybmFsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5zdC5fZGVidWdJRDtcbiAgfTtcbiAgc2V0Q2hpbGRyZW5Gb3JJbnN0cnVtZW50YXRpb24gPSBmdW5jdGlvbiAoY2hpbGRyZW4pIHtcbiAgICB2YXIgZGVidWdJRCA9IGdldERlYnVnSUQodGhpcyk7XG4gICAgLy8gVE9ETzogUmVhY3QgTmF0aXZlIGVtcHR5IGNvbXBvbmVudHMgYXJlIGFsc28gbXVsdGljaGlsZC5cbiAgICAvLyBUaGlzIG1lYW5zIHRoZXkgc3RpbGwgZ2V0IGludG8gdGhpcyBtZXRob2QgYnV0IGRvbid0IGhhdmUgX2RlYnVnSUQuXG4gICAgaWYgKGRlYnVnSUQgIT09IDApIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKGRlYnVnSUQsIGNoaWxkcmVuID8gT2JqZWN0LmtleXMoY2hpbGRyZW4pLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbltrZXldLl9kZWJ1Z0lEO1xuICAgICAgfSkgOiBbXSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFJlYWN0TXVsdGlDaGlsZCBhcmUgY2FwYWJsZSBvZiByZWNvbmNpbGluZyBtdWx0aXBsZSBjaGlsZHJlbi5cbiAqXG4gKiBAY2xhc3MgUmVhY3RNdWx0aUNoaWxkXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0TXVsdGlDaGlsZCA9IHtcblxuICAvKipcbiAgICogUHJvdmlkZXMgY29tbW9uIGZ1bmN0aW9uYWxpdHkgZm9yIGNvbXBvbmVudHMgdGhhdCBtdXN0IHJlY29uY2lsZSBtdWx0aXBsZVxuICAgKiBjaGlsZHJlbi4gVGhpcyBpcyB1c2VkIGJ5IGBSZWFjdERPTUNvbXBvbmVudGAgdG8gbW91bnQsIHVwZGF0ZSwgYW5kXG4gICAqIHVubW91bnQgY2hpbGQgY29tcG9uZW50cy5cbiAgICpcbiAgICogQGxlbmRzIHtSZWFjdE11bHRpQ2hpbGQucHJvdG90eXBlfVxuICAgKi9cbiAgTWl4aW46IHtcblxuICAgIF9yZWNvbmNpbGVySW5zdGFudGlhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIHNlbGZEZWJ1Z0lEID0gZ2V0RGVidWdJRCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3RDaGlsZFJlY29uY2lsZXIuaW5zdGFudGlhdGVDaGlsZHJlbihuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVhY3RDaGlsZFJlY29uY2lsZXIuaW5zdGFudGlhdGVDaGlsZHJlbihuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICBfcmVjb25jaWxlclVwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAocHJldkNoaWxkcmVuLCBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgbW91bnRJbWFnZXMsIHJlbW92ZWROb2RlcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHZhciBuZXh0Q2hpbGRyZW47XG4gICAgICB2YXIgc2VsZkRlYnVnSUQgPSAwO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgc2VsZkRlYnVnSUQgPSBnZXREZWJ1Z0lEKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudEVsZW1lbnQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICAgIG5leHRDaGlsZHJlbiA9IGZsYXR0ZW5DaGlsZHJlbihuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgc2VsZkRlYnVnSUQpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudXBkYXRlQ2hpbGRyZW4ocHJldkNoaWxkcmVuLCBuZXh0Q2hpbGRyZW4sIG1vdW50SW1hZ2VzLCByZW1vdmVkTm9kZXMsIHRyYW5zYWN0aW9uLCB0aGlzLCB0aGlzLl9ob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgc2VsZkRlYnVnSUQpO1xuICAgICAgICAgIHJldHVybiBuZXh0Q2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5leHRDaGlsZHJlbiA9IGZsYXR0ZW5DaGlsZHJlbihuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgc2VsZkRlYnVnSUQpO1xuICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudXBkYXRlQ2hpbGRyZW4ocHJldkNoaWxkcmVuLCBuZXh0Q2hpbGRyZW4sIG1vdW50SW1hZ2VzLCByZW1vdmVkTm9kZXMsIHRyYW5zYWN0aW9uLCB0aGlzLCB0aGlzLl9ob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgc2VsZkRlYnVnSUQpO1xuICAgICAgcmV0dXJuIG5leHRDaGlsZHJlbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgXCJtb3VudCBpbWFnZVwiIGZvciBlYWNoIG9mIHRoZSBzdXBwbGllZCBjaGlsZHJlbi4gSW4gdGhlIGNhc2VcbiAgICAgKiBvZiBgUmVhY3RET01Db21wb25lbnRgLCBhIG1vdW50IGltYWdlIGlzIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmVzdGVkQ2hpbGRyZW4gTmVzdGVkIGNoaWxkIG1hcHMuXG4gICAgICogQHJldHVybiB7YXJyYXl9IEFuIGFycmF5IG9mIG1vdW50ZWQgcmVwcmVzZW50YXRpb25zLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIG1vdW50Q2hpbGRyZW46IGZ1bmN0aW9uIChuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX3JlY29uY2lsZXJJbnN0YW50aWF0ZUNoaWxkcmVuKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gY2hpbGRyZW47XG5cbiAgICAgIHZhciBtb3VudEltYWdlcyA9IFtdO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5bbmFtZV07XG4gICAgICAgICAgdmFyIHNlbGZEZWJ1Z0lEID0gMDtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgc2VsZkRlYnVnSUQgPSBnZXREZWJ1Z0lEKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbW91bnRJbWFnZSA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChjaGlsZCwgdHJhbnNhY3Rpb24sIHRoaXMsIHRoaXMuX2hvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBzZWxmRGVidWdJRCk7XG4gICAgICAgICAgY2hpbGQuX21vdW50SW5kZXggPSBpbmRleCsrO1xuICAgICAgICAgIG1vdW50SW1hZ2VzLnB1c2gobW91bnRJbWFnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgc2V0Q2hpbGRyZW5Gb3JJbnN0cnVtZW50YXRpb24uY2FsbCh0aGlzLCBjaGlsZHJlbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtb3VudEltYWdlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgYW55IHJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSB0ZXh0IGNvbnRlbnQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5leHRDb250ZW50IFN0cmluZyBvZiBjb250ZW50LlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVwZGF0ZVRleHRDb250ZW50OiBmdW5jdGlvbiAobmV4dENvbnRlbnQpIHtcbiAgICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgLy8gUmVtb3ZlIGFueSByZW5kZXJlZCBjaGlsZHJlbi5cbiAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVubW91bnRDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIGZhbHNlKTtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gcHJldkNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndXBkYXRlVGV4dENvbnRlbnQgY2FsbGVkIG9uIG5vbi1lbXB0eSBjb21wb25lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMTE4JykgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFNldCBuZXcgdGV4dCBjb250ZW50LlxuICAgICAgdmFyIHVwZGF0ZXMgPSBbbWFrZVRleHRDb250ZW50KG5leHRDb250ZW50KV07XG4gICAgICBwcm9jZXNzUXVldWUodGhpcywgdXBkYXRlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGFueSByZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgbWFya3VwIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXh0TWFya3VwIFN0cmluZyBvZiBtYXJrdXAuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdXBkYXRlTWFya3VwOiBmdW5jdGlvbiAobmV4dE1hcmt1cCkge1xuICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICAvLyBSZW1vdmUgYW55IHJlbmRlcmVkIGNoaWxkcmVuLlxuICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudW5tb3VudENoaWxkcmVuKHByZXZDaGlsZHJlbiwgZmFsc2UpO1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKHByZXZDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd1cGRhdGVUZXh0Q29udGVudCBjYWxsZWQgb24gbm9uLWVtcHR5IGNvbXBvbmVudC4nKSA6IF9wcm9kSW52YXJpYW50KCcxMTgnKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHVwZGF0ZXMgPSBbbWFrZVNldE1hcmt1cChuZXh0TWFya3VwKV07XG4gICAgICBwcm9jZXNzUXVldWUodGhpcywgdXBkYXRlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHJlbmRlcmVkIGNoaWxkcmVuIHdpdGggbmV3IGNoaWxkcmVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cyBOZXN0ZWQgY2hpbGQgZWxlbWVudCBtYXBzLlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgLy8gSG9vayB1c2VkIGJ5IFJlYWN0IEFSVFxuICAgICAgdGhpcy5fdXBkYXRlQ2hpbGRyZW4obmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cyBOZXN0ZWQgY2hpbGQgZWxlbWVudCBtYXBzLlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAZmluYWxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3VwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAobmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIHZhciByZW1vdmVkTm9kZXMgPSB7fTtcbiAgICAgIHZhciBtb3VudEltYWdlcyA9IFtdO1xuICAgICAgdmFyIG5leHRDaGlsZHJlbiA9IHRoaXMuX3JlY29uY2lsZXJVcGRhdGVDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCBtb3VudEltYWdlcywgcmVtb3ZlZE5vZGVzLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICBpZiAoIW5leHRDaGlsZHJlbiAmJiAhcHJldkNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB1cGRhdGVzID0gbnVsbDtcbiAgICAgIHZhciBuYW1lO1xuICAgICAgLy8gYG5leHRJbmRleGAgd2lsbCBpbmNyZW1lbnQgZm9yIGVhY2ggY2hpbGQgaW4gYG5leHRDaGlsZHJlbmAsIGJ1dFxuICAgICAgLy8gYGxhc3RJbmRleGAgd2lsbCBiZSB0aGUgbGFzdCBpbmRleCB2aXNpdGVkIGluIGBwcmV2Q2hpbGRyZW5gLlxuICAgICAgdmFyIG5leHRJbmRleCA9IDA7XG4gICAgICB2YXIgbGFzdEluZGV4ID0gMDtcbiAgICAgIC8vIGBuZXh0TW91bnRJbmRleGAgd2lsbCBpbmNyZW1lbnQgZm9yIGVhY2ggbmV3bHkgbW91bnRlZCBjaGlsZC5cbiAgICAgIHZhciBuZXh0TW91bnRJbmRleCA9IDA7XG4gICAgICB2YXIgbGFzdFBsYWNlZE5vZGUgPSBudWxsO1xuICAgICAgZm9yIChuYW1lIGluIG5leHRDaGlsZHJlbikge1xuICAgICAgICBpZiAoIW5leHRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRyZW4gJiYgcHJldkNoaWxkcmVuW25hbWVdO1xuICAgICAgICB2YXIgbmV4dENoaWxkID0gbmV4dENoaWxkcmVuW25hbWVdO1xuICAgICAgICBpZiAocHJldkNoaWxkID09PSBuZXh0Q2hpbGQpIHtcbiAgICAgICAgICB1cGRhdGVzID0gZW5xdWV1ZSh1cGRhdGVzLCB0aGlzLm1vdmVDaGlsZChwcmV2Q2hpbGQsIGxhc3RQbGFjZWROb2RlLCBuZXh0SW5kZXgsIGxhc3RJbmRleCkpO1xuICAgICAgICAgIGxhc3RJbmRleCA9IE1hdGgubWF4KHByZXZDaGlsZC5fbW91bnRJbmRleCwgbGFzdEluZGV4KTtcbiAgICAgICAgICBwcmV2Q2hpbGQuX21vdW50SW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHByZXZDaGlsZCkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIGBsYXN0SW5kZXhgIGJlZm9yZSBgX21vdW50SW5kZXhgIGdldHMgdW5zZXQgYnkgdW5tb3VudGluZy5cbiAgICAgICAgICAgIGxhc3RJbmRleCA9IE1hdGgubWF4KHByZXZDaGlsZC5fbW91bnRJbmRleCwgbGFzdEluZGV4KTtcbiAgICAgICAgICAgIC8vIFRoZSBgcmVtb3ZlZE5vZGVzYCBsb29wIGJlbG93IHdpbGwgYWN0dWFsbHkgcmVtb3ZlIHRoZSBjaGlsZC5cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVGhlIGNoaWxkIG11c3QgYmUgaW5zdGFudGlhdGVkIGJlZm9yZSBpdCdzIG1vdW50ZWQuXG4gICAgICAgICAgdXBkYXRlcyA9IGVucXVldWUodXBkYXRlcywgdGhpcy5fbW91bnRDaGlsZEF0SW5kZXgobmV4dENoaWxkLCBtb3VudEltYWdlc1tuZXh0TW91bnRJbmRleF0sIGxhc3RQbGFjZWROb2RlLCBuZXh0SW5kZXgsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSk7XG4gICAgICAgICAgbmV4dE1vdW50SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBuZXh0SW5kZXgrKztcbiAgICAgICAgbGFzdFBsYWNlZE5vZGUgPSBSZWFjdFJlY29uY2lsZXIuZ2V0SG9zdE5vZGUobmV4dENoaWxkKTtcbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSBjaGlsZHJlbiB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudC5cbiAgICAgIGZvciAobmFtZSBpbiByZW1vdmVkTm9kZXMpIHtcbiAgICAgICAgaWYgKHJlbW92ZWROb2Rlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHVwZGF0ZXMgPSBlbnF1ZXVlKHVwZGF0ZXMsIHRoaXMuX3VubW91bnRDaGlsZChwcmV2Q2hpbGRyZW5bbmFtZV0sIHJlbW92ZWROb2Rlc1tuYW1lXSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodXBkYXRlcykge1xuICAgICAgICBwcm9jZXNzUXVldWUodGhpcywgdXBkYXRlcyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gbmV4dENoaWxkcmVuO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBzZXRDaGlsZHJlbkZvckluc3RydW1lbnRhdGlvbi5jYWxsKHRoaXMsIG5leHRDaGlsZHJlbik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVubW91bnRzIGFsbCByZW5kZXJlZCBjaGlsZHJlbi4gVGhpcyBzaG91bGQgYmUgdXNlZCB0byBjbGVhbiB1cCBjaGlsZHJlblxuICAgICAqIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgdW5tb3VudGVkLiBJdCBkb2VzIG5vdCBhY3R1YWxseSBwZXJmb3JtIGFueVxuICAgICAqIGJhY2tlbmQgb3BlcmF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVubW91bnRDaGlsZHJlbjogZnVuY3Rpb24gKHNhZmVseSkge1xuICAgICAgdmFyIHJlbmRlcmVkQ2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudW5tb3VudENoaWxkcmVuKHJlbmRlcmVkQ2hpbGRyZW4sIHNhZmVseSk7XG4gICAgICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYSBjaGlsZCBjb21wb25lbnQgdG8gdGhlIHN1cHBsaWVkIGluZGV4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIG1vdmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggRGVzdGluYXRpb24gaW5kZXggb2YgdGhlIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhc3RJbmRleCBMYXN0IGluZGV4IHZpc2l0ZWQgb2YgdGhlIHNpYmxpbmdzIG9mIGBjaGlsZGAuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG1vdmVDaGlsZDogZnVuY3Rpb24gKGNoaWxkLCBhZnRlck5vZGUsIHRvSW5kZXgsIGxhc3RJbmRleCkge1xuICAgICAgLy8gSWYgdGhlIGluZGV4IG9mIGBjaGlsZGAgaXMgbGVzcyB0aGFuIGBsYXN0SW5kZXhgLCB0aGVuIGl0IG5lZWRzIHRvXG4gICAgICAvLyBiZSBtb3ZlZC4gT3RoZXJ3aXNlLCB3ZSBkbyBub3QgbmVlZCB0byBtb3ZlIGl0IGJlY2F1c2UgYSBjaGlsZCB3aWxsIGJlXG4gICAgICAvLyBpbnNlcnRlZCBvciBtb3ZlZCBiZWZvcmUgYGNoaWxkYC5cbiAgICAgIGlmIChjaGlsZC5fbW91bnRJbmRleCA8IGxhc3RJbmRleCkge1xuICAgICAgICByZXR1cm4gbWFrZU1vdmUoY2hpbGQsIGFmdGVyTm9kZSwgdG9JbmRleCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjaGlsZCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gY3JlYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb3VudEltYWdlIE1hcmt1cCB0byBpbnNlcnQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNyZWF0ZUNoaWxkOiBmdW5jdGlvbiAoY2hpbGQsIGFmdGVyTm9kZSwgbW91bnRJbWFnZSkge1xuICAgICAgcmV0dXJuIG1ha2VJbnNlcnRNYXJrdXAobW91bnRJbWFnZSwgYWZ0ZXJOb2RlLCBjaGlsZC5fbW91bnRJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjaGlsZCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDaGlsZCB0byByZW1vdmUuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJlbW92ZUNoaWxkOiBmdW5jdGlvbiAoY2hpbGQsIG5vZGUpIHtcbiAgICAgIHJldHVybiBtYWtlUmVtb3ZlKGNoaWxkLCBub2RlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW91bnRzIGEgY2hpbGQgd2l0aCB0aGUgc3VwcGxpZWQgbmFtZS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgaXMgcGFydCBvZiBgdXBkYXRlQ2hpbGRyZW5gIGFuZCBpcyBoZXJlIGZvciByZWFkYWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byBtb3VudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBjaGlsZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBjaGlsZC5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbW91bnRDaGlsZEF0SW5kZXg6IGZ1bmN0aW9uIChjaGlsZCwgbW91bnRJbWFnZSwgYWZ0ZXJOb2RlLCBpbmRleCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIGNoaWxkLl9tb3VudEluZGV4ID0gaW5kZXg7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVDaGlsZChjaGlsZCwgYWZ0ZXJOb2RlLCBtb3VudEltYWdlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5tb3VudHMgYSByZW5kZXJlZCBjaGlsZC5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgaXMgcGFydCBvZiBgdXBkYXRlQ2hpbGRyZW5gIGFuZCBpcyBoZXJlIGZvciByZWFkYWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byB1bm1vdW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VubW91bnRDaGlsZDogZnVuY3Rpb24gKGNoaWxkLCBub2RlKSB7XG4gICAgICB2YXIgdXBkYXRlID0gdGhpcy5yZW1vdmVDaGlsZChjaGlsZCwgbm9kZSk7XG4gICAgICBjaGlsZC5fbW91bnRJbmRleCA9IG51bGw7XG4gICAgICByZXR1cm4gdXBkYXRlO1xuICAgIH1cblxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNdWx0aUNoaWxkO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0TXVsdGlDaGlsZC5qc1xuLy8gbW9kdWxlIGlkID0gMTM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgdmFsaWQgb3duZXIuXG4gKiBAZmluYWxcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZE93bmVyKG9iamVjdCkge1xuICByZXR1cm4gISEob2JqZWN0ICYmIHR5cGVvZiBvYmplY3QuYXR0YWNoUmVmID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmplY3QuZGV0YWNoUmVmID09PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBSZWFjdE93bmVycyBhcmUgY2FwYWJsZSBvZiBzdG9yaW5nIHJlZmVyZW5jZXMgdG8gb3duZWQgY29tcG9uZW50cy5cbiAqXG4gKiBBbGwgY29tcG9uZW50cyBhcmUgY2FwYWJsZSBvZiAvL2JlaW5nLy8gcmVmZXJlbmNlZCBieSBvd25lciBjb21wb25lbnRzLCBidXRcbiAqIG9ubHkgUmVhY3RPd25lciBjb21wb25lbnRzIGFyZSBjYXBhYmxlIG9mIC8vcmVmZXJlbmNpbmcvLyBvd25lZCBjb21wb25lbnRzLlxuICogVGhlIG5hbWVkIHJlZmVyZW5jZSBpcyBrbm93biBhcyBhIFwicmVmXCIuXG4gKlxuICogUmVmcyBhcmUgYXZhaWxhYmxlIHdoZW4gbW91bnRlZCBhbmQgdXBkYXRlZCBkdXJpbmcgcmVjb25jaWxpYXRpb24uXG4gKlxuICogICB2YXIgTXlDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJldHVybiAoXG4gKiAgICAgICAgIDxkaXYgb25DbGljaz17dGhpcy5oYW5kbGVDbGlja30+XG4gKiAgICAgICAgICAgPEN1c3RvbUNvbXBvbmVudCByZWY9XCJjdXN0b21cIiAvPlxuICogICAgICAgICA8L2Rpdj5cbiAqICAgICAgICk7XG4gKiAgICAgfSxcbiAqICAgICBoYW5kbGVDbGljazogZnVuY3Rpb24oKSB7XG4gKiAgICAgICB0aGlzLnJlZnMuY3VzdG9tLmhhbmRsZUNsaWNrKCk7XG4gKiAgICAgfSxcbiAqICAgICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24oKSB7XG4gKiAgICAgICB0aGlzLnJlZnMuY3VzdG9tLmluaXRpYWxpemUoKTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFJlZnMgc2hvdWxkIHJhcmVseSBiZSB1c2VkLiBXaGVuIHJlZnMgYXJlIHVzZWQsIHRoZXkgc2hvdWxkIG9ubHkgYmUgZG9uZSB0b1xuICogY29udHJvbCBkYXRhIHRoYXQgaXMgbm90IGhhbmRsZWQgYnkgUmVhY3QncyBkYXRhIGZsb3cuXG4gKlxuICogQGNsYXNzIFJlYWN0T3duZXJcbiAqL1xudmFyIFJlYWN0T3duZXIgPSB7XG4gIC8qKlxuICAgKiBBZGRzIGEgY29tcG9uZW50IGJ5IHJlZiB0byBhbiBvd25lciBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gcmVmZXJlbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgYnkgd2hpY2ggdG8gcmVmZXIgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtSZWFjdE93bmVyfSBvd25lciBDb21wb25lbnQgb24gd2hpY2ggdG8gcmVjb3JkIHRoZSByZWYuXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFkZENvbXBvbmVudEFzUmVmVG86IGZ1bmN0aW9uIChjb21wb25lbnQsIHJlZiwgb3duZXIpIHtcbiAgICAhaXNWYWxpZE93bmVyKG93bmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdhZGRDb21wb25lbnRBc1JlZlRvKC4uLik6IE9ubHkgYSBSZWFjdE93bmVyIGNhbiBoYXZlIHJlZnMuIFlvdSBtaWdodCBiZSBhZGRpbmcgYSByZWYgdG8gYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IGNyZWF0ZWQgaW5zaWRlIGEgY29tcG9uZW50XFwncyBgcmVuZGVyYCBtZXRob2QsIG9yIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWQgKGRldGFpbHM6IGh0dHBzOi8vZmIubWUvcmVhY3QtcmVmcy1tdXN0LWhhdmUtb3duZXIpLicpIDogX3Byb2RJbnZhcmlhbnQoJzExOScpIDogdm9pZCAwO1xuICAgIG93bmVyLmF0dGFjaFJlZihyZWYsIGNvbXBvbmVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjb21wb25lbnQgYnkgcmVmIGZyb20gYW4gb3duZXIgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRvIGRlcmVmZXJlbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgb2YgdGhlIHJlZiB0byByZW1vdmUuXG4gICAqIEBwYXJhbSB7UmVhY3RPd25lcn0gb3duZXIgQ29tcG9uZW50IG9uIHdoaWNoIHRoZSByZWYgaXMgcmVjb3JkZWQuXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlbW92ZUNvbXBvbmVudEFzUmVmRnJvbTogZnVuY3Rpb24gKGNvbXBvbmVudCwgcmVmLCBvd25lcikge1xuICAgICFpc1ZhbGlkT3duZXIob3duZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3JlbW92ZUNvbXBvbmVudEFzUmVmRnJvbSguLi4pOiBPbmx5IGEgUmVhY3RPd25lciBjYW4gaGF2ZSByZWZzLiBZb3UgbWlnaHQgYmUgcmVtb3ZpbmcgYSByZWYgdG8gYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IGNyZWF0ZWQgaW5zaWRlIGEgY29tcG9uZW50XFwncyBgcmVuZGVyYCBtZXRob2QsIG9yIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWQgKGRldGFpbHM6IGh0dHBzOi8vZmIubWUvcmVhY3QtcmVmcy1tdXN0LWhhdmUtb3duZXIpLicpIDogX3Byb2RJbnZhcmlhbnQoJzEyMCcpIDogdm9pZCAwO1xuICAgIHZhciBvd25lclB1YmxpY0luc3RhbmNlID0gb3duZXIuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICAvLyBDaGVjayB0aGF0IGBjb21wb25lbnRgJ3Mgb3duZXIgaXMgc3RpbGwgYWxpdmUgYW5kIHRoYXQgYGNvbXBvbmVudGAgaXMgc3RpbGwgdGhlIGN1cnJlbnQgcmVmXG4gICAgLy8gYmVjYXVzZSB3ZSBkbyBub3Qgd2FudCB0byBkZXRhY2ggdGhlIHJlZiBpZiBhbm90aGVyIGNvbXBvbmVudCBzdG9sZSBpdC5cbiAgICBpZiAob3duZXJQdWJsaWNJbnN0YW5jZSAmJiBvd25lclB1YmxpY0luc3RhbmNlLnJlZnNbcmVmXSA9PT0gY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCkpIHtcbiAgICAgIG93bmVyLmRldGFjaFJlZihyZWYpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0T3duZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RPd25lci5qc1xuLy8gbW9kdWxlIGlkID0gMTM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgQ2FsbGJhY2tRdWV1ZSA9IHJlcXVpcmUoJy4vQ2FsbGJhY2tRdWV1ZScpO1xudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyk7XG52YXIgUmVhY3RJbnB1dFNlbGVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnB1dFNlbGVjdGlvbicpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xudmFyIFJlYWN0VXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlUXVldWUnKTtcblxuLyoqXG4gKiBFbnN1cmVzIHRoYXQsIHdoZW4gcG9zc2libGUsIHRoZSBzZWxlY3Rpb24gcmFuZ2UgKGN1cnJlbnRseSBzZWxlY3RlZCB0ZXh0XG4gKiBpbnB1dCkgaXMgbm90IGRpc3R1cmJlZCBieSBwZXJmb3JtaW5nIHRoZSB0cmFuc2FjdGlvbi5cbiAqL1xudmFyIFNFTEVDVElPTl9SRVNUT1JBVElPTiA9IHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge1NlbGVjdGlvbn0gU2VsZWN0aW9uIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgaW5pdGlhbGl6ZTogUmVhY3RJbnB1dFNlbGVjdGlvbi5nZXRTZWxlY3Rpb25JbmZvcm1hdGlvbixcbiAgLyoqXG4gICAqIEBwYXJhbSB7U2VsZWN0aW9ufSBzZWwgU2VsZWN0aW9uIGluZm9ybWF0aW9uIHJldHVybmVkIGZyb20gYGluaXRpYWxpemVgLlxuICAgKi9cbiAgY2xvc2U6IFJlYWN0SW5wdXRTZWxlY3Rpb24ucmVzdG9yZVNlbGVjdGlvblxufTtcblxuLyoqXG4gKiBTdXBwcmVzc2VzIGV2ZW50cyAoYmx1ci9mb2N1cykgdGhhdCBjb3VsZCBiZSBpbmFkdmVydGVudGx5IGRpc3BhdGNoZWQgZHVlIHRvXG4gKiBoaWdoIGxldmVsIERPTSBtYW5pcHVsYXRpb25zIChsaWtlIHRlbXBvcmFyaWx5IHJlbW92aW5nIGEgdGV4dCBpbnB1dCBmcm9tIHRoZVxuICogRE9NKS5cbiAqL1xudmFyIEVWRU5UX1NVUFBSRVNTSU9OID0ge1xuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGVuYWJsZWQgc3RhdHVzIG9mIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGJlZm9yZVxuICAgKiB0aGUgcmVjb25jaWxpYXRpb24uXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGN1cnJlbnRseUVuYWJsZWQgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaXNFbmFibGVkKCk7XG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnNldEVuYWJsZWQoZmFsc2UpO1xuICAgIHJldHVybiBjdXJyZW50bHlFbmFibGVkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByZXZpb3VzbHlFbmFibGVkIEVuYWJsZWQgc3RhdHVzIG9mXG4gICAqICAgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgYmVmb3JlIHRoZSByZWNvbmNpbGlhdGlvbiBvY2N1cnJlZC4gYGNsb3NlYFxuICAgKiAgIHJlc3RvcmVzIHRoZSBwcmV2aW91cyB2YWx1ZS5cbiAgICovXG4gIGNsb3NlOiBmdW5jdGlvbiAocHJldmlvdXNseUVuYWJsZWQpIHtcbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuc2V0RW5hYmxlZChwcmV2aW91c2x5RW5hYmxlZCk7XG4gIH1cbn07XG5cbi8qKlxuICogUHJvdmlkZXMgYSBxdWV1ZSBmb3IgY29sbGVjdGluZyBgY29tcG9uZW50RGlkTW91bnRgIGFuZFxuICogYGNvbXBvbmVudERpZFVwZGF0ZWAgY2FsbGJhY2tzIGR1cmluZyB0aGUgdHJhbnNhY3Rpb24uXG4gKi9cbnZhciBPTl9ET01fUkVBRFlfUVVFVUVJTkcgPSB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgaW50ZXJuYWwgYG9uRE9NUmVhZHlgIHF1ZXVlLlxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5LnJlc2V0KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFmdGVyIERPTSBpcyBmbHVzaGVkLCBpbnZva2UgYWxsIHJlZ2lzdGVyZWQgYG9uRE9NUmVhZHlgIGNhbGxiYWNrcy5cbiAgICovXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkubm90aWZ5QWxsKCk7XG4gIH1cbn07XG5cbi8qKlxuICogRXhlY3V0ZWQgd2l0aGluIHRoZSBzY29wZSBvZiB0aGUgYFRyYW5zYWN0aW9uYCBpbnN0YW5jZS4gQ29uc2lkZXIgdGhlc2UgYXNcbiAqIGJlaW5nIG1lbWJlciBtZXRob2RzLCBidXQgd2l0aCBhbiBpbXBsaWVkIG9yZGVyaW5nIHdoaWxlIGJlaW5nIGlzb2xhdGVkIGZyb21cbiAqIGVhY2ggb3RoZXIuXG4gKi9cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtTRUxFQ1RJT05fUkVTVE9SQVRJT04sIEVWRU5UX1NVUFBSRVNTSU9OLCBPTl9ET01fUkVBRFlfUVVFVUVJTkddO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBUUkFOU0FDVElPTl9XUkFQUEVSUy5wdXNoKHtcbiAgICBpbml0aWFsaXplOiBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkZsdXNoLFxuICAgIGNsb3NlOiBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRGbHVzaFxuICB9KTtcbn1cblxuLyoqXG4gKiBDdXJyZW50bHk6XG4gKiAtIFRoZSBvcmRlciB0aGF0IHRoZXNlIGFyZSBsaXN0ZWQgaW4gdGhlIHRyYW5zYWN0aW9uIGlzIGNyaXRpY2FsOlxuICogLSBTdXBwcmVzc2VzIGV2ZW50cy5cbiAqIC0gUmVzdG9yZXMgc2VsZWN0aW9uIHJhbmdlLlxuICpcbiAqIEZ1dHVyZTpcbiAqIC0gUmVzdG9yZSBkb2N1bWVudC9vdmVyZmxvdyBzY3JvbGwgcG9zaXRpb25zIHRoYXQgd2VyZSB1bmludGVudGlvbmFsbHlcbiAqICAgbW9kaWZpZWQgdmlhIERPTSBpbnNlcnRpb25zIGFib3ZlIHRoZSB0b3Agdmlld3BvcnQgYm91bmRhcnkuXG4gKiAtIEltcGxlbWVudC9pbnRlZ3JhdGUgd2l0aCBjdXN0b21pemVkIGNvbnN0cmFpbnQgYmFzZWQgbGF5b3V0IHN5c3RlbSBhbmQga2VlcFxuICogICB0cmFjayBvZiB3aGljaCBkaW1lbnNpb25zIG11c3QgYmUgcmVtZWFzdXJlZC5cbiAqXG4gKiBAY2xhc3MgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvblxuICovXG5mdW5jdGlvbiBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uKHVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICAvLyBPbmx5IHNlcnZlci1zaWRlIHJlbmRlcmluZyByZWFsbHkgbmVlZHMgdGhpcyBvcHRpb24gKHNlZVxuICAvLyBgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdgKSwgYnV0IHNlcnZlci1zaWRlIHVzZXNcbiAgLy8gYFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb25gIGluc3RlYWQuIFRoaXMgb3B0aW9uIGlzIGhlcmUgc28gdGhhdCBpdCdzXG4gIC8vIGFjY2Vzc2libGUgYW5kIGRlZmF1bHRzIHRvIGZhbHNlIHdoZW4gYFJlYWN0RE9NQ29tcG9uZW50YCBhbmRcbiAgLy8gYFJlYWN0RE9NVGV4dENvbXBvbmVudGAgY2hlY2tzIGl0IGluIGBtb3VudENvbXBvbmVudGAuYFxuICB0aGlzLnJlbmRlclRvU3RhdGljTWFya3VwID0gZmFsc2U7XG4gIHRoaXMucmVhY3RNb3VudFJlYWR5ID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQobnVsbCk7XG4gIHRoaXMudXNlQ3JlYXRlRWxlbWVudCA9IHVzZUNyZWF0ZUVsZW1lbnQ7XG59XG5cbnZhciBNaXhpbiA9IHtcbiAgLyoqXG4gICAqIEBzZWUgVHJhbnNhY3Rpb25cbiAgICogQGFic3RyYWN0XG4gICAqIEBmaW5hbFxuICAgKiBAcmV0dXJuIHthcnJheTxvYmplY3Q+fSBMaXN0IG9mIG9wZXJhdGlvbiB3cmFwIHByb2NlZHVyZXMuXG4gICAqICAgVE9ETzogY29udmVydCB0byBhcnJheTxUcmFuc2FjdGlvbldyYXBwZXI+XG4gICAqL1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBxdWV1ZSB0byBjb2xsZWN0IGBvbkRPTVJlYWR5YCBjYWxsYmFja3Mgd2l0aC5cbiAgICovXG4gIGdldFJlYWN0TW91bnRSZWFkeTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWN0TW91bnRSZWFkeTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcXVldWUgdG8gY29sbGVjdCBSZWFjdCBhc3luYyBldmVudHMuXG4gICAqL1xuICBnZXRVcGRhdGVRdWV1ZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdFVwZGF0ZVF1ZXVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTYXZlIGN1cnJlbnQgdHJhbnNhY3Rpb24gc3RhdGUgLS0gaWYgdGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoaXMgbWV0aG9kIGlzXG4gICAqIHBhc3NlZCB0byBgcm9sbGJhY2tgLCB0aGUgdHJhbnNhY3Rpb24gd2lsbCBiZSByZXNldCB0byB0aGF0IHN0YXRlLlxuICAgKi9cbiAgY2hlY2twb2ludDogZnVuY3Rpb24gKCkge1xuICAgIC8vIHJlYWN0TW91bnRSZWFkeSBpcyB0aGUgb3VyIG9ubHkgc3RhdGVmdWwgd3JhcHBlclxuICAgIHJldHVybiB0aGlzLnJlYWN0TW91bnRSZWFkeS5jaGVja3BvaW50KCk7XG4gIH0sXG5cbiAgcm9sbGJhY2s6IGZ1bmN0aW9uIChjaGVja3BvaW50KSB7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkucm9sbGJhY2soY2hlY2twb2ludCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIHRoaXMsIGFuZCB3aWxsIGludm9rZSB0aGlzIGJlZm9yZSBhbGxvd2luZyB0aGlzXG4gICAqIGluc3RhbmNlIHRvIGJlIHJldXNlZC5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICBDYWxsYmFja1F1ZXVlLnJlbGVhc2UodGhpcy5yZWFjdE1vdW50UmVhZHkpO1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5ID0gbnVsbDtcbiAgfVxufTtcblxuX2Fzc2lnbihSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24sIE1peGluKTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb247XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0T3duZXInKTtcblxudmFyIFJlYWN0UmVmID0ge307XG5cbmZ1bmN0aW9uIGF0dGFjaFJlZihyZWYsIGNvbXBvbmVudCwgb3duZXIpIHtcbiAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZWYoY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCkpO1xuICB9IGVsc2Uge1xuICAgIC8vIExlZ2FjeSByZWZcbiAgICBSZWFjdE93bmVyLmFkZENvbXBvbmVudEFzUmVmVG8oY29tcG9uZW50LCByZWYsIG93bmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXRhY2hSZWYocmVmLCBjb21wb25lbnQsIG93bmVyKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmVmKG51bGwpO1xuICB9IGVsc2Uge1xuICAgIC8vIExlZ2FjeSByZWZcbiAgICBSZWFjdE93bmVyLnJlbW92ZUNvbXBvbmVudEFzUmVmRnJvbShjb21wb25lbnQsIHJlZiwgb3duZXIpO1xuICB9XG59XG5cblJlYWN0UmVmLmF0dGFjaFJlZnMgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT09IG51bGwgfHwgdHlwZW9mIGVsZW1lbnQgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgYXR0YWNoUmVmKHJlZiwgaW5zdGFuY2UsIGVsZW1lbnQuX293bmVyKTtcbiAgfVxufTtcblxuUmVhY3RSZWYuc2hvdWxkVXBkYXRlUmVmcyA9IGZ1bmN0aW9uIChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpIHtcbiAgLy8gSWYgZWl0aGVyIHRoZSBvd25lciBvciBhIGByZWZgIGhhcyBjaGFuZ2VkLCBtYWtlIHN1cmUgdGhlIG5ld2VzdCBvd25lclxuICAvLyBoYXMgc3RvcmVkIGEgcmVmZXJlbmNlIHRvIGB0aGlzYCwgYW5kIHRoZSBwcmV2aW91cyBvd25lciAoaWYgZGlmZmVyZW50KVxuICAvLyBoYXMgZm9yZ290dGVuIHRoZSByZWZlcmVuY2UgdG8gYHRoaXNgLiBXZSB1c2UgdGhlIGVsZW1lbnQgaW5zdGVhZFxuICAvLyBvZiB0aGUgcHVibGljIHRoaXMucHJvcHMgYmVjYXVzZSB0aGUgcG9zdCBwcm9jZXNzaW5nIGNhbm5vdCBkZXRlcm1pbmVcbiAgLy8gYSByZWYuIFRoZSByZWYgY29uY2VwdHVhbGx5IGxpdmVzIG9uIHRoZSBlbGVtZW50LlxuXG4gIC8vIFRPRE86IFNob3VsZCB0aGlzIGV2ZW4gYmUgcG9zc2libGU/IFRoZSBvd25lciBjYW5ub3QgY2hhbmdlIGJlY2F1c2VcbiAgLy8gaXQncyBmb3JiaWRkZW4gYnkgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQuIFRoZSByZWYgY2FuIGNoYW5nZVxuICAvLyBpZiB5b3Ugc3dhcCB0aGUga2V5cyBvZiBidXQgbm90IHRoZSByZWZzLiBSZWNvbnNpZGVyIHdoZXJlIHRoaXMgY2hlY2tcbiAgLy8gaXMgbWFkZS4gSXQgcHJvYmFibHkgYmVsb25ncyB3aGVyZSB0aGUga2V5IGNoZWNraW5nIGFuZFxuICAvLyBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50IGlzIGRvbmUuXG5cbiAgdmFyIHByZXZSZWYgPSBudWxsO1xuICB2YXIgcHJldk93bmVyID0gbnVsbDtcbiAgaWYgKHByZXZFbGVtZW50ICE9PSBudWxsICYmIHR5cGVvZiBwcmV2RWxlbWVudCA9PT0gJ29iamVjdCcpIHtcbiAgICBwcmV2UmVmID0gcHJldkVsZW1lbnQucmVmO1xuICAgIHByZXZPd25lciA9IHByZXZFbGVtZW50Ll9vd25lcjtcbiAgfVxuXG4gIHZhciBuZXh0UmVmID0gbnVsbDtcbiAgdmFyIG5leHRPd25lciA9IG51bGw7XG4gIGlmIChuZXh0RWxlbWVudCAhPT0gbnVsbCAmJiB0eXBlb2YgbmV4dEVsZW1lbnQgPT09ICdvYmplY3QnKSB7XG4gICAgbmV4dFJlZiA9IG5leHRFbGVtZW50LnJlZjtcbiAgICBuZXh0T3duZXIgPSBuZXh0RWxlbWVudC5fb3duZXI7XG4gIH1cblxuICByZXR1cm4gcHJldlJlZiAhPT0gbmV4dFJlZiB8fFxuICAvLyBJZiBvd25lciBjaGFuZ2VzIGJ1dCB3ZSBoYXZlIGFuIHVuY2hhbmdlZCBmdW5jdGlvbiByZWYsIGRvbid0IHVwZGF0ZSByZWZzXG4gIHR5cGVvZiBuZXh0UmVmID09PSAnc3RyaW5nJyAmJiBuZXh0T3duZXIgIT09IHByZXZPd25lcjtcbn07XG5cblJlYWN0UmVmLmRldGFjaFJlZnMgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT09IG51bGwgfHwgdHlwZW9mIGVsZW1lbnQgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgZGV0YWNoUmVmKHJlZiwgaW5zdGFuY2UsIGVsZW1lbnQuX293bmVyKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJlZjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9SZWFjdFJlZi5qc1xuLy8gbW9kdWxlIGlkID0gMTQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZScpO1xuXG4vKipcbiAqIEV4ZWN1dGVkIHdpdGhpbiB0aGUgc2NvcGUgb2YgdGhlIGBUcmFuc2FjdGlvbmAgaW5zdGFuY2UuIENvbnNpZGVyIHRoZXNlIGFzXG4gKiBiZWluZyBtZW1iZXIgbWV0aG9kcywgYnV0IHdpdGggYW4gaW1wbGllZCBvcmRlcmluZyB3aGlsZSBiZWluZyBpc29sYXRlZCBmcm9tXG4gKiBlYWNoIG90aGVyLlxuICovXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbXTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgVFJBTlNBQ1RJT05fV1JBUFBFUlMucHVzaCh7XG4gICAgaW5pdGlhbGl6ZTogUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5GbHVzaCxcbiAgICBjbG9zZTogUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kRmx1c2hcbiAgfSk7XG59XG5cbnZhciBub29wQ2FsbGJhY2tRdWV1ZSA9IHtcbiAgZW5xdWV1ZTogZnVuY3Rpb24gKCkge31cbn07XG5cbi8qKlxuICogQGNsYXNzIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVuZGVyVG9TdGF0aWNNYXJrdXBcbiAqL1xuZnVuY3Rpb24gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbihyZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG4gIHRoaXMucmVuZGVyVG9TdGF0aWNNYXJrdXAgPSByZW5kZXJUb1N0YXRpY01hcmt1cDtcbiAgdGhpcy51c2VDcmVhdGVFbGVtZW50ID0gZmFsc2U7XG4gIHRoaXMudXBkYXRlUXVldWUgPSBuZXcgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSh0aGlzKTtcbn1cblxudmFyIE1peGluID0ge1xuICAvKipcbiAgICogQHNlZSBUcmFuc2FjdGlvblxuICAgKiBAYWJzdHJhY3RcbiAgICogQGZpbmFsXG4gICAqIEByZXR1cm4ge2FycmF5fSBFbXB0eSBsaXN0IG9mIG9wZXJhdGlvbiB3cmFwIHByb2NlZHVyZXMuXG4gICAqL1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBxdWV1ZSB0byBjb2xsZWN0IGBvbkRPTVJlYWR5YCBjYWxsYmFja3Mgd2l0aC5cbiAgICovXG4gIGdldFJlYWN0TW91bnRSZWFkeTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBub29wQ2FsbGJhY2tRdWV1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcXVldWUgdG8gY29sbGVjdCBSZWFjdCBhc3luYyBldmVudHMuXG4gICAqL1xuICBnZXRVcGRhdGVRdWV1ZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVF1ZXVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLCBhbmQgd2lsbCBpbnZva2UgdGhpcyBiZWZvcmUgYWxsb3dpbmcgdGhpc1xuICAgKiBpbnN0YW5jZSB0byBiZSByZXVzZWQuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7fSxcblxuICBjaGVja3BvaW50OiBmdW5jdGlvbiAoKSB7fSxcblxuICByb2xsYmFjazogZnVuY3Rpb24gKCkge31cbn07XG5cbl9hc3NpZ24oUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLCBNaXhpbik7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDE0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZVF1ZXVlJyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRpbmcgY29tcG9uZW50LiAnICsgJ1RoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb3V0c2lkZSBjb21wb25lbnRXaWxsTW91bnQoKSBvbiB0aGUgc2VydmVyLiAnICsgJ1RoaXMgaXMgYSBuby1vcC4gUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGNvbnN0cnVjdG9yICYmIChjb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBjb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcycpIDogdm9pZCAwO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgdXBkYXRlIHF1ZXVlIHVzZWQgZm9yIHNlcnZlciByZW5kZXJpbmcuXG4gKiBJdCBkZWxlZ2F0ZXMgdG8gUmVhY3RVcGRhdGVRdWV1ZSB3aGlsZSBzZXJ2ZXIgcmVuZGVyaW5nIGlzIGluIHByb2dyZXNzIGFuZFxuICogc3dpdGNoZXMgdG8gUmVhY3ROb29wVXBkYXRlUXVldWUgYWZ0ZXIgdGhlIHRyYW5zYWN0aW9uIGhhcyBjb21wbGV0ZWQuXG4gKiBAY2xhc3MgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZVxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqL1xuXG52YXIgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSh0cmFuc2FjdGlvbikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlKTtcblxuICAgIHRoaXMudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuXG5cbiAgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5wcm90b3R5cGUuaXNNb3VudGVkID0gZnVuY3Rpb24gaXNNb3VudGVkKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbnF1ZXVlIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIGFsbCB0aGUgcGVuZGluZyB1cGRhdGVzXG4gICAqIGhhdmUgcHJvY2Vzc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0byB1c2UgYXMgYHRoaXNgIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAgICogQGludGVybmFsXG4gICAqL1xuXG5cbiAgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZUNhbGxiYWNrID0gZnVuY3Rpb24gZW5xdWV1ZUNhbGxiYWNrKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uLmlzSW5UcmFuc2FjdGlvbigpKSB7XG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVDYWxsYmFjayhwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQGludGVybmFsXG4gICAqL1xuXG5cbiAgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZUZvcmNlVXBkYXRlID0gZnVuY3Rpb24gZW5xdWV1ZUZvcmNlVXBkYXRlKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgaWYgKHRoaXMudHJhbnNhY3Rpb24uaXNJblRyYW5zYWN0aW9uKCkpIHtcbiAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUZvcmNlVXBkYXRlKHB1YmxpY0luc3RhbmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cblxuICBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlUmVwbGFjZVN0YXRlID0gZnVuY3Rpb24gZW5xdWV1ZVJlcGxhY2VTdGF0ZShwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSkge1xuICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uLmlzSW5UcmFuc2FjdGlvbigpKSB7XG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVSZXBsYWNlU3RhdGUocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cblxuICBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlU2V0U3RhdGUgPSBmdW5jdGlvbiBlbnF1ZXVlU2V0U3RhdGUocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSkge1xuICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uLmlzSW5UcmFuc2FjdGlvbigpKSB7XG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVTZXRTdGF0ZShwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZTtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0U2VydmVyVXBkYXRlUXVldWUuanNcbi8vIG1vZHVsZSBpZCA9IDE0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICcxNS40LjAnO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL1JlYWN0VmVyc2lvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBOUyA9IHtcbiAgeGxpbms6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcbiAgeG1sOiAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJ1xufTtcblxuLy8gV2UgdXNlIGF0dHJpYnV0ZXMgZm9yIGV2ZXJ5dGhpbmcgU1ZHIHNvIGxldCdzIGF2b2lkIHNvbWUgZHVwbGljYXRpb24gYW5kIHJ1blxuLy8gY29kZSBpbnN0ZWFkLlxuLy8gVGhlIGZvbGxvd2luZyBhcmUgYWxsIHNwZWNpZmllZCBpbiB0aGUgSFRNTCBjb25maWcgYWxyZWFkeSBzbyB3ZSBleGNsdWRlIGhlcmUuXG4vLyAtIGNsYXNzIChhcyBjbGFzc05hbWUpXG4vLyAtIGNvbG9yXG4vLyAtIGhlaWdodFxuLy8gLSBpZFxuLy8gLSBsYW5nXG4vLyAtIG1heFxuLy8gLSBtZWRpYVxuLy8gLSBtZXRob2Rcbi8vIC0gbWluXG4vLyAtIG5hbWVcbi8vIC0gc3R5bGVcbi8vIC0gdGFyZ2V0XG4vLyAtIHR5cGVcbi8vIC0gd2lkdGhcbnZhciBBVFRSUyA9IHtcbiAgYWNjZW50SGVpZ2h0OiAnYWNjZW50LWhlaWdodCcsXG4gIGFjY3VtdWxhdGU6IDAsXG4gIGFkZGl0aXZlOiAwLFxuICBhbGlnbm1lbnRCYXNlbGluZTogJ2FsaWdubWVudC1iYXNlbGluZScsXG4gIGFsbG93UmVvcmRlcjogJ2FsbG93UmVvcmRlcicsXG4gIGFscGhhYmV0aWM6IDAsXG4gIGFtcGxpdHVkZTogMCxcbiAgYXJhYmljRm9ybTogJ2FyYWJpYy1mb3JtJyxcbiAgYXNjZW50OiAwLFxuICBhdHRyaWJ1dGVOYW1lOiAnYXR0cmlidXRlTmFtZScsXG4gIGF0dHJpYnV0ZVR5cGU6ICdhdHRyaWJ1dGVUeXBlJyxcbiAgYXV0b1JldmVyc2U6ICdhdXRvUmV2ZXJzZScsXG4gIGF6aW11dGg6IDAsXG4gIGJhc2VGcmVxdWVuY3k6ICdiYXNlRnJlcXVlbmN5JyxcbiAgYmFzZVByb2ZpbGU6ICdiYXNlUHJvZmlsZScsXG4gIGJhc2VsaW5lU2hpZnQ6ICdiYXNlbGluZS1zaGlmdCcsXG4gIGJib3g6IDAsXG4gIGJlZ2luOiAwLFxuICBiaWFzOiAwLFxuICBieTogMCxcbiAgY2FsY01vZGU6ICdjYWxjTW9kZScsXG4gIGNhcEhlaWdodDogJ2NhcC1oZWlnaHQnLFxuICBjbGlwOiAwLFxuICBjbGlwUGF0aDogJ2NsaXAtcGF0aCcsXG4gIGNsaXBSdWxlOiAnY2xpcC1ydWxlJyxcbiAgY2xpcFBhdGhVbml0czogJ2NsaXBQYXRoVW5pdHMnLFxuICBjb2xvckludGVycG9sYXRpb246ICdjb2xvci1pbnRlcnBvbGF0aW9uJyxcbiAgY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVyczogJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsXG4gIGNvbG9yUHJvZmlsZTogJ2NvbG9yLXByb2ZpbGUnLFxuICBjb2xvclJlbmRlcmluZzogJ2NvbG9yLXJlbmRlcmluZycsXG4gIGNvbnRlbnRTY3JpcHRUeXBlOiAnY29udGVudFNjcmlwdFR5cGUnLFxuICBjb250ZW50U3R5bGVUeXBlOiAnY29udGVudFN0eWxlVHlwZScsXG4gIGN1cnNvcjogMCxcbiAgY3g6IDAsXG4gIGN5OiAwLFxuICBkOiAwLFxuICBkZWNlbGVyYXRlOiAwLFxuICBkZXNjZW50OiAwLFxuICBkaWZmdXNlQ29uc3RhbnQ6ICdkaWZmdXNlQ29uc3RhbnQnLFxuICBkaXJlY3Rpb246IDAsXG4gIGRpc3BsYXk6IDAsXG4gIGRpdmlzb3I6IDAsXG4gIGRvbWluYW50QmFzZWxpbmU6ICdkb21pbmFudC1iYXNlbGluZScsXG4gIGR1cjogMCxcbiAgZHg6IDAsXG4gIGR5OiAwLFxuICBlZGdlTW9kZTogJ2VkZ2VNb2RlJyxcbiAgZWxldmF0aW9uOiAwLFxuICBlbmFibGVCYWNrZ3JvdW5kOiAnZW5hYmxlLWJhY2tncm91bmQnLFxuICBlbmQ6IDAsXG4gIGV4cG9uZW50OiAwLFxuICBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkOiAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsXG4gIGZpbGw6IDAsXG4gIGZpbGxPcGFjaXR5OiAnZmlsbC1vcGFjaXR5JyxcbiAgZmlsbFJ1bGU6ICdmaWxsLXJ1bGUnLFxuICBmaWx0ZXI6IDAsXG4gIGZpbHRlclJlczogJ2ZpbHRlclJlcycsXG4gIGZpbHRlclVuaXRzOiAnZmlsdGVyVW5pdHMnLFxuICBmbG9vZENvbG9yOiAnZmxvb2QtY29sb3InLFxuICBmbG9vZE9wYWNpdHk6ICdmbG9vZC1vcGFjaXR5JyxcbiAgZm9jdXNhYmxlOiAwLFxuICBmb250RmFtaWx5OiAnZm9udC1mYW1pbHknLFxuICBmb250U2l6ZTogJ2ZvbnQtc2l6ZScsXG4gIGZvbnRTaXplQWRqdXN0OiAnZm9udC1zaXplLWFkanVzdCcsXG4gIGZvbnRTdHJldGNoOiAnZm9udC1zdHJldGNoJyxcbiAgZm9udFN0eWxlOiAnZm9udC1zdHlsZScsXG4gIGZvbnRWYXJpYW50OiAnZm9udC12YXJpYW50JyxcbiAgZm9udFdlaWdodDogJ2ZvbnQtd2VpZ2h0JyxcbiAgZm9ybWF0OiAwLFxuICBmcm9tOiAwLFxuICBmeDogMCxcbiAgZnk6IDAsXG4gIGcxOiAwLFxuICBnMjogMCxcbiAgZ2x5cGhOYW1lOiAnZ2x5cGgtbmFtZScsXG4gIGdseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsOiAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCcsXG4gIGdseXBoT3JpZW50YXRpb25WZXJ0aWNhbDogJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJyxcbiAgZ2x5cGhSZWY6ICdnbHlwaFJlZicsXG4gIGdyYWRpZW50VHJhbnNmb3JtOiAnZ3JhZGllbnRUcmFuc2Zvcm0nLFxuICBncmFkaWVudFVuaXRzOiAnZ3JhZGllbnRVbml0cycsXG4gIGhhbmdpbmc6IDAsXG4gIGhvcml6QWR2WDogJ2hvcml6LWFkdi14JyxcbiAgaG9yaXpPcmlnaW5YOiAnaG9yaXotb3JpZ2luLXgnLFxuICBpZGVvZ3JhcGhpYzogMCxcbiAgaW1hZ2VSZW5kZXJpbmc6ICdpbWFnZS1yZW5kZXJpbmcnLFxuICAnaW4nOiAwLFxuICBpbjI6IDAsXG4gIGludGVyY2VwdDogMCxcbiAgazogMCxcbiAgazE6IDAsXG4gIGsyOiAwLFxuICBrMzogMCxcbiAgazQ6IDAsXG4gIGtlcm5lbE1hdHJpeDogJ2tlcm5lbE1hdHJpeCcsXG4gIGtlcm5lbFVuaXRMZW5ndGg6ICdrZXJuZWxVbml0TGVuZ3RoJyxcbiAga2VybmluZzogMCxcbiAga2V5UG9pbnRzOiAna2V5UG9pbnRzJyxcbiAga2V5U3BsaW5lczogJ2tleVNwbGluZXMnLFxuICBrZXlUaW1lczogJ2tleVRpbWVzJyxcbiAgbGVuZ3RoQWRqdXN0OiAnbGVuZ3RoQWRqdXN0JyxcbiAgbGV0dGVyU3BhY2luZzogJ2xldHRlci1zcGFjaW5nJyxcbiAgbGlnaHRpbmdDb2xvcjogJ2xpZ2h0aW5nLWNvbG9yJyxcbiAgbGltaXRpbmdDb25lQW5nbGU6ICdsaW1pdGluZ0NvbmVBbmdsZScsXG4gIGxvY2FsOiAwLFxuICBtYXJrZXJFbmQ6ICdtYXJrZXItZW5kJyxcbiAgbWFya2VyTWlkOiAnbWFya2VyLW1pZCcsXG4gIG1hcmtlclN0YXJ0OiAnbWFya2VyLXN0YXJ0JyxcbiAgbWFya2VySGVpZ2h0OiAnbWFya2VySGVpZ2h0JyxcbiAgbWFya2VyVW5pdHM6ICdtYXJrZXJVbml0cycsXG4gIG1hcmtlcldpZHRoOiAnbWFya2VyV2lkdGgnLFxuICBtYXNrOiAwLFxuICBtYXNrQ29udGVudFVuaXRzOiAnbWFza0NvbnRlbnRVbml0cycsXG4gIG1hc2tVbml0czogJ21hc2tVbml0cycsXG4gIG1hdGhlbWF0aWNhbDogMCxcbiAgbW9kZTogMCxcbiAgbnVtT2N0YXZlczogJ251bU9jdGF2ZXMnLFxuICBvZmZzZXQ6IDAsXG4gIG9wYWNpdHk6IDAsXG4gIG9wZXJhdG9yOiAwLFxuICBvcmRlcjogMCxcbiAgb3JpZW50OiAwLFxuICBvcmllbnRhdGlvbjogMCxcbiAgb3JpZ2luOiAwLFxuICBvdmVyZmxvdzogMCxcbiAgb3ZlcmxpbmVQb3NpdGlvbjogJ292ZXJsaW5lLXBvc2l0aW9uJyxcbiAgb3ZlcmxpbmVUaGlja25lc3M6ICdvdmVybGluZS10aGlja25lc3MnLFxuICBwYWludE9yZGVyOiAncGFpbnQtb3JkZXInLFxuICBwYW5vc2UxOiAncGFub3NlLTEnLFxuICBwYXRoTGVuZ3RoOiAncGF0aExlbmd0aCcsXG4gIHBhdHRlcm5Db250ZW50VW5pdHM6ICdwYXR0ZXJuQ29udGVudFVuaXRzJyxcbiAgcGF0dGVyblRyYW5zZm9ybTogJ3BhdHRlcm5UcmFuc2Zvcm0nLFxuICBwYXR0ZXJuVW5pdHM6ICdwYXR0ZXJuVW5pdHMnLFxuICBwb2ludGVyRXZlbnRzOiAncG9pbnRlci1ldmVudHMnLFxuICBwb2ludHM6IDAsXG4gIHBvaW50c0F0WDogJ3BvaW50c0F0WCcsXG4gIHBvaW50c0F0WTogJ3BvaW50c0F0WScsXG4gIHBvaW50c0F0WjogJ3BvaW50c0F0WicsXG4gIHByZXNlcnZlQWxwaGE6ICdwcmVzZXJ2ZUFscGhhJyxcbiAgcHJlc2VydmVBc3BlY3RSYXRpbzogJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLFxuICBwcmltaXRpdmVVbml0czogJ3ByaW1pdGl2ZVVuaXRzJyxcbiAgcjogMCxcbiAgcmFkaXVzOiAwLFxuICByZWZYOiAncmVmWCcsXG4gIHJlZlk6ICdyZWZZJyxcbiAgcmVuZGVyaW5nSW50ZW50OiAncmVuZGVyaW5nLWludGVudCcsXG4gIHJlcGVhdENvdW50OiAncmVwZWF0Q291bnQnLFxuICByZXBlYXREdXI6ICdyZXBlYXREdXInLFxuICByZXF1aXJlZEV4dGVuc2lvbnM6ICdyZXF1aXJlZEV4dGVuc2lvbnMnLFxuICByZXF1aXJlZEZlYXR1cmVzOiAncmVxdWlyZWRGZWF0dXJlcycsXG4gIHJlc3RhcnQ6IDAsXG4gIHJlc3VsdDogMCxcbiAgcm90YXRlOiAwLFxuICByeDogMCxcbiAgcnk6IDAsXG4gIHNjYWxlOiAwLFxuICBzZWVkOiAwLFxuICBzaGFwZVJlbmRlcmluZzogJ3NoYXBlLXJlbmRlcmluZycsXG4gIHNsb3BlOiAwLFxuICBzcGFjaW5nOiAwLFxuICBzcGVjdWxhckNvbnN0YW50OiAnc3BlY3VsYXJDb25zdGFudCcsXG4gIHNwZWN1bGFyRXhwb25lbnQ6ICdzcGVjdWxhckV4cG9uZW50JyxcbiAgc3BlZWQ6IDAsXG4gIHNwcmVhZE1ldGhvZDogJ3NwcmVhZE1ldGhvZCcsXG4gIHN0YXJ0T2Zmc2V0OiAnc3RhcnRPZmZzZXQnLFxuICBzdGREZXZpYXRpb246ICdzdGREZXZpYXRpb24nLFxuICBzdGVtaDogMCxcbiAgc3RlbXY6IDAsXG4gIHN0aXRjaFRpbGVzOiAnc3RpdGNoVGlsZXMnLFxuICBzdG9wQ29sb3I6ICdzdG9wLWNvbG9yJyxcbiAgc3RvcE9wYWNpdHk6ICdzdG9wLW9wYWNpdHknLFxuICBzdHJpa2V0aHJvdWdoUG9zaXRpb246ICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJyxcbiAgc3RyaWtldGhyb3VnaFRoaWNrbmVzczogJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJyxcbiAgc3RyaW5nOiAwLFxuICBzdHJva2U6IDAsXG4gIHN0cm9rZURhc2hhcnJheTogJ3N0cm9rZS1kYXNoYXJyYXknLFxuICBzdHJva2VEYXNob2Zmc2V0OiAnc3Ryb2tlLWRhc2hvZmZzZXQnLFxuICBzdHJva2VMaW5lY2FwOiAnc3Ryb2tlLWxpbmVjYXAnLFxuICBzdHJva2VMaW5lam9pbjogJ3N0cm9rZS1saW5lam9pbicsXG4gIHN0cm9rZU1pdGVybGltaXQ6ICdzdHJva2UtbWl0ZXJsaW1pdCcsXG4gIHN0cm9rZU9wYWNpdHk6ICdzdHJva2Utb3BhY2l0eScsXG4gIHN0cm9rZVdpZHRoOiAnc3Ryb2tlLXdpZHRoJyxcbiAgc3VyZmFjZVNjYWxlOiAnc3VyZmFjZVNjYWxlJyxcbiAgc3lzdGVtTGFuZ3VhZ2U6ICdzeXN0ZW1MYW5ndWFnZScsXG4gIHRhYmxlVmFsdWVzOiAndGFibGVWYWx1ZXMnLFxuICB0YXJnZXRYOiAndGFyZ2V0WCcsXG4gIHRhcmdldFk6ICd0YXJnZXRZJyxcbiAgdGV4dEFuY2hvcjogJ3RleHQtYW5jaG9yJyxcbiAgdGV4dERlY29yYXRpb246ICd0ZXh0LWRlY29yYXRpb24nLFxuICB0ZXh0UmVuZGVyaW5nOiAndGV4dC1yZW5kZXJpbmcnLFxuICB0ZXh0TGVuZ3RoOiAndGV4dExlbmd0aCcsXG4gIHRvOiAwLFxuICB0cmFuc2Zvcm06IDAsXG4gIHUxOiAwLFxuICB1MjogMCxcbiAgdW5kZXJsaW5lUG9zaXRpb246ICd1bmRlcmxpbmUtcG9zaXRpb24nLFxuICB1bmRlcmxpbmVUaGlja25lc3M6ICd1bmRlcmxpbmUtdGhpY2tuZXNzJyxcbiAgdW5pY29kZTogMCxcbiAgdW5pY29kZUJpZGk6ICd1bmljb2RlLWJpZGknLFxuICB1bmljb2RlUmFuZ2U6ICd1bmljb2RlLXJhbmdlJyxcbiAgdW5pdHNQZXJFbTogJ3VuaXRzLXBlci1lbScsXG4gIHZBbHBoYWJldGljOiAndi1hbHBoYWJldGljJyxcbiAgdkhhbmdpbmc6ICd2LWhhbmdpbmcnLFxuICB2SWRlb2dyYXBoaWM6ICd2LWlkZW9ncmFwaGljJyxcbiAgdk1hdGhlbWF0aWNhbDogJ3YtbWF0aGVtYXRpY2FsJyxcbiAgdmFsdWVzOiAwLFxuICB2ZWN0b3JFZmZlY3Q6ICd2ZWN0b3ItZWZmZWN0JyxcbiAgdmVyc2lvbjogMCxcbiAgdmVydEFkdlk6ICd2ZXJ0LWFkdi15JyxcbiAgdmVydE9yaWdpblg6ICd2ZXJ0LW9yaWdpbi14JyxcbiAgdmVydE9yaWdpblk6ICd2ZXJ0LW9yaWdpbi15JyxcbiAgdmlld0JveDogJ3ZpZXdCb3gnLFxuICB2aWV3VGFyZ2V0OiAndmlld1RhcmdldCcsXG4gIHZpc2liaWxpdHk6IDAsXG4gIHdpZHRoczogMCxcbiAgd29yZFNwYWNpbmc6ICd3b3JkLXNwYWNpbmcnLFxuICB3cml0aW5nTW9kZTogJ3dyaXRpbmctbW9kZScsXG4gIHg6IDAsXG4gIHhIZWlnaHQ6ICd4LWhlaWdodCcsXG4gIHgxOiAwLFxuICB4MjogMCxcbiAgeENoYW5uZWxTZWxlY3RvcjogJ3hDaGFubmVsU2VsZWN0b3InLFxuICB4bGlua0FjdHVhdGU6ICd4bGluazphY3R1YXRlJyxcbiAgeGxpbmtBcmNyb2xlOiAneGxpbms6YXJjcm9sZScsXG4gIHhsaW5rSHJlZjogJ3hsaW5rOmhyZWYnLFxuICB4bGlua1JvbGU6ICd4bGluazpyb2xlJyxcbiAgeGxpbmtTaG93OiAneGxpbms6c2hvdycsXG4gIHhsaW5rVGl0bGU6ICd4bGluazp0aXRsZScsXG4gIHhsaW5rVHlwZTogJ3hsaW5rOnR5cGUnLFxuICB4bWxCYXNlOiAneG1sOmJhc2UnLFxuICB4bWxuczogMCxcbiAgeG1sbnNYbGluazogJ3htbG5zOnhsaW5rJyxcbiAgeG1sTGFuZzogJ3htbDpsYW5nJyxcbiAgeG1sU3BhY2U6ICd4bWw6c3BhY2UnLFxuICB5OiAwLFxuICB5MTogMCxcbiAgeTI6IDAsXG4gIHlDaGFubmVsU2VsZWN0b3I6ICd5Q2hhbm5lbFNlbGVjdG9yJyxcbiAgejogMCxcbiAgem9vbUFuZFBhbjogJ3pvb21BbmRQYW4nXG59O1xuXG52YXIgU1ZHRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIFByb3BlcnRpZXM6IHt9LFxuICBET01BdHRyaWJ1dGVOYW1lc3BhY2VzOiB7XG4gICAgeGxpbmtBY3R1YXRlOiBOUy54bGluayxcbiAgICB4bGlua0FyY3JvbGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rSHJlZjogTlMueGxpbmssXG4gICAgeGxpbmtSb2xlOiBOUy54bGluayxcbiAgICB4bGlua1Nob3c6IE5TLnhsaW5rLFxuICAgIHhsaW5rVGl0bGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rVHlwZTogTlMueGxpbmssXG4gICAgeG1sQmFzZTogTlMueG1sLFxuICAgIHhtbExhbmc6IE5TLnhtbCxcbiAgICB4bWxTcGFjZTogTlMueG1sXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7fVxufTtcblxuT2JqZWN0LmtleXMoQVRUUlMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBTVkdET01Qcm9wZXJ0eUNvbmZpZy5Qcm9wZXJ0aWVzW2tleV0gPSAwO1xuICBpZiAoQVRUUlNba2V5XSkge1xuICAgIFNWR0RPTVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzW2tleV0gPSBBVFRSU1trZXldO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTVkdET01Qcm9wZXJ0eUNvbmZpZztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9TVkdET01Qcm9wZXJ0eUNvbmZpZy5qc1xuLy8gbW9kdWxlIGlkID0gMTQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RJbnB1dFNlbGVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnB1dFNlbGVjdGlvbicpO1xudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQnKTtcbnZhciBpc1RleHRJbnB1dEVsZW1lbnQgPSByZXF1aXJlKCcuL2lzVGV4dElucHV0RWxlbWVudCcpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xuXG52YXIgc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8PSAxMTtcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIHNlbGVjdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25TZWxlY3QnLFxuICAgICAgY2FwdHVyZWQ6ICdvblNlbGVjdENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb250ZXh0TWVudScsICd0b3BGb2N1cycsICd0b3BLZXlEb3duJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93bicsICd0b3BNb3VzZVVwJywgJ3RvcFNlbGVjdGlvbkNoYW5nZSddXG4gIH1cbn07XG5cbnZhciBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG52YXIgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG52YXIgbW91c2VEb3duID0gZmFsc2U7XG5cbi8vIFRyYWNrIHdoZXRoZXIgYSBsaXN0ZW5lciBleGlzdHMgZm9yIHRoaXMgcGx1Z2luLiBJZiBub25lIGV4aXN0LCB3ZSBkb1xuLy8gbm90IGV4dHJhY3QgZXZlbnRzLiBTZWUgIzM2MzkuXG52YXIgaGFzTGlzdGVuZXIgPSBmYWxzZTtcblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IHdoaWNoIGlzIGEgdW5pcXVlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgbm90IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG5vZGVzIG9yIGJyb3dzZXJzLCBidXRcbiAqIHR3byBpZGVudGljYWwgc2VsZWN0aW9ucyBvbiB0aGUgc2FtZSBub2RlIHdpbGwgcmV0dXJuIGlkZW50aWNhbCBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24obm9kZSkge1xuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBub2RlICYmIFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKG5vZGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBub2RlLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBub2RlLnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlOiBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgIH07XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uKSB7XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcmVudEVsZW1lbnQ6IHJhbmdlLnBhcmVudEVsZW1lbnQoKSxcbiAgICAgIHRleHQ6IHJhbmdlLnRleHQsXG4gICAgICB0b3A6IHJhbmdlLmJvdW5kaW5nVG9wLFxuICAgICAgbGVmdDogcmFuZ2UuYm91bmRpbmdMZWZ0XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFBvbGwgc2VsZWN0aW9uIHRvIHNlZSB3aGV0aGVyIGl0J3MgY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9TeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIC8vIEVuc3VyZSB3ZSBoYXZlIHRoZSByaWdodCBlbGVtZW50LCBhbmQgdGhhdCB0aGUgdXNlciBpcyBub3QgZHJhZ2dpbmcgYVxuICAvLyBzZWxlY3Rpb24gKHRoaXMgbWF0Y2hlcyBuYXRpdmUgYHNlbGVjdGAgZXZlbnQgYmVoYXZpb3IpLiBJbiBIVE1MNSwgc2VsZWN0XG4gIC8vIGZpcmVzIG9ubHkgb24gaW5wdXQgYW5kIHRleHRhcmVhIHRodXMgaWYgdGhlcmUncyBubyBmb2N1c2VkIGVsZW1lbnQgd2VcbiAgLy8gd29uJ3QgZGlzcGF0Y2guXG4gIGlmIChtb3VzZURvd24gfHwgYWN0aXZlRWxlbWVudCA9PSBudWxsIHx8IGFjdGl2ZUVsZW1lbnQgIT09IGdldEFjdGl2ZUVsZW1lbnQoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gT25seSBmaXJlIHdoZW4gc2VsZWN0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxuICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihhY3RpdmVFbGVtZW50KTtcbiAgaWYgKCFsYXN0U2VsZWN0aW9uIHx8ICFzaGFsbG93RXF1YWwobGFzdFNlbGVjdGlvbiwgY3VycmVudFNlbGVjdGlvbikpIHtcbiAgICBsYXN0U2VsZWN0aW9uID0gY3VycmVudFNlbGVjdGlvbjtcblxuICAgIHZhciBzeW50aGV0aWNFdmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLnNlbGVjdCwgYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgICBzeW50aGV0aWNFdmVudC50eXBlID0gJ3NlbGVjdCc7XG4gICAgc3ludGhldGljRXZlbnQudGFyZ2V0ID0gYWN0aXZlRWxlbWVudDtcblxuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhzeW50aGV0aWNFdmVudCk7XG5cbiAgICByZXR1cm4gc3ludGhldGljRXZlbnQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvblNlbGVjdGAgZXZlbnQgdGhhdCBub3JtYWxpemVzIHNlbGVjdCBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIGNvbnRlbnRFZGl0YWJsZVxuICpcbiAqIFRoaXMgZGlmZmVycyBmcm9tIG5hdGl2ZSBicm93c2VyIGltcGxlbWVudGF0aW9ucyBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKiAtIEZpcmVzIG9uIGNvbnRlbnRFZGl0YWJsZSBmaWVsZHMgYXMgd2VsbCBhcyBpbnB1dHMuXG4gKiAtIEZpcmVzIGZvciBjb2xsYXBzZWQgc2VsZWN0aW9uLlxuICogLSBGaXJlcyBhZnRlciB1c2VyIGlucHV0LlxuICovXG52YXIgU2VsZWN0RXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICBpZiAoIWhhc0xpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcblxuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICAvLyBUcmFjayB0aGUgaW5wdXQgbm9kZSB0aGF0IGhhcyBmb2N1cy5cbiAgICAgIGNhc2UgJ3RvcEZvY3VzJzpcbiAgICAgICAgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0YXJnZXROb2RlKSB8fCB0YXJnZXROb2RlLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudCA9IHRhcmdldE5vZGU7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudEluc3QgPSB0YXJnZXRJbnN0O1xuICAgICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQmx1cic6XG4gICAgICAgIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG4gICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICBicmVhaztcblxuICAgICAgLy8gRG9uJ3QgZmlyZSB0aGUgZXZlbnQgd2hpbGUgdGhlIHVzZXIgaXMgZHJhZ2dpbmcuIFRoaXMgbWF0Y2hlcyB0aGVcbiAgICAgIC8vIHNlbWFudGljcyBvZiB0aGUgbmF0aXZlIHNlbGVjdCBldmVudC5cbiAgICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XG4gICAgICAgIG1vdXNlRG93biA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQ29udGV4dE1lbnUnOlxuICAgICAgY2FzZSAndG9wTW91c2VVcCc6XG4gICAgICAgIG1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICAgICAgLy8gQ2hyb21lIGFuZCBJRSBmaXJlIG5vbi1zdGFuZGFyZCBldmVudCB3aGVuIHNlbGVjdGlvbiBpcyBjaGFuZ2VkIChhbmRcbiAgICAgIC8vIHNvbWV0aW1lcyB3aGVuIGl0IGhhc24ndCkuIElFJ3MgZXZlbnQgZmlyZXMgb3V0IG9mIG9yZGVyIHdpdGggcmVzcGVjdFxuICAgICAgLy8gdG8ga2V5IGFuZCBpbnB1dCBldmVudHMgb24gZGVsZXRpb24sIHNvIHdlIGRpc2NhcmQgaXQuXG4gICAgICAvL1xuICAgICAgLy8gRmlyZWZveCBkb2Vzbid0IHN1cHBvcnQgc2VsZWN0aW9uY2hhbmdlLCBzbyBjaGVjayBzZWxlY3Rpb24gc3RhdHVzXG4gICAgICAvLyBhZnRlciBlYWNoIGtleSBlbnRyeS4gVGhlIHNlbGVjdGlvbiBjaGFuZ2VzIGFmdGVyIGtleWRvd24gYW5kIGJlZm9yZVxuICAgICAgLy8ga2V5dXAsIGJ1dCB3ZSBjaGVjayBvbiBrZXlkb3duIGFzIHdlbGwgaW4gdGhlIGNhc2Ugb2YgaG9sZGluZyBkb3duIGFcbiAgICAgIC8vIGtleSwgd2hlbiBtdWx0aXBsZSBrZXlkb3duIGV2ZW50cyBhcmUgZmlyZWQgYnV0IG9ubHkgb25lIGtleXVwIGlzLlxuICAgICAgLy8gVGhpcyBpcyBhbHNvIG91ciBhcHByb2FjaCBmb3IgSUUgaGFuZGxpbmcsIGZvciB0aGUgcmVhc29uIGFib3ZlLlxuICAgICAgY2FzZSAndG9wU2VsZWN0aW9uQ2hhbmdlJzpcbiAgICAgICAgaWYgKHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlICd0b3BLZXlEb3duJzpcbiAgICAgIGNhc2UgJ3RvcEtleVVwJzpcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgZGlkUHV0TGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSAnb25TZWxlY3QnKSB7XG4gICAgICBoYXNMaXN0ZW5lciA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbGVjdEV2ZW50UGx1Z2luO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL1NlbGVjdEV2ZW50UGx1Z2luLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJ2ZianMvbGliL0V2ZW50TGlzdGVuZXInKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBTeW50aGV0aWNBbmltYXRpb25FdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljQW5pbWF0aW9uRXZlbnQnKTtcbnZhciBTeW50aGV0aWNDbGlwYm9hcmRFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljQ2xpcGJvYXJkRXZlbnQnKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcbnZhciBTeW50aGV0aWNGb2N1c0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNGb2N1c0V2ZW50Jyk7XG52YXIgU3ludGhldGljS2V5Ym9hcmRFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljS2V5Ym9hcmRFdmVudCcpO1xudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcbnZhciBTeW50aGV0aWNEcmFnRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0RyYWdFdmVudCcpO1xudmFyIFN5bnRoZXRpY1RvdWNoRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1RvdWNoRXZlbnQnKTtcbnZhciBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1RyYW5zaXRpb25FdmVudCcpO1xudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcbnZhciBTeW50aGV0aWNXaGVlbEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNXaGVlbEV2ZW50Jyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGdldEV2ZW50Q2hhckNvZGUgPSByZXF1aXJlKCcuL2dldEV2ZW50Q2hhckNvZGUnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBUdXJuc1xuICogWydhYm9ydCcsIC4uLl1cbiAqIGludG9cbiAqIGV2ZW50VHlwZXMgPSB7XG4gKiAgICdhYm9ydCc6IHtcbiAqICAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICogICAgICAgYnViYmxlZDogJ29uQWJvcnQnLFxuICogICAgICAgY2FwdHVyZWQ6ICdvbkFib3J0Q2FwdHVyZScsXG4gKiAgICAgfSxcbiAqICAgICBkZXBlbmRlbmNpZXM6IFsndG9wQWJvcnQnXSxcbiAqICAgfSxcbiAqICAgLi4uXG4gKiB9O1xuICogdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnID0ge1xuICogICAndG9wQWJvcnQnOiB7IHNhbWVDb25maWcgfVxuICogfTtcbiAqL1xudmFyIGV2ZW50VHlwZXMgPSB7fTtcbnZhciB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSB7fTtcblsnYWJvcnQnLCAnYW5pbWF0aW9uRW5kJywgJ2FuaW1hdGlvbkl0ZXJhdGlvbicsICdhbmltYXRpb25TdGFydCcsICdibHVyJywgJ2NhblBsYXknLCAnY2FuUGxheVRocm91Z2gnLCAnY2xpY2snLCAnY29udGV4dE1lbnUnLCAnY29weScsICdjdXQnLCAnZG91YmxlQ2xpY2snLCAnZHJhZycsICdkcmFnRW5kJywgJ2RyYWdFbnRlcicsICdkcmFnRXhpdCcsICdkcmFnTGVhdmUnLCAnZHJhZ092ZXInLCAnZHJhZ1N0YXJ0JywgJ2Ryb3AnLCAnZHVyYXRpb25DaGFuZ2UnLCAnZW1wdGllZCcsICdlbmNyeXB0ZWQnLCAnZW5kZWQnLCAnZXJyb3InLCAnZm9jdXMnLCAnaW5wdXQnLCAnaW52YWxpZCcsICdrZXlEb3duJywgJ2tleVByZXNzJywgJ2tleVVwJywgJ2xvYWQnLCAnbG9hZGVkRGF0YScsICdsb2FkZWRNZXRhZGF0YScsICdsb2FkU3RhcnQnLCAnbW91c2VEb3duJywgJ21vdXNlTW92ZScsICdtb3VzZU91dCcsICdtb3VzZU92ZXInLCAnbW91c2VVcCcsICdwYXN0ZScsICdwYXVzZScsICdwbGF5JywgJ3BsYXlpbmcnLCAncHJvZ3Jlc3MnLCAncmF0ZUNoYW5nZScsICdyZXNldCcsICdzY3JvbGwnLCAnc2Vla2VkJywgJ3NlZWtpbmcnLCAnc3RhbGxlZCcsICdzdWJtaXQnLCAnc3VzcGVuZCcsICd0aW1lVXBkYXRlJywgJ3RvdWNoQ2FuY2VsJywgJ3RvdWNoRW5kJywgJ3RvdWNoTW92ZScsICd0b3VjaFN0YXJ0JywgJ3RyYW5zaXRpb25FbmQnLCAndm9sdW1lQ2hhbmdlJywgJ3dhaXRpbmcnLCAnd2hlZWwnXS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICB2YXIgY2FwaXRhbGl6ZWRFdmVudCA9IGV2ZW50WzBdLnRvVXBwZXJDYXNlKCkgKyBldmVudC5zbGljZSgxKTtcbiAgdmFyIG9uRXZlbnQgPSAnb24nICsgY2FwaXRhbGl6ZWRFdmVudDtcbiAgdmFyIHRvcEV2ZW50ID0gJ3RvcCcgKyBjYXBpdGFsaXplZEV2ZW50O1xuXG4gIHZhciB0eXBlID0ge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBvbkV2ZW50LFxuICAgICAgY2FwdHVyZWQ6IG9uRXZlbnQgKyAnQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcEV2ZW50XVxuICB9O1xuICBldmVudFR5cGVzW2V2ZW50XSA9IHR5cGU7XG4gIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BFdmVudF0gPSB0eXBlO1xufSk7XG5cbnZhciBvbkNsaWNrTGlzdGVuZXJzID0ge307XG5cbmZ1bmN0aW9uIGdldERpY3Rpb25hcnlLZXkoaW5zdCkge1xuICAvLyBQcmV2ZW50cyBWOCBwZXJmb3JtYW5jZSBpc3N1ZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzIzMlxuICByZXR1cm4gJy4nICsgaW5zdC5fcm9vdE5vZGVJRDtcbn1cblxuZnVuY3Rpb24gaXNJbnRlcmFjdGl2ZSh0YWcpIHtcbiAgcmV0dXJuIHRhZyA9PT0gJ2J1dHRvbicgfHwgdGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3NlbGVjdCcgfHwgdGFnID09PSAndGV4dGFyZWEnO1xufVxuXG5mdW5jdGlvbiBzaG91bGRQcmV2ZW50TW91c2VFdmVudChpbnN0KSB7XG4gIGlmIChpbnN0KSB7XG4gICAgdmFyIGRpc2FibGVkID0gaW5zdC5fY3VycmVudEVsZW1lbnQgJiYgaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHMuZGlzYWJsZWQ7XG5cbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBpc0ludGVyYWN0aXZlKGluc3QuX3RhZyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgU2ltcGxlRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgZGlzcGF0Y2hDb25maWcgPSB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdG9wTGV2ZWxUeXBlXTtcbiAgICBpZiAoIWRpc3BhdGNoQ29uZmlnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIEV2ZW50Q29uc3RydWN0b3I7XG4gICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICAgIGNhc2UgJ3RvcEFib3J0JzpcbiAgICAgIGNhc2UgJ3RvcENhblBsYXknOlxuICAgICAgY2FzZSAndG9wQ2FuUGxheVRocm91Z2gnOlxuICAgICAgY2FzZSAndG9wRHVyYXRpb25DaGFuZ2UnOlxuICAgICAgY2FzZSAndG9wRW1wdGllZCc6XG4gICAgICBjYXNlICd0b3BFbmNyeXB0ZWQnOlxuICAgICAgY2FzZSAndG9wRW5kZWQnOlxuICAgICAgY2FzZSAndG9wRXJyb3InOlxuICAgICAgY2FzZSAndG9wSW5wdXQnOlxuICAgICAgY2FzZSAndG9wSW52YWxpZCc6XG4gICAgICBjYXNlICd0b3BMb2FkJzpcbiAgICAgIGNhc2UgJ3RvcExvYWRlZERhdGEnOlxuICAgICAgY2FzZSAndG9wTG9hZGVkTWV0YWRhdGEnOlxuICAgICAgY2FzZSAndG9wTG9hZFN0YXJ0JzpcbiAgICAgIGNhc2UgJ3RvcFBhdXNlJzpcbiAgICAgIGNhc2UgJ3RvcFBsYXknOlxuICAgICAgY2FzZSAndG9wUGxheWluZyc6XG4gICAgICBjYXNlICd0b3BQcm9ncmVzcyc6XG4gICAgICBjYXNlICd0b3BSYXRlQ2hhbmdlJzpcbiAgICAgIGNhc2UgJ3RvcFJlc2V0JzpcbiAgICAgIGNhc2UgJ3RvcFNlZWtlZCc6XG4gICAgICBjYXNlICd0b3BTZWVraW5nJzpcbiAgICAgIGNhc2UgJ3RvcFN0YWxsZWQnOlxuICAgICAgY2FzZSAndG9wU3VibWl0JzpcbiAgICAgIGNhc2UgJ3RvcFN1c3BlbmQnOlxuICAgICAgY2FzZSAndG9wVGltZVVwZGF0ZSc6XG4gICAgICBjYXNlICd0b3BWb2x1bWVDaGFuZ2UnOlxuICAgICAgY2FzZSAndG9wV2FpdGluZyc6XG4gICAgICAgIC8vIEhUTUwgRXZlbnRzXG4gICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5kZXguaHRtbCNldmVudHMtMFxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wS2V5UHJlc3MnOlxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBrZXlwcmVzcyBldmVudCBmb3IgZnVuY3Rpb24ga2V5cyB0b28uIFRoaXMgcmVtb3Zlc1xuICAgICAgICAvLyB0aGUgdW53YW50ZWQga2V5cHJlc3MgZXZlbnRzLiBFbnRlciBpcyBob3dldmVyIGJvdGggcHJpbnRhYmxlIGFuZFxuICAgICAgICAvLyBub24tcHJpbnRhYmxlLiBPbmUgd291bGQgZXhwZWN0IFRhYiB0byBiZSBhcyB3ZWxsIChidXQgaXQgaXNuJ3QpLlxuICAgICAgICBpZiAoZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAndG9wS2V5RG93bic6XG4gICAgICBjYXNlICd0b3BLZXlVcCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEJsdXInOlxuICAgICAgY2FzZSAndG9wRm9jdXMnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BDbGljayc6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGNsaWNrIGV2ZW50IG9uIHJpZ2h0IG1vdXNlIGNsaWNrcy4gVGhpcyByZW1vdmVzIHRoZVxuICAgICAgICAvLyB1bndhbnRlZCBjbGljayBldmVudHMuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5idXR0b24gPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAndG9wRG91YmxlQ2xpY2snOlxuICAgICAgY2FzZSAndG9wTW91c2VEb3duJzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlTW92ZSc6XG4gICAgICBjYXNlICd0b3BNb3VzZVVwJzpcbiAgICAgICAgLy8gRGlzYWJsZWQgZWxlbWVudHMgc2hvdWxkIG5vdCByZXNwb25kIHRvIG1vdXNlIGV2ZW50c1xuICAgICAgICBpZiAoc2hvdWxkUHJldmVudE1vdXNlRXZlbnQodGFyZ2V0SW5zdCkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAndG9wTW91c2VPdXQnOlxuICAgICAgY2FzZSAndG9wTW91c2VPdmVyJzpcbiAgICAgIGNhc2UgJ3RvcENvbnRleHRNZW51JzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wRHJhZyc6XG4gICAgICBjYXNlICd0b3BEcmFnRW5kJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdFbnRlcic6XG4gICAgICBjYXNlICd0b3BEcmFnRXhpdCc6XG4gICAgICBjYXNlICd0b3BEcmFnTGVhdmUnOlxuICAgICAgY2FzZSAndG9wRHJhZ092ZXInOlxuICAgICAgY2FzZSAndG9wRHJhZ1N0YXJ0JzpcbiAgICAgIGNhc2UgJ3RvcERyb3AnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRHJhZ0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFRvdWNoQ2FuY2VsJzpcbiAgICAgIGNhc2UgJ3RvcFRvdWNoRW5kJzpcbiAgICAgIGNhc2UgJ3RvcFRvdWNoTW92ZSc6XG4gICAgICBjYXNlICd0b3BUb3VjaFN0YXJ0JzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQW5pbWF0aW9uRW5kJzpcbiAgICAgIGNhc2UgJ3RvcEFuaW1hdGlvbkl0ZXJhdGlvbic6XG4gICAgICBjYXNlICd0b3BBbmltYXRpb25TdGFydCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNBbmltYXRpb25FdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BUcmFuc2l0aW9uRW5kJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BTY3JvbGwnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVUlFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BXaGVlbCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcENvcHknOlxuICAgICAgY2FzZSAndG9wQ3V0JzpcbiAgICAgIGNhc2UgJ3RvcFBhc3RlJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgIUV2ZW50Q29uc3RydWN0b3IgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnU2ltcGxlRXZlbnRQbHVnaW46IFVuaGFuZGxlZCBldmVudCB0eXBlLCBgJXNgLicsIHRvcExldmVsVHlwZSkgOiBfcHJvZEludmFyaWFudCgnODYnLCB0b3BMZXZlbFR5cGUpIDogdm9pZCAwO1xuICAgIHZhciBldmVudCA9IEV2ZW50Q29uc3RydWN0b3IuZ2V0UG9vbGVkKGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9LFxuXG4gIGRpZFB1dExpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICAvLyBNb2JpbGUgU2FmYXJpIGRvZXMgbm90IGZpcmUgcHJvcGVybHkgYnViYmxlIGNsaWNrIGV2ZW50cyBvblxuICAgIC8vIG5vbi1pbnRlcmFjdGl2ZSBlbGVtZW50cywgd2hpY2ggbWVhbnMgZGVsZWdhdGVkIGNsaWNrIGxpc3RlbmVycyBkbyBub3RcbiAgICAvLyBmaXJlLiBUaGUgd29ya2Fyb3VuZCBmb3IgdGhpcyBidWcgaW52b2x2ZXMgYXR0YWNoaW5nIGFuIGVtcHR5IGNsaWNrXG4gICAgLy8gbGlzdGVuZXIgb24gdGhlIHRhcmdldCBub2RlLlxuICAgIC8vIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDEwLzA5L2NsaWNrX2V2ZW50X2RlbC5odG1sXG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09ICdvbkNsaWNrJyAmJiAhaXNJbnRlcmFjdGl2ZShpbnN0Ll90YWcpKSB7XG4gICAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcbiAgICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gICAgICBpZiAoIW9uQ2xpY2tMaXN0ZW5lcnNba2V5XSkge1xuICAgICAgICBvbkNsaWNrTGlzdGVuZXJzW2tleV0gPSBFdmVudExpc3RlbmVyLmxpc3Rlbihub2RlLCAnY2xpY2snLCBlbXB0eUZ1bmN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgd2lsbERlbGV0ZUxpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSAnb25DbGljaycgJiYgIWlzSW50ZXJhY3RpdmUoaW5zdC5fdGFnKSkge1xuICAgICAgdmFyIGtleSA9IGdldERpY3Rpb25hcnlLZXkoaW5zdCk7XG4gICAgICBvbkNsaWNrTGlzdGVuZXJzW2tleV0ucmVtb3ZlKCk7XG4gICAgICBkZWxldGUgb25DbGlja0xpc3RlbmVyc1trZXldO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpbXBsZUV2ZW50UGx1Z2luO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL1NpbXBsZUV2ZW50UGx1Z2luLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1hbmltYXRpb25zLyNBbmltYXRpb25FdmVudC1pbnRlcmZhY2VcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FuaW1hdGlvbkV2ZW50XG4gKi9cbnZhciBBbmltYXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgYW5pbWF0aW9uTmFtZTogbnVsbCxcbiAgZWxhcHNlZFRpbWU6IG51bGwsXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNBbmltYXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNBbmltYXRpb25FdmVudCwgQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0FuaW1hdGlvbkV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY2xpcGJvYXJkLWFwaXMvXG4gKi9cbnZhciBDbGlwYm9hcmRFdmVudEludGVyZmFjZSA9IHtcbiAgY2xpcGJvYXJkRGF0YTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdjbGlwYm9hcmREYXRhJyBpbiBldmVudCA/IGV2ZW50LmNsaXBib2FyZERhdGEgOiB3aW5kb3cuY2xpcGJvYXJkRGF0YTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljQ2xpcGJvYXJkRXZlbnQsIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNDbGlwYm9hcmRFdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzXG4gKi9cbnZhciBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQsIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNNb3VzZUV2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBEcmFnRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRHJhZ0V2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhVHJhbnNmZXI6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0RyYWdFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljTW91c2VFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljTW91c2VFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljRHJhZ0V2ZW50LCBEcmFnRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0RyYWdFdmVudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNEcmFnRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDE1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRm9jdXNFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBGb2N1c0V2ZW50SW50ZXJmYWNlID0ge1xuICByZWxhdGVkVGFyZ2V0OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNGb2N1c0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNGb2N1c0V2ZW50LCBGb2N1c0V2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0ZvY3VzRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDE1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNVxuICogICAgICAvI2V2ZW50cy1pbnB1dGV2ZW50c1xuICovXG52YXIgSW5wdXRFdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljSW5wdXRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNJbnB1dEV2ZW50LCBJbnB1dEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNJbnB1dEV2ZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0lucHV0RXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDE1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xuXG52YXIgZ2V0RXZlbnRDaGFyQ29kZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRDaGFyQ29kZScpO1xudmFyIGdldEV2ZW50S2V5ID0gcmVxdWlyZSgnLi9nZXRFdmVudEtleScpO1xudmFyIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRNb2RpZmllclN0YXRlJyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBLZXlib2FyZEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEtleWJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGtleTogZ2V0RXZlbnRLZXksXG4gIGxvY2F0aW9uOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICByZXBlYXQ6IG51bGwsXG4gIGxvY2FsZTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICAvLyBMZWdhY3kgSW50ZXJmYWNlXG4gIGNoYXJDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgY2hhckNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlQcmVzcyBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyB0aGUgYWN0dWFsIHByaW50YWJsZSBjaGFyYWN0ZXIuXG5cbiAgICAvLyBLZXlQcmVzcyBpcyBkZXByZWNhdGVkLCBidXQgaXRzIHJlcGxhY2VtZW50IGlzIG5vdCB5ZXQgZmluYWwgYW5kIG5vdFxuICAgIC8vIGltcGxlbWVudGVkIGluIGFueSBtYWpvciBicm93c2VyLiBPbmx5IEtleVByZXNzIGhhcyBjaGFyQ29kZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAga2V5Q29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYGtleUNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlEb3duL1VwIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHBoeXNpY2FsIGtleWJvYXJkIGtleS5cblxuICAgIC8vIFRoZSBhY3R1YWwgbWVhbmluZyBvZiB0aGUgdmFsdWUgZGVwZW5kcyBvbiB0aGUgdXNlcnMnIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHdoaWNoIGNhbm5vdCBiZSBkZXRlY3RlZC4gQXNzdW1pbmcgdGhhdCBpdCBpcyBhIFVTIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHByb3ZpZGVzIGEgc3VycHJpc2luZ2x5IGFjY3VyYXRlIG1hcHBpbmcgZm9yIFVTIGFuZCBFdXJvcGVhbiB1c2Vycy5cbiAgICAvLyBEdWUgdG8gdGhpcywgaXQgaXMgbGVmdCB0byB0aGUgdXNlciB0byBpbXBsZW1lbnQgYXQgdGhpcyB0aW1lLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICB3aGljaDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYHdoaWNoYCBpcyBhbiBhbGlhcyBmb3IgZWl0aGVyIGBrZXlDb2RlYCBvciBgY2hhckNvZGVgIGRlcGVuZGluZyBvbiB0aGVcbiAgICAvLyB0eXBlIG9mIHRoZSBldmVudC5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljS2V5Ym9hcmRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljS2V5Ym9hcmRFdmVudCwgS2V5Ym9hcmRFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljS2V5Ym9hcmRFdmVudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNLZXlib2FyZEV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcblxudmFyIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRNb2RpZmllclN0YXRlJyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBUb3VjaEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy9cbiAqL1xudmFyIFRvdWNoRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHRvdWNoZXM6IG51bGwsXG4gIHRhcmdldFRvdWNoZXM6IG51bGwsXG4gIGNoYW5nZWRUb3VjaGVzOiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1RvdWNoRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RvdWNoRXZlbnQsIFRvdWNoRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljVG91Y2hFdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDkvV0QtY3NzMy10cmFuc2l0aW9ucy0yMDA5MDMyMC8jdHJhbnNpdGlvbi1ldmVudHMtXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UcmFuc2l0aW9uRXZlbnRcbiAqL1xudmFyIFRyYW5zaXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgcHJvcGVydHlOYW1lOiBudWxsLFxuICBlbGFwc2VkVGltZTogbnVsbCxcbiAgcHNldWRvRWxlbWVudDogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQsIFRyYW5zaXRpb25FdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY1RyYW5zaXRpb25FdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNNb3VzZUV2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBXaGVlbEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFdoZWVsRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRlbHRhWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVgnIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFYIDpcbiAgICAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVhgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAocmlnaHQgaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWCcgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVggOiAwO1xuICB9LFxuICBkZWx0YVk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFZJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWSA6XG4gICAgLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFZYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVkgOlxuICAgIC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhYCBmb3IgSUU8OSBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YSA6IDA7XG4gIH0sXG4gIGRlbHRhWjogbnVsbCxcblxuICAvLyBCcm93c2VycyB3aXRob3V0IFwiZGVsdGFNb2RlXCIgaXMgcmVwb3J0aW5nIGluIHJhdyB3aGVlbCBkZWx0YSB3aGVyZSBvbmVcbiAgLy8gbm90Y2ggb24gdGhlIHNjcm9sbCBpcyBhbHdheXMgKy8tIDEyMCwgcm91Z2hseSBlcXVpdmFsZW50IHRvIHBpeGVscy5cbiAgLy8gQSBnb29kIGFwcHJveGltYXRpb24gb2YgRE9NX0RFTFRBX0xJTkUgKDEpIGlzIDUlIG9mIHZpZXdwb3J0IHNpemUgb3JcbiAgLy8gfjQwIHBpeGVscywgZm9yIERPTV9ERUxUQV9TQ1JFRU4gKDIpIGl0IGlzIDg3LjUlIG9mIHZpZXdwb3J0IHNpemUuXG4gIGRlbHRhTW9kZTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljTW91c2VFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljV2hlZWxFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljTW91c2VFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljTW91c2VFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljV2hlZWxFdmVudCwgV2hlZWxFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljV2hlZWxFdmVudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNXaGVlbEV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTU9EID0gNjU1MjE7XG5cbi8vIGFkbGVyMzIgaXMgbm90IGNyeXB0b2dyYXBoaWNhbGx5IHN0cm9uZywgYW5kIGlzIG9ubHkgdXNlZCB0byBzYW5pdHkgY2hlY2sgdGhhdFxuLy8gbWFya3VwIGdlbmVyYXRlZCBvbiB0aGUgc2VydmVyIG1hdGNoZXMgdGhlIG1hcmt1cCBnZW5lcmF0ZWQgb24gdGhlIGNsaWVudC5cbi8vIFRoaXMgaW1wbGVtZW50YXRpb24gKGEgbW9kaWZpZWQgdmVyc2lvbiBvZiB0aGUgU2hlZXRKUyB2ZXJzaW9uKSBoYXMgYmVlbiBvcHRpbWl6ZWRcbi8vIGZvciBvdXIgdXNlIGNhc2UsIGF0IHRoZSBleHBlbnNlIG9mIGNvbmZvcm1pbmcgdG8gdGhlIGFkbGVyMzIgc3BlY2lmaWNhdGlvblxuLy8gZm9yIG5vbi1hc2NpaSBpbnB1dHMuXG5mdW5jdGlvbiBhZGxlcjMyKGRhdGEpIHtcbiAgdmFyIGEgPSAxO1xuICB2YXIgYiA9IDA7XG4gIHZhciBpID0gMDtcbiAgdmFyIGwgPSBkYXRhLmxlbmd0aDtcbiAgdmFyIG0gPSBsICYgfjB4MztcbiAgd2hpbGUgKGkgPCBtKSB7XG4gICAgdmFyIG4gPSBNYXRoLm1pbihpICsgNDA5NiwgbSk7XG4gICAgZm9yICg7IGkgPCBuOyBpICs9IDQpIHtcbiAgICAgIGIgKz0gKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkpKSArIChhICs9IGRhdGEuY2hhckNvZGVBdChpICsgMSkpICsgKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkgKyAyKSkgKyAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSArIDMpKTtcbiAgICB9XG4gICAgYSAlPSBNT0Q7XG4gICAgYiAlPSBNT0Q7XG4gIH1cbiAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICBiICs9IGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIGEgJT0gTU9EO1xuICBiICU9IE1PRDtcbiAgcmV0dXJuIGEgfCBiIDw8IDE2O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkbGVyMzI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvYWRsZXIzMi5qc1xuLy8gbW9kdWxlIGlkID0gMTU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rO1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpIHtcbiAgLy8gVGVtcG9yYXJ5IGhhY2suXG4gIC8vIElubGluZSByZXF1aXJlcyBkb24ndCB3b3JrIHdlbGwgd2l0aCBKZXN0OlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNDBcbiAgLy8gUmVtb3ZlIHRoZSBpbmxpbmUgcmVxdWlyZXMgd2hlbiB3ZSBkb24ndCBuZWVkIHRoZW0gYW55bW9yZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzE3OFxuICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9vYmplY3R9IGVsZW1lbnQgVGhlIFJlYWN0IGVsZW1lbnQgdGhhdCBpcyBiZWluZyB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7P251bWJlcn0gZGVidWdJRCBUaGUgUmVhY3QgY29tcG9uZW50IGluc3RhbmNlIHRoYXQgaXMgYmVpbmcgdHlwZS1jaGVja2VkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1JlYWN0VHlwZVNwZWModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50LCBkZWJ1Z0lEKSB7XG4gIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgIHZhciBlcnJvcjtcbiAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAhKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSBSZWFjdC5Qcm9wVHlwZXMuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHR5cGVTcGVjTmFtZSkgOiBfcHJvZEludmFyaWFudCgnODQnLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgdHlwZVNwZWNOYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGVycm9yID0gZXg7XG4gICAgICB9XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghZXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciwgJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvcikgOiB2b2lkIDA7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICB2YXIgY29tcG9uZW50U3RhY2tJbmZvID0gJyc7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoIVJlYWN0Q29tcG9uZW50VHJlZUhvb2spIHtcbiAgICAgICAgICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGVidWdJRCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29tcG9uZW50U3RhY2tJbmZvID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFN0YWNrSW5mbyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0Q3VycmVudFN0YWNrQWRkZW5kdW0oZWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgJXMgdHlwZTogJXMlcycsIGxvY2F0aW9uLCBlcnJvci5tZXNzYWdlLCBjb21wb25lbnRTdGFja0luZm8pIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUmVhY3RUeXBlU3BlYztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9jaGVja1JlYWN0VHlwZVNwZWMuanNcbi8vIG1vZHVsZSBpZCA9IDE1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ1NTUHJvcGVydHkgPSByZXF1aXJlKCcuL0NTU1Byb3BlcnR5Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyO1xudmFyIHN0eWxlV2FybmluZ3MgPSB7fTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byB0aGUgcHJvcGVyIGNzcyB3cml0YWJsZSB2YWx1ZS4gVGhlIHN0eWxlIG5hbWUgYG5hbWVgXG4gKiBzaG91bGQgYmUgbG9naWNhbCAobm8gaHlwaGVucyksIGFzIHNwZWNpZmllZFxuICogaW4gYENTU1Byb3BlcnR5LmlzVW5pdGxlc3NOdW1iZXJgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIENTUyBwcm9wZXJ0eSBuYW1lIHN1Y2ggYXMgYHRvcE1hcmdpbmAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIENTUyBwcm9wZXJ0eSB2YWx1ZSBzdWNoIGFzIGAxMHB4YC5cbiAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGNvbXBvbmVudFxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIHN0eWxlIHZhbHVlIHdpdGggZGltZW5zaW9ucyBhcHBsaWVkLlxuICovXG5mdW5jdGlvbiBkYW5nZXJvdXNTdHlsZVZhbHVlKG5hbWUsIHZhbHVlLCBjb21wb25lbnQpIHtcbiAgLy8gTm90ZSB0aGF0IHdlJ3ZlIHJlbW92ZWQgZXNjYXBlVGV4dEZvckJyb3dzZXIoKSBjYWxscyBoZXJlIHNpbmNlIHRoZVxuICAvLyB3aG9sZSBzdHJpbmcgd2lsbCBiZSBlc2NhcGVkIHdoZW4gdGhlIGF0dHJpYnV0ZSBpcyBpbmplY3RlZCBpbnRvXG4gIC8vIHRoZSBtYXJrdXAuIElmIHlvdSBwcm92aWRlIHVuc2FmZSB1c2VyIGRhdGEgaGVyZSB0aGV5IGNhbiBpbmplY3RcbiAgLy8gYXJiaXRyYXJ5IENTUyB3aGljaCBtYXkgYmUgcHJvYmxlbWF0aWMgKEkgY291bGRuJ3QgcmVwcm8gdGhpcyk6XG4gIC8vIGh0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvWFNTX0ZpbHRlcl9FdmFzaW9uX0NoZWF0X1NoZWV0XG4gIC8vIGh0dHA6Ly93d3cudGhlc3Bhbm5lci5jby51ay8yMDA3LzExLzI2L3VsdGltYXRlLXhzcy1jc3MtaW5qZWN0aW9uL1xuICAvLyBUaGlzIGlzIG5vdCBhbiBYU1MgaG9sZSBidXQgaW5zdGVhZCBhIHBvdGVudGlhbCBDU1MgaW5qZWN0aW9uIGlzc3VlXG4gIC8vIHdoaWNoIGhhcyBsZWFkIHRvIGEgZ3JlYXRlciBkaXNjdXNzaW9uIGFib3V0IGhvdyB3ZSdyZSBnb2luZyB0b1xuICAvLyB0cnVzdCBVUkxzIG1vdmluZyBmb3J3YXJkLiBTZWUgIzIxMTU5MDFcblxuICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xuICBpZiAoaXNFbXB0eSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciBpc05vbk51bWVyaWMgPSBpc05hTih2YWx1ZSk7XG4gIGlmIChpc05vbk51bWVyaWMgfHwgdmFsdWUgPT09IDAgfHwgaXNVbml0bGVzc051bWJlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1VuaXRsZXNzTnVtYmVyW25hbWVdKSB7XG4gICAgcmV0dXJuICcnICsgdmFsdWU7IC8vIGNhc3QgdG8gc3RyaW5nXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBBbGxvdyAnMCcgdG8gcGFzcyB0aHJvdWdoIHdpdGhvdXQgd2FybmluZy4gMCBpcyBhbHJlYWR5IHNwZWNpYWwgYW5kXG4gICAgICAvLyBkb2Vzbid0IHJlcXVpcmUgdW5pdHMsIHNvIHdlIGRvbid0IG5lZWQgdG8gd2FybiBhYm91dCBpdC5cbiAgICAgIGlmIChjb21wb25lbnQgJiYgdmFsdWUgIT09ICcwJykge1xuICAgICAgICB2YXIgb3duZXIgPSBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gb3duZXIuZ2V0TmFtZSgpIDogbnVsbDtcbiAgICAgICAgaWYgKG93bmVyTmFtZSAmJiAhc3R5bGVXYXJuaW5nc1tvd25lck5hbWVdKSB7XG4gICAgICAgICAgc3R5bGVXYXJuaW5nc1tvd25lck5hbWVdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICAgICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgICAgdmFyIHdhcm5pbmdzID0gc3R5bGVXYXJuaW5nc1tvd25lck5hbWVdO1xuICAgICAgICAgIHdhcm5lZCA9IHdhcm5pbmdzW25hbWVdO1xuICAgICAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgICAgICB3YXJuaW5nc1tuYW1lXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdhIGAlc2AgdGFnIChvd25lcjogYCVzYCkgd2FzIHBhc3NlZCBhIG51bWVyaWMgc3RyaW5nIHZhbHVlICcgKyAnZm9yIENTUyBwcm9wZXJ0eSBgJXNgICh2YWx1ZTogYCVzYCkgd2hpY2ggd2lsbCBiZSB0cmVhdGVkICcgKyAnYXMgYSB1bml0bGVzcyBudW1iZXIgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBSZWFjdC4nLCBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50LnR5cGUsIG93bmVyTmFtZSB8fCAndW5rbm93bicsIG5hbWUsIHZhbHVlKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgfVxuICByZXR1cm4gdmFsdWUgKyAncHgnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRhbmdlcm91c1N0eWxlVmFsdWU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvZGFuZ2Vyb3VzU3R5bGVWYWx1ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xuXG52YXIgZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUgPSByZXF1aXJlKCcuL2dldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBET00gbm9kZSByZW5kZXJlZCBieSB0aGlzIGVsZW1lbnQuXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0ZG9tLmZpbmRkb21ub2RlXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudHxET01FbGVtZW50fSBjb21wb25lbnRPckVsZW1lbnRcbiAqIEByZXR1cm4gez9ET01FbGVtZW50fSBUaGUgcm9vdCBub2RlIG9mIHRoaXMgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gZmluZERPTU5vZGUoY29tcG9uZW50T3JFbGVtZW50KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICBpZiAob3duZXIgIT09IG51bGwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciwgJyVzIGlzIGFjY2Vzc2luZyBmaW5kRE9NTm9kZSBpbnNpZGUgaXRzIHJlbmRlcigpLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgb3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbXBvbmVudE9yRWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGNvbXBvbmVudE9yRWxlbWVudC5ub2RlVHlwZSA9PT0gMSkge1xuICAgIHJldHVybiBjb21wb25lbnRPckVsZW1lbnQ7XG4gIH1cblxuICB2YXIgaW5zdCA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KGNvbXBvbmVudE9yRWxlbWVudCk7XG4gIGlmIChpbnN0KSB7XG4gICAgaW5zdCA9IGdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlKGluc3QpO1xuICAgIHJldHVybiBpbnN0ID8gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCkgOiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjb21wb25lbnRPckVsZW1lbnQucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2ZpbmRET01Ob2RlIHdhcyBjYWxsZWQgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKSA6IF9wcm9kSW52YXJpYW50KCc0NCcpIDogdm9pZCAwO1xuICB9IGVsc2Uge1xuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFbGVtZW50IGFwcGVhcnMgdG8gYmUgbmVpdGhlciBSZWFjdENvbXBvbmVudCBub3IgRE9NTm9kZSAoa2V5czogJXMpJywgT2JqZWN0LmtleXMoY29tcG9uZW50T3JFbGVtZW50KSkgOiBfcHJvZEludmFyaWFudCgnNDUnLCBPYmplY3Qua2V5cyhjb21wb25lbnRPckVsZW1lbnQpKSA6IHZvaWQgMDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRET01Ob2RlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL2ZpbmRET01Ob2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgS2V5RXNjYXBlVXRpbHMgPSByZXF1aXJlKCcuL0tleUVzY2FwZVV0aWxzJyk7XG52YXIgdHJhdmVyc2VBbGxDaGlsZHJlbiA9IHJlcXVpcmUoJy4vdHJhdmVyc2VBbGxDaGlsZHJlbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rO1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpIHtcbiAgLy8gVGVtcG9yYXJ5IGhhY2suXG4gIC8vIElubGluZSByZXF1aXJlcyBkb24ndCB3b3JrIHdlbGwgd2l0aCBKZXN0OlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNDBcbiAgLy8gUmVtb3ZlIHRoZSBpbmxpbmUgcmVxdWlyZXMgd2hlbiB3ZSBkb24ndCBuZWVkIHRoZW0gYW55bW9yZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzE3OFxuICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBwYXNzZWQgdGhyb3VnaCB0cmF2ZXJzYWwuXG4gKiBAcGFyYW0gez9SZWFjdENvbXBvbmVudH0gY2hpbGQgUmVhY3QgY2hpbGQgY29tcG9uZW50LlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lIFN0cmluZyBuYW1lIG9mIGtleSBwYXRoIHRvIGNoaWxkLlxuICogQHBhcmFtIHtudW1iZXI9fSBzZWxmRGVidWdJRCBPcHRpb25hbCBkZWJ1Z0lEIG9mIHRoZSBjdXJyZW50IGludGVybmFsIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBmbGF0dGVuU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lLCBzZWxmRGVidWdJRCkge1xuICAvLyBXZSBmb3VuZCBhIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgaWYgKHRyYXZlcnNlQ29udGV4dCAmJiB0eXBlb2YgdHJhdmVyc2VDb250ZXh0ID09PSAnb2JqZWN0Jykge1xuICAgIHZhciByZXN1bHQgPSB0cmF2ZXJzZUNvbnRleHQ7XG4gICAgdmFyIGtleVVuaXF1ZSA9IHJlc3VsdFtuYW1lXSA9PT0gdW5kZWZpbmVkO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIVJlYWN0Q29tcG9uZW50VHJlZUhvb2spIHtcbiAgICAgICAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG4gICAgICB9XG4gICAgICBpZiAoIWtleVVuaXF1ZSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2ZsYXR0ZW5DaGlsZHJlbiguLi4pOiBFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksICcgKyAnYCVzYC4gQ2hpbGQga2V5cyBtdXN0IGJlIHVuaXF1ZTsgd2hlbiB0d28gY2hpbGRyZW4gc2hhcmUgYSBrZXksIG9ubHkgJyArICd0aGUgZmlyc3QgY2hpbGQgd2lsbCBiZSB1c2VkLiVzJywgS2V5RXNjYXBlVXRpbHMudW5lc2NhcGUobmFtZSksIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoc2VsZkRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleVVuaXF1ZSAmJiBjaGlsZCAhPSBudWxsKSB7XG4gICAgICByZXN1bHRbbmFtZV0gPSBjaGlsZDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBGbGF0dGVucyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuIEFueSBudWxsXG4gKiBjaGlsZHJlbiB3aWxsIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0aW5nIG9iamVjdC5cbiAqIEByZXR1cm4geyFvYmplY3R9IGZsYXR0ZW5lZCBjaGlsZHJlbiBrZXllZCBieSBuYW1lLlxuICovXG5mdW5jdGlvbiBmbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW4sIHNlbGZEZWJ1Z0lEKSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciByZXN1bHQgPSB7fTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lKSB7XG4gICAgICByZXR1cm4gZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSwgc2VsZkRlYnVnSUQpO1xuICAgIH0sIHJlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQsIHJlc3VsdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuQ2hpbGRyZW47XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvZmxhdHRlbkNoaWxkcmVuLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGdldEV2ZW50Q2hhckNvZGUgPSByZXF1aXJlKCcuL2dldEV2ZW50Q2hhckNvZGUnKTtcblxuLyoqXG4gKiBOb3JtYWxpemF0aW9uIG9mIGRlcHJlY2F0ZWQgSFRNTDUgYGtleWAgdmFsdWVzXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgbm9ybWFsaXplS2V5ID0ge1xuICAnRXNjJzogJ0VzY2FwZScsXG4gICdTcGFjZWJhcic6ICcgJyxcbiAgJ0xlZnQnOiAnQXJyb3dMZWZ0JyxcbiAgJ1VwJzogJ0Fycm93VXAnLFxuICAnUmlnaHQnOiAnQXJyb3dSaWdodCcsXG4gICdEb3duJzogJ0Fycm93RG93bicsXG4gICdEZWwnOiAnRGVsZXRlJyxcbiAgJ1dpbic6ICdPUycsXG4gICdNZW51JzogJ0NvbnRleHRNZW51JyxcbiAgJ0FwcHMnOiAnQ29udGV4dE1lbnUnLFxuICAnU2Nyb2xsJzogJ1Njcm9sbExvY2snLFxuICAnTW96UHJpbnRhYmxlS2V5JzogJ1VuaWRlbnRpZmllZCdcbn07XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBsZWdhY3kgYGtleUNvZGVgIHRvIEhUTUw1IGBrZXlgXG4gKiBPbmx5IHNwZWNpYWwga2V5cyBzdXBwb3J0ZWQsIGFsbCBvdGhlcnMgZGVwZW5kIG9uIGtleWJvYXJkIGxheW91dCBvciBicm93c2VyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgdHJhbnNsYXRlVG9LZXkgPSB7XG4gIDg6ICdCYWNrc3BhY2UnLFxuICA5OiAnVGFiJyxcbiAgMTI6ICdDbGVhcicsXG4gIDEzOiAnRW50ZXInLFxuICAxNjogJ1NoaWZ0JyxcbiAgMTc6ICdDb250cm9sJyxcbiAgMTg6ICdBbHQnLFxuICAxOTogJ1BhdXNlJyxcbiAgMjA6ICdDYXBzTG9jaycsXG4gIDI3OiAnRXNjYXBlJyxcbiAgMzI6ICcgJyxcbiAgMzM6ICdQYWdlVXAnLFxuICAzNDogJ1BhZ2VEb3duJyxcbiAgMzU6ICdFbmQnLFxuICAzNjogJ0hvbWUnLFxuICAzNzogJ0Fycm93TGVmdCcsXG4gIDM4OiAnQXJyb3dVcCcsXG4gIDM5OiAnQXJyb3dSaWdodCcsXG4gIDQwOiAnQXJyb3dEb3duJyxcbiAgNDU6ICdJbnNlcnQnLFxuICA0NjogJ0RlbGV0ZScsXG4gIDExMjogJ0YxJywgMTEzOiAnRjInLCAxMTQ6ICdGMycsIDExNTogJ0Y0JywgMTE2OiAnRjUnLCAxMTc6ICdGNicsXG4gIDExODogJ0Y3JywgMTE5OiAnRjgnLCAxMjA6ICdGOScsIDEyMTogJ0YxMCcsIDEyMjogJ0YxMScsIDEyMzogJ0YxMicsXG4gIDE0NDogJ051bUxvY2snLFxuICAxNDU6ICdTY3JvbGxMb2NrJyxcbiAgMjI0OiAnTWV0YSdcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIGBrZXlgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudEtleShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQua2V5KSB7XG4gICAgLy8gTm9ybWFsaXplIGluY29uc2lzdGVudCB2YWx1ZXMgcmVwb3J0ZWQgYnkgYnJvd3NlcnMgZHVlIHRvXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIG9mIGEgd29ya2luZyBkcmFmdCBzcGVjaWZpY2F0aW9uLlxuXG4gICAgLy8gRmlyZUZveCBpbXBsZW1lbnRzIGBrZXlgIGJ1dCByZXR1cm5zIGBNb3pQcmludGFibGVLZXlgIGZvciBhbGxcbiAgICAvLyBwcmludGFibGUgY2hhcmFjdGVycyAobm9ybWFsaXplZCB0byBgVW5pZGVudGlmaWVkYCksIGlnbm9yZSBpdC5cbiAgICB2YXIga2V5ID0gbm9ybWFsaXplS2V5W25hdGl2ZUV2ZW50LmtleV0gfHwgbmF0aXZlRXZlbnQua2V5O1xuICAgIGlmIChrZXkgIT09ICdVbmlkZW50aWZpZWQnKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgfVxuXG4gIC8vIEJyb3dzZXIgZG9lcyBub3QgaW1wbGVtZW50IGBrZXlgLCBwb2x5ZmlsbCBhcyBtdWNoIG9mIGl0IGFzIHdlIGNhbi5cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KTtcblxuICAgIC8vIFRoZSBlbnRlci1rZXkgaXMgdGVjaG5pY2FsbHkgYm90aCBwcmludGFibGUgYW5kIG5vbi1wcmludGFibGUgYW5kIGNhblxuICAgIC8vIHRodXMgYmUgY2FwdHVyZWQgYnkgYGtleXByZXNzYCwgbm8gb3RoZXIgbm9uLXByaW50YWJsZSBrZXkgc2hvdWxkLlxuICAgIHJldHVybiBjaGFyQ29kZSA9PT0gMTMgPyAnRW50ZXInIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gIH1cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBuYXRpdmVFdmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgLy8gV2hpbGUgdXNlciBrZXlib2FyZCBsYXlvdXQgZGV0ZXJtaW5lcyB0aGUgYWN0dWFsIG1lYW5pbmcgb2YgZWFjaFxuICAgIC8vIGBrZXlDb2RlYCB2YWx1ZSwgYWxtb3N0IGFsbCBmdW5jdGlvbiBrZXlzIGhhdmUgYSB1bml2ZXJzYWwgdmFsdWUuXG4gICAgcmV0dXJuIHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdIHx8ICdVbmlkZW50aWZpZWQnO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudEtleTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9nZXRFdmVudEtleS5qc1xuLy8gbW9kdWxlIGlkID0gMTYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG5leHREZWJ1Z0lEID0gMTtcblxuZnVuY3Rpb24gZ2V0TmV4dERlYnVnSUQoKSB7XG4gIHJldHVybiBuZXh0RGVidWdJRCsrO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5leHREZWJ1Z0lEO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vbGliL2dldE5leHREZWJ1Z0lELmpzXG4vLyBtb2R1bGUgaWQgPSAxNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHaXZlbiBhbnkgbm9kZSByZXR1cm4gdGhlIGZpcnN0IGxlYWYgbm9kZSB3aXRob3V0IGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuXG5mdW5jdGlvbiBnZXRMZWFmTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlICYmIG5vZGUuZmlyc3RDaGlsZCkge1xuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IHNpYmxpbmcgd2l0aGluIGEgY29udGFpbmVyLiBUaGlzIHdpbGwgd2FsayB1cCB0aGVcbiAqIERPTSBpZiBhIG5vZGUncyBzaWJsaW5ncyBoYXZlIGJlZW4gZXhoYXVzdGVkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7P0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGdldFNpYmxpbmdOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG5vZGVzIHdoaWNoIGNvbnRhaW4gY2hhcmFjdGVycyBhdCBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSByb290XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KHJvb3QsIG9mZnNldCkge1xuICB2YXIgbm9kZSA9IGdldExlYWZOb2RlKHJvb3QpO1xuICB2YXIgbm9kZVN0YXJ0ID0gMDtcbiAgdmFyIG5vZGVFbmQgPSAwO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgIG5vZGVFbmQgPSBub2RlU3RhcnQgKyBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcblxuICAgICAgaWYgKG5vZGVTdGFydCA8PSBvZmZzZXQgJiYgbm9kZUVuZCA+PSBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0IC0gbm9kZVN0YXJ0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG5vZGVTdGFydCA9IG5vZGVFbmQ7XG4gICAgfVxuXG4gICAgbm9kZSA9IGdldExlYWZOb2RlKGdldFNpYmxpbmdOb2RlKG5vZGUpKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldC5qc1xuLy8gbW9kdWxlIGlkID0gMTY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBtYXBwaW5nIG9mIHN0YW5kYXJkIHZlbmRvciBwcmVmaXhlcyB1c2luZyB0aGUgZGVmaW5lZCBzdHlsZSBwcm9wZXJ0eSBhbmQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVQcm9wXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBtYWtlUHJlZml4TWFwKHN0eWxlUHJvcCwgZXZlbnROYW1lKSB7XG4gIHZhciBwcmVmaXhlcyA9IHt9O1xuXG4gIHByZWZpeGVzW3N0eWxlUHJvcC50b0xvd2VyQ2FzZSgpXSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICBwcmVmaXhlc1snV2Via2l0JyArIHN0eWxlUHJvcF0gPSAnd2Via2l0JyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ01veicgKyBzdHlsZVByb3BdID0gJ21veicgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydtcycgKyBzdHlsZVByb3BdID0gJ01TJyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ08nICsgc3R5bGVQcm9wXSA9ICdvJyArIGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIHJldHVybiBwcmVmaXhlcztcbn1cblxuLyoqXG4gKiBBIGxpc3Qgb2YgZXZlbnQgbmFtZXMgdG8gYSBjb25maWd1cmFibGUgbGlzdCBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciB2ZW5kb3JQcmVmaXhlcyA9IHtcbiAgYW5pbWF0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uRW5kJyksXG4gIGFuaW1hdGlvbml0ZXJhdGlvbjogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkl0ZXJhdGlvbicpLFxuICBhbmltYXRpb25zdGFydDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvblN0YXJ0JyksXG4gIHRyYW5zaXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ1RyYW5zaXRpb24nLCAnVHJhbnNpdGlvbkVuZCcpXG59O1xuXG4vKipcbiAqIEV2ZW50IG5hbWVzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gZGV0ZWN0ZWQgYW5kIHByZWZpeGVkIChpZiBhcHBsaWNhYmxlKS5cbiAqL1xudmFyIHByZWZpeGVkRXZlbnROYW1lcyA9IHt9O1xuXG4vKipcbiAqIEVsZW1lbnQgdG8gY2hlY2sgZm9yIHByZWZpeGVzIG9uLlxuICovXG52YXIgc3R5bGUgPSB7fTtcblxuLyoqXG4gKiBCb290c3RyYXAgaWYgYSBET00gZXhpc3RzLlxuICovXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG5cbiAgLy8gT24gc29tZSBwbGF0Zm9ybXMsIGluIHBhcnRpY3VsYXIgc29tZSByZWxlYXNlcyBvZiBBbmRyb2lkIDQueCxcbiAgLy8gdGhlIHVuLXByZWZpeGVkIFwiYW5pbWF0aW9uXCIgYW5kIFwidHJhbnNpdGlvblwiIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgb24gdGhlXG4gIC8vIHN0eWxlIG9iamVjdCBidXQgdGhlIGV2ZW50cyB0aGF0IGZpcmUgd2lsbCBzdGlsbCBiZSBwcmVmaXhlZCwgc28gd2UgbmVlZFxuICAvLyB0byBjaGVjayBpZiB0aGUgdW4tcHJlZml4ZWQgZXZlbnRzIGFyZSB1c2FibGUsIGFuZCBpZiBub3QgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgbWFwLlxuICBpZiAoISgnQW5pbWF0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uaXRlcmF0aW9uLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uc3RhcnQuYW5pbWF0aW9uO1xuICB9XG5cbiAgLy8gU2FtZSBhcyBhYm92ZVxuICBpZiAoISgnVHJhbnNpdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbjtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGRldGVybWluZSB0aGUgY29ycmVjdCB2ZW5kb3IgcHJlZml4ZWQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShldmVudE5hbWUpIHtcbiAgaWYgKHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdO1xuICB9IGVsc2UgaWYgKCF2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIGV2ZW50TmFtZTtcbiAgfVxuXG4gIHZhciBwcmVmaXhNYXAgPSB2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdO1xuXG4gIGZvciAodmFyIHN0eWxlUHJvcCBpbiBwcmVmaXhNYXApIHtcbiAgICBpZiAocHJlZml4TWFwLmhhc093blByb3BlcnR5KHN0eWxlUHJvcCkgJiYgc3R5bGVQcm9wIGluIHN0eWxlKSB7XG4gICAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0gPSBwcmVmaXhNYXBbc3R5bGVQcm9wXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9saWIvZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUuanNcbi8vIG1vZHVsZSBpZCA9IDE2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcblxuLyoqXG4gKiBFc2NhcGVzIGF0dHJpYnV0ZSB2YWx1ZSB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpIHtcbiAgcmV0dXJuICdcIicgKyBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodmFsdWUpICsgJ1wiJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9xdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMTY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNb3VudC5yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL2xpYi9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lci5qc1xuLy8gbW9kdWxlIGlkID0gMTY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgX2h5cGhlblBhdHRlcm4gPSAvLSguKS9nO1xuXG4vKipcbiAqIENhbWVsY2FzZXMgYSBoeXBoZW5hdGVkIHN0cmluZywgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF9oeXBoZW5QYXR0ZXJuLCBmdW5jdGlvbiAoXywgY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL34vZmJqcy9saWIvY2FtZWxpemUuanNcbi8vIG1vZHVsZSBpZCA9IDE3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW1lbGl6ZSA9IHJlcXVpcmUoJy4vY2FtZWxpemUnKTtcblxudmFyIG1zUGF0dGVybiA9IC9eLW1zLS87XG5cbi8qKlxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnYmFja2dyb3VuZC1jb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCctbW96LXRyYW5zaXRpb24nKVxuICogICA8IFwiTW96VHJhbnNpdGlvblwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tcy10cmFuc2l0aW9uJylcbiAqICAgPCBcIm1zVHJhbnNpdGlvblwiXG4gKlxuICogQXMgQW5kaSBTbWl0aCBzdWdnZXN0c1xuICogKGh0dHA6Ly93d3cuYW5kaXNtaXRoLmNvbS9ibG9nLzIwMTIvMDIvbW9kZXJuaXpyLXByZWZpeGVkLyksIGFuIGAtbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGxvd2VyY2FzZSBgbXNgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBjYW1lbGl6ZShzdHJpbmcucmVwbGFjZShtc1BhdHRlcm4sICdtcy0nKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxpemVTdHlsZU5hbWU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9+L2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxudmFyIGlzVGV4dE5vZGUgPSByZXF1aXJlKCcuL2lzVGV4dE5vZGUnKTtcblxuLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gRE9NIG5vZGUgY29udGFpbnMgb3IgaXMgYW5vdGhlciBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlKSB7XG4gIGlmICghb3V0ZXJOb2RlIHx8ICFpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlID09PSBpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKG91dGVyTm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShpbm5lck5vZGUpKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZS5wYXJlbnROb2RlKTtcbiAgfSBlbHNlIGlmICgnY29udGFpbnMnIGluIG91dGVyTm9kZSkge1xuICAgIHJldHVybiBvdXRlck5vZGUuY29udGFpbnMoaW5uZXJOb2RlKTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICByZXR1cm4gISEob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGlubmVyTm9kZSkgJiAxNik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGFpbnNOb2RlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vfi9mYmpzL2xpYi9jb250YWluc05vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDE3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIENvbnZlcnQgYXJyYXktbGlrZSBvYmplY3RzIHRvIGFycmF5cy5cbiAqXG4gKiBUaGlzIEFQSSBhc3N1bWVzIHRoZSBjYWxsZXIga25vd3MgdGhlIGNvbnRlbnRzIG9mIHRoZSBkYXRhIHR5cGUuIEZvciBsZXNzXG4gKiB3ZWxsIGRlZmluZWQgaW5wdXRzIHVzZSBjcmVhdGVBcnJheUZyb21NaXhlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbnxmaWxlbGlzdH0gb2JqXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgdmFyIGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cbiAgLy8gU29tZSBicm93c2VycyBidWlsdGluIG9iamVjdHMgY2FuIHJlcG9ydCB0eXBlb2YgJ2Z1bmN0aW9uJyAoZS5nLiBOb2RlTGlzdFxuICAvLyBpbiBvbGQgdmVyc2lvbnMgb2YgU2FmYXJpKS5cbiAgISghQXJyYXkuaXNBcnJheShvYmopICYmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogQXJyYXktbGlrZSBvYmplY3QgZXhwZWN0ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgISh0eXBlb2YgbGVuZ3RoID09PSAnbnVtYmVyJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogT2JqZWN0IG5lZWRzIGEgbGVuZ3RoIHByb3BlcnR5JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICEobGVuZ3RoID09PSAwIHx8IGxlbmd0aCAtIDEgaW4gb2JqKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBPYmplY3Qgc2hvdWxkIGhhdmUga2V5cyBmb3IgaW5kaWNlcycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAhKHR5cGVvZiBvYmouY2FsbGVlICE9PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBPYmplY3QgY2FuXFwndCBiZSBgYXJndW1lbnRzYC4gVXNlIHJlc3QgcGFyYW1zICcgKyAnKGZ1bmN0aW9uKC4uLmFyZ3MpIHt9KSBvciBBcnJheS5mcm9tKCkgaW5zdGVhZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgLy8gT2xkIElFIGRvZXNuJ3QgZ2l2ZSBjb2xsZWN0aW9ucyBhY2Nlc3MgdG8gaGFzT3duUHJvcGVydHkuIEFzc3VtZSBpbnB1dHNcbiAgLy8gd2l0aG91dCBtZXRob2Qgd2lsbCB0aHJvdyBkdXJpbmcgdGhlIHNsaWNlIGNhbGwgYW5kIHNraXAgc3RyYWlnaHQgdG8gdGhlXG4gIC8vIGZhbGxiYWNrLlxuICBpZiAob2JqLmhhc093blByb3BlcnR5KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmopO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElFIDwgOSBkb2VzIG5vdCBzdXBwb3J0IEFycmF5I3NsaWNlIG9uIGNvbGxlY3Rpb25zIG9iamVjdHNcbiAgICB9XG4gIH1cblxuICAvLyBGYWxsIGJhY2sgdG8gY29weWluZyBrZXkgYnkga2V5LiBUaGlzIGFzc3VtZXMgYWxsIGtleXMgaGF2ZSBhIHZhbHVlLFxuICAvLyBzbyB3aWxsIG5vdCBwcmVzZXJ2ZSBzcGFyc2VseSBwb3B1bGF0ZWQgaW5wdXRzLlxuICB2YXIgcmV0ID0gQXJyYXkobGVuZ3RoKTtcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGxlbmd0aDsgaWkrKykge1xuICAgIHJldFtpaV0gPSBvYmpbaWldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogUGVyZm9ybSBhIGhldXJpc3RpYyB0ZXN0IHRvIGRldGVybWluZSBpZiBhbiBvYmplY3QgaXMgXCJhcnJheS1saWtlXCIuXG4gKlxuICogICBBIG1vbmsgYXNrZWQgSm9zaHUsIGEgWmVuIG1hc3RlciwgXCJIYXMgYSBkb2cgQnVkZGhhIG5hdHVyZT9cIlxuICogICBKb3NodSByZXBsaWVkOiBcIk11LlwiXG4gKlxuICogVGhpcyBmdW5jdGlvbiBkZXRlcm1pbmVzIGlmIGl0cyBhcmd1bWVudCBoYXMgXCJhcnJheSBuYXR1cmVcIjogaXQgcmV0dXJuc1xuICogdHJ1ZSBpZiB0aGUgYXJndW1lbnQgaXMgYW4gYWN0dWFsIGFycmF5LCBhbiBgYXJndW1lbnRzJyBvYmplY3QsIG9yIGFuXG4gKiBIVE1MQ29sbGVjdGlvbiAoZS5nLiBub2RlLmNoaWxkTm9kZXMgb3Igbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgpKS5cbiAqXG4gKiBJdCB3aWxsIHJldHVybiBmYWxzZSBmb3Igb3RoZXIgYXJyYXktbGlrZSBvYmplY3RzIGxpa2UgRmlsZWxpc3QuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGhhc0FycmF5TmF0dXJlKG9iaikge1xuICByZXR1cm4gKFxuICAgIC8vIG5vdCBudWxsL2ZhbHNlXG4gICAgISFvYmogJiYgKFxuICAgIC8vIGFycmF5cyBhcmUgb2JqZWN0cywgTm9kZUxpc3RzIGFyZSBmdW5jdGlvbnMgaW4gU2FmYXJpXG4gICAgdHlwZW9mIG9iaiA9PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqID09ICdmdW5jdGlvbicpICYmXG4gICAgLy8gcXVhY2tzIGxpa2UgYW4gYXJyYXlcbiAgICAnbGVuZ3RoJyBpbiBvYmogJiZcbiAgICAvLyBub3Qgd2luZG93XG4gICAgISgnc2V0SW50ZXJ2YWwnIGluIG9iaikgJiZcbiAgICAvLyBubyBET00gbm9kZSBzaG91bGQgYmUgY29uc2lkZXJlZCBhbiBhcnJheS1saWtlXG4gICAgLy8gYSAnc2VsZWN0JyBlbGVtZW50IGhhcyAnbGVuZ3RoJyBhbmQgJ2l0ZW0nIHByb3BlcnRpZXMgb24gSUU4XG4gICAgdHlwZW9mIG9iai5ub2RlVHlwZSAhPSAnbnVtYmVyJyAmJiAoXG4gICAgLy8gYSByZWFsIGFycmF5XG4gICAgQXJyYXkuaXNBcnJheShvYmopIHx8XG4gICAgLy8gYXJndW1lbnRzXG4gICAgJ2NhbGxlZScgaW4gb2JqIHx8XG4gICAgLy8gSFRNTENvbGxlY3Rpb24vTm9kZUxpc3RcbiAgICAnaXRlbScgaW4gb2JqKVxuICApO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSBieSB3cmFwcGluZyBpdCBpbiBhbiBhcnJheSBpZiBpdCBpcyBub3QuXG4gKiBDcmVhdGVzIGEgY29weSBvZiB0aGUgYXJndW1lbnQgaWYgaXQgaXMgYWxyZWFkeSBhbiBhcnJheS5cbiAqXG4gKiBUaGlzIGlzIG1vc3RseSB1c2VmdWwgaWRpb21hdGljYWxseTpcbiAqXG4gKiAgIHZhciBjcmVhdGVBcnJheUZyb21NaXhlZCA9IHJlcXVpcmUoJ2NyZWF0ZUFycmF5RnJvbU1peGVkJyk7XG4gKlxuICogICBmdW5jdGlvbiB0YWtlc09uZU9yTW9yZVRoaW5ncyh0aGluZ3MpIHtcbiAqICAgICB0aGluZ3MgPSBjcmVhdGVBcnJheUZyb21NaXhlZCh0aGluZ3MpO1xuICogICAgIC4uLlxuICogICB9XG4gKlxuICogVGhpcyBhbGxvd3MgeW91IHRvIHRyZWF0IGB0aGluZ3MnIGFzIGFuIGFycmF5LCBidXQgYWNjZXB0IHNjYWxhcnMgaW4gdGhlIEFQSS5cbiAqXG4gKiBJZiB5b3UgbmVlZCB0byBjb252ZXJ0IGFuIGFycmF5LWxpa2Ugb2JqZWN0LCBsaWtlIGBhcmd1bWVudHNgLCBpbnRvIGFuIGFycmF5XG4gKiB1c2UgdG9BcnJheSBpbnN0ZWFkLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXJyYXlGcm9tTWl4ZWQob2JqKSB7XG4gIGlmICghaGFzQXJyYXlOYXR1cmUob2JqKSkge1xuICAgIHJldHVybiBbb2JqXTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLnNsaWNlKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRvQXJyYXkob2JqKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFycmF5RnJvbU1peGVkO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vfi9mYmpzL2xpYi9jcmVhdGVBcnJheUZyb21NaXhlZC5qc1xuLy8gbW9kdWxlIGlkID0gMTczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyplc2xpbnQtZGlzYWJsZSBmYi13d3cvdW5zYWZlLWh0bWwqL1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBjcmVhdGVBcnJheUZyb21NaXhlZCA9IHJlcXVpcmUoJy4vY3JlYXRlQXJyYXlGcm9tTWl4ZWQnKTtcbnZhciBnZXRNYXJrdXBXcmFwID0gcmVxdWlyZSgnLi9nZXRNYXJrdXBXcmFwJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnLi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBEdW1teSBjb250YWluZXIgdXNlZCB0byByZW5kZXIgYWxsIG1hcmt1cC5cbiAqL1xudmFyIGR1bW15Tm9kZSA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpIDogbnVsbDtcblxuLyoqXG4gKiBQYXR0ZXJuIHVzZWQgYnkgYGdldE5vZGVOYW1lYC5cbiAqL1xudmFyIG5vZGVOYW1lUGF0dGVybiA9IC9eXFxzKjwoXFx3KykvO1xuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSBgbm9kZU5hbWVgIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIFN0cmluZyBvZiBtYXJrdXAuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBOb2RlIG5hbWUgb2YgdGhlIHN1cHBsaWVkIG1hcmt1cC5cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZU5hbWUobWFya3VwKSB7XG4gIHZhciBub2RlTmFtZU1hdGNoID0gbWFya3VwLm1hdGNoKG5vZGVOYW1lUGF0dGVybik7XG4gIHJldHVybiBub2RlTmFtZU1hdGNoICYmIG5vZGVOYW1lTWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG5vZGVzIHJlbmRlcmVkIGZyb20gdGhlIHN1cHBsaWVkIG1hcmt1cC4gVGhlXG4gKiBvcHRpb25hbGx5IHN1cHBsaWVkIGBoYW5kbGVTY3JpcHRgIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBvbmNlIGZvciBlYWNoXG4gKiA8c2NyaXB0PiBlbGVtZW50IHRoYXQgaXMgcmVuZGVyZWQuIElmIG5vIGBoYW5kbGVTY3JpcHRgIGZ1bmN0aW9uIGlzIHN1cHBsaWVkLFxuICogYW4gZXhjZXB0aW9uIGlzIHRocm93biBpZiBhbnkgPHNjcmlwdD4gZWxlbWVudHMgYXJlIHJlbmRlcmVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgQSBzdHJpbmcgb2YgdmFsaWQgSFRNTCBtYXJrdXAuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gaGFuZGxlU2NyaXB0IEludm9rZWQgb25jZSBmb3IgZWFjaCByZW5kZXJlZCA8c2NyaXB0Pi5cbiAqIEByZXR1cm4ge2FycmF5PERPTUVsZW1lbnR8RE9NVGV4dE5vZGU+fSBBbiBhcnJheSBvZiByZW5kZXJlZCBub2Rlcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTm9kZXNGcm9tTWFya3VwKG1hcmt1cCwgaGFuZGxlU2NyaXB0KSB7XG4gIHZhciBub2RlID0gZHVtbXlOb2RlO1xuICAhISFkdW1teU5vZGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnY3JlYXRlTm9kZXNGcm9tTWFya3VwIGR1bW15IG5vdCBpbml0aWFsaXplZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgdmFyIG5vZGVOYW1lID0gZ2V0Tm9kZU5hbWUobWFya3VwKTtcblxuICB2YXIgd3JhcCA9IG5vZGVOYW1lICYmIGdldE1hcmt1cFdyYXAobm9kZU5hbWUpO1xuICBpZiAod3JhcCkge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gd3JhcFsxXSArIG1hcmt1cCArIHdyYXBbMl07XG5cbiAgICB2YXIgd3JhcERlcHRoID0gd3JhcFswXTtcbiAgICB3aGlsZSAod3JhcERlcHRoLS0pIHtcbiAgICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5pbm5lckhUTUwgPSBtYXJrdXA7XG4gIH1cblxuICB2YXIgc2NyaXB0cyA9IG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuICBpZiAoc2NyaXB0cy5sZW5ndGgpIHtcbiAgICAhaGFuZGxlU2NyaXB0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCguLi4pOiBVbmV4cGVjdGVkIDxzY3JpcHQ+IGVsZW1lbnQgcmVuZGVyZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNyZWF0ZUFycmF5RnJvbU1peGVkKHNjcmlwdHMpLmZvckVhY2goaGFuZGxlU2NyaXB0KTtcbiAgfVxuXG4gIHZhciBub2RlcyA9IEFycmF5LmZyb20obm9kZS5jaGlsZE5vZGVzKTtcbiAgd2hpbGUgKG5vZGUubGFzdENoaWxkKSB7XG4gICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmxhc3RDaGlsZCk7XG4gIH1cbiAgcmV0dXJuIG5vZGVzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZU5vZGVzRnJvbU1hcmt1cDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL34vZmJqcy9saWIvY3JlYXRlTm9kZXNGcm9tTWFya3VwLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbi8qZXNsaW50LWRpc2FibGUgZmItd3d3L3Vuc2FmZS1odG1sICovXG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbi8qKlxuICogRHVtbXkgY29udGFpbmVyIHVzZWQgdG8gZGV0ZWN0IHdoaWNoIHdyYXBzIGFyZSBuZWNlc3NhcnkuXG4gKi9cbnZhciBkdW1teU5vZGUgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSA6IG51bGw7XG5cbi8qKlxuICogU29tZSBicm93c2VycyBjYW5ub3QgdXNlIGBpbm5lckhUTUxgIHRvIHJlbmRlciBjZXJ0YWluIGVsZW1lbnRzIHN0YW5kYWxvbmUsXG4gKiBzbyB3ZSB3cmFwIHRoZW0sIHJlbmRlciB0aGUgd3JhcHBlZCBub2RlcywgdGhlbiBleHRyYWN0IHRoZSBkZXNpcmVkIG5vZGUuXG4gKlxuICogSW4gSUU4LCBjZXJ0YWluIGVsZW1lbnRzIGNhbm5vdCByZW5kZXIgYWxvbmUsIHNvIHdyYXAgYWxsIGVsZW1lbnRzICgnKicpLlxuICovXG5cbnZhciBzaG91bGRXcmFwID0ge307XG5cbnZhciBzZWxlY3RXcmFwID0gWzEsICc8c2VsZWN0IG11bHRpcGxlPVwidHJ1ZVwiPicsICc8L3NlbGVjdD4nXTtcbnZhciB0YWJsZVdyYXAgPSBbMSwgJzx0YWJsZT4nLCAnPC90YWJsZT4nXTtcbnZhciB0cldyYXAgPSBbMywgJzx0YWJsZT48dGJvZHk+PHRyPicsICc8L3RyPjwvdGJvZHk+PC90YWJsZT4nXTtcblxudmFyIHN2Z1dyYXAgPSBbMSwgJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPicsICc8L3N2Zz4nXTtcblxudmFyIG1hcmt1cFdyYXAgPSB7XG4gICcqJzogWzEsICc/PGRpdj4nLCAnPC9kaXY+J10sXG5cbiAgJ2FyZWEnOiBbMSwgJzxtYXA+JywgJzwvbWFwPiddLFxuICAnY29sJzogWzIsICc8dGFibGU+PHRib2R5PjwvdGJvZHk+PGNvbGdyb3VwPicsICc8L2NvbGdyb3VwPjwvdGFibGU+J10sXG4gICdsZWdlbmQnOiBbMSwgJzxmaWVsZHNldD4nLCAnPC9maWVsZHNldD4nXSxcbiAgJ3BhcmFtJzogWzEsICc8b2JqZWN0PicsICc8L29iamVjdD4nXSxcbiAgJ3RyJzogWzIsICc8dGFibGU+PHRib2R5PicsICc8L3Rib2R5PjwvdGFibGU+J10sXG5cbiAgJ29wdGdyb3VwJzogc2VsZWN0V3JhcCxcbiAgJ29wdGlvbic6IHNlbGVjdFdyYXAsXG5cbiAgJ2NhcHRpb24nOiB0YWJsZVdyYXAsXG4gICdjb2xncm91cCc6IHRhYmxlV3JhcCxcbiAgJ3Rib2R5JzogdGFibGVXcmFwLFxuICAndGZvb3QnOiB0YWJsZVdyYXAsXG4gICd0aGVhZCc6IHRhYmxlV3JhcCxcblxuICAndGQnOiB0cldyYXAsXG4gICd0aCc6IHRyV3JhcFxufTtcblxuLy8gSW5pdGlhbGl6ZSB0aGUgU1ZHIGVsZW1lbnRzIHNpbmNlIHdlIGtub3cgdGhleSdsbCBhbHdheXMgbmVlZCB0byBiZSB3cmFwcGVkXG4vLyBjb25zaXN0ZW50bHkuIElmIHRoZXkgYXJlIGNyZWF0ZWQgaW5zaWRlIGEgPGRpdj4gdGhleSB3aWxsIGJlIGluaXRpYWxpemVkIGluXG4vLyB0aGUgd3JvbmcgbmFtZXNwYWNlIChhbmQgd2lsbCBub3QgZGlzcGxheSkuXG52YXIgc3ZnRWxlbWVudHMgPSBbJ2NpcmNsZScsICdjbGlwUGF0aCcsICdkZWZzJywgJ2VsbGlwc2UnLCAnZycsICdpbWFnZScsICdsaW5lJywgJ2xpbmVhckdyYWRpZW50JywgJ21hc2snLCAncGF0aCcsICdwYXR0ZXJuJywgJ3BvbHlnb24nLCAncG9seWxpbmUnLCAncmFkaWFsR3JhZGllbnQnLCAncmVjdCcsICdzdG9wJywgJ3RleHQnLCAndHNwYW4nXTtcbnN2Z0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG5vZGVOYW1lKSB7XG4gIG1hcmt1cFdyYXBbbm9kZU5hbWVdID0gc3ZnV3JhcDtcbiAgc2hvdWxkV3JhcFtub2RlTmFtZV0gPSB0cnVlO1xufSk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFya3VwIHdyYXAgY29uZmlndXJhdGlvbiBmb3IgdGhlIHN1cHBsaWVkIGBub2RlTmFtZWAuXG4gKlxuICogTk9URTogVGhpcyBsYXppbHkgZGV0ZWN0cyB3aGljaCB3cmFwcyBhcmUgbmVjZXNzYXJ5IGZvciB0aGUgY3VycmVudCBicm93c2VyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBub2RlTmFtZSBMb3dlcmNhc2UgYG5vZGVOYW1lYC5cbiAqIEByZXR1cm4gez9hcnJheX0gTWFya3VwIHdyYXAgY29uZmlndXJhdGlvbiwgaWYgYXBwbGljYWJsZS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFya3VwV3JhcChub2RlTmFtZSkge1xuICAhISFkdW1teU5vZGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTWFya3VwIHdyYXBwaW5nIG5vZGUgbm90IGluaXRpYWxpemVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBpZiAoIW1hcmt1cFdyYXAuaGFzT3duUHJvcGVydHkobm9kZU5hbWUpKSB7XG4gICAgbm9kZU5hbWUgPSAnKic7XG4gIH1cbiAgaWYgKCFzaG91bGRXcmFwLmhhc093blByb3BlcnR5KG5vZGVOYW1lKSkge1xuICAgIGlmIChub2RlTmFtZSA9PT0gJyonKSB7XG4gICAgICBkdW1teU5vZGUuaW5uZXJIVE1MID0gJzxsaW5rIC8+JztcbiAgICB9IGVsc2Uge1xuICAgICAgZHVtbXlOb2RlLmlubmVySFRNTCA9ICc8JyArIG5vZGVOYW1lICsgJz48LycgKyBub2RlTmFtZSArICc+JztcbiAgICB9XG4gICAgc2hvdWxkV3JhcFtub2RlTmFtZV0gPSAhZHVtbXlOb2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIHNob3VsZFdyYXBbbm9kZU5hbWVdID8gbWFya3VwV3JhcFtub2RlTmFtZV0gOiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcmt1cFdyYXA7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9+L2ZianMvbGliL2dldE1hcmt1cFdyYXAuanNcbi8vIG1vZHVsZSBpZCA9IDE3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2V0cyB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBzdXBwbGllZCBlbGVtZW50IG9yIHdpbmRvdy5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlcyBhcmUgdW5ib3VuZGVkLCB1bmxpa2UgYGdldFNjcm9sbFBvc2l0aW9uYC4gVGhpcyBtZWFucyB0aGV5XG4gKiBtYXkgYmUgbmVnYXRpdmUgb3IgZXhjZWVkIHRoZSBlbGVtZW50IGJvdW5kYXJpZXMgKHdoaWNoIGlzIHBvc3NpYmxlIHVzaW5nXG4gKiBpbmVydGlhbCBzY3JvbGxpbmcpLlxuICpcbiAqIEBwYXJhbSB7RE9NV2luZG93fERPTUVsZW1lbnR9IHNjcm9sbGFibGVcbiAqIEByZXR1cm4ge29iamVjdH0gTWFwIHdpdGggYHhgIGFuZCBgeWAga2V5cy5cbiAqL1xuXG5mdW5jdGlvbiBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbihzY3JvbGxhYmxlKSB7XG4gIGlmIChzY3JvbGxhYmxlID09PSB3aW5kb3cpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgeTogd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3BcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogc2Nyb2xsYWJsZS5zY3JvbGxMZWZ0LFxuICAgIHk6IHNjcm9sbGFibGUuc2Nyb2xsVG9wXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb247XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9+L2ZianMvbGliL2dldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgX3VwcGVyY2FzZVBhdHRlcm4gPSAvKFtBLVpdKS9nO1xuXG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIHN0cmluZywgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICpcbiAqIEZvciBDU1Mgc3R5bGUgbmFtZXMsIHVzZSBgaHlwaGVuYXRlU3R5bGVOYW1lYCBpbnN0ZWFkIHdoaWNoIHdvcmtzIHByb3Blcmx5XG4gKiB3aXRoIGFsbCB2ZW5kb3IgcHJlZml4ZXMsIGluY2x1ZGluZyBgbXNgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaHlwaGVuYXRlKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoX3VwcGVyY2FzZVBhdHRlcm4sICctJDEnKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL34vZmJqcy9saWIvaHlwaGVuYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaHlwaGVuYXRlID0gcmVxdWlyZSgnLi9oeXBoZW5hdGUnKTtcblxudmFyIG1zUGF0dGVybiA9IC9ebXMtLztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBoeXBoZW5hdGUoc3RyaW5nKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGVTdHlsZU5hbWU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9+L2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gMTc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyBhIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBpc05vZGUob2JqZWN0KSB7XG4gIHJldHVybiAhIShvYmplY3QgJiYgKHR5cGVvZiBOb2RlID09PSAnZnVuY3Rpb24nID8gb2JqZWN0IGluc3RhbmNlb2YgTm9kZSA6IHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmplY3Qubm9kZVR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBvYmplY3Qubm9kZU5hbWUgPT09ICdzdHJpbmcnKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOb2RlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1kb20vfi9mYmpzL2xpYi9pc05vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDE3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL2lzTm9kZScpO1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIHRleHQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNUZXh0Tm9kZShvYmplY3QpIHtcbiAgcmV0dXJuIGlzTm9kZShvYmplY3QpICYmIG9iamVjdC5ub2RlVHlwZSA9PSAzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dE5vZGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9+L2ZianMvbGliL2lzVGV4dE5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDE4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNZW1vaXplcyB0aGUgcmV0dXJuIHZhbHVlIG9mIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIG9uZSBzdHJpbmcgYXJndW1lbnQuXG4gKi9cblxuZnVuY3Rpb24gbWVtb2l6ZVN0cmluZ09ubHkoY2FsbGJhY2spIHtcbiAgdmFyIGNhY2hlID0ge307XG4gIHJldHVybiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgaWYgKCFjYWNoZS5oYXNPd25Qcm9wZXJ0eShzdHJpbmcpKSB7XG4gICAgICBjYWNoZVtzdHJpbmddID0gY2FsbGJhY2suY2FsbCh0aGlzLCBzdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVbc3RyaW5nXTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplU3RyaW5nT25seTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL34vZmJqcy9saWIvbWVtb2l6ZVN0cmluZ09ubHkuanNcbi8vIG1vZHVsZSBpZCA9IDE4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIHBlcmZvcm1hbmNlO1xuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHBlcmZvcm1hbmNlID0gd2luZG93LnBlcmZvcm1hbmNlIHx8IHdpbmRvdy5tc1BlcmZvcm1hbmNlIHx8IHdpbmRvdy53ZWJraXRQZXJmb3JtYW5jZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwZXJmb3JtYW5jZSB8fCB7fTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtZG9tL34vZmJqcy9saWIvcGVyZm9ybWFuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDE4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBwZXJmb3JtYW5jZSA9IHJlcXVpcmUoJy4vcGVyZm9ybWFuY2UnKTtcblxudmFyIHBlcmZvcm1hbmNlTm93O1xuXG4vKipcbiAqIERldGVjdCBpZiB3ZSBjYW4gdXNlIGB3aW5kb3cucGVyZm9ybWFuY2Uubm93KClgIGFuZCBncmFjZWZ1bGx5IGZhbGxiYWNrIHRvXG4gKiBgRGF0ZS5ub3coKWAgaWYgaXQgZG9lc24ndCBleGlzdC4gV2UgbmVlZCB0byBzdXBwb3J0IEZpcmVmb3ggPCAxNSBmb3Igbm93XG4gKiBiZWNhdXNlIG9mIEZhY2Vib29rJ3MgdGVzdGluZyBpbmZyYXN0cnVjdHVyZS5cbiAqL1xuaWYgKHBlcmZvcm1hbmNlLm5vdykge1xuICBwZXJmb3JtYW5jZU5vdyA9IGZ1bmN0aW9uIHBlcmZvcm1hbmNlTm93KCkge1xuICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgfTtcbn0gZWxzZSB7XG4gIHBlcmZvcm1hbmNlTm93ID0gZnVuY3Rpb24gcGVyZm9ybWFuY2VOb3coKSB7XG4gICAgcmV0dXJuIERhdGUubm93KCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGVyZm9ybWFuY2VOb3c7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWRvbS9+L2ZianMvbGliL3BlcmZvcm1hbmNlTm93LmpzXG4vLyBtb2R1bGUgaWQgPSAxODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIHRyYXZlcnNlQWxsQ2hpbGRyZW4gPSByZXF1aXJlKCcuL3RyYXZlcnNlQWxsQ2hpbGRyZW4nKTtcblxudmFyIHR3b0FyZ3VtZW50UG9vbGVyID0gUG9vbGVkQ2xhc3MudHdvQXJndW1lbnRQb29sZXI7XG52YXIgZm91ckFyZ3VtZW50UG9vbGVyID0gUG9vbGVkQ2xhc3MuZm91ckFyZ3VtZW50UG9vbGVyO1xuXG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nO1xuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cblxuLyoqXG4gKiBQb29sZWRDbGFzcyByZXByZXNlbnRpbmcgdGhlIGJvb2trZWVwaW5nIGFzc29jaWF0ZWQgd2l0aCBwZXJmb3JtaW5nIGEgY2hpbGRcbiAqIHRyYXZlcnNhbC4gQWxsb3dzIGF2b2lkaW5nIGJpbmRpbmcgY2FsbGJhY2tzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBGb3JFYWNoQm9va0tlZXBpbmdcbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBmb3JFYWNoRnVuY3Rpb24gRnVuY3Rpb24gdG8gcGVyZm9ybSB0cmF2ZXJzYWwgd2l0aC5cbiAqIEBwYXJhbSB7Pyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgdG8gcGVyZm9ybSBjb250ZXh0IHdpdGguXG4gKi9cbmZ1bmN0aW9uIEZvckVhY2hCb29rS2VlcGluZyhmb3JFYWNoRnVuY3Rpb24sIGZvckVhY2hDb250ZXh0KSB7XG4gIHRoaXMuZnVuYyA9IGZvckVhY2hGdW5jdGlvbjtcbiAgdGhpcy5jb250ZXh0ID0gZm9yRWFjaENvbnRleHQ7XG4gIHRoaXMuY291bnQgPSAwO1xufVxuRm9yRWFjaEJvb2tLZWVwaW5nLnByb3RvdHlwZS5kZXN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmZ1bmMgPSBudWxsO1xuICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICB0aGlzLmNvdW50ID0gMDtcbn07XG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oRm9yRWFjaEJvb2tLZWVwaW5nLCB0d29Bcmd1bWVudFBvb2xlcik7XG5cbmZ1bmN0aW9uIGZvckVhY2hTaW5nbGVDaGlsZChib29rS2VlcGluZywgY2hpbGQsIG5hbWUpIHtcbiAgdmFyIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jLFxuICAgICAgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG5cbiAgZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IEZvckVhY2hCb29rS2VlcGluZy5nZXRQb29sZWQoZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaFNpbmdsZUNoaWxkLCB0cmF2ZXJzZUNvbnRleHQpO1xuICBGb3JFYWNoQm9va0tlZXBpbmcucmVsZWFzZSh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIFBvb2xlZENsYXNzIHJlcHJlc2VudGluZyB0aGUgYm9va2tlZXBpbmcgYXNzb2NpYXRlZCB3aXRoIHBlcmZvcm1pbmcgYSBjaGlsZFxuICogbWFwcGluZy4gQWxsb3dzIGF2b2lkaW5nIGJpbmRpbmcgY2FsbGJhY2tzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBNYXBCb29rS2VlcGluZ1xuICogQHBhcmFtIHshKn0gbWFwUmVzdWx0IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICogQHBhcmFtIHshZnVuY3Rpb259IG1hcEZ1bmN0aW9uIEZ1bmN0aW9uIHRvIHBlcmZvcm0gbWFwcGluZyB3aXRoLlxuICogQHBhcmFtIHs/Kn0gbWFwQ29udGV4dCBDb250ZXh0IHRvIHBlcmZvcm0gbWFwcGluZyB3aXRoLlxuICovXG5mdW5jdGlvbiBNYXBCb29rS2VlcGluZyhtYXBSZXN1bHQsIGtleVByZWZpeCwgbWFwRnVuY3Rpb24sIG1hcENvbnRleHQpIHtcbiAgdGhpcy5yZXN1bHQgPSBtYXBSZXN1bHQ7XG4gIHRoaXMua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICB0aGlzLmZ1bmMgPSBtYXBGdW5jdGlvbjtcbiAgdGhpcy5jb250ZXh0ID0gbWFwQ29udGV4dDtcbiAgdGhpcy5jb3VudCA9IDA7XG59XG5NYXBCb29rS2VlcGluZy5wcm90b3R5cGUuZGVzdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZXN1bHQgPSBudWxsO1xuICB0aGlzLmtleVByZWZpeCA9IG51bGw7XG4gIHRoaXMuZnVuYyA9IG51bGw7XG4gIHRoaXMuY29udGV4dCA9IG51bGw7XG4gIHRoaXMuY291bnQgPSAwO1xufTtcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhNYXBCb29rS2VlcGluZywgZm91ckFyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dChib29rS2VlcGluZywgY2hpbGQsIGNoaWxkS2V5KSB7XG4gIHZhciByZXN1bHQgPSBib29rS2VlcGluZy5yZXN1bHQsXG4gICAgICBrZXlQcmVmaXggPSBib29rS2VlcGluZy5rZXlQcmVmaXgsXG4gICAgICBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG5cbiAgdmFyIG1hcHBlZENoaWxkID0gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChtYXBwZWRDaGlsZCwgcmVzdWx0LCBjaGlsZEtleSwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChtYXBwZWRDaGlsZCkpIHtcbiAgICAgIG1hcHBlZENoaWxkID0gUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZUtleShtYXBwZWRDaGlsZCxcbiAgICAgIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgIGtleVByZWZpeCArIChtYXBwZWRDaGlsZC5rZXkgJiYgKCFjaGlsZCB8fCBjaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkgPyBlc2NhcGVVc2VyUHJvdmlkZWRLZXkobWFwcGVkQ2hpbGQua2V5KSArICcvJyA6ICcnKSArIGNoaWxkS2V5KTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2gobWFwcGVkQ2hpbGQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIGFycmF5LCBwcmVmaXgsIGZ1bmMsIGNvbnRleHQpIHtcbiAgdmFyIGVzY2FwZWRQcmVmaXggPSAnJztcbiAgaWYgKHByZWZpeCAhPSBudWxsKSB7XG4gICAgZXNjYXBlZFByZWZpeCA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShwcmVmaXgpICsgJy8nO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBNYXBCb29rS2VlcGluZy5nZXRQb29sZWQoYXJyYXksIGVzY2FwZWRQcmVmaXgsIGZ1bmMsIGNvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0LCB0cmF2ZXJzZUNvbnRleHQpO1xuICBNYXBCb29rS2VlcGluZy5yZWxlYXNlKHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLm1hcFxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwga2V5LCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBmdW5jLCBjb250ZXh0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkRHVtbXkodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLmNvdW50XG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hTaW5nbGVDaGlsZER1bW15LCBudWxsKTtcbn1cblxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4udG9hcnJheVxuICovXG5mdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgUmVhY3RDaGlsZHJlbiA9IHtcbiAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxuICBtYXA6IG1hcENoaWxkcmVuLFxuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsOiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsLFxuICBjb3VudDogY291bnRDaGlsZHJlbixcbiAgdG9BcnJheTogdG9BcnJheVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENoaWxkcmVuO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RDaGlsZHJlbi5qc1xuLy8gbW9kdWxlIGlkID0gMTg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudCcpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzJyk7XG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlJyk7XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIE1JWElOU19LRVkgPSAnbWl4aW5zJztcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGFsbG93IHRoZSBjcmVhdGlvbiBvZiBhbm9ueW1vdXMgZnVuY3Rpb25zIHdoaWNoIGRvIG5vdFxuLy8gaGF2ZSAubmFtZSBzZXQgdG8gdGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIGJlaW5nIGFzc2lnbmVkIHRvLlxuZnVuY3Rpb24gaWRlbnRpdHkoZm4pIHtcbiAgcmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFBvbGljaWVzIHRoYXQgZGVzY3JpYmUgbWV0aG9kcyBpbiBgUmVhY3RDbGFzc0ludGVyZmFjZWAuXG4gKi9cblxuXG52YXIgaW5qZWN0ZWRNaXhpbnMgPSBbXTtcblxuLyoqXG4gKiBDb21wb3NpdGUgY29tcG9uZW50cyBhcmUgaGlnaGVyLWxldmVsIGNvbXBvbmVudHMgdGhhdCBjb21wb3NlIG90aGVyIGNvbXBvc2l0ZVxuICogb3IgaG9zdCBjb21wb25lbnRzLlxuICpcbiAqIFRvIGNyZWF0ZSBhIG5ldyB0eXBlIG9mIGBSZWFjdENsYXNzYCwgcGFzcyBhIHNwZWNpZmljYXRpb24gb2ZcbiAqIHlvdXIgbmV3IGNsYXNzIHRvIGBSZWFjdC5jcmVhdGVDbGFzc2AuIFRoZSBvbmx5IHJlcXVpcmVtZW50IG9mIHlvdXIgY2xhc3NcbiAqIHNwZWNpZmljYXRpb24gaXMgdGhhdCB5b3UgaW1wbGVtZW50IGEgYHJlbmRlcmAgbWV0aG9kLlxuICpcbiAqICAgdmFyIE15Q29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gKiAgICAgICByZXR1cm4gPGRpdj5IZWxsbyBXb3JsZDwvZGl2PjtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFRoZSBjbGFzcyBzcGVjaWZpY2F0aW9uIHN1cHBvcnRzIGEgc3BlY2lmaWMgcHJvdG9jb2wgb2YgbWV0aG9kcyB0aGF0IGhhdmVcbiAqIHNwZWNpYWwgbWVhbmluZyAoZS5nLiBgcmVuZGVyYCkuIFNlZSBgUmVhY3RDbGFzc0ludGVyZmFjZWAgZm9yXG4gKiBtb3JlIHRoZSBjb21wcmVoZW5zaXZlIHByb3RvY29sLiBBbnkgb3RoZXIgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBpbiB0aGVcbiAqIGNsYXNzIHNwZWNpZmljYXRpb24gd2lsbCBiZSBhdmFpbGFibGUgb24gdGhlIHByb3RvdHlwZS5cbiAqXG4gKiBAaW50ZXJmYWNlIFJlYWN0Q2xhc3NJbnRlcmZhY2VcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RDbGFzc0ludGVyZmFjZSA9IHtcblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgTWl4aW4gb2JqZWN0cyB0byBpbmNsdWRlIHdoZW4gZGVmaW5pbmcgeW91ciBjb21wb25lbnQuXG4gICAqXG4gICAqIEB0eXBlIHthcnJheX1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBtaXhpbnM6ICdERUZJTkVfTUFOWScsXG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgdGhhdCBzaG91bGQgYmUgZGVmaW5lZCBvblxuICAgKiB0aGUgY29tcG9uZW50J3MgY29uc3RydWN0b3IgaW5zdGVhZCBvZiBpdHMgcHJvdG90eXBlIChzdGF0aWMgbWV0aG9kcykuXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgc3RhdGljczogJ0RFRklORV9NQU5ZJyxcblxuICAvKipcbiAgICogRGVmaW5pdGlvbiBvZiBwcm9wIHR5cGVzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBwcm9wVHlwZXM6ICdERUZJTkVfTUFOWScsXG5cbiAgLyoqXG4gICAqIERlZmluaXRpb24gb2YgY29udGV4dCB0eXBlcyBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29udGV4dFR5cGVzOiAnREVGSU5FX01BTlknLFxuXG4gIC8qKlxuICAgKiBEZWZpbml0aW9uIG9mIGNvbnRleHQgdHlwZXMgdGhpcyBjb21wb25lbnQgc2V0cyBmb3IgaXRzIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNoaWxkQ29udGV4dFR5cGVzOiAnREVGSU5FX01BTlknLFxuXG4gIC8vID09PT0gRGVmaW5pdGlvbiBtZXRob2RzID09PT1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC4gVmFsdWVzIGluIHRoZSBtYXBwaW5nIHdpbGwgYmUgc2V0IG9uXG4gICAqIGB0aGlzLnByb3BzYCBpZiB0aGF0IHByb3AgaXMgbm90IHNwZWNpZmllZCAoaS5lLiB1c2luZyBhbiBgaW5gIGNoZWNrKS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCBiZWZvcmUgYGdldEluaXRpYWxTdGF0ZWAgYW5kIHRoZXJlZm9yZSBjYW5ub3QgcmVseVxuICAgKiBvbiBgdGhpcy5zdGF0ZWAgb3IgdXNlIGB0aGlzLnNldFN0YXRlYC5cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGdldERlZmF1bHRQcm9wczogJ0RFRklORV9NQU5ZX01FUkdFRCcsXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb25jZSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgdXNlZFxuICAgKiBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiBgdGhpcy5zdGF0ZWAuXG4gICAqXG4gICAqICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICogICAgIHJldHVybiB7XG4gICAqICAgICAgIGlzT246IGZhbHNlLFxuICAgKiAgICAgICBmb29CYXo6IG5ldyBCYXpGb28oKVxuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGdldEluaXRpYWxTdGF0ZTogJ0RFRklORV9NQU5ZX01FUkdFRCcsXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBnZXRDaGlsZENvbnRleHQ6ICdERUZJTkVfTUFOWV9NRVJHRUQnLFxuXG4gIC8qKlxuICAgKiBVc2VzIHByb3BzIGZyb20gYHRoaXMucHJvcHNgIGFuZCBzdGF0ZSBmcm9tIGB0aGlzLnN0YXRlYCB0byByZW5kZXIgdGhlXG4gICAqIHN0cnVjdHVyZSBvZiB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBObyBndWFyYW50ZWVzIGFyZSBtYWRlIGFib3V0IHdoZW4gb3IgaG93IG9mdGVuIHRoaXMgbWV0aG9kIGlzIGludm9rZWQsIHNvXG4gICAqIGl0IG11c3Qgbm90IGhhdmUgc2lkZSBlZmZlY3RzLlxuICAgKlxuICAgKiAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAqICAgICB2YXIgbmFtZSA9IHRoaXMucHJvcHMubmFtZTtcbiAgICogICAgIHJldHVybiA8ZGl2PkhlbGxvLCB7bmFtZX0hPC9kaXY+O1xuICAgKiAgIH1cbiAgICpcbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9XG4gICAqIEBub3NpZGVlZmZlY3RzXG4gICAqIEByZXF1aXJlZFxuICAgKi9cbiAgcmVuZGVyOiAnREVGSU5FX09OQ0UnLFxuXG4gIC8vID09PT0gRGVsZWdhdGUgbWV0aG9kcyA9PT09XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGluaXRpYWxseSBjcmVhdGVkIGFuZCBhYm91dCB0byBiZSBtb3VudGVkLlxuICAgKiBUaGlzIG1heSBoYXZlIHNpZGUgZWZmZWN0cywgYnV0IGFueSBleHRlcm5hbCBzdWJzY3JpcHRpb25zIG9yIGRhdGEgY3JlYXRlZFxuICAgKiBieSB0aGlzIG1ldGhvZCBtdXN0IGJlIGNsZWFuZWQgdXAgaW4gYGNvbXBvbmVudFdpbGxVbm1vdW50YC5cbiAgICpcbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsTW91bnQ6ICdERUZJTkVfTUFOWScsXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWQgYW5kIGhhcyBhIERPTSByZXByZXNlbnRhdGlvbi5cbiAgICogSG93ZXZlciwgdGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIERPTSBub2RlIGlzIGluIHRoZSBkb2N1bWVudC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3BlcmF0ZSBvbiB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBoYXNcbiAgICogYmVlbiBtb3VudGVkIChpbml0aWFsaXplZCBhbmQgcmVuZGVyZWQpIGZvciB0aGUgZmlyc3QgdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290Tm9kZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudC5cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudDogJ0RFRklORV9NQU5ZJyxcblxuICAvKipcbiAgICogSW52b2tlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCByZWNlaXZlcyBuZXcgcHJvcHMuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIHJlYWN0IHRvIGEgcHJvcCB0cmFuc2l0aW9uIGJ5IHVwZGF0aW5nIHRoZVxuICAgKiBzdGF0ZSB1c2luZyBgdGhpcy5zZXRTdGF0ZWAuIEN1cnJlbnQgcHJvcHMgYXJlIGFjY2Vzc2VkIHZpYSBgdGhpcy5wcm9wc2AuXG4gICAqXG4gICAqICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24obmV4dFByb3BzLCBuZXh0Q29udGV4dCkge1xuICAgKiAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAqICAgICAgIGxpa2VzSW5jcmVhc2luZzogbmV4dFByb3BzLmxpa2VDb3VudCA+IHRoaXMucHJvcHMubGlrZUNvdW50XG4gICAqICAgICB9KTtcbiAgICogICB9XG4gICAqXG4gICAqIE5PVEU6IFRoZXJlIGlzIG5vIGVxdWl2YWxlbnQgYGNvbXBvbmVudFdpbGxSZWNlaXZlU3RhdGVgLiBBbiBpbmNvbWluZyBwcm9wXG4gICAqIHRyYW5zaXRpb24gbWF5IGNhdXNlIGEgc3RhdGUgY2hhbmdlLCBidXQgdGhlIG9wcG9zaXRlIGlzIG5vdCB0cnVlLiBJZiB5b3VcbiAgICogbmVlZCBpdCwgeW91IGFyZSBwcm9iYWJseSBsb29raW5nIGZvciBgY29tcG9uZW50V2lsbFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiAnREVGSU5FX01BTlknLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoaWxlIGRlY2lkaW5nIGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIGJlIHVwZGF0ZWQgYXMgYSByZXN1bHQgb2ZcbiAgICogcmVjZWl2aW5nIG5ldyBwcm9wcywgc3RhdGUgYW5kL29yIGNvbnRleHQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIGByZXR1cm4gZmFsc2VgIHdoZW4geW91J3JlIGNlcnRhaW4gdGhhdCB0aGVcbiAgICogdHJhbnNpdGlvbiB0byB0aGUgbmV3IHByb3BzL3N0YXRlL2NvbnRleHQgd2lsbCBub3QgcmVxdWlyZSBhIGNvbXBvbmVudFxuICAgKiB1cGRhdGUuXG4gICAqXG4gICAqICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiBmdW5jdGlvbihuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpIHtcbiAgICogICAgIHJldHVybiAhZXF1YWwobmV4dFByb3BzLCB0aGlzLnByb3BzKSB8fFxuICAgKiAgICAgICAhZXF1YWwobmV4dFN0YXRlLCB0aGlzLnN0YXRlKSB8fFxuICAgKiAgICAgICAhZXF1YWwobmV4dENvbnRleHQsIHRoaXMuY29udGV4dCk7XG4gICAqICAgfVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY29tcG9uZW50IHNob3VsZCB1cGRhdGUuXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiAnREVGSU5FX09OQ0UnLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBhYm91dCB0byB1cGRhdGUgZHVlIHRvIGEgdHJhbnNpdGlvbiBmcm9tXG4gICAqIGB0aGlzLnByb3BzYCwgYHRoaXMuc3RhdGVgIGFuZCBgdGhpcy5jb250ZXh0YCB0byBgbmV4dFByb3BzYCwgYG5leHRTdGF0ZWBcbiAgICogYW5kIGBuZXh0Q29udGV4dGAuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIHBlcmZvcm0gcHJlcGFyYXRpb24gYmVmb3JlIGFuIHVwZGF0ZSBvY2N1cnMuXG4gICAqXG4gICAqIE5PVEU6IFlvdSAqKmNhbm5vdCoqIHVzZSBgdGhpcy5zZXRTdGF0ZSgpYCBpbiB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0XG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsVXBkYXRlOiAnREVGSU5FX01BTlknLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCdzIERPTSByZXByZXNlbnRhdGlvbiBoYXMgYmVlbiB1cGRhdGVkLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBvcGVyYXRlIG9uIHRoZSBET00gd2hlbiB0aGUgY29tcG9uZW50IGhhc1xuICAgKiBiZWVuIHVwZGF0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcmV2UHJvcHNcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2U3RhdGVcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2Q29udGV4dFxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHJvb3ROb2RlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgY29tcG9uZW50LlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogJ0RFRklORV9NQU5ZJyxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYWJvdXQgdG8gYmUgcmVtb3ZlZCBmcm9tIGl0cyBwYXJlbnQgYW5kIGhhdmVcbiAgICogaXRzIERPTSByZXByZXNlbnRhdGlvbiBkZXN0cm95ZWQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIGRlYWxsb2NhdGUgYW55IGV4dGVybmFsIHJlc291cmNlcy5cbiAgICpcbiAgICogTk9URTogVGhlcmUgaXMgbm8gYGNvbXBvbmVudERpZFVubW91bnRgIHNpbmNlIHlvdXIgY29tcG9uZW50IHdpbGwgaGF2ZSBiZWVuXG4gICAqIGRlc3Ryb3llZCBieSB0aGF0IHBvaW50LlxuICAgKlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiAnREVGSU5FX01BTlknLFxuXG4gIC8vID09PT0gQWR2YW5jZWQgbWV0aG9kcyA9PT09XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGNvbXBvbmVudCdzIGN1cnJlbnRseSBtb3VudGVkIERPTSByZXByZXNlbnRhdGlvbi5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhpcyBpbXBsZW1lbnRzIFJlYWN0J3MgcmVuZGVyaW5nIGFuZCByZWNvbmNpbGlhdGlvbiBhbGdvcml0aG0uXG4gICAqIFNvcGhpc3RpY2F0ZWQgY2xpZW50cyBtYXkgd2lzaCB0byBvdmVycmlkZSB0aGlzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAb3ZlcnJpZGFibGVcbiAgICovXG4gIHVwZGF0ZUNvbXBvbmVudDogJ09WRVJSSURFX0JBU0UnXG5cbn07XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIGNsYXNzIHNwZWNpZmljYXRpb24ga2V5cyB0byBzcGVjaWFsIHByb2Nlc3NpbmcgZnVuY3Rpb25zLlxuICpcbiAqIEFsdGhvdWdoIHRoZXNlIGFyZSBkZWNsYXJlZCBsaWtlIGluc3RhbmNlIHByb3BlcnRpZXMgaW4gdGhlIHNwZWNpZmljYXRpb25cbiAqIHdoZW4gZGVmaW5pbmcgY2xhc3NlcyB1c2luZyBgUmVhY3QuY3JlYXRlQ2xhc3NgLCB0aGV5IGFyZSBhY3R1YWxseSBzdGF0aWNcbiAqIGFuZCBhcmUgYWNjZXNzaWJsZSBvbiB0aGUgY29uc3RydWN0b3IgaW5zdGVhZCBvZiB0aGUgcHJvdG90eXBlLiBEZXNwaXRlXG4gKiBiZWluZyBzdGF0aWMsIHRoZXkgbXVzdCBiZSBkZWZpbmVkIG91dHNpZGUgb2YgdGhlIFwic3RhdGljc1wiIGtleSB1bmRlclxuICogd2hpY2ggYWxsIG90aGVyIHN0YXRpYyBtZXRob2RzIGFyZSBkZWZpbmVkLlxuICovXG52YXIgUkVTRVJWRURfU1BFQ19LRVlTID0ge1xuICBkaXNwbGF5TmFtZTogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBkaXNwbGF5TmFtZSkge1xuICAgIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gIH0sXG4gIG1peGluczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBtaXhpbnMpIHtcbiAgICBpZiAobWl4aW5zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1peGlucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3RvciwgbWl4aW5zW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNoaWxkQ29udGV4dFR5cGVzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGNoaWxkQ29udGV4dFR5cGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgY2hpbGRDb250ZXh0VHlwZXMsICdjaGlsZENvbnRleHQnKTtcbiAgICB9XG4gICAgQ29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMgPSBfYXNzaWduKHt9LCBDb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0VHlwZXMpO1xuICB9LFxuICBjb250ZXh0VHlwZXM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgY29udGV4dFR5cGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgY29udGV4dFR5cGVzLCAnY29udGV4dCcpO1xuICAgIH1cbiAgICBDb25zdHJ1Y3Rvci5jb250ZXh0VHlwZXMgPSBfYXNzaWduKHt9LCBDb25zdHJ1Y3Rvci5jb250ZXh0VHlwZXMsIGNvbnRleHRUeXBlcyk7XG4gIH0sXG4gIC8qKlxuICAgKiBTcGVjaWFsIGNhc2UgZ2V0RGVmYXVsdFByb3BzIHdoaWNoIHNob3VsZCBtb3ZlIGludG8gc3RhdGljcyBidXQgcmVxdWlyZXNcbiAgICogYXV0b21hdGljIG1lcmdpbmcuXG4gICAqL1xuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzID0gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24oQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzLCBnZXREZWZhdWx0UHJvcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBnZXREZWZhdWx0UHJvcHM7XG4gICAgfVxuICB9LFxuICBwcm9wVHlwZXM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvcFR5cGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgcHJvcFR5cGVzLCAncHJvcCcpO1xuICAgIH1cbiAgICBDb25zdHJ1Y3Rvci5wcm9wVHlwZXMgPSBfYXNzaWduKHt9LCBDb25zdHJ1Y3Rvci5wcm9wVHlwZXMsIHByb3BUeXBlcyk7XG4gIH0sXG4gIHN0YXRpY3M6IGZ1bmN0aW9uIChDb25zdHJ1Y3Rvciwgc3RhdGljcykge1xuICAgIG1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzdGF0aWNzKTtcbiAgfSxcbiAgYXV0b2JpbmQ6IGZ1bmN0aW9uICgpIHt9IH07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgdHlwZURlZiwgbG9jYXRpb24pIHtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gdHlwZURlZikge1xuICAgIGlmICh0eXBlRGVmLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgLy8gdXNlIGEgd2FybmluZyBpbnN0ZWFkIG9mIGFuIGludmFyaWFudCBzbyBjb21wb25lbnRzXG4gICAgICAvLyBkb24ndCBzaG93IHVwIGluIHByb2QgYnV0IG9ubHkgaW4gX19ERVZfX1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIHR5cGVEZWZbcHJvcE5hbWVdID09PSAnZnVuY3Rpb24nLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICsgJ1JlYWN0LlByb3BUeXBlcy4nLCBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgcHJvcE5hbWUpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlKGlzQWxyZWFkeURlZmluZWQsIG5hbWUpIHtcbiAgdmFyIHNwZWNQb2xpY3kgPSBSZWFjdENsYXNzSW50ZXJmYWNlLmhhc093blByb3BlcnR5KG5hbWUpID8gUmVhY3RDbGFzc0ludGVyZmFjZVtuYW1lXSA6IG51bGw7XG5cbiAgLy8gRGlzYWxsb3cgb3ZlcnJpZGluZyBvZiBiYXNlIGNsYXNzIG1ldGhvZHMgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cbiAgaWYgKFJlYWN0Q2xhc3NNaXhpbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICEoc3BlY1BvbGljeSA9PT0gJ09WRVJSSURFX0JBU0UnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gb3ZlcnJpZGUgYCVzYCBmcm9tIHlvdXIgY2xhc3Mgc3BlY2lmaWNhdGlvbi4gRW5zdXJlIHRoYXQgeW91ciBtZXRob2QgbmFtZXMgZG8gbm90IG92ZXJsYXAgd2l0aCBSZWFjdCBtZXRob2RzLicsIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzczJywgbmFtZSkgOiB2b2lkIDA7XG4gIH1cblxuICAvLyBEaXNhbGxvdyBkZWZpbmluZyBtZXRob2RzIG1vcmUgdGhhbiBvbmNlIHVubGVzcyBleHBsaWNpdGx5IGFsbG93ZWQuXG4gIGlmIChpc0FscmVhZHlEZWZpbmVkKSB7XG4gICAgIShzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTlknIHx8IHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWV9NRVJHRUQnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lIGAlc2Agb24geW91ciBjb21wb25lbnQgbW9yZSB0aGFuIG9uY2UuIFRoaXMgY29uZmxpY3QgbWF5IGJlIGR1ZSB0byBhIG1peGluLicsIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzc0JywgbmFtZSkgOiB2b2lkIDA7XG4gIH1cbn1cblxuLyoqXG4gKiBNaXhpbiBoZWxwZXIgd2hpY2ggaGFuZGxlcyBwb2xpY3kgdmFsaWRhdGlvbiBhbmQgcmVzZXJ2ZWRcbiAqIHNwZWNpZmljYXRpb24ga2V5cyB3aGVuIGJ1aWxkaW5nIFJlYWN0IGNsYXNzZXMuXG4gKi9cbmZ1bmN0aW9uIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzcGVjKSB7XG4gIGlmICghc3BlYykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgdHlwZW9mU3BlYyA9IHR5cGVvZiBzcGVjO1xuICAgICAgdmFyIGlzTWl4aW5WYWxpZCA9IHR5cGVvZlNwZWMgPT09ICdvYmplY3QnICYmIHNwZWMgIT09IG51bGw7XG5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGlzTWl4aW5WYWxpZCwgJyVzOiBZb3VcXCdyZSBhdHRlbXB0aW5nIHRvIGluY2x1ZGUgYSBtaXhpbiB0aGF0IGlzIGVpdGhlciBudWxsICcgKyAnb3Igbm90IGFuIG9iamVjdC4gQ2hlY2sgdGhlIG1peGlucyBpbmNsdWRlZCBieSB0aGUgY29tcG9uZW50LCAnICsgJ2FzIHdlbGwgYXMgYW55IG1peGlucyB0aGV5IGluY2x1ZGUgdGhlbXNlbHZlcy4gJyArICdFeHBlY3RlZCBvYmplY3QgYnV0IGdvdCAlcy4nLCBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDbGFzcycsIHNwZWMgPT09IG51bGwgPyBudWxsIDogdHlwZW9mU3BlYykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgISh0eXBlb2Ygc3BlYyAhPT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91XFwncmUgYXR0ZW1wdGluZyB0byB1c2UgYSBjb21wb25lbnQgY2xhc3Mgb3IgZnVuY3Rpb24gYXMgYSBtaXhpbi4gSW5zdGVhZCwganVzdCB1c2UgYSByZWd1bGFyIG9iamVjdC4nKSA6IF9wcm9kSW52YXJpYW50KCc3NScpIDogdm9pZCAwO1xuICAhIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChzcGVjKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3VcXCdyZSBhdHRlbXB0aW5nIHRvIHVzZSBhIGNvbXBvbmVudCBhcyBhIG1peGluLiBJbnN0ZWFkLCBqdXN0IHVzZSBhIHJlZ3VsYXIgb2JqZWN0LicpIDogX3Byb2RJbnZhcmlhbnQoJzc2JykgOiB2b2lkIDA7XG5cbiAgdmFyIHByb3RvID0gQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICB2YXIgYXV0b0JpbmRQYWlycyA9IHByb3RvLl9fcmVhY3RBdXRvQmluZFBhaXJzO1xuXG4gIC8vIEJ5IGhhbmRsaW5nIG1peGlucyBiZWZvcmUgYW55IG90aGVyIHByb3BlcnRpZXMsIHdlIGVuc3VyZSB0aGUgc2FtZVxuICAvLyBjaGFpbmluZyBvcmRlciBpcyBhcHBsaWVkIHRvIG1ldGhvZHMgd2l0aCBERUZJTkVfTUFOWSBwb2xpY3ksIHdoZXRoZXJcbiAgLy8gbWl4aW5zIGFyZSBsaXN0ZWQgYmVmb3JlIG9yIGFmdGVyIHRoZXNlIG1ldGhvZHMgaW4gdGhlIHNwZWMuXG4gIGlmIChzcGVjLmhhc093blByb3BlcnR5KE1JWElOU19LRVkpKSB7XG4gICAgUkVTRVJWRURfU1BFQ19LRVlTLm1peGlucyhDb25zdHJ1Y3Rvciwgc3BlYy5taXhpbnMpO1xuICB9XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBzcGVjKSB7XG4gICAgaWYgKCFzcGVjLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gTUlYSU5TX0tFWSkge1xuICAgICAgLy8gV2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWQgbWl4aW5zIGluIGEgc3BlY2lhbCBjYXNlIGFib3ZlLlxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIHByb3BlcnR5ID0gc3BlY1tuYW1lXTtcbiAgICB2YXIgaXNBbHJlYWR5RGVmaW5lZCA9IHByb3RvLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgIHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUoaXNBbHJlYWR5RGVmaW5lZCwgbmFtZSk7XG5cbiAgICBpZiAoUkVTRVJWRURfU1BFQ19LRVlTLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBSRVNFUlZFRF9TUEVDX0tFWVNbbmFtZV0oQ29uc3RydWN0b3IsIHByb3BlcnR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2V0dXAgbWV0aG9kcyBvbiBwcm90b3R5cGU6XG4gICAgICAvLyBUaGUgZm9sbG93aW5nIG1lbWJlciBtZXRob2RzIHNob3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBib3VuZDpcbiAgICAgIC8vIDEuIEV4cGVjdGVkIFJlYWN0Q2xhc3MgbWV0aG9kcyAoaW4gdGhlIFwiaW50ZXJmYWNlXCIpLlxuICAgICAgLy8gMi4gT3ZlcnJpZGRlbiBtZXRob2RzICh0aGF0IHdlcmUgbWl4ZWQgaW4pLlxuICAgICAgdmFyIGlzUmVhY3RDbGFzc01ldGhvZCA9IFJlYWN0Q2xhc3NJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gICAgICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIHZhciBzaG91bGRBdXRvQmluZCA9IGlzRnVuY3Rpb24gJiYgIWlzUmVhY3RDbGFzc01ldGhvZCAmJiAhaXNBbHJlYWR5RGVmaW5lZCAmJiBzcGVjLmF1dG9iaW5kICE9PSBmYWxzZTtcblxuICAgICAgaWYgKHNob3VsZEF1dG9CaW5kKSB7XG4gICAgICAgIGF1dG9CaW5kUGFpcnMucHVzaChuYW1lLCBwcm9wZXJ0eSk7XG4gICAgICAgIHByb3RvW25hbWVdID0gcHJvcGVydHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNBbHJlYWR5RGVmaW5lZCkge1xuICAgICAgICAgIHZhciBzcGVjUG9saWN5ID0gUmVhY3RDbGFzc0ludGVyZmFjZVtuYW1lXTtcblxuICAgICAgICAgIC8vIFRoZXNlIGNhc2VzIHNob3VsZCBhbHJlYWR5IGJlIGNhdWdodCBieSB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlLlxuICAgICAgICAgICEoaXNSZWFjdENsYXNzTWV0aG9kICYmIChzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTllfTUVSR0VEJyB8fCBzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTlknKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogVW5leHBlY3RlZCBzcGVjIHBvbGljeSAlcyBmb3Iga2V5ICVzIHdoZW4gbWl4aW5nIGluIGNvbXBvbmVudCBzcGVjcy4nLCBzcGVjUG9saWN5LCBuYW1lKSA6IF9wcm9kSW52YXJpYW50KCc3NycsIHNwZWNQb2xpY3ksIG5hbWUpIDogdm9pZCAwO1xuXG4gICAgICAgICAgLy8gRm9yIG1ldGhvZHMgd2hpY2ggYXJlIGRlZmluZWQgbW9yZSB0aGFuIG9uY2UsIGNhbGwgdGhlIGV4aXN0aW5nXG4gICAgICAgICAgLy8gbWV0aG9kcyBiZWZvcmUgY2FsbGluZyB0aGUgbmV3IHByb3BlcnR5LCBtZXJnaW5nIGlmIGFwcHJvcHJpYXRlLlxuICAgICAgICAgIGlmIChzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTllfTUVSR0VEJykge1xuICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihwcm90b1tuYW1lXSwgcHJvcGVydHkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZJykge1xuICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBjcmVhdGVDaGFpbmVkRnVuY3Rpb24ocHJvdG9bbmFtZV0sIHByb3BlcnR5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvdG9bbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgLy8gQWRkIHZlcmJvc2UgZGlzcGxheU5hbWUgdG8gdGhlIGZ1bmN0aW9uLCB3aGljaCBoZWxwcyB3aGVuIGxvb2tpbmdcbiAgICAgICAgICAgIC8vIGF0IHByb2ZpbGluZyB0b29scy5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdmdW5jdGlvbicgJiYgc3BlYy5kaXNwbGF5TmFtZSkge1xuICAgICAgICAgICAgICBwcm90b1tuYW1lXS5kaXNwbGF5TmFtZSA9IHNwZWMuZGlzcGxheU5hbWUgKyAnXycgKyBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtaXhTdGF0aWNTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3RhdGljcykge1xuICBpZiAoIXN0YXRpY3MpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgbmFtZSBpbiBzdGF0aWNzKSB7XG4gICAgdmFyIHByb3BlcnR5ID0gc3RhdGljc1tuYW1lXTtcbiAgICBpZiAoIXN0YXRpY3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBpc1Jlc2VydmVkID0gbmFtZSBpbiBSRVNFUlZFRF9TUEVDX0tFWVM7XG4gICAgISFpc1Jlc2VydmVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgYSByZXNlcnZlZCBwcm9wZXJ0eSwgYCVzYCwgdGhhdCBzaG91bGRuXFwndCBiZSBvbiB0aGUgXCJzdGF0aWNzXCIga2V5LiBEZWZpbmUgaXQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgaW5zdGVhZDsgaXQgd2lsbCBzdGlsbCBiZSBhY2Nlc3NpYmxlIG9uIHRoZSBjb25zdHJ1Y3Rvci4nLCBuYW1lKSA6IF9wcm9kSW52YXJpYW50KCc3OCcsIG5hbWUpIDogdm9pZCAwO1xuXG4gICAgdmFyIGlzSW5oZXJpdGVkID0gbmFtZSBpbiBDb25zdHJ1Y3RvcjtcbiAgICAhIWlzSW5oZXJpdGVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgYCVzYCBvbiB5b3VyIGNvbXBvbmVudCBtb3JlIHRoYW4gb25jZS4gVGhpcyBjb25mbGljdCBtYXkgYmUgZHVlIHRvIGEgbWl4aW4uJywgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnNzknLCBuYW1lKSA6IHZvaWQgMDtcbiAgICBDb25zdHJ1Y3RvcltuYW1lXSA9IHByb3BlcnR5O1xuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9iamVjdHMsIGJ1dCB0aHJvdyBpZiBib3RoIGNvbnRhaW4gdGhlIHNhbWUga2V5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvbmUgVGhlIGZpcnN0IG9iamVjdCwgd2hpY2ggaXMgbXV0YXRlZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0d28gVGhlIHNlY29uZCBvYmplY3RcbiAqIEByZXR1cm4ge29iamVjdH0gb25lIGFmdGVyIGl0IGhhcyBiZWVuIG11dGF0ZWQgdG8gY29udGFpbiBldmVyeXRoaW5nIGluIHR3by5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhvbmUsIHR3bykge1xuICAhKG9uZSAmJiB0d28gJiYgdHlwZW9mIG9uZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHR3byA9PT0gJ29iamVjdCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ21lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoKTogQ2Fubm90IG1lcmdlIG5vbi1vYmplY3RzLicpIDogX3Byb2RJbnZhcmlhbnQoJzgwJykgOiB2b2lkIDA7XG5cbiAgZm9yICh2YXIga2V5IGluIHR3bykge1xuICAgIGlmICh0d28uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgIShvbmVba2V5XSA9PT0gdW5kZWZpbmVkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKCk6IFRyaWVkIHRvIG1lcmdlIHR3byBvYmplY3RzIHdpdGggdGhlIHNhbWUga2V5OiBgJXNgLiBUaGlzIGNvbmZsaWN0IG1heSBiZSBkdWUgdG8gYSBtaXhpbjsgaW4gcGFydGljdWxhciwgdGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHR3byBnZXRJbml0aWFsU3RhdGUoKSBvciBnZXREZWZhdWx0UHJvcHMoKSBtZXRob2RzIHJldHVybmluZyBvYmplY3RzIHdpdGggY2xhc2hpbmcga2V5cy4nLCBrZXkpIDogX3Byb2RJbnZhcmlhbnQoJzgxJywga2V5KSA6IHZvaWQgMDtcbiAgICAgIG9uZVtrZXldID0gdHdvW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvbmU7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0d28gZnVuY3Rpb25zIGFuZCBtZXJnZXMgdGhlaXIgcmV0dXJuIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbmUgRnVuY3Rpb24gdG8gaW52b2tlIGZpcnN0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHdvIEZ1bmN0aW9uIHRvIGludm9rZSBzZWNvbmQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSB0d28gYXJndW1lbnQgZnVuY3Rpb25zLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24ob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZFJlc3VsdCgpIHtcbiAgICB2YXIgYSA9IG9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHZhciBiID0gdHdvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGEgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfSBlbHNlIGlmIChiID09IG51bGwpIHtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICB2YXIgYyA9IHt9O1xuICAgIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoYywgYSk7XG4gICAgbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhjLCBiKTtcbiAgICByZXR1cm4gYztcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIGlnbm9yZXMgdGhlaXIgcmV0dXJuIHZhbGVzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uZSBGdW5jdGlvbiB0byBpbnZva2UgZmlyc3QuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHR3byBhcmd1bWVudCBmdW5jdGlvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVDaGFpbmVkRnVuY3Rpb24ob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNoYWluZWRGdW5jdGlvbigpIHtcbiAgICBvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0d28uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBCaW5kcyBhIG1ldGhvZCB0byB0aGUgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb21wb25lbnQgQ29tcG9uZW50IHdob3NlIG1ldGhvZCBpcyBnb2luZyB0byBiZSBib3VuZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCBNZXRob2QgdG8gYmUgYm91bmQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGJvdW5kIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gYmluZEF1dG9CaW5kTWV0aG9kKGNvbXBvbmVudCwgbWV0aG9kKSB7XG4gIHZhciBib3VuZE1ldGhvZCA9IG1ldGhvZC5iaW5kKGNvbXBvbmVudCk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XG4gICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQXJndW1lbnRzID0gbnVsbDtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZTtcbiAgICB2YXIgX2JpbmQgPSBib3VuZE1ldGhvZC5iaW5kO1xuICAgIGJvdW5kTWV0aG9kLmJpbmQgPSBmdW5jdGlvbiAobmV3VGhpcykge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICAvLyBVc2VyIGlzIHRyeWluZyB0byBiaW5kKCkgYW4gYXV0b2JvdW5kIG1ldGhvZDsgd2UgZWZmZWN0aXZlbHkgd2lsbFxuICAgICAgLy8gaWdub3JlIHRoZSB2YWx1ZSBvZiBcInRoaXNcIiB0aGF0IHRoZSB1c2VyIGlzIHRyeWluZyB0byB1c2UsIHNvXG4gICAgICAvLyBsZXQncyB3YXJuLlxuICAgICAgaWYgKG5ld1RoaXMgIT09IGNvbXBvbmVudCAmJiBuZXdUaGlzICE9PSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYmluZCgpOiBSZWFjdCBjb21wb25lbnQgbWV0aG9kcyBtYXkgb25seSBiZSBib3VuZCB0byB0aGUgJyArICdjb21wb25lbnQgaW5zdGFuY2UuIFNlZSAlcycsIGNvbXBvbmVudE5hbWUpIDogdm9pZCAwO1xuICAgICAgfSBlbHNlIGlmICghYXJncy5sZW5ndGgpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdiaW5kKCk6IFlvdSBhcmUgYmluZGluZyBhIGNvbXBvbmVudCBtZXRob2QgdG8gdGhlIGNvbXBvbmVudC4gJyArICdSZWFjdCBkb2VzIHRoaXMgZm9yIHlvdSBhdXRvbWF0aWNhbGx5IGluIGEgaGlnaC1wZXJmb3JtYW5jZSAnICsgJ3dheSwgc28geW91IGNhbiBzYWZlbHkgcmVtb3ZlIHRoaXMgY2FsbC4gU2VlICVzJywgY29tcG9uZW50TmFtZSkgOiB2b2lkIDA7XG4gICAgICAgIHJldHVybiBib3VuZE1ldGhvZDtcbiAgICAgIH1cbiAgICAgIHZhciByZWJvdW5kTWV0aG9kID0gX2JpbmQuYXBwbHkoYm91bmRNZXRob2QsIGFyZ3VtZW50cyk7XG4gICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZENvbnRleHQgPSBjb21wb25lbnQ7XG4gICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZE1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQXJndW1lbnRzID0gYXJncztcbiAgICAgIHJldHVybiByZWJvdW5kTWV0aG9kO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGJvdW5kTWV0aG9kO1xufVxuXG4vKipcbiAqIEJpbmRzIGFsbCBhdXRvLWJvdW5kIG1ldGhvZHMgaW4gYSBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCBDb21wb25lbnQgd2hvc2UgbWV0aG9kIGlzIGdvaW5nIHRvIGJlIGJvdW5kLlxuICovXG5mdW5jdGlvbiBiaW5kQXV0b0JpbmRNZXRob2RzKGNvbXBvbmVudCkge1xuICB2YXIgcGFpcnMgPSBjb21wb25lbnQuX19yZWFjdEF1dG9CaW5kUGFpcnM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgYXV0b0JpbmRLZXkgPSBwYWlyc1tpXTtcbiAgICB2YXIgbWV0aG9kID0gcGFpcnNbaSArIDFdO1xuICAgIGNvbXBvbmVudFthdXRvQmluZEtleV0gPSBiaW5kQXV0b0JpbmRNZXRob2QoY29tcG9uZW50LCBtZXRob2QpO1xuICB9XG59XG5cbi8qKlxuICogQWRkIG1vcmUgdG8gdGhlIFJlYWN0Q2xhc3MgYmFzZSBjbGFzcy4gVGhlc2UgYXJlIGFsbCBsZWdhY3kgZmVhdHVyZXMgYW5kXG4gKiB0aGVyZWZvcmUgbm90IGFscmVhZHkgcGFydCBvZiB0aGUgbW9kZXJuIFJlYWN0Q29tcG9uZW50LlxuICovXG52YXIgUmVhY3RDbGFzc01peGluID0ge1xuXG4gIC8qKlxuICAgKiBUT0RPOiBUaGlzIHdpbGwgYmUgZGVwcmVjYXRlZCBiZWNhdXNlIHN0YXRlIHNob3VsZCBhbHdheXMga2VlcCBhIGNvbnNpc3RlbnRcbiAgICogdHlwZSBzaWduYXR1cmUgYW5kIHRoZSBvbmx5IHVzZSBjYXNlIGZvciB0aGlzLCBpcyB0byBhdm9pZCB0aGF0LlxuICAgKi9cbiAgcmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAobmV3U3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy51cGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUodGhpcywgbmV3U3RhdGUpO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdGhpcy51cGRhdGVyLmVucXVldWVDYWxsYmFjayh0aGlzLCBjYWxsYmFjaywgJ3JlcGxhY2VTdGF0ZScpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZXIuaXNNb3VudGVkKHRoaXMpO1xuICB9XG59O1xuXG52YXIgUmVhY3RDbGFzc0NvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHt9O1xuX2Fzc2lnbihSZWFjdENsYXNzQ29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RDb21wb25lbnQucHJvdG90eXBlLCBSZWFjdENsYXNzTWl4aW4pO1xuXG4vKipcbiAqIE1vZHVsZSBmb3IgY3JlYXRpbmcgY29tcG9zaXRlIGNvbXBvbmVudHMuXG4gKlxuICogQGNsYXNzIFJlYWN0Q2xhc3NcbiAqL1xudmFyIFJlYWN0Q2xhc3MgPSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjb21wb3NpdGUgY29tcG9uZW50IGNsYXNzIGdpdmVuIGEgY2xhc3Mgc3BlY2lmaWNhdGlvbi5cbiAgICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNyZWF0ZWNsYXNzXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzcGVjIENsYXNzIHNwZWNpZmljYXRpb24gKHdoaWNoIG11c3QgZGVmaW5lIGByZW5kZXJgKS5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IENvbXBvbmVudCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY3JlYXRlQ2xhc3M6IGZ1bmN0aW9uIChzcGVjKSB7XG4gICAgLy8gVG8ga2VlcCBvdXIgd2FybmluZ3MgbW9yZSB1bmRlcnN0YW5kYWJsZSwgd2UnbGwgdXNlIGEgbGl0dGxlIGhhY2sgaGVyZSB0b1xuICAgIC8vIGVuc3VyZSB0aGF0IENvbnN0cnVjdG9yLm5hbWUgIT09ICdDb25zdHJ1Y3RvcicuIFRoaXMgbWFrZXMgc3VyZSB3ZSBkb24ndFxuICAgIC8vIHVubmVjZXNzYXJpbHkgaWRlbnRpZnkgYSBjbGFzcyB3aXRob3V0IGRpc3BsYXlOYW1lIGFzICdDb25zdHJ1Y3RvcicuXG4gICAgdmFyIENvbnN0cnVjdG9yID0gaWRlbnRpdHkoZnVuY3Rpb24gKHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gICAgICAvLyBUaGlzIGNvbnN0cnVjdG9yIGdldHMgb3ZlcnJpZGRlbiBieSBtb2Nrcy4gVGhlIGFyZ3VtZW50IGlzIHVzZWRcbiAgICAgIC8vIGJ5IG1vY2tzIHRvIGFzc2VydCBvbiB3aGF0IGdldHMgbW91bnRlZC5cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodGhpcyBpbnN0YW5jZW9mIENvbnN0cnVjdG9yLCAnU29tZXRoaW5nIGlzIGNhbGxpbmcgYSBSZWFjdCBjb21wb25lbnQgZGlyZWN0bHkuIFVzZSBhIGZhY3Rvcnkgb3IgJyArICdKU1ggaW5zdGVhZC4gU2VlOiBodHRwczovL2ZiLm1lL3JlYWN0LWxlZ2FjeWZhY3RvcnknKSA6IHZvaWQgMDtcbiAgICAgIH1cblxuICAgICAgLy8gV2lyZSB1cCBhdXRvLWJpbmRpbmdcbiAgICAgIGlmICh0aGlzLl9fcmVhY3RBdXRvQmluZFBhaXJzLmxlbmd0aCkge1xuICAgICAgICBiaW5kQXV0b0JpbmRNZXRob2RzKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xuXG4gICAgICB0aGlzLnN0YXRlID0gbnVsbDtcblxuICAgICAgLy8gUmVhY3RDbGFzc2VzIGRvZXNuJ3QgaGF2ZSBjb25zdHJ1Y3RvcnMuIEluc3RlYWQsIHRoZXkgdXNlIHRoZVxuICAgICAgLy8gZ2V0SW5pdGlhbFN0YXRlIGFuZCBjb21wb25lbnRXaWxsTW91bnQgbWV0aG9kcyBmb3IgaW5pdGlhbGl6YXRpb24uXG5cbiAgICAgIHZhciBpbml0aWFsU3RhdGUgPSB0aGlzLmdldEluaXRpYWxTdGF0ZSA/IHRoaXMuZ2V0SW5pdGlhbFN0YXRlKCkgOiBudWxsO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXG4gICAgICAgIGlmIChpbml0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLmdldEluaXRpYWxTdGF0ZS5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGJhZCBwcmFjdGljZS4gQ29uc2lkZXIgd2FybmluZyBoZXJlIGFuZFxuICAgICAgICAgIC8vIGRlcHJlY2F0aW5nIHRoaXMgY29udmVuaWVuY2UuXG4gICAgICAgICAgaW5pdGlhbFN0YXRlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgISh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpbml0aWFsU3RhdGUpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5nZXRJbml0aWFsU3RhdGUoKTogbXVzdCByZXR1cm4gYW4gb2JqZWN0IG9yIG51bGwnLCBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCc4MicsIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuXG4gICAgICB0aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgIH0pO1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IG5ldyBSZWFjdENsYXNzQ29tcG9uZW50KCk7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLl9fcmVhY3RBdXRvQmluZFBhaXJzID0gW107XG5cbiAgICBpbmplY3RlZE1peGlucy5mb3JFYWNoKG1peFNwZWNJbnRvQ29tcG9uZW50LmJpbmQobnVsbCwgQ29uc3RydWN0b3IpKTtcblxuICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzcGVjKTtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIGRlZmF1bHRQcm9wcyBwcm9wZXJ0eSBhZnRlciBhbGwgbWl4aW5zIGhhdmUgYmVlbiBtZXJnZWQuXG4gICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgQ29uc3RydWN0b3IuZGVmYXVsdFByb3BzID0gQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKCk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB0YWcgdG8gaW5kaWNhdGUgdGhhdCB0aGUgdXNlIG9mIHRoZXNlIG1ldGhvZCBuYW1lcyBpcyBvayxcbiAgICAgIC8vIHNpbmNlIGl0J3MgdXNlZCB3aXRoIGNyZWF0ZUNsYXNzLiBJZiBpdCdzIG5vdCwgdGhlbiBpdCdzIGxpa2VseSBhXG4gICAgICAvLyBtaXN0YWtlIHNvIHdlJ2xsIHdhcm4geW91IHRvIHVzZSB0aGUgc3RhdGljIHByb3BlcnR5LCBwcm9wZXJ0eVxuICAgICAgLy8gaW5pdGlhbGl6ZXIgb3IgY29uc3RydWN0b3IgcmVzcGVjdGl2ZWx5LlxuICAgICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgPSB7fTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAhQ29uc3RydWN0b3IucHJvdG90eXBlLnJlbmRlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdjcmVhdGVDbGFzcyguLi4pOiBDbGFzcyBzcGVjaWZpY2F0aW9uIG11c3QgaW1wbGVtZW50IGEgYHJlbmRlcmAgbWV0aG9kLicpIDogX3Byb2RJbnZhcmlhbnQoJzgzJykgOiB2b2lkIDA7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb21wb25lbnRTaG91bGRVcGRhdGUsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLCBzcGVjLmRpc3BsYXlOYW1lIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBzcGVjLmRpc3BsYXlOYW1lIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIC8vIFJlZHVjZSB0aW1lIHNwZW50IGRvaW5nIGxvb2t1cHMgYnkgc2V0dGluZyB0aGVzZSBvbiB0aGUgcHJvdG90eXBlLlxuICAgIGZvciAodmFyIG1ldGhvZE5hbWUgaW4gUmVhY3RDbGFzc0ludGVyZmFjZSkge1xuICAgICAgaWYgKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgaW5qZWN0TWl4aW46IGZ1bmN0aW9uIChtaXhpbikge1xuICAgICAgaW5qZWN0ZWRNaXhpbnMucHVzaChtaXhpbik7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDbGFzcztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0Q2xhc3MuanNcbi8vIG1vZHVsZSBpZCA9IDE4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBmYWN0b3J5IHRoYXQgY3JlYXRlcyBIVE1MIHRhZyBlbGVtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgY3JlYXRlRE9NRmFjdG9yeSA9IFJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0RWxlbWVudFZhbGlkYXRvciA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50VmFsaWRhdG9yJyk7XG4gIGNyZWF0ZURPTUZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRmFjdG9yeTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwcGluZyBmcm9tIHN1cHBvcnRlZCBIVE1MIHRhZ3MgdG8gYFJlYWN0RE9NQ29tcG9uZW50YCBjbGFzc2VzLlxuICogVGhpcyBpcyBhbHNvIGFjY2Vzc2libGUgdmlhIGBSZWFjdC5ET01gLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFJlYWN0RE9NRmFjdG9yaWVzID0ge1xuICBhOiBjcmVhdGVET01GYWN0b3J5KCdhJyksXG4gIGFiYnI6IGNyZWF0ZURPTUZhY3RvcnkoJ2FiYnInKSxcbiAgYWRkcmVzczogY3JlYXRlRE9NRmFjdG9yeSgnYWRkcmVzcycpLFxuICBhcmVhOiBjcmVhdGVET01GYWN0b3J5KCdhcmVhJyksXG4gIGFydGljbGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2FydGljbGUnKSxcbiAgYXNpZGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2FzaWRlJyksXG4gIGF1ZGlvOiBjcmVhdGVET01GYWN0b3J5KCdhdWRpbycpLFxuICBiOiBjcmVhdGVET01GYWN0b3J5KCdiJyksXG4gIGJhc2U6IGNyZWF0ZURPTUZhY3RvcnkoJ2Jhc2UnKSxcbiAgYmRpOiBjcmVhdGVET01GYWN0b3J5KCdiZGknKSxcbiAgYmRvOiBjcmVhdGVET01GYWN0b3J5KCdiZG8nKSxcbiAgYmlnOiBjcmVhdGVET01GYWN0b3J5KCdiaWcnKSxcbiAgYmxvY2txdW90ZTogY3JlYXRlRE9NRmFjdG9yeSgnYmxvY2txdW90ZScpLFxuICBib2R5OiBjcmVhdGVET01GYWN0b3J5KCdib2R5JyksXG4gIGJyOiBjcmVhdGVET01GYWN0b3J5KCdicicpLFxuICBidXR0b246IGNyZWF0ZURPTUZhY3RvcnkoJ2J1dHRvbicpLFxuICBjYW52YXM6IGNyZWF0ZURPTUZhY3RvcnkoJ2NhbnZhcycpLFxuICBjYXB0aW9uOiBjcmVhdGVET01GYWN0b3J5KCdjYXB0aW9uJyksXG4gIGNpdGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2NpdGUnKSxcbiAgY29kZTogY3JlYXRlRE9NRmFjdG9yeSgnY29kZScpLFxuICBjb2w6IGNyZWF0ZURPTUZhY3RvcnkoJ2NvbCcpLFxuICBjb2xncm91cDogY3JlYXRlRE9NRmFjdG9yeSgnY29sZ3JvdXAnKSxcbiAgZGF0YTogY3JlYXRlRE9NRmFjdG9yeSgnZGF0YScpLFxuICBkYXRhbGlzdDogY3JlYXRlRE9NRmFjdG9yeSgnZGF0YWxpc3QnKSxcbiAgZGQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2RkJyksXG4gIGRlbDogY3JlYXRlRE9NRmFjdG9yeSgnZGVsJyksXG4gIGRldGFpbHM6IGNyZWF0ZURPTUZhY3RvcnkoJ2RldGFpbHMnKSxcbiAgZGZuOiBjcmVhdGVET01GYWN0b3J5KCdkZm4nKSxcbiAgZGlhbG9nOiBjcmVhdGVET01GYWN0b3J5KCdkaWFsb2cnKSxcbiAgZGl2OiBjcmVhdGVET01GYWN0b3J5KCdkaXYnKSxcbiAgZGw6IGNyZWF0ZURPTUZhY3RvcnkoJ2RsJyksXG4gIGR0OiBjcmVhdGVET01GYWN0b3J5KCdkdCcpLFxuICBlbTogY3JlYXRlRE9NRmFjdG9yeSgnZW0nKSxcbiAgZW1iZWQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2VtYmVkJyksXG4gIGZpZWxkc2V0OiBjcmVhdGVET01GYWN0b3J5KCdmaWVsZHNldCcpLFxuICBmaWdjYXB0aW9uOiBjcmVhdGVET01GYWN0b3J5KCdmaWdjYXB0aW9uJyksXG4gIGZpZ3VyZTogY3JlYXRlRE9NRmFjdG9yeSgnZmlndXJlJyksXG4gIGZvb3RlcjogY3JlYXRlRE9NRmFjdG9yeSgnZm9vdGVyJyksXG4gIGZvcm06IGNyZWF0ZURPTUZhY3RvcnkoJ2Zvcm0nKSxcbiAgaDE6IGNyZWF0ZURPTUZhY3RvcnkoJ2gxJyksXG4gIGgyOiBjcmVhdGVET01GYWN0b3J5KCdoMicpLFxuICBoMzogY3JlYXRlRE9NRmFjdG9yeSgnaDMnKSxcbiAgaDQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2g0JyksXG4gIGg1OiBjcmVhdGVET01GYWN0b3J5KCdoNScpLFxuICBoNjogY3JlYXRlRE9NRmFjdG9yeSgnaDYnKSxcbiAgaGVhZDogY3JlYXRlRE9NRmFjdG9yeSgnaGVhZCcpLFxuICBoZWFkZXI6IGNyZWF0ZURPTUZhY3RvcnkoJ2hlYWRlcicpLFxuICBoZ3JvdXA6IGNyZWF0ZURPTUZhY3RvcnkoJ2hncm91cCcpLFxuICBocjogY3JlYXRlRE9NRmFjdG9yeSgnaHInKSxcbiAgaHRtbDogY3JlYXRlRE9NRmFjdG9yeSgnaHRtbCcpLFxuICBpOiBjcmVhdGVET01GYWN0b3J5KCdpJyksXG4gIGlmcmFtZTogY3JlYXRlRE9NRmFjdG9yeSgnaWZyYW1lJyksXG4gIGltZzogY3JlYXRlRE9NRmFjdG9yeSgnaW1nJyksXG4gIGlucHV0OiBjcmVhdGVET01GYWN0b3J5KCdpbnB1dCcpLFxuICBpbnM6IGNyZWF0ZURPTUZhY3RvcnkoJ2lucycpLFxuICBrYmQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2tiZCcpLFxuICBrZXlnZW46IGNyZWF0ZURPTUZhY3RvcnkoJ2tleWdlbicpLFxuICBsYWJlbDogY3JlYXRlRE9NRmFjdG9yeSgnbGFiZWwnKSxcbiAgbGVnZW5kOiBjcmVhdGVET01GYWN0b3J5KCdsZWdlbmQnKSxcbiAgbGk6IGNyZWF0ZURPTUZhY3RvcnkoJ2xpJyksXG4gIGxpbms6IGNyZWF0ZURPTUZhY3RvcnkoJ2xpbmsnKSxcbiAgbWFpbjogY3JlYXRlRE9NRmFjdG9yeSgnbWFpbicpLFxuICBtYXA6IGNyZWF0ZURPTUZhY3RvcnkoJ21hcCcpLFxuICBtYXJrOiBjcmVhdGVET01GYWN0b3J5KCdtYXJrJyksXG4gIG1lbnU6IGNyZWF0ZURPTUZhY3RvcnkoJ21lbnUnKSxcbiAgbWVudWl0ZW06IGNyZWF0ZURPTUZhY3RvcnkoJ21lbnVpdGVtJyksXG4gIG1ldGE6IGNyZWF0ZURPTUZhY3RvcnkoJ21ldGEnKSxcbiAgbWV0ZXI6IGNyZWF0ZURPTUZhY3RvcnkoJ21ldGVyJyksXG4gIG5hdjogY3JlYXRlRE9NRmFjdG9yeSgnbmF2JyksXG4gIG5vc2NyaXB0OiBjcmVhdGVET01GYWN0b3J5KCdub3NjcmlwdCcpLFxuICBvYmplY3Q6IGNyZWF0ZURPTUZhY3RvcnkoJ29iamVjdCcpLFxuICBvbDogY3JlYXRlRE9NRmFjdG9yeSgnb2wnKSxcbiAgb3B0Z3JvdXA6IGNyZWF0ZURPTUZhY3RvcnkoJ29wdGdyb3VwJyksXG4gIG9wdGlvbjogY3JlYXRlRE9NRmFjdG9yeSgnb3B0aW9uJyksXG4gIG91dHB1dDogY3JlYXRlRE9NRmFjdG9yeSgnb3V0cHV0JyksXG4gIHA6IGNyZWF0ZURPTUZhY3RvcnkoJ3AnKSxcbiAgcGFyYW06IGNyZWF0ZURPTUZhY3RvcnkoJ3BhcmFtJyksXG4gIHBpY3R1cmU6IGNyZWF0ZURPTUZhY3RvcnkoJ3BpY3R1cmUnKSxcbiAgcHJlOiBjcmVhdGVET01GYWN0b3J5KCdwcmUnKSxcbiAgcHJvZ3Jlc3M6IGNyZWF0ZURPTUZhY3RvcnkoJ3Byb2dyZXNzJyksXG4gIHE6IGNyZWF0ZURPTUZhY3RvcnkoJ3EnKSxcbiAgcnA6IGNyZWF0ZURPTUZhY3RvcnkoJ3JwJyksXG4gIHJ0OiBjcmVhdGVET01GYWN0b3J5KCdydCcpLFxuICBydWJ5OiBjcmVhdGVET01GYWN0b3J5KCdydWJ5JyksXG4gIHM6IGNyZWF0ZURPTUZhY3RvcnkoJ3MnKSxcbiAgc2FtcDogY3JlYXRlRE9NRmFjdG9yeSgnc2FtcCcpLFxuICBzY3JpcHQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3NjcmlwdCcpLFxuICBzZWN0aW9uOiBjcmVhdGVET01GYWN0b3J5KCdzZWN0aW9uJyksXG4gIHNlbGVjdDogY3JlYXRlRE9NRmFjdG9yeSgnc2VsZWN0JyksXG4gIHNtYWxsOiBjcmVhdGVET01GYWN0b3J5KCdzbWFsbCcpLFxuICBzb3VyY2U6IGNyZWF0ZURPTUZhY3RvcnkoJ3NvdXJjZScpLFxuICBzcGFuOiBjcmVhdGVET01GYWN0b3J5KCdzcGFuJyksXG4gIHN0cm9uZzogY3JlYXRlRE9NRmFjdG9yeSgnc3Ryb25nJyksXG4gIHN0eWxlOiBjcmVhdGVET01GYWN0b3J5KCdzdHlsZScpLFxuICBzdWI6IGNyZWF0ZURPTUZhY3RvcnkoJ3N1YicpLFxuICBzdW1tYXJ5OiBjcmVhdGVET01GYWN0b3J5KCdzdW1tYXJ5JyksXG4gIHN1cDogY3JlYXRlRE9NRmFjdG9yeSgnc3VwJyksXG4gIHRhYmxlOiBjcmVhdGVET01GYWN0b3J5KCd0YWJsZScpLFxuICB0Ym9keTogY3JlYXRlRE9NRmFjdG9yeSgndGJvZHknKSxcbiAgdGQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3RkJyksXG4gIHRleHRhcmVhOiBjcmVhdGVET01GYWN0b3J5KCd0ZXh0YXJlYScpLFxuICB0Zm9vdDogY3JlYXRlRE9NRmFjdG9yeSgndGZvb3QnKSxcbiAgdGg6IGNyZWF0ZURPTUZhY3RvcnkoJ3RoJyksXG4gIHRoZWFkOiBjcmVhdGVET01GYWN0b3J5KCd0aGVhZCcpLFxuICB0aW1lOiBjcmVhdGVET01GYWN0b3J5KCd0aW1lJyksXG4gIHRpdGxlOiBjcmVhdGVET01GYWN0b3J5KCd0aXRsZScpLFxuICB0cjogY3JlYXRlRE9NRmFjdG9yeSgndHInKSxcbiAgdHJhY2s6IGNyZWF0ZURPTUZhY3RvcnkoJ3RyYWNrJyksXG4gIHU6IGNyZWF0ZURPTUZhY3RvcnkoJ3UnKSxcbiAgdWw6IGNyZWF0ZURPTUZhY3RvcnkoJ3VsJyksXG4gICd2YXInOiBjcmVhdGVET01GYWN0b3J5KCd2YXInKSxcbiAgdmlkZW86IGNyZWF0ZURPTUZhY3RvcnkoJ3ZpZGVvJyksXG4gIHdicjogY3JlYXRlRE9NRmFjdG9yeSgnd2JyJyksXG5cbiAgLy8gU1ZHXG4gIGNpcmNsZTogY3JlYXRlRE9NRmFjdG9yeSgnY2lyY2xlJyksXG4gIGNsaXBQYXRoOiBjcmVhdGVET01GYWN0b3J5KCdjbGlwUGF0aCcpLFxuICBkZWZzOiBjcmVhdGVET01GYWN0b3J5KCdkZWZzJyksXG4gIGVsbGlwc2U6IGNyZWF0ZURPTUZhY3RvcnkoJ2VsbGlwc2UnKSxcbiAgZzogY3JlYXRlRE9NRmFjdG9yeSgnZycpLFxuICBpbWFnZTogY3JlYXRlRE9NRmFjdG9yeSgnaW1hZ2UnKSxcbiAgbGluZTogY3JlYXRlRE9NRmFjdG9yeSgnbGluZScpLFxuICBsaW5lYXJHcmFkaWVudDogY3JlYXRlRE9NRmFjdG9yeSgnbGluZWFyR3JhZGllbnQnKSxcbiAgbWFzazogY3JlYXRlRE9NRmFjdG9yeSgnbWFzaycpLFxuICBwYXRoOiBjcmVhdGVET01GYWN0b3J5KCdwYXRoJyksXG4gIHBhdHRlcm46IGNyZWF0ZURPTUZhY3RvcnkoJ3BhdHRlcm4nKSxcbiAgcG9seWdvbjogY3JlYXRlRE9NRmFjdG9yeSgncG9seWdvbicpLFxuICBwb2x5bGluZTogY3JlYXRlRE9NRmFjdG9yeSgncG9seWxpbmUnKSxcbiAgcmFkaWFsR3JhZGllbnQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3JhZGlhbEdyYWRpZW50JyksXG4gIHJlY3Q6IGNyZWF0ZURPTUZhY3RvcnkoJ3JlY3QnKSxcbiAgc3RvcDogY3JlYXRlRE9NRmFjdG9yeSgnc3RvcCcpLFxuICBzdmc6IGNyZWF0ZURPTUZhY3RvcnkoJ3N2ZycpLFxuICB0ZXh0OiBjcmVhdGVET01GYWN0b3J5KCd0ZXh0JyksXG4gIHRzcGFuOiBjcmVhdGVET01GYWN0b3J5KCd0c3BhbicpXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NRmFjdG9yaWVzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RET01GYWN0b3JpZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gKlxuICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIHByb3BUeXBlczoge1xuICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAqXG4gKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gKlxuICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gKiAgICAgfSxcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICogICB9KTtcbiAqXG4gKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gKlxuICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAqXG4gKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gKlxuICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICBwcm9wVHlwZXM6IHtcbiAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAqICAgICAgICAgICk7XG4gKiAgICAgICAgfVxuICogICAgICB9XG4gKiAgICB9LFxuICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gKiAgfSk7XG4gKlxuICogQGludGVybmFsXG4gKi9cblxudmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxudmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyXG59O1xuXG4vKipcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICovXG4vKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgaWYgKHggPT09IHkpIHtcbiAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cbi8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG4vKipcbiAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIgd2UgZG9uJ3QgdXNlIHJlYWxcbiAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cbiAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMuc3RhY2sgPSAnJztcbn1cbi8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cblByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG5mdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICB9XG4gIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0ICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgIGlmICghbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICsgJ2Z1bmN0aW9uIGZvciB0aGUgYCVzYCBwcm9wIG9uIGAlc2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICsgJ2FuZCB3aWxsIG5vdCB3b3JrIGluIHByb2R1Y3Rpb24gd2l0aCB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLiAnICsgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nLCBwcm9wRnVsbE5hbWUsIGNvbXBvbmVudE5hbWUpIDogdm9pZCAwO1xuICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkICcgKyAoJ2luIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGBudWxsYC4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyhudWxsKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgIH1cbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICBpZiAoIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzKTtcbiAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIHByb3BWYWx1ZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgfVxuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gIC8vIE5hdGl2ZSBTeW1ib2wuXG4gIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG4gIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbmZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgcmV0dXJuICdhcnJheSc7XG4gIH1cbiAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICByZXR1cm4gJ29iamVjdCc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgcmV0dXJuICdzeW1ib2wnO1xuICB9XG4gIHJldHVybiBwcm9wVHlwZTtcbn1cblxuLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG5mdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gJ2RhdGUnO1xuICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wVHlwZTtcbn1cblxuLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbmZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcbiAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgfVxuICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlcy5qc1xuLy8gbW9kdWxlIGlkID0gMTg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlJyk7XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIFJlYWN0UHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAvLyBEdXBsaWNhdGVkIGZyb20gUmVhY3RDb21wb25lbnQuXG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5mdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG5Db21wb25lbnREdW1teS5wcm90b3R5cGUgPSBSZWFjdENvbXBvbmVudC5wcm90b3R5cGU7XG5SZWFjdFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5SZWFjdFB1cmVDb21wb25lbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVhY3RQdXJlQ29tcG9uZW50O1xuLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5fYXNzaWduKFJlYWN0UHVyZUNvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZSk7XG5SZWFjdFB1cmVDb21wb25lbnQucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFB1cmVDb21wb25lbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdFB1cmVDb21wb25lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDE5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzJyk7XG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vaztcblxuaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSB7XG4gIC8vIFRlbXBvcmFyeSBoYWNrLlxuICAvLyBJbmxpbmUgcmVxdWlyZXMgZG9uJ3Qgd29yayB3ZWxsIHdpdGggSmVzdDpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjQwXG4gIC8vIFJlbW92ZSB0aGUgaW5saW5lIHJlcXVpcmVzIHdoZW4gd2UgZG9uJ3QgbmVlZCB0aGVtIGFueW1vcmU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcxNzhcbiAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xufVxuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P29iamVjdH0gZWxlbWVudCBUaGUgUmVhY3QgZWxlbWVudCB0aGF0IGlzIGJlaW5nIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHs/bnVtYmVyfSBkZWJ1Z0lEIFRoZSBSZWFjdCBjb21wb25lbnQgaW5zdGFuY2UgdGhhdCBpcyBiZWluZyB0eXBlLWNoZWNrZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUmVhY3RUeXBlU3BlYyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQsIGRlYnVnSUQpIHtcbiAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgIGlmICh0eXBlU3BlY3MuaGFzT3duUHJvcGVydHkodHlwZVNwZWNOYW1lKSkge1xuICAgICAgdmFyIGVycm9yO1xuICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICEodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIFJlYWN0LlByb3BUeXBlcy4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgdHlwZVNwZWNOYW1lKSA6IF9wcm9kSW52YXJpYW50KCc4NCcsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCB0eXBlU3BlY05hbWUpIDogdm9pZCAwO1xuICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgIH1cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFlcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIEVycm9yLCAnJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yKSA6IHZvaWQgMDtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgIHZhciBjb21wb25lbnRTdGFja0luZm8gPSAnJztcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICghUmVhY3RDb21wb25lbnRUcmVlSG9vaykge1xuICAgICAgICAgICAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGVidWdJRCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29tcG9uZW50U3RhY2tJbmZvID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFN0YWNrSW5mbyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0Q3VycmVudFN0YWNrQWRkZW5kdW0oZWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgJXMgdHlwZTogJXMlcycsIGxvY2F0aW9uLCBlcnJvci5tZXNzYWdlLCBjb21wb25lbnRTdGFja0luZm8pIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUmVhY3RUeXBlU3BlYztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QvbGliL2NoZWNrUmVhY3RUeXBlU3BlYy5qc1xuLy8gbW9kdWxlIGlkID0gMTkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLm9ubHlcbiAqXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gICFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLicpIDogX3Byb2RJbnZhcmlhbnQoJzE0MycpIDogdm9pZCAwO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb25seUNoaWxkO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC9saWIvb25seUNoaWxkLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50U3ltYm9sJyk7XG5cbnZhciBnZXRJdGVyYXRvckZuID0gcmVxdWlyZSgnLi9nZXRJdGVyYXRvckZuJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgS2V5RXNjYXBlVXRpbHMgPSByZXF1aXJlKCcuL0tleUVzY2FwZVV0aWxzJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG5cbi8qKlxuICogVGhpcyBpcyBpbmxpbmVkIGZyb20gUmVhY3RFbGVtZW50IHNpbmNlIHRoaXMgZmlsZSBpcyBzaGFyZWQgYmV0d2VlblxuICogaXNvbW9ycGhpYyBhbmQgcmVuZGVyZXJzLiBXZSBjb3VsZCBleHRyYWN0IHRoaXMgdG8gYVxuICpcbiAqL1xuXG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBjb21wb25lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gY29tcG9uZW50IEEgY29tcG9uZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudEtleShjb21wb25lbnQsIGluZGV4KSB7XG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuICBpZiAoY29tcG9uZW50ICYmIHR5cGVvZiBjb21wb25lbnQgPT09ICdvYmplY3QnICYmIGNvbXBvbmVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiBLZXlFc2NhcGVVdGlscy5lc2NhcGUoY29tcG9uZW50LmtleSk7XG4gIH1cbiAgLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZVNvRmFyIE5hbWUgb2YgdGhlIGtleSBwYXRoIHNvIGZhci5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2l0aCBlYWNoIGNoaWxkIGZvdW5kLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IFVzZWQgdG8gcGFzcyBpbmZvcm1hdGlvbiB0aHJvdWdob3V0IHRoZSB0cmF2ZXJzYWxcbiAqIHByb2Nlc3MuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sIG5hbWVTb0ZhciwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsIHx8IHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInIHx8XG4gIC8vIFRoZSBmb2xsb3dpbmcgaXMgaW5saW5lZCBmcm9tIFJlYWN0RWxlbWVudC4gVGhpcyBtZWFucyB3ZSBjYW4gb3B0aW1pemVcbiAgLy8gc29tZSBjaGVja3MuIFJlYWN0IEZpYmVyIGFsc28gaW5saW5lcyB0aGlzIGxvZ2ljIGZvciBzaW1pbGFyIHB1cnBvc2VzLlxuICB0eXBlID09PSAnb2JqZWN0JyAmJiBjaGlsZHJlbi4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgY2FsbGJhY2sodHJhdmVyc2VDb250ZXh0LCBjaGlsZHJlbixcbiAgICAvLyBJZiBpdCdzIHRoZSBvbmx5IGNoaWxkLCB0cmVhdCB0aGUgbmFtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBhbiBhcnJheVxuICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3MuXG4gICAgbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZHJlbiwgMCkgOiBuYW1lU29GYXIpO1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGNoaWxkO1xuICB2YXIgbmV4dE5hbWU7XG4gIHZhciBzdWJ0cmVlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBjaGlsZHJlbiBmb3VuZCBpbiB0aGUgY3VycmVudCBzdWJ0cmVlLlxuICB2YXIgbmV4dE5hbWVQcmVmaXggPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SIDogbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpKTtcbiAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoY2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gY2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICB2YXIgaWkgPSAwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHZhciBtYXBzQXNDaGlsZHJlbkFkZGVuZHVtID0gJyc7XG4gICAgICAgICAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHZhciBtYXBzQXNDaGlsZHJlbk93bmVyTmFtZSA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpO1xuICAgICAgICAgICAgaWYgKG1hcHNBc0NoaWxkcmVuT3duZXJOYW1lKSB7XG4gICAgICAgICAgICAgIG1hcHNBc0NoaWxkcmVuQWRkZW5kdW0gPSAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbWFwc0FzQ2hpbGRyZW5Pd25lck5hbWUgKyAnYC4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhkaWRXYXJuQWJvdXRNYXBzLCAnVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3QgeWV0IGZ1bGx5IHN1cHBvcnRlZC4gSXQgaXMgYW4gJyArICdleHBlcmltZW50YWwgZmVhdHVyZSB0aGF0IG1pZ2h0IGJlIHJlbW92ZWQuIENvbnZlcnQgaXQgdG8gYSAnICsgJ3NlcXVlbmNlIC8gaXRlcmFibGUgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLiVzJywgbWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSkgOiB2b2lkIDA7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgY2hpbGQgPSBlbnRyeVsxXTtcbiAgICAgICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBLZXlFc2NhcGVVdGlscy5lc2NhcGUoZW50cnlbMF0pICsgU1VCU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCAwKTtcbiAgICAgICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkIG9yIHdyYXAgdGhlIG9iamVjdCB1c2luZyBjcmVhdGVGcmFnbWVudChvYmplY3QpIGZyb20gdGhlICcgKyAnUmVhY3QgYWRkLW9ucy4nO1xuICAgICAgICBpZiAoY2hpbGRyZW4uX2lzUmVhY3RFbGVtZW50KSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEl0IGxvb2tzIGxpa2UgeW91XFwncmUgdXNpbmcgYW4gZWxlbWVudCBjcmVhdGVkIGJ5IGEgZGlmZmVyZW50ICcgKyAndmVyc2lvbiBvZiBSZWFjdC4gTWFrZSBzdXJlIHRvIHVzZSBvbmx5IG9uZSBjb3B5IG9mIFJlYWN0Lic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpO1xuICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBhZGRlbmR1bSArPSAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSBTdHJpbmcoY2hpbGRyZW4pO1xuICAgICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ09iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogJXMpLiVzJywgY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nLCBhZGRlbmR1bSkgOiBfcHJvZEludmFyaWFudCgnMzEnLCBjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcsIGFkZGVuZHVtKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIFRyYXZlcnNlcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAsIGJ1dFxuICogbWlnaHQgYWxzbyBiZSBzcGVjaWZpZWQgdGhyb3VnaCBhdHRyaWJ1dGVzOlxuICpcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbiwgLi4uKWBcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5sZWZ0UGFuZWxDaGlsZHJlbiwgLi4uKWBcbiAqXG4gKiBUaGUgYHRyYXZlcnNlQ29udGV4dGAgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQgdGhhdCBpcyBwYXNzZWQgdGhyb3VnaCB0aGVcbiAqIGVudGlyZSB0cmF2ZXJzYWwuIEl0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFjY3VtdWxhdGlvbnMgb3IgYW55dGhpbmcgZWxzZSB0aGF0XG4gKiB0aGUgY2FsbGJhY2sgbWlnaHQgZmluZCByZWxldmFudC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIG9iamVjdC5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBUbyBpbnZva2UgdXBvbiB0cmF2ZXJzaW5nIGVhY2ggY2hpbGQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBmb3IgdHJhdmVyc2FsLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgJycsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRyYXZlcnNlQWxsQ2hpbGRyZW47XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0L2xpYi90cmF2ZXJzZUFsbENoaWxkcmVuLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRQUFBUUFCQUFELzJ3Q0VBQWtHQnhNVEVoVVRFeE1WRlJVWEZoY1hHQlVWRlJnVkZoZ1dGaFVYRnhjVkZSY1lIU2dnR0JvbEhSVVhJVEVpSlNrckxpNHVGeDh6T0RNdE55Z3RMaXNCQ2dvS0RnME9HeEFRR3kwbElDVXRMUzB3TFM0dExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TGYvQUFCRUlBTUlCQXdNQklnQUNFUUVERVFIL3hBQWNBQUFBQndFQkFBQUFBQUFBQUFBQUFBQUFBZ01FQlFZSEFRai94QUEvRUFBQkF3RUVCZ2NHQlFNRUF3RUFBQUFCQUFJREVRUUZJVEVHRWtGUllYRUhFeUtCa2FId0ZESkNzY0hSSTFKaWNwSXo0ZkVWUTRLeWM2TFNGdi9FQUJvQkFBSURBUUVBQUFBQUFBQUFBQUFBQUFNRUFBRUNCUWIveEFBd0VRQUNBUU1EQXdFR0JnTUJBQUFBQUFBQUFRSURCQkVTSVRFRkUwRlJGQ0l5WVpId0kxSnhnYUd4UXRIaHdmL2FBQXdEQVFBQ0VRTVJBRDhBM0ZCQkJRZ0VFRWphTFExZ3E1d0NoQlpCUU5wMGhhUGRIZWZzbWh2dVYyWGtBcjBzMm9ObHBRVk1udjJWdWJqNEtPdFdtVTBZMXFoemVRcU9hbUFpdDV2Z3RPbG1rOEZnaEVzMVRWMnExcmFhem5VclFWTk1obWtkRGRLbVhoRytSakN3TmRxMGNRU1FSVUhETGI0TEl1a1cvd0EyMWtSY1JTTnh3QW9DSktDdk1FRHhLbk9qWFNPQ3h4T2plMDZ6MzZ4Y0RzMVdnRDUrS0M1KytvaFBaWnFMMjNOaVFVTlpkSnJNOFZFZ0hOSVg1cGJaNEk5WVBFanpneU5wcTV4NURHaUpKcUt5eFZ4YTVSWUV4dDk4UVEvMVpXTjRFNCtBeFdYVzYvTHlucVMyME5ZZmhpaGUxdE4xYVZQaW9zWGRLZmVpbjV1aGY5a25LOC9LdnFZYmw0UmZidzZSb0c0UlJ2azRuc044OFZGTjZTNWEvd0JDT203V2RYeG9xcE5ZQzMzZzhjMk9IekNiOVFOaHJ6UzBybW8zemdHM1VOQmg2U0cvRlozRDlyd2ZtQXBDejZmMlozdk5sWnphRDhpc3pGbU93RHhTY3ppM09nVzQzTlJlU3RjbHliUlpOSXJMSjdzeks3bkhWUGc2aWsydUJ4R0kzaGVmak1OLzBUdXczN1BDYXhTUGJ3QjdKNXRPQjhFVlhucWkxVjlUZUVGUUxoNlJveXlscXFIMXdjeHRXbHU4aXVCVnlzZDZ3eXM2eGtySE4zMUdIQWc0ZzhDbW9WWXo0WVJTVDRIcUNqSjcvczdjNUIzWXBxN1N1emZtUGdpQmxTbStFeWRRVmRkcGhaOTY0elRHem5hZm1vYTlucS9sWlkwRkgyTytvSlBka2JYY2NENXArb0RsRnhlR2pxQ0NDaGtDQ0NDaEFJTGlDaERxQzRtMXZ0Z2lZWEh1NXFFRUwydlJzSTN1T1ErcFZGdmErc1NTNnJ0NU9YTGNvelNDL3dERnppYzFTTFhlcGNhazl5MzhJM1JvNUxmSmZZNXBySnBUcTVGVWUxWGxzQlRCMXJKUTNNNmRPMVQ1TkZicGkvTENpVS8xcUYvOVNNR3VkQ1cvSlp5eTBHbWFVRnRLejNHTUt4aVcrMTJHeHZhUTBQWVR0MTliYnVLRmlzVmxZTzJIUE5jRHJGbmRRR2lxOGRzd3pOZkw1by90eFE4ck9jRHNiSk5jdlA2bDJqa3NyVFRVZUR3bGQ5U1ZIMm5TTnRqbERvWWhJSGp0T2U0bCtmdWg0eUhDaXJYdGJqanVUZTBTNjFLNDBVbFVCeTZWQ1R6Si93QW1nUmRJckhDdXE1cDNFMUhpcGk2dWtObGFGN21uaWRZZUJXUnZnd3Ftc2xXNTRyY0xqT3pPZmM5SDdlOFdlbzdudnlPY0RFVk9SQnEwL1k4Q24wOTN4UDhBZmlqZCs1alQ4d3ZOZWkybEw3TzhWTldITmIzb3JwR3kwTUJEcTdLN2E3ajkwVENrY1dwU2xUZTRhMmFHMk4vKzFxSGZHNHQ4c3ZKUmMrZ0RmZ25keWthMTQ4cUs2b0lVcUZPWEtCR1oyelFHWWU2MktUOXBMRDRHZzgxWEx4dUo4UDhBVWprajRrYXpmRVllYTI5UW1rZDhOaFlSOFJIZ0VDVmxGL0M4RktDYnhneGsyRUhLUWQ3YWZVcEVObGlkckEwNHRPQjRIN0ZGMGp2Um9jWE5hQiswVStTaXJMcFRRMGtiaHd4OFFsSjIxV204cmY4QVFMS3lsekVrclhlVWdJTlNLcGpMZXNtUWNwU3p5d3ppa2JnZHRBY1FkNDJxSnRkaGN4M2F4cms3Zno0bzlPdTVMRDVQVTlHdVlWY1VhaXhOZnovMEh0TDNWTlRYNklwYy9IRStOT1NlV2F3dTFkWWJObkRhVXBMWUhNQnFPQXBqWEtvODBYVzF5ZWswVStOc2pPQzJ5dE5kZDN6VnF1UFRxMXdBRngxNDYwN1dJNVZVUC9wVW5acUtpbndqR2hybnZ6SGp3UXVteXhPZVdTT2NBY0t0SUJEcTB5T1l6V3U0NHJJaGZLelVQeFVuL0xOajBiMHlndFFBcnFQL0FDazRIOXBWa3F2Tmt6WFFTT2FIVjFYRVZhY0RRNWdqdUsxYm8vMHg2NENHWTlySnJ6dC9TN2lpeG5rODUxSG8zYWgzcU84ZWYyTDhndUJkUkRnQVFRUVVJRktvR25kNzBxMEhBWUs4VytiVVk1MjRGWVhwbGJ5NTNPcFdvK29TbkhMSy9lOTRWSk5WQVNXblBlbExkS28rcUZOblh0NHBDb2R2WFFVbUVjRkJiT2hGaW9jamF5VEpGRjFxemtPcERpSVZ3U2dHQk5SaFREYjNKczBvMnNxR0l6d2hWcnE0SisrNzNDUFhvU04rd2MxMjVySHJPWTRqc2wycmhuWGx1V2ozVGRna2kxQzAxMVNIYlFIYnZrZThJOEtXVUsxcnp0R1VhNlJsZFZQNzlzaGlsY3c3RDZ6VWErbUdLRm93d3NxK3FJaTF1S3VPZzkrT2dsR0oxVGc0Y1B1cWM0SmF5MndzYzA3QnNSb3ZCeWJpaXB4WjZzdU8zOWJHTWFrVXgzZ2lyWGVDa2xuSFJqZkxaWTI2cHlPb1J0QU9MUWU4clJrVm5DbEZ4ZUdNNzJ2QnNNWmVlNGNWak9sT2tCY1NhcDkwajZiTU14aVk2b1poaGxYYjVyTjdiYmpKalZabExDT2hhV3NwYjRHbDQya3ZjbURvU1ZKUngxKzZlUVdkdnhEWWVHT3hMU21laHBkTjFJaFlJM0FnaW9JMmpOWGJSaTB1blBWU2RvNWduUERmdjU1cU5zMTJoN3RWdmNyRmRlams4RDJ6QVlORmU2aFE5RG04c1lsWVU2YXhKclBqdzgrTU1ucDJ0amFNTlVna0Z1V1dKQUoySEdoM3B2Wm9SVTFOUlFPYWVGYWlpWVgzZVRwZFVrVkZLSGtkNFQyN1dVWUFjd2FjMjFxRXZlVnUxaVg3R3UzS2xSVG05eTRYYTJQVkZRQ2MxU0k3bzY2OFpXUllSNjlTUnNPcUM4K05lOVQ4bHAxWTN2clRVRmZESUltaFo2dXIzQ3JwQ1NUek5Tc0s2aldVSS9QYzQxU204T1MzSXJTelJZeDFld0YxVFd0ZmR3MjhQc3FyWmJZNko0b2RvcUJ3eVBOYmk5Z2thUWNhZytheC9TVzUzUVR1Rkt0SkxnUmgyU2NBdWkxamRjSFg2VmU5K0xvMU9WL0pzbWg5OSswd2d1L3FOb0hjY01IZDZubGl1Z2w4T3M5b2JYM0hkbDNJbkE5MmEya0ZGaExLUExkVnMvWnE3UzRlNk9vSUlMWnpTRzBxazFiTzdqUUxCZEkzbDBoNExjdE5UK0IzL1FyRHIxYlZ4V3ZBMWJsU3R1WlRXbUNsTGJCaW8yUmxFS1NPblNld0F1Z29nSzZFTEFkU0ZDYUl6Sk0rS1Nvak5WWUN4azhpd1JoblJKSU5LaVFiVVhqUTVsZFUweEJydkZCaWE4NmVTMHk0ck4xYlhQY2E2Mk5PTkJYbmo1VVdWYUkyOE1PcVRRSFBITUN1SExGWHIvOEFRdDFCUWJFekRnNXQ3Q1RrVTNwTXNvYk1IajR2VkZTSE9WcDAzdHZXT2JqWHZxUFdhcXV0VE1JYytSaWkyb0pNS1NqRm1GVnhyc2FwMjBmaEhpVk1GNUxQMFhYeDFNejR6azl1c1AzTXgrVlZzbW4razRzdDNPbWFhU1N0REl2M1NETWNoVTl5ODIzWmFoSE0xOWFBVnJ5TFNQcXJQMGlhUW0wUTNmRUNhTXN3a1A3cEhGdmlHeGorUzNuM1RsVnFhZGRGVWM4dWRVblBhVTZnQ1p4Si9FbDVIZnRJckk5WkhRSlZtS1JZRTRqNElEUFEwVVdUUlNOdld0SUJPR05hREd1emVNbHBsdmthSUhWd3dQRCt5em5Ra0V6Z2I2TFJyOWdQczd3M2Q4azNENERnOVdhOXFoRi9JemF4UzFyR2FFVm9IakhidDRLUnRNd2phemZ0N2sxczFrcGlSbmpXbUk0VkZWSFg5TTR5TmFNZzBZODgxeHJ4YTNwUXgxQ29zSlI4a2pOYW5TMGpia1NDN2pUSWZJK0NuV3ZhMEJvMkRQaXE3ZEVSQUozWTEyMTNKeTYzVXlxZVM1MEU0eTB4NEU2VWRVc0lzMTJYM3F5QmhxUWNPWEVvZElGbDE0TmNERnZ5TzlWbTdyUTU4ck1DTVJpZWF2ZCtOclozWVZORjZLZzNLbGlSSzFOVzl6VG5IbnlaWGQ4emdleUFjS1lrSEFZNFV5eVczYUhYaDExbFlUN3pScXU1dHk4cUxHV2gwY2dQazRBRGhRamZ4V2hkR052MW5Tc3lxQTREa2FINXJWQ1crQTNYNkNxVU80bHh2LzRhQWd1SUpzOFVRV21iSzJZbmM0SHlJV0szckYydkZieGYwR3ZaNUcvcEo4TWZvc1d2V0tocXRMZ1pvY0ZTdExLbFJkcGhWZ3RzV05WR1RSckRIb1NJWXNYV3RUM3E4Y2tac0tyQTNCak56S25KQVJwNTFTTjFhckFXTDNHbUpvRWFTQnpjd1U0NnBGbGNhWWxad0ViUXJZcEtGUzR0QkF6cDNxdU1uTFNsN1RlSFlvRnBNRlVsa0Y0V3NFNFlwdmR0aGx0RW9paFlYdmRzRzdhU2RnRzhwaExLdDI2R2JqWkhZaE9SV1NjbHhPME1hUzFyUnd3ci93QWxpVEU2MXdvTFlqdEhlaU5nQWRhNUM5MjJPTTZyUndMdmVQUEJYR3lhRDJDTUFDelJtbjUyNjU4WFZWa0FRVkhPbFhxUzhrVzNSK3pES3p4RGxHMzdKQzFhS1dPVDM3TkNjS1ZNYmFnYmdhWUtjb2dxMk1hNWVwU2JiMFpXQi91eHVqTytON2g1R284bFc3ejZLWkFLd1RCd0h3eUNoL2szRHlXdFVYZFZUWmpGSzlyVW5zL3FlZUx6dUMwMmMvaXhPQS9QN3pjUDFEQWQ2YlFtaFhvNldFRVVJcnpWSXY3bzlpZVMrQTlVN010K0E4dnk5MkhCRGxUZktQUldIWHFiZW11c2ZOY0ZRMEtuMWJRQ1FCVThQbHpXcDJzNjBaRmRubXNqbHNNbGtrcE13dElOUWExRHYybkkrc2xwdWpkNXNsamFhNDBGYTcwU2s4ckJyckVGSnh1SWJyNUZKdDFzMVg2anE0Wm5WcDRWeEtZeVFNZjJpNXJYTkZPMVdoeEpCSGo1Qld2VFBSM1hJbGp6cUFSczU0YkZUSEVOYzVwcmhRVkc4bmZ1U3RhMlFlRVlYVkZTcHYza0Qyc3RaVEdoeXdvY2FWUGtta2M0Ty9uczhVZTBTQ2xBU1NCdHFhMFNObllUaUJpTTZaNDd0NldWRGZMR0xXMDdhekltcmdrYzZWbzFzQnlXaDJ3MWhvZG9weTRxbzZOMkFWMTZERDEzYmxkWTRnOEFiUFBrVTNDU2hCbzVuVTZzZTZzZUNtVytHZ28vdE5wbTBWcFgvQ2t0QVdodHBCYWNITkl3eXgvd3BxMlhRMDVEbU5oU0dqZGlEWm1rQ2xEU2c4VUsyYjFtS3QzR3BiVGo4aThvSUlMcW5sRGoyMUJHOFVXTTM3WjlWNzJuNFhFZUJXemxadDBnV0RVbTF4bElLOTR3SStSNzFhRFVKWWtaOWFvcXFKbml4VTdPMVJ0cUNqUTlHU0loN0Z3Qkt5dFNXc3NEVVpBY2kxb2ltUk5aN1RSUXZ1RHN2VWZhYTVsRTlvNG9rbG9xRk1FN21CSXZSSkg3a1Z6a2k4ckNGNmxUWUs0MUs5QzlFbDZOTmtiQVQybzh1TENhK1JKQ3dLNzROWnkwSFJtODNRRnBHQkJ3UHpISkxYTlRSakhnQ29hb052eWIwSEl3S2hManZoazdBNXBGUjd6ZHJUdVV1eDYxQ2Frc29Ud0tveVQxa05aYlpXQlFMcVRxZ0NWblVpOUlvRndoRjFsMEZXcEZhUnJlVjJSek1MSkdod08vNWc3RHhWTC9BTkNkWXBDOXBMb2FiYzJZakEvZFg5RmxqQkZEaXRjN2pkdGUxS0NjZVl2bGZma2g3dnRyWkc1MUNpYjIwVWlsMW5ON0xzNmdiVVc5N3RkWmoxc0kvREJxNWcrSGVSK25oc1RxN2I5YTl1WTcwVFVuc3pwVTljUHhyZDdmMThtVkNmUk9WdUFBb1BYMlRTelhISUNTYTQxRzdFWkxUbzdZMTI3SlZ5OXJXQzJRTjNnNGNrR2NZTGM2RkRxTnhONldoUFI1dXRVRVpiYUsyeFJpbFFxNW81SHE5NnNzQndYT3kyem1YOHMxSGdGb3lSYnRoL0ZyMytXYTVhVGg2eVR5NW9zTlk4azViUnpMSWpPV21teVRRWFVFK2M4Q2hkTExzNit6dUFIYWIybTh4bU84S2FYQ29Xbmg1TUV0RE1hS010RFZlZFBibTZtWHJHanNTVkk0TzJqNnFtVExROUY1V1NEbWFtTXBVcGFtcUt0S3kwRlVocExOUk1udlJyUzdGTnFySmVzazdzdXA4Mkl3YldsYzY3NktmdFdpY01ZQmZhRFU3QUI5bFhiQmU1aWJRREVWb1J4cWZxcmowWTNBYnh0VHByUjI0WWFFdE9MWFBPTFduZU1LbmZnTWlsYWlxdVd6d2pQY1M1RnJoNk8yMmdhekd5bGh5ZTl3WXdqZUtDcEhKV3F5OUVNQTk0dDVVYzd6Yzc2TFQ0NHdCUUJIb3FWRjQ5NlQrdjhBb0JLNWI0U1g3R2FTZEZrYlIrRzVyVCt3ajVPVE9ibytuWms1amhURFBQbHNXc0lwQ3k3ZUQ4djZsZTAxRE9MbHVreDQ2cm9wRzRWRzNLcDRnN2o0SzNXZTJVQTFqanRwODFKeXd0T1lVUmFydkd6QkpWb1ZiZGFxZTVhbEdvL2VKQ09ZRkhhYXFFaGdld1Z4T095bm53VCt5Mi9XSUF6T3pJajUxV0tOL3dCeHFNMWhtcFVkTzhkMFNJWFFVa2RZYkVJNVUvM0VuaGd0SXZWY0tBUmd0NE1nQlJrUUpSYmlaWWxKR0RVSGFzNjBodXgxbWxCWUQxVDNIQUhBWWU3OWxwSkNaWHJZR3l4dVk3SWp2QjJFSzV4Yld3M1kzYnQ2bWZENVgzNkdkUlcxd0xqVTd1SHJGUHJFenN1QitLaHgyVVZkdDFzZlpwbnhTUmpXQnpyZzVweERoaHRIMlQyeWFTNGlzWXBnTTZKS1RlY002bGJxdHRuRWMvUXVGMk1vN1BncG1JNEtvMkRTU0t1SU9kY0tIUFBjcHF6MzNaem5JRzRaTzdQbWNQTlpTUno2bHhUcVBLWklobXU0VVU3WjQ5VUFLT3VtTERXcUNEa1JpQ040VXFGMDZNTk1STzRucWVGd2d5QzRnaWk1MUFvSUZRaEZYOWQ3WjRuUnUyNUhjZGhDdzIrTE02R1IwYmhRZzAvdU9DMzYwNUxOK2tLNk90YjFqQitJMGZ5YnU1N2xhRFVwNGVETXAzcUt0YVdtbXhvVXptZlZRWXlSZHBDYkVxUWZBWFpEdjJEbVVnYkYrcnlLRktjVXdjcXNZN05qVmVodWhxNytxc1g2blAxbmN5MFVXRVhWWVM2ZU5wR0JlSzhoaWZrdlFXZ3RzYTB1aXlxS2p1OWVTelBmZ0l2ZXB5YUx1Z3VBcnFwaWdGeWk2Z3NrQ0ZxYlR4cDRrM2hacVFVbzROUmVHTjJ4Z0NpaDd4dWxqaFFPZkdhNnpYeE8xWE5kdjNFY0RVRlRid2tYaEtWS2Nkc2NyZ05HVEthN1NHMzJOMUxWR0xURU1wNFc2cjZiNVdEQUhpS0JXRzdMNmd0TFd5Uk9xRGh5M2c3bEo5VURtQW1vdWlOaGMrSnJXUGNhdUxXZ2F4M3VwbWVLdVVLamo2L2YzNU5hb2VtQ1JqeVIwMXM3eTNCdyszY25IV0FvOU9TY2ZtQ2x5R1J3azJwUkZpWWtkS0tRalZRb2lHQ3BhZGFPKzBSYTdCK0xIVXQvVU16R2VkTU9LeWlGeDQ4dHZndlFMd3NhMDl1NFFXeHhiZzJSdldVL1VTZFllSXIvQU1rbmN3WHhJelVXVmtpV1RVQ1dmYXpUSGQvbE1JbjU3UFIyb0NUMTlVazVDeFlibTBrbnM1QmpmUWJXdXhZZUpITGF0QTBmNlFJSmFNbS9Da3dGVC9UY2NzSGJPL3hXUUd1MC9mRkVwVGVPWXh5cmtpVTdpZFBndFNhUFNnS0N3Q3ozOWFXTkRXVHl0YU1BQTRnRGtnbS9iNC9sQ2QxSG9GQkJCUGhCQzBEQlV2U2RwQUpWM2tWZHZ5eTZ3S3RGb3czU1d4QjdpOXZaZHQzSG54VmNnczdxblhCQUhtZUhCYVJwSGR6V0F1Y2FDdEJ0Sk80QlVlMk9yc29CbC9maWxybXJwOTFjbWF0WnhXRnlOWm43c0FNZ05pWVNQVGlVcGxLVXZCQ2FlUnhkMCtySzEyNDFXazNmZVpCYkkwME9CSDFDeWxrbENEeFZvdTYza0FEWm1FVjdIZDZYaHhhK1o2RnVhODJ6eGg3VHpHNHFSQ3hqUnZTRjhEd1FhZzBxQ2NENjNyV0xvdldPZGdldzEzamFEdUsxR1dkbVM2dFhTZXBmRC9SSUlMZ1hhcXhJQzQ0THFDb2drV29wWWxxTGhhc3VKclVKQUxvQ1VvZ3FVQzlRbTVpUWtiUk95a1pXTE5XTGEyUmNXaGcrOG1zY0d1SUJPOVNNTXdJcURVS0N2bTdCSTNLcFZQdDE1U1dXUmpHeUZoMW0xYTRnNnpUZ1EwVU80N1B1a0tWeFdqTnhjZnY1ZW93NlVKTFo3bXBvS3MzZGZ6eWRWNEhDbVl3cmlNbE5HMWVxcDJuZVU2a2RTQVNwT0x3T2k1WTkwbDI4U1d6VmIvdHNEU2Rtc1RyRWVCYXREdmU4ZFdON3lhTlkxempUOUlxc01mYW5TT2RJODRra252eElRWjErNHNSNEJWNDZJNzhzWFk0YzhlN2IzbEtDdS91R0hrbXJUL2FucnVUaHJ1ODd0bmY1K3NFdTBKQ3pSdDNqRGlOL0pHcHY5ZlZjakEyNVk0NzhOaVZhUWNSZ1BQOEF5cXdWazZ4Z0l4OGx4TG1tL3dCZUM2cGdtVDBLZ2dndStOaWNxZzczdFRXTWM5NW8xb0pKM0FLWnREc0ZtdlNYZUZJaEVEaTl3T2Z3dE5mblJacVQwUWNqTW5oWktKcExlVHJSSVhuQVpOYnVhcS9NUFJUNlVWOWJremtHUDkxeGxOeWVXSk50c2piUUZIeWxTazdmV0tqSjIwVHRObTRqZHlsYnNucTJtNVJaYlZkaGwxRFVIbWpOWlEvWjF1MVBmaGx0c2srd24xdVZudU85NUlYYXpEM1pnOER2VkdobzRBMTlid3JIZGJDVzUxcG1VREc1NnVPbHczM1JzVndhVHh6Z05kUmtuNVNjL3dCcFZnYVZpRWJ4VUdwQlZ2dUhTYVJ0R3ZPdTBEYWNSM3JhcVkrSTV0ejAzL0tsOVA4QVJvU0NqYkJmTVVtVHNkeHdLa0E1RVRUV3h5WndsQjRrc0JseWlGVUNxTUFRb2dRdUtGbmFMaEM2Z0ZlU2hGMGFyMmt1alVkcWFOYnN1RmRWd3pGZjhEMVZXVWhFY3hDcVJUUnVNMm1aMVo3b2tpcDFrcnF0Y0FIQUZ6cVZwanNhUEZXNlNZREFqTGFscmJEbnhvZThHb1BrcWJwTmYzVVIxSkJQdWdmbWR3NExsVlpTenBYSTVERFRsSjdEZnBCdnhySXVxWlRXa3BVZm9CeHJ6d0hpczU5czJhclA0L1JKV3kxdWxlWHZkVnhPTmZJRGdrZzNmOUVlTU1MYzVGeFg3azhyZ2ZzdHVQdU1HekFHdnpSeGFpUGhaL0VINThreENBcXBwUXZsa2w3YzQvbC9nMzdZSlJsc2RzcC9CdmxnbzlydldhWGFWaG9tUjZMVzdmOEE5UjgwRWsyTTdrRmpLSms5TG9GQmNjdlFqb3l0OGxBVmllbDl1NiswdXBrenNBNzZISHpKOEZxZWw5djZxQjc5b0dIN2pnUE1ySEd4MU5jeWZYMVhPdjZuRUYrb0dzL0F6Y3dlc1BCTWJRMENvcDY0S1duanBYTGdvK1dFNG5DbSt2cXFRaHNMa1pLMnV6Rk1MUkNCNzFhL2wyOSs1U3M3Z01HOTdqbWVXNEtOdERFNVRacEVaSWZCTm5wOUxFbXoySjJMUVdMRFdDMkZob2ZkK1N2ZWoxcUJPRzBWRzQ3NkZaN3FKN2RkcmZFNEZ1SXJYVk9YTlNVVTNsSFhzNy90clJQaitqVmpHRHN4U2ROMmZyZW8rNUwvQUdTZGttanZ5blB1M3FiYkMwNUh4UTVSTzlUcXByS2V4MkdiVnpOTzlUVmcwaGtpd0pOT09JODhsQ1BzMmRLZXVhSUlhVXpCOGtEUzF3RmxDblVXSmJsNnNlbGJYWU9aNEg2S1ZndnVGMkd2UTdpczBqMWdkYW1HOGYyVHFPMVkxOWY0Vjl5YUVxblRLTXQ0N0dueHp0T1JCU21zczU5c2NNVzFwdnFuVUY5U3RIdlZHejBlYTByajFRalBwY3Y4V1gwRmRWVnMra2JxWXQxanRwZ3BHSy9tSE1PQjhWcFZvc1ZuWjFZK0NZb3VGUi8rc000K0M1TGJxNVlLU3FSeHlEVkNwNVFXODVCVnZmWGxoOWxoR2xOcWRMYXBhbkJqM01hTmdEU1I0a2hhTHB6cFUyeXRPcjJwQ0NHTjRuNGp1QVdNVFhqSVNTQlFtcDFqMmpqdi93QUpLbkdWU2JuNDRBM2NsR0tobjlSN3FGZERLWmhSditvVERFaHBIRWYvQURST0liMS9OR2ViVDlDUHFqdWxJNStCNDFpVkFPOUpNdkNNakovZXdWN3UxUksrMERZMXgvZFJ1UElWcjRoQ2NXdVN0ZzhjUmNhQVZQRFl0RzBXMEdqZTBTU3YxNmpCc2RRMGJ3NDVrK0NvTmpsSU9YaGdQWE5YL1FpLytybGJHUlZyeUFlRlRRT1dhYzRLb2xOYkJZS1BrdThXak5tQUE5bmovaUQ1bEJXTU1YRjErelQvQUNyNkI5SzlCVkp5dXdTaVJ0QXdXeXpQZFBweThzakdXTG5kMkErcXB4aERmV1hCV0RTYWM5ZThWeEJvT1ZBVldMYmFNZnJsVmNpdkpPYll0UGRqYTJQQUdPSnJnUHZ1VVRhSks1cGEwSGFtVDZrL1JMUlc0TVJlTnFiU2hXRzd0RjdWUDdrVHFmbUkxUjRsV2F3OUZzcmhXU1JyZUF4VFVJVGZDTFVXK0RMWklxcHU2QmJoRjBVUS9GSy91QUNsTEgwYVdHT2g2b3lFYlpIRStRb1BKTndwVlBRSXFjanovWWJxbG1kU0pqbmJ5QmdPWnlDc01laVQyQ2hGVHRQMlcrdzZQeHRhR3NZMXJSazFvRFFPNExyN2dhZGdUTWFlT1JpbkZSNVBQYjdpZTNZVTZzdHJuaXdQYmJ1T2ZpdHZuMFhZZmhUQ2ZRMWgySzNGTWRwVjlEMmVET0xKcEV3NFBEbTg4dkVLWnNkNXNkN3JnUnpCVTVhTkIyN0FtRW1nWTJCRGRJNkVML3hJTlZoeEZCM3BhSU54OUJNam9aSU1uUEgvQUNLS2RHclFNcEhlU0U2SWRYa0dQMnhBZTY3dUtQN09jeDRmVlI3Ym50Zy8zRDN0QitpV1pZYlp2QjdqOTFoMEdhOXBqNmorR0N1WW9lQnhTeklIRGQ4OEVoQlk3VnRhM3pVcFpydnRCOTROODFYczdCeXVvK29TRmhyZ085SlhyZVhzN0NCMnBDT3kzZHhkdUhyRlRrTjB1UHZPOE1FdTNSK0xQVjljVVJXcXh1em5WN3h2YUppbG9zRHBIbVNmckh1SitBQm9wdUJkWER1UjJNc3pNN0k1M0YwaEo4TUF0b2RvL0grVUpsYU5FbzNiRlR0RmpZNWppbThzeUNXR3hQclJra0R0NHE1dmUwazE4bEhXcTZ3M3RBdGMzWStPbi9zMDR0UGd0V3R1Z2dQdXFEdEdoVWpUVUR3UzhyYWNlR1lsU1RNOTlsM1krUjhFWnJlSDNWdHRXaTc5amFIZGpRL2Ixa29hMDJKN1RSemFIajlDbEp1VVhpUUp3MGpDTldUUkNLdHFnLzhBSXovc0ZDc2hwL2RUZWpsbzZ1Vmo5clhCM2dhMFFaU1NhYjRMUzNONUNDVHM4elh0YTlwcUhBRUhnVUY2Tk5NWkZrVjZDQ3NoakdrcC9IazR5Ty83S3ZXbjNqeitpQ0M0Tlg0cGZxeFdmSnd0R3JrTTFvWFIvWUl0WFc2cVBXL05xTnI0MFFRVytuN3pOeDVMd0doSGFFRUYzUTRvMEpVQkJCUWdZQkJCQlpJQWhFSVhVRmFJSk9DSTVvM0lJS3kwSnVhTnlUMVJ1UVFVQ0lMcWpjRjBORzVkUVdTQjJ0Q1dZQXVJS0dXS3RDT0VFRlpsaGtFRUZSUndoSkZvUVFVSU5yUkUzOG84QXFwcFBabUZocXh2OFFnZ2w3bGZoc3FYQm1rbzdTV2h6N3dnZ3ZQU0FSTHRkdHBlSW1nUGNCVElPSTJvSUlJa0pQU3R4ay8vMlE9PVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wdWJsaWMvaW1hZ2VzL2ZydWl0cy9hcHBsZS5qcGVnXG4vLyBtb2R1bGUgaWQgPSAxOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRQUFBUUFCQUFELzJ3Q0VBQWtHQnhJUUVoSVFFQkVRRWhBUUVCQVBFQkFRRHc4UUR3OFFGUkVXRmhVUkZSVVlIU2dnR0JvbEd4VVZJVEVoSlNrckxpNDZGeDh6T0RNc055Z3RMaXNCQ2dvS0RnME9HaEFRR2kwbEhTVXRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TGYvQUFCRUlBTUlCQXdNQkVRQUNFUUVERVFIL3hBQWJBQUVBQWdNQkFRQUFBQUFBQUFBQUFBQUFBd1FCQWdVR0IvL0VBRHNRQUFJQkFnTUZCUWdBQXdnREFBQUFBQUFCQWdNUkJDRXhCUkpCVVhFR01tR0JrUk1pUWxLaHNjSFJZbktDRkJVak02TGg4UEVIUTlML3hBQWFBUUVBQXdFQkFRQUFBQUFBQUFBQUFBQUFBUUlEQkFVRy84UUFMaEVCQUFJQ0FnSUJBd01DQmdNQUFBQUFBQUVDQXhFaE1RUVNRUVVUVVNJeVlYR1JNMEpTZ2JIUkZLSEIvOW9BREFNQkFBSVJBeEVBUHdEN2lBQUFBQUFBQUE4bHRudDNoNk1wVTZWNjA0NVRtdjhBSXA1MnpuOFQ4RjZuUGs4aXRPSTVsMFl2R3RmbnFIbXNWMnZxMUpLU3F5VHphalNmczR4VnVUNzJuRzV5em55VzUzcDFSNDlLeDF0YzJmMjlxcGY0c1l6V2tYWnhxTjN0bWxrMTVJMHI1Vm80bmxuYnhhejF3OVpzRHRKU3hqbENFWndxUmp2T0UwbGVON1hXZWZEMVJ2aXoxeVRxTzNOa3hUVGwyamRrQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUhtKzNXMVBZNGYyY1g3OWR1bXM3T05PM3Z5OU12NmptOG5KNlYxOHk2UEd4KzE5ejFENUJYcXlkUzBHa2s3YnF2dXBLMTNhNnp5dFk4MnZXM3Aya3cyTWNwUnBUYWJiazFaV3NrV3R4WDIwcE4vaUhUblVqRGRhV2Q4NWNUbDlyWFYvcTdQWkd2UCsyVVpVNHlrcE9VYWxrMmxUa3M1U3RvazdPNzVJNnZDcmFMeExEUHFhUHE1N0xnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUQ1UjIwcnQ0MnNweWJqR05OUVR5VUl1TjNGVy9pM2p5UEp0TTVKMzhQVThhSSsyOHJ0T2NJSnY0bkYyYjB1M3BmbmNwV050N2Nkdk92ZmhVVlRkZDQ1TEo1M3kvSnY3UmF2cTQ1NG5ib3JFMTVKdDdzYjJYRExQeHpNb2lsZWozZlIvOEF4TGhyVHJ5M3BOcW5DTHU4bnZTYjA4TjM2blI0Yzd0TG56VzNENldlZ3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFT014Q3B3bE42UlY3YzN3WHFaNWNrWTZUYVUxck5wMUQ1aHQ1ZTBiYlc5VWxmTlJUbG03dXg4NTl5YlhtWi9MMU1jeFhoeGEyeHFhaEdVNDNxZDY3Ynk0cFBvYWZkbUoxQmt0dVhIeEt2TlI0YXY4STNyeERtbVdtTWpiYzhaZmdtczdVZlFQL0Z0ZTFXckQ1NlNmbkNTLyttZEhoenJKTWZ3enljeHQ5S1BUWkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUR6ZmFyR2FVMDhvKy9QcndYNTgwZVQ5U3o5VWgwWUsvTHhWQ3J2MTEwbEx5U3QrVWVYV3ZHM1J0cHRhOXhqbmRsTFc0ZWNxUjk4N0t6d3pucHB0U243cWZLWDRKeHp5ajRkM3NOalBaNGlqSytUbHVQcE5idjVUOGpTbHZUTkVxZHcreW5zc2dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQ0xFMWxDTG05SXEvWHdLWkx4U3MybjRURWJuVDUzdHpGT1RiYnprM0tYNlBsOGw1eVgzTHVpTlJwek96OE42VlNxLzVJL3dBdDgvcXZvYVduVWVwTGJhcGxoN1kyY0NVZmVSMlZuaGJKR2ttMEtONlQ4TFA2bGFUK3BTRmZaRDlVelRLci9EN2RzVEhxdlJoVTR0V211VTFsSmV2M1BZd1pZeVk0c3ltTlN2bXlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFJSytLakRYTjhsbXpITG5wampsZXRKdDA0TzJjYkthelZvTE8xODIrRnp4Zkw4eWNrYzhRNktZNHE4UHR1cTkxdmk5UDBjWGo4enRxNmV5TUo3T21sNWRiSzMzdVRhM0c1UmJ2U3B0T25xVXhUeXhzNGRXSHZJNjZ6dzB5YzZsZDloZUxUNHBveTl0U3ljdkEwbkdiaTlUcHZhSnJ0YTBmTDJuWnJhRlREdjNWdlFsYmZoZTM5UzVNeHcrYlBqMi9NVDhLVFRiM2VDeDBLeXZCOVl2S1VlcVBlOGZ5c2VlTjBuL2I1WlRXWTdXVG9WQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQ2h0REc3bnVSN3oxL2hYN09QeXZJKzNIclh0cml4KzNNcUtsLzJlVGEzTzVkT25QeDBkL29jR1dQYVY0aDUzRWJMbFdxUlVjb3dhbEtYQldkL05sdkgzRVRCUEQwVU1IWkpjRXJJdmVuRFBmTGw3UndUZWZrY2xiVFMzS3RvMjg5aU1JNHlzL0k3YTVJbUUvR25VdzJEM2wxT1RKbDFKRldNVHNWMzNsM2w5U2ErVE90U24wK0ZuQ3czZnlZWkxibGFLT2pRcXVMVW91MGxvMFh4WmJVdEZxenFTYVJNY3ZUYk4yaXFxczdLYTFYQitLUHFmQzgydWV1cDRzNU1tT2EvMFh6dlpnQUFBQUFBQUFBQUFBQUFBQUFBQUFBRVdLcktFWE42UlYrcjRMMUtaTHhTczJsTlkzT25uYWNuSnVVbmR5ZDJlRmUwMm1iVDI3b2pVYWIxSjVISGt0OExSQ3RVZDhqUHVkTEpxS1VWWkc5WWl2Q08wdnRTWmxIcWhycE5ISG1oWFRqNDNEM1Y3WnJOR2RiVHBFZHQ4QXpHMC9xYWFYOVRUUXE0aWh4WC9BR1VtRW9ZU3NaNzFLK2x1ak5xelRzMW1tanB4NVpyTVRFNmxTMWR2UjdPMmdwKzdLeW45SmRQRStuOEx6NjVvOWJjVy93Q1hGa3hUWG1PblFQUllnQUFBQUFBQUFBQUFBQUFBQUFBQUFPUHQ2dDNZYzN2UG90UCtlQjUvbjVOVmlyZkJYbmFoRThtMDhPcEhVa2NjenVkcnhDT0R6TDR1WjJXU05tc2tDWkEzdVlYamNLekNuWGpxWVZWMDU2bnVTOEdVdFhjTDFkT25LNnVSV3laU05YTDZRcTE2SEZhL2NwYXExWitHdEdabFczSzB4dGNweU9xbDFmVjE4RnRMU05UeWwrLzJlOTRuMVA4QXk1Zjcvd0RianlZUG1ycXhrbm1zMTRIc3hNVEc0Y3pKSUFBQUFBQUFBQUFBQUFBQUFBQUR6ZTFaNzFhWEtLVWZwZC9jOFh6YmJ5Ni9Ec3d4cWpRNEx6cUcwUXIxR2NrOU5JUjRlVjc5VFhCKzJVWDdUTTFsRUNJUzNpWjJoV1VWZUp6VEdwUTUyS3BYWGp3NmtUeEpYaVdjQmlPRE1yUjZ6dHBNT2xGbWtTcm9hSjBpWVExYUhGYThqSytQNWhlcy9saWxNclMzNVdtRnVMT2lKVm1GbkRZbVVOSGx5ZWgyZVA1ZVREKzJlUHg4TXNtS3R1M1V3KzBJeTE5MStPbnFlM2crcFlzbkZ1Si9ucis3a3ZodFhybGJUUFFpZHNXU1FBQUFBQUFBQUFBQUFBQUFBZVdydTlTYi9qbDl6NS95SjNrbitydnBINllaYnlPUEwwMHFncW1GdW1pdmhYbkplWmZ4cDdoWElzczJsV0pDRm0wV1VtQWtqbXlSeXJwWG5USzl3T2JpSWJrdDVhUFhxUjNHcGFVNWpTL2hhKzhqS3M2blNKaGJpYndodllzTkowNzlUTytPSjZJbVdxYlJselh0ZnROQ1pyV3lKU3BtMFNxbXBWNVIwYlhodzlEb3hlVGt4ZnNuL3BuYkhXM2NMbExhUHpMelg2UFR4ZlZmaTlmN09lM2ovaVZxbmk0UDRsMGVSMzQvTXczNGkzOTJWc1Y0N2hNbWRPMmJKSUFBQUFBQUFBQUFBQUI1T2ZmbC9OTDduem1iL0VuK3IwSy90aHZjNWN2UzlVVlJHVXh3c3BRZHA5YnI4bGNNK3Qxcnh1Rnc3WmhsQVpyc2I1V1pOSkZLNWpia1lhTUk0blNOS3VKcFhUWE1teVluVG0wMjRTcytIMVJTMGI1YmR1cmhxMStwV2xwaWVWSnF0eFp2RTdVYm91RGhjaWE3TjZSdUZqS2FUQzBXYlJrUkZ0SjdTUmthUmVGWmh1cEdrV2hXWWJOa3pLSWJRazFvMnVqYU5LWkwwL2JNd3JOWW50UERHVFhGUHFqcnA5UnoxN25iT2NGSlRSMmkrTWZSblZYNnIvcXIvWm5Qai9pVXNkb1E0M1hWZm82YS9Vc005N2hTY0Ywa2NWQjZTWG5sOXpvcjVXRzNWb1VuSGVQaE1tYnhPNFVaSkFBQUFBQUFIbGNRclZKcitPWDNQbnZJaldTZjZ2UXh6dXNNeE9TL1M3U1psOExPWmk4czFxczExUmpNNmxwQzNScXFVVkpjVjZlQjMxbmNNWmpUWk1yS3pEUmxhRXcycHNvTnJtT1NOY2pFb2tSTzRRcDR2RGJ5eTFXYS9SSFMxWjBwMHFqVHRvMFV0WDVhOXVwaHNUZko2bGEzOWUyYzFYSXM2SzMycHBJbWF3alRhd21FTlpVN2xiWTRsTVRwbzR0ZUpsTkxSMHRGbUZQMUsrMmx0YmJxWnBGcFJwc3BsdnVJOVd5cUUrOEt6RFpUTFJNSTAyVFJiY0kwTklhaVRjc0pOYU5ybzJpYTJ0U2Ywek1FeEU5d21oanB4MXRKZU9UOVVkdVA2bG1wKzdtR2R2SHJQWEM5aHNkR2VXa3ZsZXZselBXOGZ6c1diaUoxUDRseTN4V290SFl6QUFBRFNVd1BPN1RqYXJMeHMvb2VGNTFkWlpkMkdkMFF4WncyYWpSbEN5bGlvR1dTcTlaVU5uMTkyY3FUMGZ2UTYvRXZ6Nm0yRys0UmV2eTZiTlpWWXVaMkdkNHpTMnVWdHlONHN4MTZwbHM0RisxVkRIWVBlOTZQZVhwTHdLZnQvb3ZXMmxLblY0YU5hcmltVXRWcXYwTVZiVXkzTmVsWnF2VXFxZWh2ank3WnpDeEdSdkZsVzZaZmFOTWt3aGlVVTliRVdyRTltNVF5dzN5dHI2cjZtTTRJbnBlTHo4b1p3cVI0S1hSMmZvek8yTzhMeGFzb1hqZDNLU2NlcWFLN3RIY0ppdStwYnh4c1h4Uk1YUFNXNnhTNWo3c0k5V3l4YTVqNzBmazlHeXhKUDNrZWpQdHhPV1VlcU9wVlJsYklhVU5vOXFwNFIwODR5ak9wQ01sVXZhTUhKS1U3ck5XdjQ5RDN2cGZsWjdXOVpuZGY1YzJYRlRXM3V6Nkp3Z0dKTUN0VWtRbHg5cUs3VXZDeDVYMUNuVm5WZ25pWVU0czh0MEpFWmRTc2hyUnVSZXUwdzRlMHNNKzlIS1VYdkorS01xVzlaMVBUU0Y3QTR0VllLV2owa3ZsbHhSMHhMTzBhVHNpeERGektVdDFJZ1ozaWx1U0UxS3B3WmxFNm5rbUVyaGMwMXVGWVVNZGdOL05aVFdqNFB3WlRVMS9vMXJaekl5Y1h1eVZwTGcvdVJhc1RHNFhoWnAxR3RHWVRVMHUwY2J6SmpKYXZhazEvQzdTcnA2TTZLWm9sbk5aaE1tYnhaV1ladVRzMERTR1NlVU1TamZWZVFtTnBpZEtsYlp0T1h3MjhZdmQrbWhTYVF2R1MwS0ZmWlU0LzVjcitFc242bWM0NGFSbDJvVmExU203VGkwL0hqMGZFcDlpc3I3aVduOTRQa2lQL0FCcW8ydzlxU1hBdlh4NC9LdHBWNjIySitCclh4YS9MS2J6RHpXM01IWHg4NFU2TVpWSjJhVVl4dWxtbXQ1MnRGWDR2STlqNmZTSzhWWVpMYmpsOXkyWmhQWTBhVkZ6blVkS25DbTZsU1c5VXFPTVV0K1Q0dDJ1ZTI0VmtEV1pFaW5YSVREbll5TjAvVTV2SngrK09XbU8yck9jandKNGQ2U0xNckpaYUppZGlyaUtOekhKUmVzdlA0aHl3MVQya1UzQ1dWU0s0cm12RkZzVnZhUFdlNGFURzNacFZsTktVV21tcnByUm9tTGZFc3RhYlhFZ3BGSkd5WkNXNlpXYXdKNk5hMlQwTTRtYVQvQnBac21hOFdVNlZzWGdZMUZhV3ZCcnZSNkZmV1k1aGVMNmNYRVVLbEh2ZTlENTB0T3E0RlppTGZ4TFdKaVdhZFZNeXRXWW5sS1dNN0djMWlVTEZQR3lYaVdpYlIxS3MxaGJwNDlQWEl2R2VmbUZab3N3cnhlak42NTYvbFNheWszamFMd3JvM3lmWkdoeUptZERWeUtUWk1RaHJRVWsxSkpya3pPWjBzNE9PMlp1NTA4NC9MeFg3SXJrajVXMjB3ZXhxMVh1d2FqODB2ZGo5ZGZJN3NQaTVjdjdZL3dCK21lVExTdmN2U2JMN0owWVdsVi94WmNyV3ByeTQrZm9ldmcrblVyemZtZjhBMDRyNTVucmg2T2pRakJXaEdNVnlqRlJYMFBRaXNSeEVNSm5hUXNBR0pJQ25YUkNZVUt4U2Y1VERtVkkyWjRIbFl2Uzh1N0hiY01KbkxNTlVzSkZJNEdaUkxUSEFvNHZDS1NhYU9hOVozdUdsYlBQYjBzSkozdTZFbmQ4WFRiK0plSE5lZlhhTFJtajhXLzVhYWlZZGluWFVrbW1tbm1tczAwWSsrcDFMT1kwMjN5M3RzMDJVeXFCMUNOcGJRcWxkeElzVXF6WFFweldkd2lZMnUwNnlsMTVHdE1rVDJycHRLTnkxcXhKRXVaaTlqUmQ1VTN1UzhPNitxL1JUOVVkOHcwaS81Y3V0N1NsbFVqWmZPczQrdkR6Syt0YmRkdE9KWmhYVDRsYlk1ZzBrM2l1a2FiS29WOUJKSEZTWEVlc3gwalVKbzdRZkV2RTNSNndrVzBGeHVXOTdLK3FSWXVMNGtmY2xHbWZhcDhVVXRjUnpiNEZZM1BTdHBjcmFYYW1wZzZsQ0N0SlZhaWpLRXJ0YmwwbTFiTlBOZnBuMFgwck5sNm1kMWo4Ly9IUGt4MW1KbjVmUm9JK2djS1FBQUFBUVZZRURuWW1CV1lXaHpNUWNYbDRmdVYzOHcyeFgxS0M1NGRvMDdXeWtaV1Nuaks1TVNobHdKMEsySXdrWkpwcTZaamFreHpDOFdlYXhPenF1RmJsU1RuUnZlVlA0b2VNUDBYOXE1T01uRS9sckZvc2x3K09qVVY0di9uSXl2aXRUaVRTekNzVjNLdnFsVXJrVE8wYVpNNWdTUm5ZbUprU3htVnRTSjVTdFVzVStPWkh2YXZhczFoYnAxVTlEb3JlSmhTYTZabkJQVXRPT0xJaVpoeWNac0tFczRlNUxuSFI5Vm9WL1hUK1lhMXlPUGljTlhwYXgzNC9ORE4rY2RmUzVNV3gyL2lmNVhpWWxCU3g2ZkV2T0dZVzBzUnJtYzBWYmUwSTlVTU9ST2xVVTVQbVgxQ0VNcTgxcEt4cEdPczl3cGFVZFRhVlMzZVJldmpZKzlNTFRMaGYzZGlkbzR5bFJwdXppNFRsVXlrcU5OU3ZLbzFmUE95UzR0OWJlMTRPR3RZM0hUUEpmVmVYM3BJOVJ5TWdBQUFEV1NBcVlpbVZsTVM0K05wR2N3dkRtcVdkbncrcDQzbVlOVDdSMDdNVitFbHp6WjRiTm95c1VTczA1M0wxdnRXWWJsNWlKR0pVN21WcUVUcHdkcWJDVGJxVXZjbnh0M1pmekxqMTFKcmFhOFR6RFN0M0hWZVZON3RSYnI0UDRaZEdUNlJlTjFhTGxLdW54TUxVbUVKNDFUUFNFaW1SSXlwbGRpV05Za1NScThpbHFmZ1Qwc2Mxcm1UWEplcUpwRXJWUEdSZkczVTJybWllMUpwS1NhVExXcld4RzRjVGF1eHFkVE8yN0xoS09ULzM4eXRjdDhYWE1maHBGbm1hK0hyMHBXNzY0U1dUODBkK0syUE5ISFpNNjdTMDZzK01KcitsbHJlUGFQaFgzcitWdW5OdmcvUm1NNGIvaVVlMGZsUENoSi9DL1BJdFh4YzF1cXlyT1N2NVdhT3lkN3ZPeThEdHhmVHJ6KytkTUxacS9EdVlMWTFCS3pwUWw0elNrL3FlcGo4VEZYL0s1clh0THViUHdOT2xmMmRPRU42Mjg0eGpGeXRwZHJYVm5UV2xhOFZqVE9abWUxOHVxQUFBQUFCcE9OeUJReFdIdVZtRm5uOW9ZVnJOYXJOSFBrcEZvMDFwT2tOR3FwTGsxcWp3OCtHY2M2ZGxMYmIzT095N1pTS2FTbGhYNWt4ay9KNnJFS2lacDdRalRMekt6S0ZESDdPaFZpNHlWMC9YcXVUTXZiVnZhdmJTSm1IaGNiVW5oS3ZzcWp2RjUwNm5DVWI4ZkZjVHZyV010ZmFPMXZmOEFMb1VNWW5uY3d0aTBMMUd0YzU3VTBiV0V6T1lOczNJTmlrUm9aOW9QVVBhRWVpVzhNUzQ2TWVrL0FzTEhwNU1uOVhVcTZRMTFHYUtWbWEyMm1WT005ektWMnVkdE9wNy9BSW5uNy9UZis3ank0dnc2RkJLU3VtbXVhZHoxNnpFOHc1NTQ3WHFHR3VhUkNzeTZGRENGNGhYYm9VYUZpeXN5dVFqWW1FTnlRQUFBQUFBQnBPQkNWREZZVzVTWVdpWG5jZnM5eGU5REpyL2xqbHpZb3ZHcGJVdnBCUnhDbGs4cExWZmxIaTVzRTBkVmJiaEt6a3RYVFNHclpoYUV0WTFyR003anBaWnA0eUwxZGkzM1orVlpodjdUaW1SdjhFeThsMjN4T0dsRlVxN2txbDk2RXFjWFVuVHZrNU5MNFh5ZXRzczBlaDRWTTN0N1VqaitWTFdqWEx3ZUh4ODZNbW9TVTRwdGZGdXlYTlhTYVBXdGlpMGN4eVJaNlRabmFDbkt5azl5WEtXajZNNGN2alRFY0xSWjZHamlFOUdjRjhjd3VzeGR5bWhzMFJNQ09TQnRveVRiWE1uUnRxN2xvZzJqbFZsSGlXaWtTamFLdmpIYlF2WERDczJoWTdJMTR1RlNNVlp4cnozM1orOUtWcFhiNHV6UzhrZlErTi9oeERpeS91ZXl3a2IyT3VyQ1hXbzB5OFFxc3hpVHBEWWtBQUFBQUFBQUFHc29rQ3JYdzZaVzBKaVhDMmxzbStheWEwYTFPYkxpaTBhYTF2cHg1VlowOHFpZHZtUys2UEl6K0pOZjJ1dW1TSjdTUnFKckozdWVkTlcwUzBxSXhtcXl0TWlJNUpWTVJpSkxSczN4NDZ6Mnd2YVlmT3R0dXRLbzVQZWxLZFIzU1RrOWJSLzAyMFBvZkhpa1ZpR2Q5eTdHRzdOMUhGT1hlc3IraE0xbVoybUxhaGlyMmVtdUgwS3pTVXhkcFFwWWloM0hLM3l0WGovdDVHTjhVVzdoYUx1dGhOdnlqbFVwdGVNYzE2SEZrOFAvQUVyL0FISFh3MjE2VTlKcS9KNVAwWnkyOGU5ZmhlTFJLNnFxZkV4bUVzU2tpTkRSc25SdG81SW1JbENERVROcVZtVVRLbjdHZFhLUHVwNWIzTHhzZCtIeDdUOE9lMW5xTmxZVGNqQ0MwakZSVGVyc3RYNG5yMGpVT2EwdlM0T2tieENreTZsSkZsVWhLQUFBQUFBQUFBQUFBWWFBaXFVaUpoTU9maTlucVhBenRUYTBXMDg5amRoT0xjcWJjWDRhZWh4WnZFcGZ1SFJUTnB5YThxMVB2UTN2R1A2WjVtVDZkYmY2WmRGYzBTbzF0cU5mK3FvMy9TbDl6R1BBdnZtWVRPU0ZhRmF0VmR0eFFqNXQrcDE0dkRyWHZsbGF6ME95dGtySzZQVHg0cXgxREMxbm9LR3kxeU40b3pteVdXeUl2Z1Q2STkxV3QyZWcvaEt6aWlWdmR6Ni9aU0Q0Rkp3d3RHVnpjUjJOVDBLZlpsYU1xalBzclZoM0pTWFNUUzlESzNqUlBjTHhsUXoyVmlvNlNrK3FUTVo4T240V2pOS0tXRXhhNGY2Q3MrRlQ4Sis5TFgrdzRwODEwaWtJOE9zZkJPVlBoOWgxbm5MZWZXNXRYeHRmRE9jajBHejlpeVZybzZhNDJkclBRWVBBV042d3ptZHVwUm8yTEt5c3BGa01nQUFBQUFBQUFBQUFBQUFhVElJVjZxSVdjN0ZSWEplaG5hRXgwNFdMcFJ2M1Y2SXh0RU5ZUjRhQzVMMFJXQ1hld0NSMFZaUzYxSkdpc3BBaGhoTU1OQktPU0lrYVRpdVNKRU1vcmt2UXFoRTRMa3ZRRE1ZTGt2UUNTTVZ5WG9XV2xOQkJDeEJCRXBVV1F5QUFBQUFBQUIvLzJRPT1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcHVibGljL2ltYWdlcy9mcnVpdHMvYmFuYW5hLmpwZWdcbi8vIG1vZHVsZSBpZCA9IDE5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFBQUFRQUJBQUQvMndDRUFBa0dCeElURWhVUUVoSVZGUlVWRlJVVkZ4QVZGUlVWRUJjVkZ4Y1dGaFVXRlJVWUhTZ2dHQm9sSFJVVklURWhKU2tyTGk0dUZ4OHpPRE10TnlndExpc0JDZ29LRGcwT0doQVFGeTBkSFIwdEt5MHJMU3NyTFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMZi9BQUJFSUFMY0JFd01CRVFBQ0VRRURFUUgveEFBYkFBRUFBZ01CQVFBQUFBQUFBQUFBQUFBQUF3UUJBZ1VHQi8vRUFEVVFBQUlCQWdRRUJBTUlBd0FEQUFBQUFBQUJBZ01SQkFVaE1SSkJVV0VHRTRHUkluR3hGREpTY3FIQjBmQWpRdUZEVTJML3hBQWFBUUVBQXdFQkFRQUFBQUFBQUFBQUFBQUFBUUlEQkFVRy84UUFLeEVCQUFJQ0FnSUJCQUVGQUFNQkFBQUFBQUVDQXhFU0lRUXhRUVVUSWxGaEZESnhvYkdCa2RFai85b0FEQU1CQUFJUkF4RUFQd0Q3Y0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU5rVE92WTUrUHppbFNWNVNSdzUvcUdMRjFIY3RLNDVsNWZOdkV0V3JDMUNuVmtycmlsQ052aDVwUGU3N0huMzhueU0wYXJFeERlbU90ZTVjakc1aFh4U1ZOSnhWN2EzdTN0cmN3bkZreTJpTEkxeGw3SHd4NGNoaFkzZnhUYTFkdHV2cjM5dWQvZDhmeDY0by9samUvTDA3eDBzd0RBQURJQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZQSDVsVHBLOHBMNWR6aThqenNlR08rNVdpc3k0VHhHS3hlbEplVlQ1MVpMbC84QUs1czg2c2VSNWx0LzIxLzZ2SEdybzVmNGNvVTN4dE9yUC8yVmZpZm90bytoNmVEd3NPTDFIZjhBS0p5V25wZHpIRnFuQnU2NHJhTG44N0Y4K1d0Sy93QW1PazJzOHY0VnBPdldsWGtyY01tK0c3YTR1VnIrck9UeEtjcDNMZlArUFQyWjZia0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFERXBKYXNyZThVamNqZ1pobmNwUzhtaEZ6bStteTd0OGtlTm44M0ptdDl2REMrdEpNRjRmVGFxWWgrWk85K0gveHhmNy9RMzhmNmJXdjU1ZTUvMGliTzRrZW5FUkNveE85ZER3cy9QcVYzVGFkMW8wK3JmMDUrcDgvU2w3NVpyYjI5RGRhMTNEMXVWWmRHakRoWDNtN3lsdGQvd2ozTU9LTWRkT0s5cHRPMTAxVUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTVRra3JzcmEwVmpjamo0dnhGU2hlK20rNzZMZC9xZVpiNnBTT29qdHBHUGZiaVpkak1Ualp0dy94MFZMNHFrbGR1MytzWTdmM1U0OE5NL2wyM002aHBmaldOUTlYZ2NEQ2xIaGhHMTlXLzhBYVQ2dG51WXNOTVVhckdtRXp0Wk5VQUFCWWpVYjJCSUFBQUFBQUFBQUFBQUFBQUFBQURXZFJMZCtuTXBmSld2dVU2UVBHTG96bXQ1bFluV2s4UjQyUE81RStkamoyY1pUVTZxbHFuYzZjZVdtU04xbmFKalRjMFFBQUFBRFN0V2pCY1Vta3VyTThtU3VPTjJuU1loNTdOYytwT2xLY1oyVVpOUzAxK0YyZjBQSjhqeW95eDF1STJ2U3J6dUdvckg0aHZEM2hTalpTbmEyblJMOFQxT1hENDMzczh6RWFyQzl2eGg5Qnd1SGpUaEduQmNNWXF5WDk1bjBWS1JXTlF4bWRwU3lBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJGWHFXMFc3L0FMYzU4K2I3Y2ErVXhHMVY5VHpMMzY1VDdheENKek9UK29tWlRwSEpGTGZrbUVQbXlpK0pNeHJudmh0eXJLWmlKZG5EVjFPS2t2VmRHZlVlUG5qTlNMMWM5bzFLVTNRQUFNVG1rcnZZcmU4VmpjOVFQTjFxRHgwbXAzamhvdTF0VktwSmJyOHFmTThqaFBtWDVXNnBIKzB2TWVJY0pRbzFWU3BTdEY2emplOGtrOU9LKzZUOWJNOC95SXg0c21zYy9pMHJHbnRmQ21CcFVzTlRWTFpyaWN1Yms5Ny9BRTlEMy9FcldNVVRYNVV0TzVkYzZsUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTU5U3BkdG5oWjgrOGt0cXgwaHFWRGd5NTl3dEVJWE00K2VwV1I4WXJrbmFOTkpNcmV5WVc4bnFXazQ5ZnFqMS9vMmFZdE5KbjJwbGpyYnExYXFpcnYvcDcrVExYSEc3TVlqYW5QRnlmM2JKZDFkbm4zOHpKYWZ3Ni96Qy9HSTl0Wll5VWVqN1ArVnNKODIxZmZad2VFelhOOFhMRWZacXljYVZTYWpDcEZXU1RlcVVsdkszcjhqanlacHkvM2ZId3ZOYS9EMHRPdFdyUlZQQ3c4cWxGY0txUzBWbHBhUFg1Nmt4YnlQSmlLNG80MGo1bFRxSGlzOHl5cFF4Q2RYNG5KYVN1M0dVWG8zcnJjNUw0YllyL2J5ZktQYjIzZzJxNEtlRmx2QnRyNWFKNit6OVQxL3A5dU1UaW4zQ2oweDZZQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFESW4wT1BPUjhubnRxMHVtRU01SEJlNllSU2tZemRLSnpJaklhSEl2TitoTmdxalVsSmUzb2R2Z1pKcGVMUWkwYmhlMWZ4UzFmclpIcTJ2TnA1MzdsbkVmcG0vd0RXeW5QVXAwZ25LL014dGVaVEN2VmlyR2U0aXZ0S2ZMOGE0dFJmM1hwOG4vQjIrSDVzMXRGTGVwVXRWcjR0eWY3UlRqdzZTaEs2bGJpMGUrbDlWZTM2bmQ5UXdmY3BGb2p1UCtJeFdpSjdlZSswVG8rWGlLMVNNS2tQaGxLVXY4Y29xNmkrNmxIVHJzZWZqeVdpYTMrZlMxc2U1M0QxT1hlSUtGYW1xa0pPejVPTWxmdkc2K0pkMW9lcC9XNG9qdWRUK21VMGxZV1p3NlNYZTJuNkVSNStLZjNIL2hQQ1ZxaldqSlhpMC83elhJNnFaSzNqOFoycHFXNWNBQUFBQUFBQUFBQUFBQUFBR0pTUzFic1Z0YUt4dVowYVFQR3cvRWNzK2ZnaWRjbHVNc3d4a0h0TDlpYStiZ3RPb3NjWlRwOURxaVluMHE0Mk9qd3lhNjZyMVBrZnFOSnhaNWo5OXc2S2R3cHptZVZlM2JSRTVHUElSVGtSYVJxcWhGY20vYWRPaGxxMHUrcDduMDJrVFhsTU03L3BkbE5IYmE4Ym50VlhsVU9LMlR0YlNLVXlrMzJhUlNrVTVKUlNlcFBQc2VtdzlTOEl5ZjRVMi9UVSt2eFhpY1VYbjlPYTBkdkw0dkk2RldzNjhvY2VxNFl6MWhHMnQxRjZMbSt2c2VQazQydk0wNmJSTTZXMVJzOTduTncxTzA3VFJScEU3UWhxSnhmRkYyZlZHY3piSE1Xck9qMjZtWFkvaitHV2tsN05kVi9CN0hoK1pHYU9OdXJmOVoycnBlTzlRQUFBQUFBQUFBQUFBQUJpY3JLNVRKZUsxMm1JVXB4NHRaYTl1UjQ5N1RsbmQ1YWVtazBsc2tZWmExckdvaUpURzBEaXVhME9PS2ZsdTBkZndzMGkzRjNpN2RpOWI1Y2M3eHpNR29sak1NVnhSamROU1R0ZmxZajZoNU1aOE1UTWF2V2Y5SnBYVXViS3FmTzN5dGRJblVNdVVtbkx6VE9ZVXBSaTA1T2IyVnRGK0ozNUhYNDNpM3o3NzFwRXpFTVZjMWhIUlhrL3d4MVowVjhHdGY3N2YrbVZzdjZla3dNN1UwdXliWHBxZCtPMFV4OGE5UW4zN2J6cS9ReXRsU2hsVU0rZTRHanFFY3hIT29WdFlRMUtwbGJMcVV3NmtzZEZ3alRpOXRKTHZaU1hwcWZRNWZLckdHbU9zL0RMajJrcHNwUzB5bVcwOWkxNTZRMGl6T3M2VExlU3VqU1k1UjM2UTV0YThmaWk3Tk82ZmM0dVZzZHQxOXd0N2VpeTNHS3JUVTF2dEpkR3R6NmJ4ZklqUGppME1MUnFWbzZVQUFBQUFBQUFBQUFBQVFZbVd5T0x6TDZpSVhwN1ZKMUR4TW1mZzAwaVVtM29ZNDV0bXRxRSttOHFXaDNXeFJXdWxZbnRXZEcvUDlUam1uS2ZhK3lWSzJtNkszeDJySHZadFF4V0dzcng5ci96eVBPeWVIVzA3ck9sNHQrM1B4ZFdNSU9Ua205clIrSjY3RksrRldQN3JiSnYrbkdwNVZLdkpPYWszK0NPc24rWi93QUd0TWt6UERCWGYrRmVIemFYcTh2eUZVNHB5aW9ybEJidjh6T3V2MHpMU3YzYzgvNGovd0NvaThlb0tId3hVZHJhYjN0YnIxS1pKMGtsTTU1NmpvUXVvWlJkS09VaU85aU9jeWw3YUZhZFRVeGp1eVcyQnB1TTV0cTNGVWxKUHM3SmMra1VlbGJMeXZIOEZvZDJsTTc2WDY2WnBiNkdtK2tJbEl6cE94THhkemZlbzJoejhXOVRoelR1eXlUdzNpZUNxNFBhZTM1bHNkdjBqUHh5VFNmVnYrcTVJM0czcVQ2VmlBQUFBQUFBQUFBQUFCV3hzZEV6elBxVlo0eE1OS09mTm56V1dXcVdpckhxZVBXTVZGSjdLbFFqSmwybUlRdVp5V3l4OEphU3FHZHNxVVVwR0U1UGcwODlpTUxUcHp0R0tpbkpPeWJiZHJ1N3ZlM3VXblAxdVlpSWhHdTNwTXV6eW5wRjAxRHZCTGg5ajFQRCtzNGY3YlU0L3dDRmJZNS9icTRxYWxEaWkwMTFSNmZtWHJsOGZsU2R4Q3RPcDdlWnhkWGduWjdUMVg1bHV2by9jK1k1YmlkdHA2bEdxNjlUS01rYVMxY3l1dCtobzVpSW41RVZXUlc5WW1DRmJESnluMldwalN2NlREbzFWcytaMThZaU5wc3U0V1doMlllNFpKbXpXKzU5Q09VeW0rSTA4d25taEZVbGN4bjhwU3FTVGpKTmJwM1h6V3FLMTNTKzQ5d2UzdDZOVGlpcGRVbjduMmVPM0tzVy9iQ1c1ZEFBQUFBQUFBQUFBQUlzVEtOck4veWMzbFdwR09ZdEthNzI1bkJjK2EvcDR0TzIrMlp5TnMxdFRwRUlwU09TOXBXUVRxcTV4V3l4dlJwcEtvVW04eUk1VHNVdGFhOXJSRGc1bmlQOHR1bHIvUGhacHFiWTlxVy91WnBWVGttR2tPbGhjYktPejMwYTVOR3VMeTh1THFzKy9qOWsxaWZibCtMTWRDVkd5dnhSYWtwZEhyWko5YjJPL3dBZWxyMjNQeXp2RzNFeUx4SjVxNEtrWEdva255YWxGN1NkbStGNmJPekxlWjRVNHZ5clBVclJNL0x2MDhVbXQwYzFaaUkxS1dmTlhVUnFmbENTR0duTFJKN050dlRSYnNtYVRPNjE3bjMvQU9FajRZS3k5K3B5NG81ejM2VE02VVo0aDdyMzUvSTYvdVJyVUtUTXU3aDUvQ21ubzdOSTdJNnBFd2hZYzdHbkxVSlY2bFU1c21TSWtSdW9WNXpaQXBGcS90TEY3NjJOSW5jN1E5ZmdZMnB3VC9DajYzeDRtTWRkL3FHRSswNXNnQUFBQUFBQUFBQUlLOWUzd3JmNkhINUhreFQ4YTl5dEZWYmg1dlU4NjBiN3YyMGhGVXFwSExrejFxblNEanVZUmtqTDZXMGptYytXc3dtRkpVTFNjcnZYZTdkdlJjamhuRk16dExkSXRGRUk4VEpKYXZRcmV1NTRwaWRQSFZNTGl1T1VyUmtwU1VyUm5HMjcxK0tLZTNEejZuc2ZieHpqMVdmaFMweE03ZEZLMmowUEV5VW1zNmxNU3NSbnlMK0xpaTE5ejhMVFBTcm1lVndydzRKU2NWMmRuK2g3RkptczdyT2xZbHhNSmt0S2g5eTdmT1RlL29ZK1RudGYzSXNObkVPaGxPWWNENFpmZDY4MFo1TWUvVTZURXZvT0d3TVkwcFdzM09QM2xxdFZwWjlENnJ4UHAxTVBqVzEzYTBkeXh0ZVpzOEpqYWw1dnM3ZXg4bHg0OU41VlpUSmhWMk1ucjNodzlQb3owUEh0eXJOUmFxVEszdDhDTzVqN0FSQXlhUkd4Y3kvRE9ja2w2czlMeE1FNUxSQ3RwMDlXbGJRK21pTmRNR1NRQUFBQUFBQUFBUllpcndydnlPZnljMFlxYitaVFdOeW9yVFU4UG5ydVpiYVJWS3JPUEw1RXluU3RVbWNWN3BoWGRSbzV2dXpTZHdzMmppazk5RHBwNWRMeDMwYVpsSmRTMHpIeEtWVEVZeU1lZDMwVzVoYkpyMGh6SlloemxyNkl6eDdtOElYcXROY0o3SEdJcW81V0lPTEpHMHFycjYraGxpbmhzWWRjMis2SzlTUm5NN1NnYkVJYVJrN2xwZ2w3cndabTNGVG5RbTlZUmNvL2w1cjBmMTdIdS9TL0ovOEF6dGl0UHFKbVA4TTdSMjhoNXQyKytwODdhTjl0cEhJalNFMkN4WEJKUGxzL2thNDdjYkR0ZVl2K20xNGpZY1pUU1NNcmxxMTJUQ3pocWJrMGxyZjFPekRnbTg2aFdaMDlWbCtEVk9OdWIzZjdIMGZqWUl4Vi9tV05wMnRIU3FBQUFBQUFBQUFBSE94czd5dDBQQitvWmVXWFg2YlVqcFZxVkR5TXVhZDZYMGhuTTViWkU2VjUxT1J6V3k5NmhPa0ZTWmprc2xWbXpHQldTNHBka2Qvalk1bnRFeWd4QzFJdlhVb2JZV1ZtYmVQRWIyckt6T3RvZDAzaVlRcFlpZWh6NUoxQTVPSW5hUm5FYkpsckdZMG5hUmw0aUpnYU9KRXdiUlNFRXBjRmpYVGx4UjZTajZTaTR2Nm11Szg0NTNIOC93QzFKbGlFakMwTk5wbUlyc1J1STFJdDRXdTQ5MTBMMDY5bzI2TU1WQjhtam9qZ25hZWpYajBiL1EyeDhVYmV0eUtsRHkxSlJTZXFaOUQ0bEt4VGNReHRQYnBIWXFBQUFBQUFBQUFBQURsWW5kL00rYjh5djV6TGV2cFRtenhiN1hRVkdjOWt3Z2s3R005SlY1eU1abVpFRlNSYWxkenBFeTNvcXl1ZTFTc1VxcXBWOVhjNWIxM0p0RGV3ckdrTVNxbDV2cjBoRFhtVnZPME9UaVphbWxJNlJMU0ZRbVlJbFlWUWlPbG1ycUFSenFFeFZFeWlwNnlTWE5wZStocFdOenBWWnFMaGs0dmVMYTluWXBldXBtRnR0bzFDa2RMSmZNTHhhQnZHWmRDYW5JbUJld3Nqb3h4b2U0eVdkcVM3dHY2TDlqNlR4WTFqWlc5cjZtZENyYmlKR2JnQUFBQUFBQUFBSFB6Q25aOFhKL1U4ZjZoaTFQS1BUV2t1Yk5uejJXRzBLOVJuSGJvVnFzakd5VldjakNJR2tZdDY4bFp2M1MvYzdQRnh6YkpHbzlLU2txdmtlcGtqNFJFcU5ZNWJVblp0VXFUc1k5K2tTaWNnaHBVZWhhS2puVjNkdEc5RWEycnFScHBXRWthaFdhcmJIVUVWTm9wekxSQ3NyMlFVSFVyUlhLUHhQMDIvV3h2aHg4cnByN1c4K3d6akxqNVMrcEhrWStOdC90ZVhOaFVPYVlSRGRUSzZXU3dxRnF6cEMxUnFHMVV1amd0V2pxeFUzSkwzT0NwdU1JeDVwYS9QbWZSWXE4YVJEQ1ZpSnFoTEdRRzZaSXltQnRjQmNCY0JjRElBQTJSc1JWV21yTXp2V0x4cVV3NGVMcE9MN2NtZkxlWjQxc016K25UVzIzUHF5UEl5TEt0U29jdktaRmU5M2I2N0dtTEhONWlJVmwxMUtuR2pLRVdtM1p1WE50TlAyUHA4R0xGaHd6U3ZjejduOXM1M3R5S3N6anlSMmxYbExRejlpdFVpWnppMmhCTFFyd2lCRGlKRTJvaHZsMUNQRDVrM28yN0xzdFA1TjZVckVic3RYMDVlWXdpcHR3ZDR2VmR1eEg0NzZWdENyNWhPbFd2bWs4VGJTVTdreENIcDhtclU2Tk4vRW5PV3NuOHRvbzdjVTFwWGZ6SzhRanh1WXFxbkRrLzdvYzJiTkZ1bDlPTlVWbjI2blBHcFYwd3FnNGpmejExSTRKaFBReFNMMTZudEwwdmhYRVFuTysvRDdYUFk4R2tUUEtWYnowOTFDUjdFTVc2WUd5WkkyVEEyVEpHYmdadUJtNEM0RzRBQ09veXNpQm9wSzBJTVJxcld1YzJlc1hycVkzQzBQTTVpbkY2TFErVTgzeFppMjZ4MDJpWExxWXM4K01VL0taYzdFVm0zZTdPaWthVlYvdGtsek9pczJqNVJ0MU1OakZPTithM1g3blhXMFdoRExrVjFwQ0tVeTBRaFdxelhVaWF3S2RhcW5vWjJ0R2t3MXExSk5KSk95VmtpdkcxbG5QeE5WN1dacFRHck1xTXFrdVMvUTNpaW9sTi82c3R3UnB2SERWSDJKNFQrazZUUm96N2tUaWxadnd5UmxPT1JCVnF5RVVpQkY1N0xjSVF3NnpleE1VVERwWmJsbFNwYStpL1UycDQwMmttWHYvRCtWeHBKVzM2bnJZTWNValVLVEwwc0puWENpUlNKRzhaRWplNEd5WUd5WklYQXp4QU9JQ1lBQWFJME5IQXJwTFNkRkZackNZbFR4R0FqTGRIUGZ4NjJXaTB1VGlzaGcrUnhYOENrL0MwWGN2RWVHMXlPYTMwNnZ3bmxEblZ2RFQ3bFA2RFNkd3J2SXBSMVRkeUo4T1k5STNEbll0MW9icjlEbnRpdldSeTYrT3FkYkNLL3RTZG9vMVp5ZHRYOGlZeDc5UWR1MWxlVDFKYXRNNk1maVRQdUU3ZWpvNVR3clZIb1U4ZUloSEpyVXlwUGtYK3pINlJ0aU9TTDhKUDJZTnBGa1VlaFAyalk4aVhRZmFOb2FtUnJvUk9KTzFhcmszWXpuQ2JjM0U1VjJNNXhRbFJubFBZeit4Q1ZuQjVhbHlOS1k0aEQwZUF3OXVSMVZoRXk3bUdpZEZWWlhhYU5JUXNSUlpEZEVqWk1ES1lHYmdadVNNcGdMZ1dnQUFBQUlHclJHa3RIVEltQnI1SkhFYXZETG9Sd2hPMnJ3VVh5SDI0UnRYcTVQVGx2QlAwS3poclB3bmxLcFB3dmgzcTZVZllyL1RZLzBjcGJVL0Q5R1AzYWFYb1RHQ2tmQ05wMWw4VnNyRitFRER3U0hFWSt3b2NSc3NJaHhHLzJaRThRK3pqUTBsaGtSeEVOVEJKbFpvYlZLdVdKOGlrNDF0cTA4blhRcjlvMjJwNU9seUpqR2JXcVdYSkY0b2phM1R3dGk4VlFualJMb1NLQk9obmhBdzRnWXNBc0FSSTJRR1FMWUFBQUFBQUFBalFEUUVnQUlHR2dNY0lHSEVnWTRRbGpoQ0RoQWNJR0hFRFYwd05YVElTZVVBOG9EUGxrb1pVQU04Sk9nNFFNV0F4WURGZ01XSkN3R2JBTEFmL1pcIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcHVibGljL2ltYWdlcy9mcnVpdHMvZ3JhcGVzLmpwZWdcbi8vIG1vZHVsZSBpZCA9IDE5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFBQUFRQUJBQUQvMndDRUFBa0dCeE1URWhVU0VCTVZGaFVYRnhVWkZoWVhGUmdZRlJZWUdCWVdHUmNXRlJjWUhTZ2dHQndtR3hZWUlURWhKU2tyTGk0dUdCOHpPRE10TnlndExpc0JDZ29LRGcwT0d4QVFHaTBtSUNVdExTc3RMUzB0TFMwdEt5OHZMUzB2TFMwdEx5MHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMU3N0TlMwdExTMHRMZi9BQUJFSUFMY0JFd01CSWdBQ0VRRURFUUgveEFBY0FBRUFBZ01CQVFFQUFBQUFBQUFBQUFBQUJBVURCZ2NDQVFqL3hBQS9FQUFCQXdJRUJBTUZCZ1VEQXdVQUFBQUJBQUlSQXlFRUVqRkJCU0pSWVFZVGNUS0JrYUd4RkVKU3dkSHdCMkp5NGZFVkk3S0NrcUlXSkRORFUvL0VBQm9CQVFBREFRRUJBQUFBQUFBQUFBQUFBQUFCQWdNRUJRYi94QUFwRVFBQ0FnRUVBUVFCQkFNQUFBQUFBQUFBQVFJUkF3UVNJVEVGRXlKQlVXRnhvYkhCUWxLQi85b0FEQU1CQUFJUkF4RUFQd0R1S0lpQUlpSUFpSWdDSWlBSWlJQWlJZ0NJaUFJaUlBaWk0L0hzcENYbU9nM1B1V3Q0bnhTOGs1QUdpTjduMUowQ3E1SkhSaDB1WEx6RmNmWnR5TFNXK0wzQTNMVFlTSVY3d2Z4QlRyd1BaZEdoTmo2RlFwcGw4dWh6WTF1YTRMbEVSWE9RSWlJQWlJZ0NJaUFJaUlBaUlnQ0lpQUlpSUFpSWdDSWlBSWlJQWlJZ0NJaUFJaXJlTjhTOGxraU14MC9WUTNTc04wU2NiajZWSVpxcjJzSGN4OEZGL3dEVUdGZ0h6NmNIK1lmc0xsZkUzT2U4dWNTNGttU2JxRTU4TG5lZDN3aW00N2JSeGxONWhqMk9NVEFjQ1k2MldIaS9FRzBLVHFydEd4YnFTUVB6WEY2Tlp3Y0N3a1BtMldRNmUwSzBwY1V4bUtJcFZENWpXL2U1Qmt2Qk9ab2duYURKc3A5Ymcyd0pTbXR5ZFh6UjY0dHgxOVZ4Sk5qdVo1UVNZanR0Q3BuY1J5bm1GblREZzdsZ2RUdWZkc3JoM2hrUHFacTFmTjFhR3dBQUxFYzIxOXR3cWppWGhwN1E0VUtqWE5JQkRYaUhheHl1MDFXRzZ6N0xIUEVsdGp3Ui93RFVyV3VOeUh5TmZ2QWo2S2Znc2JCRG1tYnlIVE54R29PNDZyVm5ZbDRkSnloN1prRnNFV2lEYlhzc3RIR3pGbSt5Snk2Z2lZY1J1ZXZaTFplU1RSK2hlQ1k3enFMS2t5U0wrbzFVOWMrOE5lSTI0ZkNaWGpOVURqREJ5OHBBNXBJZ0tXN3g2RzVTK20wVFAzNW4wTWFMcmpOVXJQbHNtZ3l1Y3RrZUxOMlJhdnd2eHRoNmh5UG1rNytZZ3QzKzhQUmJNeDRJa0dRZENOQ3JwcDlISmt3enh1cHFqMGlJcE13aUlnQ0lpQUlpSUFpSWdDSWlBSWlJQWlJZ0NJaUFJaUlBaTFieEw0anFVWFpLSWJiVXVCTitnZ2hSK0JlTDNPT1hFZ1hObnRFQVQrSUU2ZDFUZXJvamNqY1Z6L3haeEROV2NCbzNsdjIxK2EzOEZjcDhVZy9hcTFpQm50OEJkVExvcGs2S2ZFNHE4ZnYzcUtkTzY4VjNYMFBjbGZPR2pOVll3NkUvSUFrL1Jja28wSUp5YWl2a20wK0VWWHNjWWlSWUdRU0hTTTNiVDk3MlhCcVl3dExJNTRjNG1ZR2dtQUd0SDNqTnBVckVZNjBrbUNZYUJHWjE0aG8vVWJIcXFMRll1Sm1XTklKQTNxWG1DVGZMR282YUxGcHQyejYzU2FOWTQ3U3l4ZU9hR2tCME9BbkszS0d5U1JBaVRQY0tEUzRpR2pMbURnZTROOTJTUkVqdUwyOVZTL2J4UG1aUVRma0FnTXZNZ2J5SjAwaFlYWWtpd2l6cEJCNTRuVE1CZlhkU2VoNlNTb3ZPTzRMN1N4aDlsOFdkQXpTTEJycGpsSXZINktoOFBjTkxYWnF6UzJvMXhhMWxwbmZNUG9kSXVzekhYSkpKM2pSM3RaZ1cySWlSOUZaNDUvSTJvU1drMmMrSjBCbHgzMEdpc21VY0tya3hQeEo1cWJtK1k3bTVXQ0EwVzlwdzlxTjVzb2YyZ0VPTEdFd1lsNEJiSnNDQVlIMVVDdGltVGxjNnFHQVRFWlhSUEswU2Q5VEt3SEZoMXkrcHkreTJOR2R6dDhJVnJKNkx6N1FRVG1jd2ZpQWFNMGFucEkwc3RuOE9lTUt0RWdFRjlHUlBRTkoxQUZ3UjgxenRqNlZwYThRUmZYa09uNUxNMnE3MW1ZTWtGNEJFKy9UUldVbW1aWk1VTWtkc2tmcEhCNHBsVmdxVTNCelhhRWFGWjF6aitFZkZTNXRTZzRRQnp0dVQwQkFuYlQzeXVqcnFqSzFaOHBxY1BvNUhBSWlLeGdFUkVBUkVRQkVSQUVSRUFSRVFCRVJBRVJFQVZaeG5pemFJajc1RmgwN2xXWlhOUEVXS25GVlJPam8rQUN6eVMyb2hrWGllSUwzRWs2cUMxOEZlYTFTOTlGaWNWekoyVWFOODhHY2J6ZjhBdDNtNEhJVHVCcTMzZnZSWS9HdkM1YzJzMGE4cnZkb3RIdzJLY3g0ZTB3NXBCQjdoZFN3K0twNHpDNTluTk9ZYnRjQmNlNWRFSldxSlh1VkhNcXVFQlBRYm1OK2dYaHBwMDdzSE51WkJJQmpvWi9lNmc4UnhkaEpJOW1SYVNKUHp0Y3F2YmoyeTNsYzI0Sms2dGtrU0R0bHVzWnpzK28wWGpzZUdLazFjdnNzMzRxSUlNbTRhWGJTMHVMaDhmbXFYRVZ5N0kwa2taUkhXY3NSOG85eWxWbnV1ZFRtblRZaUMzMGlWVzFnQkZ0SkEvVjNxTHJHajJGU1BMcXppUVRCTEppMjNkZUdrVzBNZHRSL1pZMjd5TkRlMXgrcXlRWkdwQVBTNHpmVkMzWm5wMUlBRUEyT1MvZTQraWxHcXp5WDZpelRlU0d3UmNEWFFHTnJuM1FXQ0JiN29sdmRTcVlIbHVhNXdBTFlCSWtBT01FKzY2V1VrdUNpT0pPVjV6M2NRU0NETG91UGN2RDYwbWJ5ZmFPN3I3ZEZ0UCtoWVlIMm4xQ1lrdWRsMDBBQUhvc3VKNEJobjNhS2xPUUFNanc0YkNTSFNUcnNieXJHSEpxR2NYZ0VTWXNkaHJLa1lhb1pCM0R0VDNpUG92dkZlRjFhRWwwRmgrOE5JMmthdEo2S0poRExnQUpreHJmc3BSUnlvNnAvQ0REazRoNzRzMmxCUDlUdVdMWG1DdW5Zbmk5RmtoMVJzalVBeTc0QzY1RndLcTZoUTh0dFFnTzVubTRnZ2V5WXU2QU5PNnh2cmtSTHRiY3RnN2NBQ05WckhKdFZJOC9Qb1BYeXVjblNPcjAvRTJHTS83a1IxYTRma3JMRDRsanhtWTRPSFVHVnhSdUpkTVpYQUNTUUFPaEFHYmJyQ2xjTzRuWG91TG1GN0NEekZ4bHNScVJFSDhySzZ5bU9UeE1hOWt1ZnlkblJVM2hyampjVFNhWmlvQU00aUw2RnpmNVNmaEt1VnFuWjQwNFNoSnhsMmdpSXBLQkVSQUVSRUFSRVFCRVJBRVVIaW5GcU9IWVgxbmdBRFNSbVBacmRTVm92R1A0a09JakMwOHBtNzZrRzNaclRyNmxaeXlSajJRMmtkSVhNdkYxUExpcWhpSnlrZDVhTC9BQkMxM2lYalBHMVc1WFZvSDhnREQvM052ODFUdjQzaVAvM2VmNm5GMy9LVno1TXlsd2tWYnN1M2tsRzZRZE92VCt5b2FYaUtySURtTXFUcHlaWEgwTElFK29LbTRmakZKNXlrdXBPL0RVRnVsbmdScmFYQnF5M0lsUlpLcVdKVmp3ZmpnbzA4UlNlWEJsU20vTGwxRlFONVQ3OUQ2QlY3N2NydGR2ZitYZFZtTWZDMVRKaTlza3pIaTNiam1QS1d1SjZFODJXT3FyblZ5eHozZVpMMm5YVUdUZjhBZlpaUHRBRFFBU01zRDR6ZWVrRUxEaDhBNTdaQXREdVl6Qkk2QVgyV1o5dkNTbkJTWHlaTVBqaVFHUGR6T2d6MUJzMmZRaytzcjArSnRxR3hOclJBTFRPdXZ5V0YvQlp1QzZZQkZvZ1dPY240UU9xd1ZLTlJ2c2lXVFl1dGY4MExibXV6T0NJYjNHMHlSM0M5aHdCa1NRMkpFMzFzUjFzVlZQeDVFQjlqc05oTzRQUmV4amhKZzY2U2R3TlJDbWl2cngreXpic1kwZ09nMjlmaXZPSXJtUlRhQ1RKSkFibW05Z2RoMTdLcXJjWEYvTEFrMkorN0hXTlNWOHBaaERnOHp2Mi9YMVViU3F6S1RxSnRHRzRoNXJTM0pMbTNnTjJCdURGOXQvOEFHV25pNGh6bVFIL2pjNkJGcEJGK214VkxTcjVpMGdGZ0VBNVoxMjFPdmNxUUh5TFNDQ05idG5RbWRvVXMyU0xsMVp0UmpxYjdOSWNIQngxSkVTMDdhMjdoWXNCNGRiUW9PeGZtQXZZN0xSQWREcjJEc3crK0pKZ1d0S2d0eEkxSnoyQkxvMGNEQWszbHFpY1J4NUF5QVpNemdTMllhSURyZ2JnaHhGdHdrZXpuenc0VFgyWERzUTk3U1E1c1RHWTNhUVRKSmJCdkc4U2pzUmxZMWdhOWcwOHdFdGFaZzlMUjI2cXZZOXVXR0VsZ0V0blFtTkRHaEU2ZjRYdXBWY1hFdURuSE5JRGpMU0czSUkzK1NpK1RlS1RSTEdNWWJWTXBnOGpocmxIL0FDSmsrMXVubnk0dEVrMkljSkJHcHpCbzVRQVprcUl6RnZkR1ZqUUE1enZaRWRYQUEvVHNneEdiTExnQ0E0ald3RHB5VzJPM29wM0UwYmw0UXg1cFlocm1tR3VMV1BuTG9UQkUrdHhIUmRjQzROZ1RCQWdHOXNzRWdFbUo2NlF1NjRVeXhwZ2psRmpNaXcxbThyb3d1MDBmUGVYeHBTakpmUDhBUmxSRVc1NHdSRVFCRVJBRVJFQVdwOGM4Wk5wdExhTENYNlM2elduM0dUNkxiRnJ2aXJ3MDNFTUxxY05xalE2Qi9aMzZyTEx2cjJrTy9nNUhqS3BjNXozR1hPSkpQVWt5Zm1vVDNMTmpudVk1elhnaHpTUVd1RndScURLaTBaZThNWUFYT0lBRXhKUHF1R2pOSzN3WmNMZ24xVERCNmsreTMxSzJUQThGbzBUTlFlWTRBa3Vqa0U5V3lSb2U4OUZub01aUnBGakprQUY4M0JNYWtucjA3S0RXeFJ1MHNweURKTGkwQUE2bUFiZk1xYW8rbTBYakl3anVtcmY4RnNLeldNQWFHTmFMU0Exb2JzWWdXTTlqdXNEK0pGcE44MGdSSXVCNnh6ZXZmZFV0U3NTY3pHellOa3VzSS9DQitjckErdTQyRFhra3lDNjdTZFlpT2c3NktkeDZxMDhWOEZoV2RURGZMQVlBTXpnSkFjQWJtTXNnWHZIY0tpNGdMQzlqN0x0Si9sY05pdll4WkU1cXJmWjFGdzN0SkUzNlJGMVY0ckZRSkpFV0dVRGFkQ0xTTmUrNElVcG5GcmZIWThrSEtLcVMrdmtzdUZVYVRzTTZyVUphNmk5N1RsZ0Y3YWdhYVllU0RvNXRTTGZlVnJ3YW15b0E5MW1pd2FSWUNDQnJyQWdrenNxVGhBWUtaYzhIbmdqTUk5bWN1WVJFZ3pmMEtzRzRzZ1poeWlXdGJJZ0VuZU9rRVJySHpVUGxsdkg0Snh3UjNNdXNhNWdBWlRiSklpSW5rN2owL0phNWpTQ2NvRmhyRjdEVFFkZG9YdDJKaG9seGh6em1MU05yQUNSTSt1c3FDYXNaaHZ0SXVZRnZRcUVqdTJwRUhGVWc2YkFnZHZ6Mlh5aHc2aU1MV3FGNDg1aGxyWHhseVdzMlJPYTVpK3dVcDFPWUZyMytPb0pIZFI2MkZEZzV0cmo0SDBXa1pVY21vMDZ5TDhsRmgyV3R2ODFQWm9RQ0lzVHRmb0ZXVUhYanBOOWo2S2N4NC94b3BrVjA4bFJZaW9lc2l4MTMwRXF3NFZ3K3RYbHVIcE9xOVlFTUJPNWNZRWp1VlplQi9DLzJsM20xcDhrR3cwTlFqWDBhT3U2N0Z3MmpUcE5EV01ER2pSclFBUGdGTWNkOW1HcjhuSEU5c0ZiL0FHT1pVZjRjWTk4bHhwc3RBRG5UbXRvY2dNZXQxUWNkL2gvaTZUYWxXdFRKRkpnYzAwaWFnZWM0QmJsczlvRFNUT1dCR3E3OTl0Nkw2M0VOUHRhOVZ0NmNmZzhxWGs4MCtKVlIrWmNIaXdZekIxeVNRUFpOdHZlcHBxbUJIcUNIRXhKMEk2WEMzTCtLM2hWbElIRzRVQmpRNy9mWTJ6WmNRQlZhQnB6RUJ3SFVIcXRKNEZnSDFuRE5tWlNrelV5NkdiQnBpSEg2TG1uR21lNXBkVXNzYlI5RlhVdXpTYzBFV0duOWxub1M0QzAyQWxvMnZBOVNmb3R2d09CbzBnNE1ZWENBWEY0TGlTUDZoQUhZYnJNM0VGckFXdGNOSXlpNHYxQUhLT2lwUjErcCtDRDRZd2pxMVZqUlp4SWE2Uk9VM3ViNlJ0K2E3YTFjc3dIRVgweUh0YmxjSjVnQWN4dUNEWVI3NWhiSmdQR2pjeldWWUpNeTVwOWtSYmxBdmNMb3dOUjdQRjhsaHk1cEtVVndqY1VXUEQxbXZhSHRNdGNBUWVvS3lMcVBDQ0lpQUlpSUFpSWdDSWlBNS84QXhKOEllYzEyTG9UNXJRTTdBSjh4b3RJL21BK0lDNXg0VmVCV2U0bm1hdzVSSkRwSkFQd0gxQy9RNjFMeGo0ZnBGanNReGdiVUVabk5CQmMyYnlHaThhMzB1dWJMaS95UnZwRkZhaURsMVp6ckZWbXljOHdPWXRhSXVRUGFQNXF2cWkzTUFCR3NYZEozTy84QVpTc1VaTG1pQm1tUjZYRTk3VzlWWDFxdWFBMllMZENUN1FpVDN0OVZ5bjNFVWVhcnhuTWMwZGpGdXpkckJZSHZEczBTYmEreUJlOXJyNitwMW13QUJtSTlEc082aVZPbnh2WTkwc3NrSDFvSEtjcDBoc3k3MTYraXFlSlBPVzNRV0V6Zit5blZuYmUrSk95cmNYVU5vdVpGbGFQWnk2bVZRZkpjY0xydThrQUhsdE8wRzJidXBKcmMyYlVoMGh1MEMzeC9RTE5pK0JWTUk5cktycWJtMU5ITWRvNk9jRUc5anY2ZWlpMW13N1RyTWZ1NFZwS25SVFRabzVNYWFGWXhOOURMYnpNbTk5eksrT3EzZ3VtVE1rWEJBajkraXd1MG13dmJ2Mlh6T0lNV0VpUnVEMjdLRFJ2a3NLRk1PbTJvdkJBdHZiZGVNUlNjM3B2QW1IUk8zZWJlOWVjTmlSY2tBbUl0UHhFS1BqcXBtVFQxSHRITVJQdkc2cXJzeWMrVFgrSjRZdFBtOHBZNXhiWTNsb0JPWVJ2S3ljTW8rWTRDUTJMbDJ1L3cvd0FMWU1Qd00xUUtWVEVVcUxqT1dtOE8xTW1Ia0NHVDFQVlVtRm81QzVqckVHREg2OUZ1MnRwNXVDM21jWDBkMTRFNWphYkJUSXlnQUNPZ0ZsY21vZDF4amdYSEt0RnpjcnVRM2gya0hVOXZjdDh3SGk2ZytBWFE0MmcyU00xOG5KcXZHNVl2ZEQzTDl6Ym1WRjdwMUZWdHhvTVpTQ3M0eGM2TFJNODF3YTdQdkhxTGF0R3BTZDdOUmptSDBjMGo0cmsySHkwNFkxamdHZzZPT1hhNVBVeE56N2wwM0hZdXk0eGhNVk5SK1lrdExxbkxOcmszSUh1K1N4eThucytKNDNJMkx6b2k1dEpEUnpPekhVWmg3NzNYcDJLYTZjem5BUUJrOW9iKzl0L3FxNm5WdEFCMHU0YkhZajlGbFpWTFEwRGN5RDNucXVadWozS0pRcmx6c3h5akxzMTV6RVdtUTZiL0FBWHVwVklkTUgxaUNKL0VKdkh2OVZHYzF0eSs3eWRPcDl5OVBBQm5ZQVJ6RzA2YS91eWxTSzBiajRCOFIxaFhHSGZMcWI5QWYvck56TGVvSi9lczlRQy9Qd2xwYVduS1pCRW5mdDB2dnN1NzhMcUYxR21TY3hMR0VucWNva3J1d1N0VWZQOEFsc01ZeldTUHozK3BLUkVXNTVBUkVRQkVSQUVSRUFYeHdYMWZFQnlEeGZ3WjFDb1FHdXlFa3NjWUlNeE9tNHYwNjdyV3E1djBodGpBa0cxdlQzTHVQSE1FeXN3c3FOQkY0NmlScTA3RmN1NHo0YXFVOHhZUThiV0lNVzExbi9DNDh1SnA4SDB1aThqR1VGSEp3LzVOUmNTQkowY0lOK2xwN0Rzb3ppQWVuZlQ2S2RpcWJtbks5c0hTOXZUOC9ncXVxVHRlNEVBU1NlZ0c2eG85YjFJMWRtTEV1Njk3OWZpdlBDc0w1dFlDd2EyN2lZQW43dnoyN0svNGQ0U3FWSWRWUEwrRUdEYlVUMksyS253aWpUQTVRSWlHaUJwMU9wV2thanl6ejlUbFUvWWlDZUdNcUF0cVZSSWtnbHhHVXhBSU8rdWtyV09KVXFsRWtHSHNuS0tyVHlrZ0FrYTk5RDBYVGVHNGxrdWhyUm1pUmw2U1BkN2w0eDNCbWFoa1NKQWtGcEZ4WW00SzFlMmF0SERnbThNdHR2OEE2Y2tPS0dudGFrYkFGYkg0UzRPSzRkVmNBNFRER3VrNjhwZTdxQjAzVWZ4WjRhRkVDb3lSbkpHWGF3dVlWcjRmeGpNT1drQXdCRnRETVhnYnhKdHVzblVhczlPRG5sVWxGOHBGOGNLR3cyaUd0RENlZUlOaGF3RnREdDBXczRqaXdyNHB6bkZwWlN6RmdEQTF0Uis5UWdlMFFUYVoxVzlHblNxc2MrbUd1YVFRZEM1cDNtM2VJbGNzeCtCZmhLdVNvUmxkTU9pTnh0ZkxzdGNxOXZIUjRzSk5UYW4yZWVLTkRudEozSitrcXR4RlhuZGVOUGZZTExYeE9hc0kwYmIzck1PRythMHVHdVl3ZXpXZ0VMTlJOOE9UYksyZWNPK1FjMXphTjQ2S2JUckhZUmI4bEI0ZlRuVVpTRHFmb3BEbTlmZjZyTm51NFpXaXp3Mk5lMTJacmlMN0U5UDBWblQ4VVZ3UGFCdHUzY0h0R3kxOWp0ZjM4a0k2YS9SUWk4OGVPYTl5VEwzRWVLbnVhUTROdUlrU1BlRnB1RjVIRVhzWXZxUjFWL3dqaHh4RlVVMi8xR1FZRFJFekh3MnVWTjhVY0ZBZDVqYkVDQ05pQllRT3EyVUhLTm5tWmN1SEJsakNLU3ZzcmFHSTAyMENsc1BTOTdqcGNYalZWVERFRTN2NzFJcDFvTXg4NGQvZFlPSjZGMnJSYkI3Wmt5QjFCbjUrcEN5Q29JazZnU1RhNXVCSGJYNEtxcDFMeVJKbnJwZFdGQm9jNTNTQ080RVhNNkhRUUVVQ3N1aXZmaUQ1bWR3T1UreUJFSHNTTkQySzc1NFQ0bWNSaG1WVFNOSUd3YnRBc0MzdDBXbGVBZkFwWTltSnJFZ05KeVUzTmd1dHl1TjdDK2tUSVhUUUYyWVlPUExQbS9JNmlPUjdGOGZQOUgxRVJibmxoRVJBRVJFQVJFUUJFUkFSOFExVStMdzRPb1Y3VWFvR0lwS0dpOFhScU9QNE14MnkxN0Q4TGI5cUZHazBaZzB2YzZBUXh2VzJqcHNKNnJlOFJUV3I0VWpEWTUxWnpnR1BZV3VCc05RWkJpRGY2ckdSNldpOXpsOXBjTDhrdmlQRFhVNllGTnJqQW0wa2krLzE5NjFYRlVhd2R6VTZsNyt3NzlGMHIvV01QSC95TkgvVVBtdmorTzRkb256R1d2cXNaNFl5ZDdqYkZtelIvd0FHelNlQWNGeERpWEZoWXo4VHdSOEdtNStuZGJoaWZMbzB3WHhsWU5TZjNxcVRqWGoyazBSaDI1eWZ2UllmRmFIeHZqOWJFQ0tqK1g4STBsSXVHSlZIazY0YUxOcUpLZVZiVis1RDhZY2ZPSXJTTE1iSWEzMWk1NzJXWEROLzJ3VEdsajBqWVR2K2kxM0VzSklWdGhxeHlnQTNGeFAvQUpLclRxMmQybHlROVNTaDF4WDZJdE9HY1FmUVBtTWRBdnliUE1tN3Yzc3JzMU1OalJscURMVXR5dnVKL2xPdndJV3FoNGdnaSt4NlFMd29WVTZIcWRCNmxUQ2JpYmFyUjRzNnVYRCtHall6NEFwNWlPWm8vRUhaaDh4S25ZUHcwMmt3TXZsRitZZ3VjZDR5clhNRnhtdXdnTXFPSS9DYmowditTbTBPTlY3elZKdVJvSnZiVUMyNjFXU1AwZVMvRjVQOTFSUWVKS0hrNGcySUJhMTBIWWtYQkEwMFVLbGoydk56ZWR4cnRDM0RFOEZGUVMvMmpxZSs2ajAvQlRUSnpYVVBIZkpqSFh1RXF2Z284MzUyV2ZENGR6akRHazllay9RTGErSCtFR2lBYitxMlBBOEZZelFmSkZoTnArWFZlMWNrWHdudzl0R25kbzh3KzArTGtiRHNOTExKeGpodWNHRmNVOExDeXVvU3Qxd3FQRW5rYzV1YjdPYTEvRHh2QWdxSTdndFVXeXlOb3N1b25CQTZoWmFmRFIwVlhCTTZjV3V5WSttY3N3M0I2N2lJcHhmcUJ0djZMZlBDSGhSclNIMTRxVzlod2xvZE92ZmNMWTZQRDJqWlcrRHc4SkhFa3ljM2tjdVNOZEUybm9zaTh0QzlMVTh3SWlJQWlJZ0NJaUFJaUlBaUlnQ3cxYWNyTXZoUUZaWHc4cW94M0RROEZyMmdqdjhBa3RuY3hZS2xGVmFOSVRjWGFPUmNZOEtWS2Nta2M0TzJoQWtkNzZuNExYS3RGN2ZhQkJ0cUNEZUlYYzYrRUIxQ3FzVndkanRRc0pZVStqMjhQbWNrVlUxWng4VTNHdzFFUmJYcWY3S1JoK0ZQZDdRdDZEOUYwcDNBV0RRTDUvcGdHZ1NPSklybjhyUEpIYXVFYUJYNEpONFViRWNOaHBJMUYvZ3VqbkFEb28xWGhJUFpYMm80c2VwbENTa2psTHozOU9rcnkwd1RGNTZSdDNYUWVJZUUyMU5PVTlvdmU4aFY3ZkJEczA1ajhMKzhyTDBtZXpIeXVLUzkzQnFkQ25OdEk3Zk9Wc3ZCT0ZtUThqMHRlK2g3TFllSGVGMnNna1NlcXVhWEQ0MEN2SEhYTE9MVitUOVNPeUhSVVVjSE95bjBjSjJWcFN3ZlpTNmVFV2xIa09SVzBjTXBkUERxd1poRm5aaFZhaW00cm00ZFpXNFpXTGNPc3phS21pTEt4dUdXWmxCVGhTWG9VMG9XUmFkRlM2YlY5REY2QVVrSDFFUkFFUkVBUkVRQkVSQUVSRUFSRVFCRVJBRjhJWDFFQmdmVFdGMUZUVjVMVkZFMlFIWWRZM1lWV1dSZk1pVU54Vi9ZMTRPQ1Z2NWFlV2xDMlUvMlBzdlF3blpXdmxwNVNVTEt6N0t2VGNJcklVMTZEVW9XUTZlRldkdEJaZ0Y5VWtIZ1UxOXlyMGlBK1F2cUlnQ0lpQUlpSUFpSWdDSWlBSWlJQWlJZ0NJaUFJaUlBaUlnQ0lpQUlpSUFpSWdDSWlBSWlJQWlJZ0NJaUFJaUlBaUlnQ0lpQUlpSUFpSWdDSWlBSWlJRC8yUT09XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3B1YmxpYy9pbWFnZXMvZnJ1aXRzL2x5Y2hlZS5qcGVnXG4vLyBtb2R1bGUgaWQgPSAxOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRQUFBUUFCQUFELzJ3Q0VBQWtHQnhNVEVoVVRFeE1WRlJVVkZ4Y1ZGeGNYRlJVWEZ4Y1ZGUmdXRnhVWEZ4Y1lIU2dnR0JvbEhSVVhJVEVoSlNrckxpNHVGeDh6T0RNdE55Z3RMaXNCQ2dvS0RnME9HaEFRR3kwbElCOHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TGYvQUFCRUlBTVlBL2dNQkVRQUNFUUVERVFIL3hBQWJBQUFEQUFNQkFRQUFBQUFBQUFBQUFBQUFBZ01CQkFVR0IvL0VBRDBRQUFJQkFnTUVCZ2tEQWdVRkFBQUFBQUFCQWdNUkJBVWhFakZCVVFZVFlYR0JrU0l5UWxLaHNjSFI4R0p5NFFjakZET1NvdkZUZ3FPeXd2L0VBQm9CQVFBREFRRUJBQUFBQUFBQUFBQUFBQUFCQWdNRkJBYi94QUF1RVFBQ0FnRUVBUVFBQlFRREFRQUFBQUFBQVFJUkF3UVNJVEZCQlJNaVVSUWpNbUZ4RllHUm9iSEI0VFAvMmdBTUF3RUFBaEVERVFBL0FQdUlBQUFBQUFBQUFBQUFBQUFBQUFBTE9hV3JhUzdTRzB1d2xacVZjMHBSOXEvZHIvQjU1YXJGSHliUndUZmcxYW1leDRSYjhVakI2K0hoR2kwa3ZMSVR6OThJTHpiTTM2ajlJdXRJdnNSWjlQM1kvSDdsZjZqTDZSYjhKSDdIam56NHhYbXl5OVEvWXE5Sis1YW5uME9NV3U1cC9ZMWpyNFBzbzlMTHd6Y29abFNsdWtsMzZmTTlFTlJqbDB6R1dHY2UwYmFadVptUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFqaU1UR0N2SjIrYjdrWjVNa1lLNU10R0RrNlJ4Y1huY25wQmJLNTczL0J6TTNxRDZod2V6SHBWM0k1ZFd1NU83YmI3V2MrZWVVbnl6MXh4cGRJaktSazVsNkUyaXU2aWFGbFVNNVpTVkVWVkNudUZ0bzBaRXh5V1E0bUpTTFBLMFJ0TVJxbG9aaUhBMnNMbU00ZXJLM1p3OGoyWXRWT0Q0WmpQREdYYU85Z005akt5bjZMNThIOWpxNE5kR2ZFdUdlTEpwbkhtSjJFejMyZVV5QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFITXpITlZDOFk2eStDKzdQRnFOWkhId3V6MFlzRG55K2p6ZUp4amsyNU8vYWNMTnFuSjIyZEtHSkpVaUZPdGRYTVZOczFjYUNVaU9RTGNxU0xLWEl5bEorQ1VqRGtWM09pYUUyek55b3RRcmx5Rzc2RkdOc2hTWW9WekxLVFJGSm1ZMXVCdmp5ZUdWY1JxZGZ0Tm9aVjBVbEE2MlZaeEtrN1BXSExsMm82bW0xYng4UGxIa3phZFQ1WFo2NmhXak9LbEYzVE8xQ1NrclJ6WlJjWFRLRmlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRGk1MW1tejZFSHJ4ZkxzUnp0WnE5bndqMmVyQmh2NU04M1VtY0hKa2JaMG94RW51MU1aT2x5YUxzV25QZ1JESXVpV2pMa2FicklvUjd5akpHVWkxY0VHR1ZjVVNtVGtZeW9zaEw5cG5USkVjMlV0MldwR0kxRWFZNUo4TWhxaVZSMkpiYTZDU05lbzJVNU5GUlNqaUh1WjdNVTM1TXB4UjNzZ3pqcXBXay9RazllejlSMXRIcWZibFQ2WjROVGczcTEyajNLWjNqbEdRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU5IT01iMVZOdmk5Rjl6emFyTjdVTDhtdUtHK1ZIalpWSExYbWZONUpOdXpxd1NTSk9wNW5rMy81TjFFVnlNM0lza1RwdlVyRHNzellzZXRVWkF5d0MvWVYzQ2pFcEZaTWxFNW1Ub3QwVFVXVlViNUp2d0ZSa1pFd2lNbXJrSksrU2VSSTl4YUhBWVQzRjMwUWlFdUpNWFhLTENPcnhORmtmWTIrRDZIMFJ6RHJhQ1Rlc1BSOFBaKzNnZlRhRE43bUwrRGg2dkZzeWNlVHVIdVBLQUFBQUFBQUFBQUFBQUFBQUFBQUFjdk9la0dHd3JncTlUcTl1K3plTW5mWnRmMVU3ZXN0NVNXU01leXlpMzBjWFBNYkdzNHVEMm9XVGkxdWQ5YnI4NEhJMTJUZktsMGoyNmVHMUhHcVZMZDV4Y2s2Wjc0SW01bm5jL3MxU01iUmxMNkxEVTJYeHVpSkZGSTBqTWlnNnduM0NOb3ZXSXFwcnNuYVluVVhJaWMwRkZpYmZFejNlVVRSaFZDMFpoeEpWSmtTbHpUSlNKWFFqVEo1SDBObFJVaktSUnV1U3lKVG1UQjJUUW15YnhqZlpWczlOMEJyV3JUaHdjTCtNV3Z1enMrbVNxYmoreHp0ZXJpbWU4TzJjc0FBQUFBQUFBQUFBQUFBQUFBQUFBNEhUSG90VHg5TFlrM0NjYnVuTksrekoyM3JpcnBhYWJpazRLUmFNbkU0TlhET2tsVGxhOEVvdTI3UkphZGh3dFJCeGs3T2ppZG81bFdwNlJ4c3IrWjdvTDRtS2t6REl6U0NNeG1Wakw3TE9JVktnbEw2RVkyWVZVcnZaTzBPdUkzTWJSV3lPU2VERUpFb05HV3kzUlZjaEoyTkV0cUkvVXlWU2FJZE1sSm9nNmdVU3dxcUFVRHFGbTdJU0pUckY0OEU3V1JlSzh6Uk5rZTJlbTZCU3ZpZFBkazM4RWRYMHQzbXY5am42OVZqL0FMbjBZK2lPT0FBQUFBQUFBQUFBQUFBQUFBQUFBQUI1L3BSZzlPc1hEU1gwZjA4am42N0ZjZDZQVnBwMDlwNGpFMUxNK1kxSERPeGo1UktWVzU1SHlicU5ES1pXaVRNcGtFaU9lcE5FMENtS0FiWW9HZHNtaUREcUVvaWhaVk5ONVBJb2xPc1dTSjJtdFZxRjRvdFJxckVhbXV3dHRLS3VWMkViU05hcWFSaVNrYTNYYTZHbTNndFI5Si9wcmdHb3pyUGo2QytEbDlEdGVsWWRzWE4rVGcrcFpFNUtDOEh1RHJuTUFBQUFBQUFBQUFBQUFBQUFBMU1WbUVJYU4zZkpHR1RVUWgyeldHR1Uram4xTTk1UTgzL0I1SmVvTHdqZGFSK1dTZlNDWHV4ODJadjFKcndYL0JyN0ZuMGhpMDR6cHV6MGRwSi9CMktQMVdGVk9QQS9CUzdpenhtYzBrMjlpN2p3dXJPM2FjZlBQSGtmNWJPamczUi9VY1NPSnM3TTg3eG51MjN5V2hpRE53SWFMcXNVMmtVSktzcmtxQlpJeDF4T3dVVGVKTGUyVzJqeHI2RlhFcTRpeXJGbEVsUkU2d21oUktjeTZRSVZLcGRSTFVhZFNkalpJc2tJOFVrVzl1eTJ3bEt1NVdTdjRieTZnbzhzbmJYWjBzdnk2YmFjb3RMdDMyN2pDZWJHblRaNThzK1BpZlVjdHorbFRweHB3cFRVWXF5dnNxL042TjczZG5YdytxNFZGUmpGOGZ3Y0hKbzhrcE9VbXVUb1E2UlE0eGt2Si9VOU1mVWNiOE14ZWttYnVIelNsUGROSjhub2VxR3B4VDZaakxET1BhTjAzTXdBQUFBQUFBQUFBQU9MbXVhV3ZDRDdHL292dWMzVjZ2YjhZSHN3YWUvbEk0YzVIR25rczZDaVJjanp1YjdMN1NjcEZIayt5MUVYRFhpeWtuWllqVTM2SGxrOXI0THBXalF4dVd4bnJhejVyUitKcERNMGFSbTRuQ3hXRnFVbmQ2eDk1ZlhrZXVNb3o2N040eVVoWTRyVGVIajVMYlREeFE5c2JSVmlMOFNkZ29TY3lVaVVVcFZueElsRmVDR2pNc1FSc0kyaEt0eENpVHRKT3UyeTIyaWRwR3BVc1hVYkpVVFVxMUhKcEpOdDhGeE40eFNWc3VrbHl6cVpmMGZsTFdvN0wzVnY4V2VYTHJZeDRnWlR6cGNSUFI0TExZVTFhTVV1N2UrOThUbnp5enlQbG5tbE52czZGT2drVEdGZG1MWlM2TlZOSXBRdTJTc3JKY1RLcXMwam5kbFhCRy9oTTJxd1RVWjJUVmxkYlNUNE5MNkhTMDJ2bkR0OEhseTZhTWppWWJJczJ4dFI5ZmpWQ2pHVFRkTjdPMnJYV3pUaGEyLzI1YVc5cEhZZzVaL2tud2VPV3pIeFhKN3JvbmtYK0NvZFFwdXA2YzViVFRYck85clhmejVucHhZOWlxekNjOXpzN0pvVUFBQUFBT2RuT0wySTJYclMwN2x4WjVkVm0yUnBkczN3WTkwanpFNW56dVhKeWRXRVNjbm9lYVRkR2lKc3h2eVdGa1ViWkpOeUs3bWlhSk9US1haYWhXdU5pclZPeWI4RTYxTzYzYitCZTIrVUU2WjViT2NxbEM4NmF1dU1lWGQ5am9ZTXlsOFpucnhaVStKSERXTFBZOFZHKzB0VHFsSlJLdEYxVzBLYlNyUmpyUnRCamFKb2tXVlFLSktEclJ0QVVLTTZzdG1LNzN3UzVzbVVvNDFjaVhKUlZucXNyeW1OSmFheTR5NCtISkhLejZtV1IxNFBKa3lPUjFxZEk4eVZzeGJMV3NiTGdvRXBCeXNKQ05tYlpZUlNFV3lXakVwRnR4V2hGVlpyREt3NEhVeWJNM1Ntbnc0cm1qcjZIVnZGS3ZCNHRSZzNJOTFTcUtTVWx1YXVqNmVNbEpXamtOVTZISklBQUFBQVBKNXppZHFyTGt2UlhoL056aDYzTmNtZFBUUXFLT1hLVnpoNUpibWU2S294S1puUElrcVJaTGtWR2E1TEFQSkFzMFJKTWxFWnh1WXR0bDF3TE1NbENwa3hsUkRST3JUTmlFenkrYTVBNVRUcDJUazdhdFJUYjNhdlJlT2gwZExxRzZnLzdIcFdmYkhud2ErSjZLNDJsNitHcXI5c2R0ZWNMbzZVc0dSZHhLeDF1Q2ZVbC93YzZyQ1VYYVY0dmxKV2ZrekJ4YTdSc3BwOU94NGFtYkc0cWt1TFhtVXNydU5paGdwejlTRTUvdGpLWHlSWlJuTHBNcExOR1BiUnN6eU91dG5icFRncE95YzR1UGZvOVdSbGpQRkhkTlVpc05SQ1RxTHM3Mlg0S05PTmt1L20zMm5IelpuTjJ5c3BObS9CR0hrektvMFZrTXltRS9zZ1ZzcTNSSXJrSEw2SlVTZTBWVmxxSnprV3BoSVM1SkpTblBVOUdHZkpqTldlMTZLWXZhZzRQMmRWM1BmK2RwOWI2ZG0zdzJ2d2NiVncyeXY3TzhkRThnQUFBSlZuYUxmSk4rUldUcE5rcFc2UEJWcHQrSjh0bmJhTzNqU1JyeWxZNU9TVFhCNlVyRlZReFV5KzBlTE5JTkVORkxsbnlWRWJLdVQ2Wk5HVkJieTBZUjdJYlpPWm5Ob3NpTDdETk11SEExajF5eXI3TlRFUTNvbE5wbDBlbjZFNTllMkdxdjBsL2xTZkZMMkgycGJ1enUxK3E5TDEzdUwyNTlybzVIcUdrMi9teDY4bnNLbE5TVm1rMXlhdWpzTkhMVG8xNVpaUWUralNmZlRoOWlOa2ZvdjdrL3QvNUhwNEtuSDFhY0YzUml2a2h0WDBRNVNmYk00ekZScFFsT2J0R0t1L3N1YjRXSXlaSTQ0dVV1a0lRYzVLSzdaODN6REhTeEZWMUphTGRHUHV4NEx2NXZuNEh4T3Uxa3RSa2NuMTRYN0gwZURCSEREYXY3bUlST2UyYUZyRnFLbVNmQUJzUDZZRnVWNkhaS1RLbHFKU1plaXdqWmFnSzJTS0doSW1McGxKSHBPaWxhMVZMbW12ZzM5RDZQMHVmem81V3NqOFQyaDlBY3dBQUFOYk1uL2FxZnRsOGpMTi93RE9YOEY4ZjYwZUdxbnplVkhaZ2FsZVJ4OVIrcmc5V01sRm5uTmk5S1JhUFpSbzJZSTlVVlprMks0bEpRNExKaU5HVFJJbGlsV2l3aVdwRVNSSnNtK1FrU25xdHhleDB6VHFVMm1wUmJVb3ROTmIxSk82YTdtYjRza29TVWw0TE9wS24wZlMraldickUwVk4yVTE2TlJMaE5jdXgzVFhlZmE2VFVMUGlVMS9jK2IxT0I0Y2pqNDhIV1BTZWNBRHduUzdNK3RxOVRIMUtiMS9WVTQrRWQzZmMrVzlaMXUrWHRSNlhmOEFQL2gydEJwOWtmY2ZiNi9nNU1LZGo1OXM5OWxvb21LNTVLdDhESkZrdVJZV0xVaUJKR2JWZGxrVGxJaWkxQ1RaS0pJeWwrZHR6UklrUnorbnhKVWVMQU1oSU16RW55VVozdWpVdjcwTy93Q2gzUFRIK1lqbmF0ZkJudlQ2YzQ0QUFBYStZUnZTbXYweStSbmxWd1pmRzZrandkVm56V1hvN1VEVHFuSXp4cDJlcUJDYjdUQkd5TmlnUW55VmtiU1o2WXZreFpTVmphU1ZGU1VqQ1NwbDBTbWVlU291aWJaVkZqRXJGZ3JKdDh2SXNoWDJTa3l5Wk5HMTBYekwvRDRtTjMvYnEyaExrbmYwSmVEZHU2VE96NlZxdmJ5YlgwenlhN0I3bUsxM0Urbm4xWjg4YzNQOHc2aWhLYTlaK2pEOXozZVdyOER5YTNVckJoYy9QUy9rMzAyTDNjaWo0OG56NmhUNTd6NFNjM0oyejZGL3NYUlZVQnkxV1Y2RzJUUlJvaXhTcjRaSWtqTnV5eUl5angvUElYWERMSms1TXNrV1FqWk5Bazk5K3kzeUwrS0pCQjBWWXlaRkZXZDNvNS9uVS8zSTdmcHkvTmljL1Yvb1o3OCtvT01BQUFDempkTmM5UE1ocTFRVG8rZjR1RFRhNHJUeTBQbWRSRnBuY3hOTkduVlJ6TThiUjZZY0dzMXpQR2VoTXRTZGl2a2lTTHdrWGcrVE5yZ3J0bnAzcGxLRW1ZNUVXaVJrenptaUp5WktSWVd4SUYyU2JJYkVraXlISnA0cUYwYlkzeVdSOVA2TVkvcnNOVG0zZVZ0bVg3bzZOK05yK0o5cnBNM3U0WXlQbWRWaTl2TEtKNXpwcGpOdXZHa25wVFYzKytXdndqYnpad2ZYTTl6V05lUCtUbytuWXRzSE4rZitFY3FLUG5tZThaSUpDeWlOVlhncVBZMlViS2lUTXBwVVdSR1RNRFFsTmxrRVNreXhkRW52N2ZvWDVvQ1NaWkFGTCtPM3UvT0FhK2lHVWlpRnladG5vdWk5TzlhSGUzNVJaM3ZUSTNrUnpkWS9nejNSOUlja0FBQUFBOGQwaHcrelZmS1hwTHgzL0c1eE5kanFmOG5UMHM3aC9CeHRrNUVvSHVUSVZJSFB5eHBtOEpDUVJpelJzcWlwQlJUTmxJcFF6WmR0RUlqTXdmWmRFNU1GMEltVFFZSmdxWWtTZ2pXbkhSbWlaZXowL3dEVHJISlJyMDI5SXRWZkJxMHYvV1BtZlQrajVQeTVKK09Ua2VxWXZsR1M4OEhHNjkxSnlxUGZPVGwzWGVpOE4zZ2ZOYXJLOG1XVTM1WjBJdzl1Q2l2Q0twbmxza3pFc2d5dE5NMnhwMFVkRkc5RGZwRlNFenlUWm9pTW1ab3VTa1hSSkdUMTgrUm9sd1Q1RW1nbVNTUmZ3U3g0ZHZoK2NDSFhnb3pacG90ampabEk5VDBSb1hxT1h1eCtNdjhBaG4wbnBjUGszOUk1T3Nsd2tldU8yYzhBQUFBQTVIU1BDYmRQYVcrSHllODhldHhiNFd2QjZkTmsyenI3UEhWRDU3S2pyUko3SjVKUk5FeFpLeDVad3JrMWk3RmJNR1dGdVNXWmxUQ0lvdzJBSklrc2hTUTJZNDJCQmxvRUVab3VpYklaWGp1cXFWbC8xS0U2YTc1VHByenM1TTYybHkrM2ltLzJvalBpOXlNSDlTdi9BRXpmdzcwUnhaa1NMTmxBUEZGNHBGR2JGTm5yaDBac0tqSzVKVWhFaEpubGJzMVNJU0lSY2xObWlTQ0pQK1MzTExDVGtrdFgyTCtDeWpiNElNV0lEWThTQ3B0WWVKNjhNVERJejNYUmJEYk5MYWUrYnY0TFJmVitKOVY2ZmoyWXIremk2cWR6cjZPeWU0OHdBQUFBQmlTdXJQYzlDSHp3RHcyYzRGMDV1UERldTFQZDlqNTdXWUhDVFIxOVBsM1JzNThXYzJYQjZ4S2g0OHJOSWs1dlF3bzFSQnlKb3VaMmhRb3pjaWlvOENDclliSkpGaHNXTE5NamNTbTlRWFhSQ3ZJdkZFeE9NcFh4TUZ5VW44bDlUMjFXRnM5UFdObnBLVWREbk04YmZJNVFsRHdMUnBNcTBXNnczZVJVVTJzV1V6S1V1Q1VpVXBHVkdsRTVNc2lVU1pZa1J2OEFQenhMVXdZYUZrQ3VKTmdwVGlXZ3JaU1RPbmdNTzV5akJiNU8zM2ZnanA2WEZ2a29yeWVQTFBhbXo2SlNnb3BSVzVKSmR5M0gxc1lwS2w0T0kzYnNja2dBQUFBQUFEUXpmQTliQzN0TFdQMjhUejZqQXNzYThtdUhKc2tlSnIwV205Tng4M214TkhZaE95RXR4enNzZURlSkRaUEtiV0xLSXNzbUlXTEdFUVF5MUdQQUpXNk01U28yWTB6MHh4cEl4Y2pFNG9TVVVpRTJSYlhJeVZVWDVPWmphMWkrT05ub2dyTkxMOEc1U25YNFUzQ24zdXJ0eWZsc1IvMUhRbGpmNFp5L2RGcDVVbXNmM2IveFIzS1QwT1F6Rmpvb3dNQVoyaVc3RkNOaWlSTm9VV29SbGtCU2VBWkJCaElraXdzVFJEWmFsQTlPT1BKakpucnVpV0IzMVd2MHgvOEFwL1R6UG8vVE1GZm1QK3h5dFprdjRvOU1kYzhJQUFBQUFBQUFBQnhNOXlyYjlPQzlMaXVmYXUwOEdyMHFtdDBlejFhZlB0K0xQSjFxVmo1N05pcG5WaE96V2FPZkxIeWJKaXVOakdVV2pSU3NSMDdrV1czQzdCTmsyYkZGRXc3c3ltK0RhZTQ5cjRSZ2E5VFU4azdiTG9uV2pvV2NBbWNUTjZxakJ5ZTZLdWJhZUxsSkw3UFRGMGVteTNKcDBjb2NxaWFxMUp4eEUwOThkcVVZeGoyV3BxT25PNTlKcThHM1JPSy9ZNVMxRy9XSitPa2NxbFYwUGszRitEcE5jbDlvekpIYjBJSVFtMFRSYWpEWW9JVWttd2NRUlpsUkpUSWJCUkhaRFlXSlJBMFltMFlsR3pvWlZnWFZxS0M3MitVZUxPbHBOTzhzMUZIbHo1VkNObjBDalNVWXFNVlpKV1hjZlZSaW9wUlhnNHJiYnRsQ3hBQUFBQUFBQUFBQUFISHpmSlZVdktGbExpdUV2c3p3NnJScklyajJlbkRxSERoOUhrc1RobkZ0Tk5OYjB6NTNOcDNGMDF5ZFNHUk5XaURSNW5DelZTRWNiSG5sajVMN3JGc1pPRFJiY1VwUHNMNDdUNk01RlhNOURsWlFqMXZhWnF5V0pOTzNleFV2OGhORzMwZnlKWW1zcFNTNm1qSlNmNjZrYlNqRHVXa240TGl6dStsNk81ZTQxd3VqemFyVTdJN1YyLzhBUjczTWNLcXRLZE51MjNGeHZ5YldqOER2WnNmdVFsSDdSeXNjM0NTa3ZCOHRoVGFiaTlKUmJpMTJyUm8rSGNKWTVTZytLUG9uSlNTa2g0bzh6TlUrQjdsUVlhQklwSU1vQmpSQkRNeEpYSlZtWWxvcXlHd2lqYU1hS05temhzTzV5VVlxOG51WDV3UFZod3VjbEdLNVpqT2FpcmZSN3ZLTXRqUmhaYXllc3BjMzlrZlZhYlRSd1FwZCtUalpzcnlTdG0rZWt5QUFBQUFBQUFBQUFBQUFBTlhHNENGVldrdGVEVzlHT1hCRElxa1hoa2xCMmp6T1k1RlVockZiYTdOL2lqajZuMCtVZVk4bnZ4YXFMNGZCeEtsUGdjcWVMd3oyUm41SVU4T2s3cHk3cjZHVHhHbnVjVWJkT0plR0xneWNpZUlsWk43cmFsbGhiSzdqNVBtZlNyRXpyVDZ1YWhHTGR0bUtsZFhhdTdyWG40SFp4YURCR0NjbGJabThzM0tsMGZTZjZjUXI0K2p0MUZhTVpPTXBwYjByWHN0MjFyNEdYOU8zNWFqK243LzZSWEpuOXVQUFo5Vnd1SGpUaW9RVm94MFMvTjc0M081Q0VZUlVZOUk1Y3BPVHRsUzVCNWJwVmtUbSt1cEs4dmJpdDhrdDBsMnBjT0srUEY5VDlQOEFjL05oMzVYL0FHZS9TYWxSK0V1dkI1WncwUG5KNGFWblZqTVZJeTJsOXhseEd3bmNJb01oeEc1REtGZ29NT1JsTVVpdGpLSmFNU0d4WnlTTm93NEsyYm1YWU9kWjJoRy9idVM3VytCN05QcHBaWFVFWTVjc2NhK1I3Yko4cWpRanptL1dsOUZ5UjlKcGRKSEJIanZ5emtac3p5dm5vNko2ekVBQUFBQUFCZHRjMTVnQnRybXZNQVlBQUFBQUFBQUFOVEc1YlNxcTA0SjM0NnAvNmxxWnp3d24rcEY0NUpRL1N6alZ1aDFIMkoxSWY5MjE4enpTME9OOUc2MWsxMmE4K2hyZW5YLytOMzgxTkdYOU9oOWwvd0FZL29qRG9CVDNUeEZkMzNxTTloZlZyek5vYUxIRXpscXBTOEhHNlNmMG5vVHAzd2oyS3NVOUp1NnE4YlNsdlR2N1d1OHRMVDhmRmxzZXFhZnlSdmYwbHkzRzRhaldvNG1sMVZKVFVxS2xLRG5lVit0dnNOclp1b3Rkc3BjTEd1S0xTcGxOUk9NNVdqM3BxZWNBQUFPRm0vUjZOUnVWTnFFbnZYc3k3K1Q3VG02cjA2T1htUERQWGgxVW9jUGxIbHNabHM2YnRPTFhKNzArNW80V1hSVHhQNUk2V1BQR2ZUSk9KazhiUmRTc1ZSZklxc2YyaWJCMDBWZU5FN2ljMlJzSlRGanRTYVVWZDhscTMzSkdrTUxrNlNJbEpKV3p2WlgwVm5ON1ZiMFY3dnRQNlJPdnAvVEpQbkp3djkvK0hoeTYxTGlCNi9DNGFGT0tqQ0tqRmNGK2FzN2VQSEhISGJGVWpteWs1TzJXTGxRQUFBQUFBQUE0RVpxeTAzTy9EbitJQXp0cDI5R3p1bmNBN3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQXM0cDZOWFhKa05KOE1IUHhHUjBKK3haL3BiWHczZkE4MDlIaG4ydjhjRzBkUmtqNU5PZlJlbnduUC9hL29lZCttNDM1WnF0WlA2UmhkRjZmdnovMi9ZaitsNHZ0L3dDaWZ4ay9wR3hTNk9ZZGI0dVg3cFA1S3lOWStuNEkrTE0zcXNyOG5SdytGaERTRUl4N2tsOGoxd3h4aCtsVVl5bktYYkxGeW9BQUFBQUFBQUFBQUgvLzJRPT1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcHVibGljL2ltYWdlcy9mcnVpdHMvbWFuZ28uanBlZ1xuLy8gbW9kdWxlIGlkID0gMTk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUFBQVFBQkFBRC8yd0NFQUFrR0J4SVNFaFVTRWhNVkZoVVhHQmdYRlJnWUZ4VVhHQllYRlJVWUdCY2FGaG9ZSFNnZ0dCc2xHeGNYSVRFaEpTa3JMaTR1Rng4ek9ETXNOeWd0TGlzQkNnb0tEZzBPR3hBUUd5MG1JQ1l2TFMwMU1pMHRMUzB0TFMwdkxTMHRMUzAxTFMwdExTMHRMUzh0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExmL0FBQkVJQU1JQkF3TUJFUUFDRVFFREVRSC94QUFiQUFBQkJRRUJBQUFBQUFBQUFBQUFBQUFBQVFJREJBVUdCLy9FQUR3UUFBRURBZ01GQlFZRkF3UURBUUFBQUFFQUFoRURJUVF4UVFVU1VXRnhCb0dSb2ZBVElqS3h3ZEZDVW1MaDhRY2pjaFFWZ3FJemtySVcvOFFBR2dFQkFBTUJBUUVBQUFBQUFBQUFBQUFBQUFFREJBSUZCdi9FQURJUkFBSUNBUVFBQXdZRkJBTUJBQUFBQUFBQkFnTVJCQkloTVJOQlVRVWlNbUZ4Z1pHaHNkSHdGQ1BCNFROQzhXTC8yZ0FNQXdFQUFoRURFUUEvQVBjVUFJQVFDSUFRQ0tRQ0FFQUlBUUFnQkFDQWpmaUdBd1hOQjRFZ0ZjYjQ5WkJJdWdDa0NJQVFBZ0JBQ0FSQUNBRUFJQVFBZ0JBQ0FFQXFBYzBxQUtnQkFDQUVBaUFFQUlBUUFnRVFBcEFJQVFIbWZiM3RaV0ZWK0dvdUxHMDREeUxPY1MwSDR2d2dUR2k4alYzMk9UaEhoSXkzWFk0UndMcXN6dmVlYTg3WVovR05MWmZhUEU0WS93Qm1zNE5INEhlOHcvOEFFNWQwRlhWM1RyK0ZsMGJYNUhmYkEvcVJScUVNeExmWXYvT0wweWVlck8rUnpYcFU2NVM0bngraGZHMVBzN2hqd1FDQ0NEY0VYQkIxQlc5TlBvdEZVZ0VBSUFRQWdFUUFnQkFDQUVBSUFRQWdCQU9hb0E1QUNBRUFJQkVBSUFRQWdCQUlnQlNBUUFnUEdQNmk0WGN4MVdjcWdhOGQ3UTArYlN2RzFDY2JYOCtUek5Vc1RPVkR5TFpqZ2ZYeVdlU1JtalBIREZlNk9YSS9kY2JHWHBvaXFIaWlSWmszZXkzYkN2Z1hBRCs1Um4zcVpPWE5oL0NmSSthMDBYeXJmSFJaQzF4UFpkZzdjb1l5bjdTZytSazVwczVoNE9HbnlPaTlldTJNMWxHdU1sSlpScEt3NkJBQ0FFQWlBRUFJQVFBZ0JBQ0FFQUlCelVBNVFBUUFnQkFJZ0JBQ0FFQUlCRUFLUUNBRUJ5ZjlRT3paeFZJVktZbXJTbUIrZG1yZXVvNytLeWFxbmV0eTdSUmZWdldWMmVSbjRqSSs0aGVYR0tUeWVidHcrU25qVzYraXJGeWN0RkgyamhiUThWRzFNNmpKb2V5cUR5K1M1Y2NGaWtqUTJSdEt0aGFvclVIbHJ1VjJ1SDVYRDhRNUpHeHdlVVd3azQ4bnVQWkx0TlN4MUxlYjd0UnNlMHA2dEoxSEZwMEs5YWk5V0w1bTZNbEpHNnRCMENBRUFJQkVBSUFRQWdCQUNBRUFJQnpVQTVRQVFBZ0JBSWdCQUNBRUJEaU1VMW1adncxWEU3SXc3TzRWeWwwVW43VE9qZkc1OEZuZXA5RVhyVHJ6WkIvdUR5WUpnNTVDNCthci9xWk40YndXZUJIR2NBN2FCSDRqeHlzZkt5bDZqYjVrZUFuNUV6Tm91Z0VnRUVTT25kcXJGZThaT0hSSE9FeTFReHpIV21EelYwTG95S3BVeWp5YzMydjdHTXhVMWFPNnl2bWJlN1UvenRZL3E4WjBwdTB5bnpIc3lXVktmMVBJdHQ3T3JVSEZsYW02bVovRURCL3hkazdxQ3Njb3RjTXhUcmFmSmttbWVvSGhtdUN2WXdaVEI0ZUlVUEpIaHN0MDZUaEFBTW5RRFBoSEZWTlpPbHZSM2ZZanN4ajZkVnVKWXdVZ0FiVkNXKzBhYzJsb0JJQnRjZ2FIUmFLS0wwOTBlUHFiYVlQT1h3ZWhVdHVRUzJyU2N4emZpM0hNcXRFWi9DZDREcTBMWTlXbzVVbDE2Yy83L0kxWU5MQzRsbFJvZXh3YzA1RUxUWFpHeUtsRjhFRXE3QUlBUUNJQVFBZ0JBQ0FFQUlCelZBSElBUUFnQkFJZ0JBQ0F5OGR0U1BkWm54K2dXSy9WcUwyeE5kV216ekl6SHRMd1RKQk43M1BydldLU2RrWHpnMXBxTDZNMFlwdzNnWUowM2dQSmVmNDFzZHk3K3BxOEdMdzErUldvNHB3M2lEQk9vbXdrekUzc3N2ajI0ZTNndmxWRjR5V3Rtdk1tcVd1YzZQZDR4eFBCYmRMTnJOa2xsbWUrS3hzVHdpMmNUYVhWTjJMeHZCeEpPaGpJY2d0UGpwcm1XUHVua284UEQ0V2ZzWnUzZTBGSEROSHRIRGV2N3JmamRJekFCdGZVa2E1cXlVODR3WjdMNFZaM2RuSTR2K3BtTUkzYU81U0doajJqaDN1RWVTdFdvc1N4azhtM1VxVHlsZzVYYWUzY1pYbjJ1SXF2QnpidnVEZi9BRkVEeVhMbTM4VEtmRnoyWXI2SmNiejNrbFR1d2N1U0gwY01POVJLWnk1STE5bjF6VGNITWNXT0Z4dWtnZzlRcXR6VE9ON1Q0UFN1eW45UmZlYlN4VWtHd3FSZHAvV0I4UTVpL1hUYlRxOHZiSTFWM1orSTduRlk3Q09HODk5RndOcjdyNTFpTCtDMHpsVi8yd2FVL1F3YTFQRHRPOWcvYjBYbldqVGNhYmlQelUzRGRkM1FlYXhUc3FoelZuUHlYSDdIYXBrK2VpblI3V1k5ZzNzUmhQY2JPKzVrUVJ4aVpaMzJYTDF0eVNsdDQ4enBVeTh6ZDJWMnFvWWhvZFRKbVkzWEJ6VFBBV3YzTFd0Ylc4ZXJFS1hKWlJvamFUUmQ0TFJ4T1hpdTNxWUpabHdkZUJKL0R5V0tHS1kvNFhBcXlGc0ovQ3l1VmNvOW9sVmh3Q0FFQUlBUUFnSE5RRGxBQkFDQUVBaUFFQnoyMjlyZmdaMzgrL2d2SDErdVVQY2gyZWxwZExuMzVHUFJ4Qk9kKzhlWTFYazFYeWw4L3ViNVZva3FFNkFqbVpBOHN2Tlh6bEpkTDduRVV2TW8xSGk3bnVKQXZOd0IxSkU2Y2xsVGNubVR6K2haT1VvUi90cjl5dFcycTl3YWY5TXhqR3pMaTVyM1ZTUkRXc0EwSmd5U3RzN0tOcWlseWVYVmJjNTRXVFJvMGFnWUE5eDM0dnV0Rzd2UmVGdzZtbHkyZWx2aTN3Y3AybHgvc0J1TWR2VlhDZENHZzZubndIbzVLdEpGeTNQb3AxM3RId283SWZGK2h4YnlTNDd4Tytia2tra3l2VFhYSFI4eE9UYnl5R3F3ajkxYWtWRWJYY1ZMV1JnZTBBbUQzRkZIa1lHR25jeGx4NExwcFpKd0t3ampQVDc1ZWE1Y0dOak9wN0piRXFZbDAweHUwMi9GVU40NU5uNGp5QVVRZzI4STAwNmZkeWVqNFBEME1QdXdSdkRXUGVNelltWlZrcDF3YWNuMGV4VnAzakVVUHh1SUw0M1pBZ2tsdXZIbDR5cWI1K0pqYnd1ZXY1ZzAxVnFIeEZIRkYzczNVM0IwUGFSdmdHd00ySXlKV0syZGtWdHc4ZlE2bFVyTTdXaWwyY3c3cURSUjNudDk2WjNXZ2tPRUdEY2dTQmUvUlRWT2U1YnNyUDhBUHNjVjZkd2kzdzhHNVhGS2tjekl1WGJybjIveWNZOEZybXFxWHhuNXZEZkgxWWh2cy9pUkV6YUxIa3c0emR6WEFGc1JIcml1STZ1dXpLaTNudlBSM0xUemd1Vi9rMGRtOW9SWVZUYkxmL1YrcUxSejhscDAvdFNMNHNmeXo4ek5mb1d1WWZoOGpvR2tFU0RJT1JYcnBwcktQTmF3S3BBaUFWQUlnSE5VQWNnQkFDQUVBaUF5OXZZNzJiTjBIM25lUTEreXhhN1VLcUh6WnIwbFBpU3kra2NiVWVUSkZ3Ty92ODE4aGJPVTIydWNIdlJpbHdQb3U2ZDl1aTZxbGhPU3g5em1hTGZ0TFI3cnB5a1pkSlc1V1pqaE5NbzI4NTZFZFhJRWU2U2VNUlBJWndMcVhkSmU3eGwrdjdFS0dYbm5BMXRKamFjRnN1ekVaYngxQUhYa2pqQ0VNTlpsNi9Namx6eXVFVjhkdE45R2srbzUxbU5uU0hSa09CazJTdWQzVzdraS93QU91RG5nOG94V0xxVktqbnZ1NTVra2M5QndBNGNsNkNobFlSOHRaT1U1TnNrTU9iT3V1Wnk1cTZGYWlqanRGZXJmaDlaN3BoVGhlUkNpeUFzQjRueXk4Vk8xczYyZ1huU0IzY3AxVWJTY0lqclAxdWM0bThlS2w0UkowM1puc282cVcxTVNkeW5GbXpEM2djYlMxdlArVm5sYW04Sm5vNmZRVG10MGx3ZHgvdWpXdGJSb05hQXlCWXhBeWdib3ZlL2Rya3M5dXJVRmhkL3owUGNxMGFYMERCa2pRdUZpWk02ODFncXNsdTZ6NTkvdWFiRXNjY0Y5MklJRzc4TVhFT3owR1FpSjRyYkt5U1dPdlRuL0FGMTlUS3EwM252N0NmNjBqOHJpTW9qZE1Hd0dydUppRkg5UktQSERmNWY3K1k4RlBubGZyL29pcmJScUEzSm5PTjFyZ2ZxcXBhcTFTNWY1Sm83anA0WTQvWERKSytNSUVFNTJJWUdpRzZEUE04THdyTE5RMUgzbm5Qb2wxK0p6Q3BOOEw4Y21aV3haUHd1TFFCQUFBRnN6TzdBSzgrelVPWFRhWFdQL0FBMndweDJza1Rhd0FnSHl2NHFyS1VjSi9sL2s2Y012TFJ2OW5OdkNtZlp2Sjlua0Nmd25qMCtTOVQyZDdSOEtYaHorSHkrWCtqemRkb1hOYjQvRitwMnErcFBCQkFDQUVBNEJRQlVBSUFRQWdFUUhCOW9NZnYxREJ0a081ZkkrMWRUdnN3dWo2UFJVYklMSmxVVEJ6MUE4VjVrT0huSnRrc2xtaStRUWRTT1VUcXJLMzdyakx6WlROWWVVV0dUcEVUSGdMUkMxMXhmbDEwVlBIbU5yQzBtQ1dpMTRFOXk3c2hsWjd3SXZEd3ZNYmlLc3R1SnNMOERPUjV3dUxKS1VPVi9ybm82aEhFdURMMjFoeFVvdW96ZXhCSk9iYmdHTkZGVjZwbGgrUlhxOU05UlUwdXpoNitDZlRNUGFXbnhCNkhWZTNWYkNheWo1SzJxVlV0czFobFNvQyt3NDhiNTNWam1sd1Zwam1ZY3c0QVpmT0k5ZFYzdTRKeXlGbEVnbnBIeVhPNXBCSWx3MnlLdFFpR3hPcnJDL21lNVVUMUVJdmxtM1Q2Qys3bU1lRHJ0azluYU5BaHpvcXVCczZDV3RpRExXbjVtL1JlZlpxM0tXRjhPVDJ0TDdNald0MCtaZmthdVB4cjM3elBlYmU4ZTZlWUpKSzVzMUVrbW53ZWxDaVBERW8wZDBDd3k1YTlGaG0zM0l0eXVrV21NdGZqbHdWdGRheGwrcFc1Y2ozMUNCR1U1Q1hSUE9EZFh5YlVmOEhLaW15QTFKa3phSVBMa09HU3pPV2N2eS9uSHlMTnVQNS9Na0RxMFdCNjUzNmc4bFM1WVdGLzZXS3ZQTEdPckU1eDNBRDVJNU45blNyUzZHNzNNcmxkSFcwVTVaTHJEU3pnQTExL05RMTVrTkhiOWp0cmUwYWFMajd6QkxlYmYydDNFTDZiMlJySFpId3BkcjlQOEFSODc3VDB2aHkzeDZmNm5TTDJUeXdRQWdIcUFDQUVBSUFRRmJhRDRwdlA2VDUyVmRyeEJzc3FXWnBmTTgyeFQ1SytEdWJjMno2eXRZUXplblBNcVBpN0p3VEIydGpsTSt1WG1yZm54NUZlUEltRlFOeXZrVzZ5Um9GcWpOUXpoZlFyY2Nsclp1QnFWTHRCYkJpZEQxdmFQcXV0TkNkcjl4ZnNWWDN3cjRieWErRjdPdEVsNWttNWpqOVY2RmZzMlQ1c2Y0R0d6WHQ4UlJkcDdKb3R6YU8rRmZEMmJURmU4VVMxTmt2TVpqdGowS3JTMXpHa0gxM0ZXLzBsYWVZY2ZRcmxQZXNUNVJ6bFRzRlFrN2hjM3ZKaGNPbXoxS3Y2ZW41bWZpK3dtNER1TzN0YnpCOE1sbXRlb2crTVA3RjlPbTByK1BQNHI5am1hK0RORjI2NWdhNGVwQldLZDlrdUd6NlBTYURSeFc2RWMvWGttd1RaZFBENTZMTFk4STMyY0xDTklPdEFrOHVxcVQ4a1ptdlVjeW1CZnlVUEdlU0czMFdHTkdjR0orMmYyVnNhMCtjRlRiOVN3V20vRFVUM1Q1TFlvdm5qZ3I0KzVCVXFDWmdqT2VWb0JIS1ZWS1NiejEzL0VXS0x3VTV2NjRYV1BISmZqZ1k1eWp6T2tnYktKTmpna3BOa2RTQm5DdXJobjlEbVR3UEFFQW1OVFkzUEQrVlp0V012OEFVNWJlY0lTcTJKNWNjL0VXWE00SlpKaXlUWitNTkNxeW9Qd21TQnEwMmNQQlRSWTZMbE5lWDZlWlZxYVZkVTRmeko2cXg0Y0FRWkJBSVBFSEpmYXBwcktQajJtbmhpcVNBUUQxQUJBQ0FFQUlDanRuL3dBTCtuMVZPby80Mlg2Yi9sUjV4aUczWHdsaWFrejZxRDRHTmNNaW9UWG1kTlB5TGVEd3pxaDNXZ09Bek1ITDBBcjRRbE9XMlBQN0dleXlNRmw4SFU3UDJFeG9CZUpQMlh0YWIyYmxadFBJdTFrcFBFZWkxak5wMDZNZ0NYY0JrRHBLMGFqWFU2Vllpc3YwUlRYcDUyOHQ4R1pVMjFVZllXUEw2ZDByekg3VnVzOTFMSDBOYTBrSThsQ3M5MTk0dU0zenZGajBXZTF5eTk3YisvOEFFYUl4V09FaUdqaW5zRWh4QStwK2FwcDFOc1BoYlMvYzZuVkNYYTVMZUcyeTlwaHgzZ2RNaXR0UHRLMkx4TGxGTTlMQnJLNE56WitQWlZCaXhHWWtMMnRMcUs3MXgyWUxxcFZ2a3E3YTJMVHJOSUlGN25qT2hIQlo5Vm9vdDdvOE11MDJyblUrRGdLbUJOQnhZN2pJUEVhU3ZCdCtMaytsaGFyWXFTSE5OK2lxZkRJZlJaWVpqdjZnYys1ZHh3K1AvU3A1UlBTa0Fua0o4NUk1NWVhMVY1aW15dVdHOERudjNiNm0wYUhvclpTMkxQbS96T1VzOEZLdFVuTFdKNVd5SGZLeVdTM2RmTC93MHhqZ2hMbzgxVjBkNEd6WkYwZFlGWUo2bkx4L2xkUmpsNEliTE9IR2ttTTlMd2ZrdE5NY3Zibmp2NmxVL1Vud3d2WnM1eVQxTVdWOVNTZkNLNTU4MkZSa0NRQ005TTQ1YWRWTW9ZV1VzQlBMNUtWUVI2K25WWWJGZ3VYSjZGMk54Vy9oV2dtU3dsaDdydC82a2VDK245bDI3OU92bHgvUHNmTGUwYTltb2Z6NS9uM054ZWlZUVFEMUFCQUNBRUFJQ3B0TmswbmpsOHJxdTFaZzBXMHZGaVo1M2pHM1BEVDE2elh4MnBoaVQ5R2ZVMVBnWForQWRXZHVpM1AxeVZGVkx0a29SN0l2dlZVY3M3WEI0V25oMlRZUm1lZkpmU2FlaXZTMXVUKzU0RnRzNzVtVGk5dE9lU0d5d1dnaTVqV2YyWG0zZTFKVzVqREsvbm1hNGFOUTVseVVxeExqdkM4bWJaQTkvSlliTjA3TjhmTi9tYVlZVWRySXZaUjFPY2FUbGRjVHIyOGVmNmZjNlVoYXhKQWpMNWpJZkpUWk9VbHgxK29pa2lvNXZsNmxaOFBvc3loSHN2ejE3MVk0K1htRXdZZDI0TmgzU2VLNnJ6RGxQb2lXSmRuVGJCMmlhamQxeGtqWGorNitnOW5hdDNRY1o5cjh6eTlWU29Tekhvb2RxdG03N2Q5c1NQWGZLeCswZE8wOTZOZnM3VWJaYlgwY1V5cDRyeTl1VDMzRW5wMVBYUFJTVnlpWEE0V040a3ora25TRnBUWERYV2Z3S01Qb1RFVkRBQTBtOHllbkRJcnF5VHdrSVJXY2xWN3hQUTZaUUZtbGhTTGtuZ2pMaks1OHp0ZENkVXh6eVQ5QjFMTURXZm91NEo1UnpMb3NOaTlwQmtOOFpBNUxURkpQUGsraXQvbVdONGlSWTV4M0M0SzBMTVhncWFUTERnZU9uZGZSWE5QQlh3VWNTMkJQTXg0MytuaXNGMGVNbDhHZEgvVDZ0NzFabkpydThFZ256QzlMMkxMbWNmb3p4L2JNUGhsOVVkb3ZmUERCQVBDZ0NvQVFBZ0JBTmUyUVJ4RWVLTWxQRHljTFh3SmMvZEU1d3ZtOVZWNzJGMjNnK2loY293M002TENZWm1IcHp3RWt4Yzh1cTJVYWVHa3EzUHZ6UExzc25mUEJnWTNIdnFPM3BjT0RSSXorYThYVTZ1ZHNsTlpYeTZQUXFvakJZQU16QXlJMDRjMVZHRzNNWTlNbk9VbS9JaWREQkhIVGhBSDFud1ZjMUdwYmZVN1dadkpJM08zbnc5ZkphSTR6eC9FY2VYSkZpY2h1NkMrbDgvc3Fic05KUTh1LzFPNGQ4bFdUbVBQV01sUXMvRWkxNDZJM2RaNHFWRnZrUGdHdHNiU2N6d2kyV3ZLeTdoSEt4MnlHeVhBNGh3cU5nejd3SkF5QXl5eXlLdHF0bEcyT0g1L1lyc2duQjVPdHhMTittUU5SWmZSYW10MjFTU1BLcmxzbW1lV2JZSHNxcEdoSmpxQ3ZucTQ1amowNFByS1o3b0ppVWF5NWF3V3RKbCtsaUo0NVJZL09WMHBtZVZlQkt6eWVFM3ZrTC9NcUp5YjdKaWtRay90bFpWczdHdWQvUE5TU2tKS0VrbEtEbnh5NWRWM0RHZVRtUlB2ZTdCbjlKalEvV3l1eXRtSDlpdkhQQk9hM0IwekdlWEIxenJ5Vi9pZWFmODh6amI2b2Z2Zzh1QXVaSjFQZ3V0eVp4Z2hxTzZXOHBWRmo0TzBqYzdDSCsrN25USS83Tit5MmV4ditXWDBQTTlyciswdnFkMnZwRDU0RUE4S0FLZ0JBQ0FFQWlBeXNQUWFYdXFEVW1PZkh6dXZOaEdObHJzWDBOY3B2WW9NenR2NGdQRzR4MTJuM3VIVHF2UDhBYWx5c2hzcmx6RjhtclJ3MlBkSmRtVmh3QUJPWk1nNkNPSE5lWnA1UTJwUzdieitCdHNiYjRMVzZDWTVUMG5Ub3RlMkxudCtXZm9VOHBaSU1TQVJZWjh1NVp0UWxLT0V1eXl2aGlNYnFSZVk2MlhNSXBQTFhQWDVCdnlSSGpYekF0bWN2RDZMblVTVThMNW5WYXh5VTNBYXlxWTE1K0xvc3o2QlNZVFB5MTdsZFhYbktJbEpJakRZemRmbG9PcHRLNFN3K0h6L1BNblB5R2I4U0FaSEVUOHptZkpjdHVLYVQrNU9NOW5XYkRxbDFGczhDUEJmUWFHeHoweXo5UHdQTDFFRkcxbm52YmRvQmM3OHJnZTRtRjVGSE4wb3J6eWU5cG4vYVJoWVBFcXl5QnNqSTFxRlcyaXl0WUpheVRCL1Zjbk9CSVVFalNwUklBcG5CQTVvZy93QXJwUERJZkpJSHdJQk1BMjhmM3pWaWxoWTVPZHBLMnNNeDd0NzJzZjNDdDhWZHJnNTJlcElLeE5wQTFKNGRGUGl0OFpPZGlYSkZucHlXZVhQa2Q5SFc5aDhORDN2djhNWDVuaDNGZTU3SnF4bVI0WHRhemhST3dYdUhoZ2dITlVBY2dCQUNBRUJXeHRUZFk0OG9IZmI2cWpVMmVIVTVIZGNkMGtpblhxZXpva2pRVzZteXhUbXFkTnVqNkdpTWQ5bUdjeUFTREJzVGZpNG5PRjg3dGxLTHcrRy94OVQxdUYyTFR0SnlFOTFvaUJ4dDVwV2tzdkdGbjl2SWgrbm1XRFZ0QXRKdEp1UjFHUzF1Y2xIYkhqbmpuc3F3czVZMm9TWFRuNGVGbFRiS1RubGY0T280U0o4RGhUVWM5ejJrTjAwdU1vODFmbzlNOVJaT2RzY1JLN3JWQ0tVWHlQeCtEWnV6ZjNSY3pFRHZ0TXJmZnBLdG1WNWZ6OFNtcTZXN0RNVmxOcmhPOE9NUzBMekZRcHJMZjZHMXphNFNHRUdkMFdCakxYdm41TGh3dzl2WDBPczhaSTY5TnJiYnJwemtrUVBGdCtpcnRoWFdzWWVmNThqcU1wUzV5TWJjR1JhTy9MT0IvQ3BXV25MSEIxMCt6cDlpMHkyZ09oSW5xWVh1YUdManBGbnZsbm02aHAzSENkclR2TnJmNHU3eUFUSzhlaC8zMC9tZTdRc1ZIRTRDc3ZUdGlXUWtibUZyTEJPSm9UTHpIcWhva2tEbEJBaFVFaHZLY0FSMVFJb2tBTVFPUFdWMnM5a1lKS1ltNG1PSUV3VXdISkxobDRiT3JidSthWkRlSkVkSUJ2NUt5ZGRrSTdwUndqUC9BRk5UbHRVc3Nqb3RraFJDT1pJdG04STcvc25RM2FKY2Z4SHlBWDFHZ2h0cXo2bnkzdEtlNjNIb2JhM0huZ2dGYW9BOUFDQUVBSUNsdEcrNFAxanZnRXJIclZsUlh6UmRUMjM4aXR0ZGswbkFFRExQcXMrdmhuVHRKNEx0TzhXSm5OaDlnUVFOMzEzcjV5TjBXbEtQL1U5UnJscHJzZFRveU40MkpPc1NSeTRLMnVxTW8rSkxodjFPWlNhZUJ3ZXlZKzVQY3JQRnAzWVpHSll5RDdhQVI0anBxdVpmVDkvM0NOakN3V04zVHBlWkhXeDVyM3RNbEtxTGl6QmJsVGVVWisyY1cwRDJVYjBpWm53S3AxbDBJeDhQc3QwOWJiM21MQWlHdU56QUI0cnlKTmJmY2YyTnl6bmxFYmk1dnhDL01DM2xJOGxubGJPTDk1Yy9NN1NUNll5cHU3dW04VHBiditYbXVaN2R2LzB6cFp6OGdaUWNDMkhCeE9ROTYwOVFFZFVrNCs5bHZyc2JrMCtNSFhZcDI1U01UbEdsdWE5N1dTOExUKzc5RHlxbHZzUE45dlZacDFqK2gvOEE4bGVCcFZtMlAxUG84YmEvc2NEZzNRdmRzV1RQQjROakRWMWpuQTFSa2FkQ3ZLeXlnV0tST0tpcjJuV1NTa0hPTzYwT2NlRFFTZkFLWTF1VHdrY3lzakZaYndYYVd4Y1M0N3ZzaTJEZmU5MENiNjU5eXRlbm1uaHJCUTlaVGpLZVRWdzNaV0wxYWg2TmdlWit5dGpRbDhSa25yMi9nUlovMmlnd2YrSUU4VExpb2JyUzVSd3I3Rzg3aWRoQWFQZElpMEcxcCszQlRHY1ZEaGZpY1BPYzVObkZDYVhIM1Y2T3RqdTArZmtZYVhpMzduSTRHZ1MvZEF2TURxVEFYbmFTRG0wZTVkYWxETFBTOEpRRk5qV0RRZWV2bXZxNFIyeFNQa3JKNzVPVEpWMGNBZ0JBUFVBVkFDQUVCUng1dlQveStoV0xWdkRoOWY4QURMcWYrMzBLWGFDZlltT0krYXhlMWszcG5qMVg2bW5SNDhWSFBOYkFnZ3dlVjVpeFhoUmlsREQ2L005SnZuZ0tqcGlHbUJPcGkrZHl1SnozNFVZdmdsTEhiSmFUSUY0NHdQcXRWRktoSE1zWjc0T0pQSkhYcWczQWlPSHlDcXV0Mzh4WFIxQ0dPeW43ZHdCOTRnWmVKRnZKVFJmTkxzNm5YRitRZzNuT0x2M2pLUkdZQ3ZzbEtmdm5HRkhnbXBBQTZHMHpBSmprY3greW12Q2w1ZlVoOG9qTkl2SnZNaTJYUzVJazZMTzZwV044NTRPMDFFcVZtZ09hUm5hZElJSG1zODJsSk5mSXRpMjF5YW13ZG55LzJqaklIdzlkZkM2OVRRYVhkUHhaUEtYUmsxVitJN1VUZHFjWUEwTUI0emRWKzFMdDBsWEh5TFBaOU9YdVo1NTJqeEVVWGppSThiS2pSUXphajFMM2lET2YyZDJleHRUNE1OVTZ1YnVEeGZDOWlUajZtQld4WG1kWmdQNmU0a3RtcFZwMDNmbGd1OFRiNnFweHowaVA2eUs4am9NSjJKb05qZXFWWEhXSE5BUC9BRm56VktpbStUaVdzbjVHbmdkaFlTbStQWmI1NHZKY0IzSDNmSlcwZUY0bXh4ei9BRDhDbTIrNlVNN3Z3TnFneW5Ua01ZeGdqZU82QTJiNW1GNlVWR0Q2d3V6Rkp5bjIyeWhWeEV1TjU0Y0NQdXZFdnRjcnBKYytubzBiWVFTaWlPcFVPZ1BWVnR5ZlVUcEpMekdQZzNKeTQySGYvSzcyUW43MHZJbkw2UkZXbk9MZDBUeWpMdlZzb1BHZkltTDhqUndaL3NqT3dPZkpiSXZHbCt4a2t2N3dkbGRtWE5aM0U3bzU4Zm9yZlpkR0sxTmsrME5SbisydnVkT3ZXUEtCQUNBRUE5UUJVQUlBUUZMYVE5MEhnNEg2ZlZaTmFuNGFrdkpwbDFIeFk5VVFiU0pGSjhad3FkVzJ0UExiM2d0b3g0aXljb1h6a1NNczgzSGpueXlYekdZNHd1T3ZxMmV4Z25icVk3dnV0SzR5MnZ0KzVXK2VDdldxRThoOXVYQllyN0pQaGNMK2ZrV3hTUWpMalMyUStwVmxmd1o5QSt5dStvUUFOSkhublBoNXBYYTBrdklscmthNjRrV3prNkEzejVaTHVVdDBmZDRRU3crUkdPSXl6RnhsbmFSZFZ4Y29jUjhnOE1maUtoTGQ2UVFkUGgzU0xrV3VmM1Z0cjkzZm52N1krUnpGYzRLMUNpNm9XdFlPcE9Rdm1xS2FuYzFHSjFPYWdtMmRWUzNhTlBrMGQ1NGxmUXpsRFRVN2ZRODFLVnMvcVpHQmJUclZDNm8zZUp5QkpzTkJZcndOUE5XYW4zbHcvVTlHM3hLb1lnOEd2VXdkSmtPWlNZMk00YUpYcjZ1S3FTbkZKTDVHR05rNVpVcE4vVWszeEJPUkl6OWFxaFh4bEZ6NnlSdGZRMy9VQVo5NVQrclVWbVg0aytHMzBSMThURWJvejhoeEs1dTFMV05pN080MTU3TTdIdU9lbXZyMW1xN2s0ckw4K3pSV2tRbDczSDRyQnU2UnhHWDBVdXl5eDVUNHhqN2RFN0lyeUpzT2JlcENVeDQrWkVpVDJoR3YwVnNaVGkrV2N1S1pIVXZ6NzlGRWx1NUpYQlh4VG9FQVNZZ1RyKzY0dG00ckNSMUZaTmpETTNhTFFjOTJUUEUzdXZUeHMweVQ5REMzdXQ0TjdaOXFUUDhBRnZ5WHE2ZFlxaXZrano3WG1iZnpMRXE0NEZsQUtFSUVRQ3lnSHFBQ0FFQkJpcWU4eHplSXQxMDgxVmZEZlc0L0k2aExiSk1xVUtvZTN1Z2o1eXNORjBib1kreG9sSFl6bThiUTlpNkRINkR4KzNOZUZxSzNwWll4OUdlcFZQeFkvcVZzeEk1VE9wNGRPU29YdlJ5dXYxWlpqREluazVuTHdWRW5KKzlMbzdTWFNFYTYwbXd0K3c2S2EyM0hNbHdTMXpoRUpFeHJONDlkL2dwU1dVa1Q2ajJzL3RseG5kSkhNaURkYUl4L3RPVDZiUncvaXdRQTNON2s3MDljL29WbGF5KytlenNnYUNUdWdFdW1BTlVWYms5dmI5Q1cwbGxuUmJQd3dvc2x4dm00L1FMM2FhNGFTcHlsMzVubTJUZDA4SXlkcjdRRlJ3WU9oNkx4OVRxSGU5Mk1KSHFhYWp3NDdtUjRPdnV2QjVyTlRMWk5TTExZYm9IVnlITjRncjZtK0ViNmNIaHJNWkdaUmRONU5zaG1Rdmx0UEYvRTIrUEwwTnNsNURIMWpOOVBxdTVTazVZbDVIU2lrdUJoZEp5dHI4MWRYR01wNXdkWXdodUpmdkR6UFNSOXd0ZDB0OGNJUldCdUh5bm1mSWtyclRyM04zMUUrOERBKzdvemJjY3dmUlhFWGx2SGEvUU5FKzhkUVI2K2F2eTN3MFZ0RVJlMW9tY3BKakx3MFZlWXdXVXpyRFl4MFZJRFJja2VFMzhrZTIzRVV1Y29ON1UyemEyZ2ZkM2VnSGl2VzFLVFNyOWNJOCtsNGJrYmxDcUNMTDFsNkdCOWt3Y3BJRmxDQjdTb0FLUUNBa1VBRUFJQnFBek1UVDluVTMvd3UrTGtmM1hrWDFlQmY0cStHWGYxL3dCbXV1VytHM3pRYlF3VGF6UURtTHRQQS9aVzZuVFExRUVuNWNwaXExMXl5am5zVGczMHdYT0FJR1puT1lCUEplRmJwN3FZdVUxbGZ6azlLRnNKOFJmSm5PRjR6Snk2RmVlK09PMmFsNmpYTzBPdmtOUFhNS1h3c05oZXFCdEtUYWJBbmhQckpXMDFOeXlRNWNFYldtVEFrUjVUQ3E1M05ka3RvczRIWmIza0Z3TFdqVTVtMlFXdlQ2R2RyVGtzSXB0MUVZckM1WnEwOExTb2lRQUR4ekpYb3QwYVNQSCt6Sm15NW5QN1oyMW0wSDlsNDlsdGw4c3ZvOVBUNlpSNVpnWWJGLzNBU2M1SGlGTXF2Y1p0ZUdzR25UcUxQZ05IUmJIeGtqZE9tWFJlaG9kVzAvRGw5anl0VlR6bEJqNkpZWkh3a3piandXWFg2ZVZGbTZQd3Q1Ky9vUlJOVFdIMmlGL1c1SXNPTmd1TUo0V2VXeTFEcEFJSEVFbmtNbHVpbzF2YjY1STVheVFWS3Nid2kwZlBMeVhFck51VjVmei9BQWRLT2NEbVBrRTlZOGJlUkMwMXliaTJjdGNrZGI0Z2NyR2VjWGoxd1ZkaVNtcEwwSlhXQ2N1dG5scjVMUmxPT2ZRcXh5UlY2bnVrZ1NkUXVKeVcxdExKMUZjbHJZUkJjOTdTNk9laG5JZDByVm9NU2xLY2V2bVo5VzhKSmp0bzE1cUJ1ZytmTHhXMnIrNWY4by9xWlplN1g5VFp3RlN5OUl3czBHdlFnZHZJQ2FrVkpBOUFDQWtVQUVBSUJxa0RLbE1PQkJFZ3JpVUZOYlpMZ21MYWVVWmRjUHBYSHZNOHgxKzY4ZStOMmtibkgzb2ZtalpCeHQ0ZkRKR1lsanhtTDZLeW5XMDNMc2lWY29zcFlqWTlOMHdJSjFDcHQ5blVXWlNXUG9YUTFWa1NsLzhBbmhOM21PZ254V1JleFk1NW53WGYxengwU3YyRXdtUzUwVE1XMHl1dEV2WjFUZkxlRGhhdWFYUmNvWVNsVHlBNW1aS3VoRFQwOHIvWlZPeXl6c3FiUjJ2VFlDQVJPU3lhdjJqRkxiWDJYMGFTY25sbkliVzI0WFNBdkZVSldQZEk5YXFpTURsOFZpZFN0dGRaWkthUm12eFJjYkdBRjZOR216ekl5VzN2cEhSNERHaDRtYjZqZ1Y1V3AwN3FsanlObFZxc2prMmNIaWQweXNzb3Y0bzlpeUNranFxRlZ0Um5FRmZRMHlyMU5XR2VIWkdWVThtZnRMRGxqbXVId1prNTM1cnk5WnBQNmV4VGo4UCtmbWE5UGFySXRQc2lZOEYwOHZyKzZtdXhUbTVMMExHc0xCRFdjQzJPRnJhcXFjbE5iWDVIU1hPUnJhd0VpOWdUMTRsWFJzaXVQUWh4WTdGR1FIRElHM09mUlhXcDZVdkw5eUlkNEdPZVdqbnI2eU9pS1RoSDVrNHl4bURCZThNNDN0dzV4bmI1TGltdVU3VkU1c2tvUmNqb210WlJwMnNCUGVWN3VJVVY0ai9HZVczS3lXV1l0SjI4NHU0clhwcTlrZWUzeVYzU3l6YndqMXBNN05PaTlEa21EbEpCYXBDeUVEMEFJQ1JRQVFBZ0dxU1FLZ2dZNUdTWldOd0xibHZ1bmxsNEx6dFI3TnB0NVN3L2thcXRSSmNQa3hLbTBIMGpjcnlaYUxWMFN6Q1dVYlkrRll2UWEvdENZc1ZudDFXc1hHTUZzZEhCbExFOW9ISElySEs3VXo0Yk5FZEpCR1hpZHRQT3ZndUZDVFhMTDFWQ1BrWW1MeG1wZDVxK3VyMFIyNXBHUGlkck1GZ2Q0OHJyYlhwSnZ5d1V5dlNNK3BWZlVQQWNGNkZlbmpBenlzY2g3S0JWNktzbG5ERjdEdk4vbFYyMVJzanRrZFZ6Y0hsSFNZTEZoNHRucU5WNU05TEt0OG5vd3RVMGJHejhlV0gxNktxaHVxbHZnY1cxS2F3enA4TmkydkZpQ05WN05PcHJ0WEhKNDlsVW9NcjR6WndmZHAzVDVMSHFQWjhKdHV2aC9rWFZhbHg0bHladU53ajZjRndrYWtaY3VDOCs3UzIwdFNtcy9UbzExWFFzNlpDMTdYY0FZaUJwNmhTcHdtdlI0TzJtaU9uTG9wTmtrandKM3BueVNPWnJ3NDhpVFVmZVpZYnMydTZBUkF6dWN2RE95dmhwZFRQaHJDK1pSTFUxUjZOakJZTmxFRTV1MVBMZ09BWHEwMHcwOFcvTXcyMnl0ZVBJeTlvWTMyaGdIM1FmRlhVMHUyWGlUNlhTL3dBbkVwS0MycnNiaHd2Uk16WnI0U21WSncyYk9Hb0ZEZ3UwNklDa2dsUUFnSFFvQTVBQ0FFQTFBSWdHbFNTUlZHU29KVE1ySDdNRDF3NDVMWTJZT1gyajJkTjRDcGxVbWFZWG5PNHpZRlRSengveUtvZWxnL0pGNjFEOVRKcjluNnY1My84QXNWei9BRTBGNUk2OGQrcFdkMlljZmlMajFKUHpYU3B4MGlQRkpxWFoyTkYxNFpIaUl0MDlqUm91bFdjdXd0TTJUeVU3RG54Q1ViSTVMcllGWU9HeUNMaXhYTXFsSllaWkc3RDRIT1k1dVk4Rmh0MEdlWW11dlZlcFBoY2NXR1FWNWM5TE9xZTVjTTBOd3NSdFlMYmdObmVzbEVOYk91V0xFWmJOTG40VFpwWXRyc2lGNjFldHJseGt3eW9sRWtEYWVlNjNtWUN1VHBmT0VjZjNQVmllNk1vRTlGeEt5cVBDd3NqRTMyVnNSdE5qYkUzNEtoYTFTbHNnc3M3Vkw3Wmk0dmFEcW1rQzhjWU9pMTFhYVVudnQ3OURtVTFGWWlNdzJHSk5ndDZNN1owR0EyVTdXeTZLM0kzTVBoUTFTY0Zsb1FnZktBVUlCNENnQ29BUUFnQkFOVWdGQUdrSUJwQ0VqU0VBeDFJRkJrcjFNQXc1aFJnNjNNclAyT3c2SmdueEdRdTJHemdvMmsrSXlJN0Jid1RhUEVZRFlMVTJrK0lQYnNSbkJUZ2p4R1N0MlN3YUpnamVNcWJNYndUQk84ejhWc2dLTUZrYkdZR08ySnlYRW9KOWw4THNHTmlObVZXL0M0OTRsWko2S3VYa2FZNnFTOHlJVmNZMnczVDFCKzZ6UzlsMU02ZXFKRzR6SEUvaEgvRS9Vb3ZaVmVjOC9pY1BVcjBMZUhwNHAwQnp6M0FmWlh3OW0wUjh2ektwYWxtdGc5aVZYWElQVXJiQ3FNRmlLd1o1WFpON0I5blFMdU1xM0JRN01tMWg4Q3htUUNrNHlXZzFDQndDQWRDQUVBSUIyOG9BYnlBY2dCQUNBYXBBSUFVQVJBSVVBeENSRUFJQkNnRVFDSUJFQUZBTWNnSW5oQ1VVcTdSd1VIYUtGWmc0QkRwTXFtbU9BOEVESmFWTWNCNEJTY214Z3FiZUE4QWh3elJZRkpCSUVJRkNJQ2hBT1FBZ0JBQ0FlRkFCQWYvWlwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wdWJsaWMvaW1hZ2VzL2ZydWl0cy9vcmFuZ2UuanBlZ1xuLy8gbW9kdWxlIGlkID0gMjAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUFBQVFBQkFBRC8yd0NFQUFrR0J4TVRFaFVURXhJVkZoVVhGeGNZR0JjWEZSVVlGeGdYRnhVWUZ4WWFGeFlhSFNnZ0dCMGxIUlVYSVRFaEpTa3JMaTR1R2g4ek9ETXROeWd0TGlzQkNnb0tEZzBPR3hBUUd5OG1JQ1V0TFMwdE56QXRMUzh0TFMwdExTMHRMUzB0TFMwdEx5OHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExmL0FBQkVJQU1JQkF3TUJJZ0FDRVFFREVRSC94QUFjQUFBQkJRRUJBUUFBQUFBQUFBQUFBQUFBQWdNRUJRWUJCd2oveEFCQkVBQUJBd0lEQkFnRkFnUUVCUVVBQUFBQkFBSVJBeUVFTVVFRkVsRmhCaE1pY1lHUnNmQVVNcUhCMFZMaEJ5TkM4VE5pa3JJVlkzS0N3aFkwUTFTaS84UUFHZ0VBQWdNQkFRQUFBQUFBQUFBQUFBQUFBd1FBQWdVQkJ2L0VBQzRSQUFJQ0FRUUFCQVVFQWdNQUFBQUFBQUFCQWdNUkJCSWhNUVVUUVZFaWNZR1IwUlF5b2ZCaDRiSEI4Zi9hQUF3REFRQUNFUU1SQUQ4QTl4UWhDaEFRaENoQVFoQ2hBUWhOMWF3Ym1WeHZCRXNqaUZWNGphb0h5L1ZSSGJRY2RVQ1dwZ3V1UThkTk5sOUs2cUZ0YzhUNXJqc1lSa1NocldMMkxmcHBGK2hVOURhWjFnOTlsT280NXB0TUhuK1VhT29oTGpJT2RNNDlvbElYSlhVWUVDRUlVSUNFSVVJQ0VJVUlDRUlVSUNFSVVJQ0VJVUlDRUlVSUNFSVVJQ0VJVUlDRUlVSUNFSVVJQ1JVcWhva21Ba1luRUJnaytBV2EyaGludWtrOXdRckxOb2VtaDJQL0FBV1dMMnlBRHU1Y1Q5bFE0bmFwY1RjOTZyc2JWZEgyVlZoOGVBNkNzeSs2VDdOM1Q2R0NqbEl0cW1OSkl1cE5IRW1ZV1l4T0szYWd2Wlh1d1QxZ0xoN0NIWHlnOTBJd2prdktOYXlpMTYwbXk2NSs3TUNWQXFWVHdoWGF4MktWd1RlVVdESy9GUE5yK1NxNk5hZnlualY0cXNtbWkwcXVTK3dtMEMzV1I3eVYxUnFod2tHeXhUY1FwdXpkcDdqdVdvUjZkUzRQYkxvUnYwZVZtUFpyRUpGT29IQUVaRkxXb1pZSUpUVmV1R2lTVlM0N2FjMkNITzFSQzEweXM2TGVyakdqbjNLSFUyd0JwOVZRdXhSNHFOV3hBNHBPZXJmb1AxNkZlcG92K09EZ2xNMjIwMmo2ckl2eHJVcWhqQVRheUd0WS9jWWZoOGNkRzBidFJpY2J0Qm5GWmFtNEVacE8rZVAxUm82cHNYZWlpYkpsZHB5SVRpeU5ERkZXV0cyZ1JxalIxQ2ZZdlpwSlI2THhDajRmRkIzSXFRanBwOG9VYWFlR0NFSVhUZ0lRaFFoeENFS0VCY2U0QVNjZ3VxczI1aU4xbTd4OUZ5VHdzbG94M1BCWDQzR2J4azl3Q3JhMVdVeFhxWHV1dGVJdWszeWFVZmc2STJMcG5kS3hHMnFWUVA3TFhFazJnWFBKZWowbnROaW1jYnNxbldHN0xtbk1PYkFMU0RJSUo0UWdPS3p5UFY2cHhSNTgyaFczV05jMmFyblF4dWtURnpwZWVTOUJ3RklVV0JvdVRFblNZMDVLc3A5RytxcXRyZGYxaGFIV0xBREphUUR2RE1nazU4U2x2clh2OTFXdkNXR1Z0bksza21WcXQxQzYrVGRNMXEwNmxNYjkvZm1oMlNHNksvaEp4cUJGVEVDZkN5aWdUeTRjVTZ4c1pCVWhDYy9rSzZuWFVVY041ZnNoN3JqSEx5U1BpZzNYNkptb1BjcHMweHlSL0lXT1dZdG5qTnJmd1JTWDNORHN6cFl5bU4xekhrY2dMZlZUYXZUV2xlR1BuU2QzNjNXT05JY1I5ZndvNzhPVC9VMy9BUFg0Ull6bkNPMU16cDZxY3BibmcwdGZwS3g1dTRqdkg0bE0wOGExM3ltZTQrcXpidG5uOVErcWJPRHFDOXY5YlB5RUdXNWpsUGlzNGNPS2EreHA2cnpyNzhWWFlxc3E1bU1yTUhhYTR0NHdmOXcrNnNkbm1sWERnWHdZczJ3UDdwSzdNZVdiK2o4UW90L3cvWXA2Mk1pYy9aVmhzbkVUNzgxUTlKYUJwa0Z0Mm42RlgvUlhkTFJJa2tJTHRpb0tTOVRhdWNQSzNJdktENXNubk5oUzZXQWt5MndUdndUUm1VYU0rTTRNU1YwYzhGZUhjSlRqS3NGUFlpbTJMS0c5c2MweEMxTTZzU0xLbmlGYzdQeCs5MlhaNkhpczFUS2tVMzhNMDNWWnRGcnFJeVJyVUtKczdGYjdiL01NL3dBcVd0QlBLeVpNb3VMd3dRaEM2VkJDRUtFQlp2YnRXWGtjRnBGanR0VkR2Tzd6OTRRcm53SDA2eklxc1ZWRTVxT2NiSG9vK0lxd291R3dWV3VZWUxaYnhzMGVPdmdrNVdLS3pKbW5zSnpOb1h6aFNhZFdvK1F6UVptd04rSnpVL1pIUmdVeHZPY1hPN3JUeUJ6VjFRd2dIUG1zeTdWemNzVnJqM0xxNnV0Y0xMS1RDN1BydkY0YUR4ZEo4Z25tOUdqUGFxejNOSHF0QXlJVGlrZDBsbHNCTFdXWjR3dm9aeXIwWVlSRysrZiszOEtrMmxzNDRlQzhsemRIQWZROEZ2MktOdENrQzI0QnRjSElqVUZkVUpKNXlWV3FuUDRKdDQreGdoaWdORWgrUEhDZkZTdHQ3R05NRjlLU3k1TGN5MzhoWmZFUGk0eVhKWFdKNHlhZW44TDBkaTNKWityTFoyMDd4QVRQL0ZEd0VkNnBYNHVMcEdEcWRaVWF3SDVuQWQwbS93QkpWNDJXUDFHbjRQb2tzdUMvbjhtdkZMK1MycTUwYjF3Mkp0b1o1NXFscmJVakpzODVzckRiR0xrN3JjaFljaGtGVTBzT1hPWFozeVQ0WXBEd2JTeVdaUS9sL2tXemFGWjN5dGFQQWxXbUV3TmQvd0F4YUIvMG44cVJnOEVHaFhGRnNLdm1UZmJLV2FMU1JXSTFvcjI3Qk9sU0QzSDhwakc0QnpHNzcyYjViZmVhWWZiZzhYbnZsWDdxZ1VTdFdjYkEzOExya291WHVDcTAxU2Y3RjlqQmJkeEFxTUxxTGkrQjIyVzZ3YzRGbmQ0VnQvRDJqV3FEZmRUY3luK3A0TFo0YnMzUGVGb05tN0V3MUY1cUNtMDFDU2Q0aWQwNmhnUHk1NmZzcmFwaXB0S2lvZ283WkJwV3ovYkhvazFNU0JZS0k2dHpVQ3RYdW90U3VVUnBZSkRUbG5VeFhQeVNHWWdIM2RWcktuN3p3WGFiN3F2UWJ5VWtXOU04RXRodW9WQ3RiaXBKcUlrSmdKUmFaWjRERWJyd2ZBOXkwb0t4bE9wY0xVYk1xN3pCeEZ2d3RQVHo5REwxbGVNU0phRUlUUWdDRUlVSUN4KzMyOXB3R2NuNnJYVkhnQ1NZQVZLOW9lOHYzZTVKYXkrTmNVdlY5SVkwL0R6NkZCcy9ZTTlxcGY4QXkvbml0QlJ3d2JZZnNPNVNHZ0JLSVdRNjNZOTAzK0JpZHprTkRQa25BMUNiZFdSSTFwZGcrV0xpQ2x1RmxIZldhQkpJODFuOXNkTXNOUkVtb0RuOHBuNmFvaWlvOWw0MVRtK0VhRTFCTmlrWTdFaHRNbk54c0J6Szg5eG5UZHpxZS9RcC9OWUY4aVR3dUl5dk1teWc0VHBYVmM3K1lRWUk3UURpMEVtTTR0d2xVblZMR1lqVU5KbDhzMldFeFVtSnNEZnVVRGJmUlZsVUYxRWhqei9wSjd0UEJjd2RTbThCekhOQkluZExya0hJZ3Q0OXl2c0dHd05UM2svc3FaZ280bHlOVG5LbVc2SEI1UGpOZ1l4cml3WVo3aU5XRGVhZkZQN0E2UDR4bFlWSDRkN1d0YTZONHRCa2lCYVoxWHJRSnY2SnVyU0tUdDFrb0w0WWZjcy9FckpjTkk4enhMWGgzYmFXbm1JL3VwdUNhdG5qTUMxN1MxelpCOTI0TElWR0drOHNPbkhVYUtVMytaeTFoajlHcFYwY0pjbG5ScTJUdlgyVUtrK3laeEdJNEkyWGtyNWVXVGV2blVwMmxpT3lUWXhhUjlaOFZTSEVkb2NrcW5pZXlJTmlKeWpPOFI0cHFIQ09UcUxWK0wxOTJTVzRxUkhHNFZYOFRjeVRwS1ZUZGZ4K3FwSmx2SlNSTXFWUUUyYXZ2Uk5QT3FiQTcvb3E3dUM2Z2lTY3A5M1Q5SXB0ak11Q1ZSdFpkVHlpakpyV3hmUlAwd283SFdVbWczVXF5OXhhZlJKcFpxLzJFLzVoNCsvTlVQY3JiWUx1M0hJL1pQNmQ4b3pkVXMxczBDRUlXaVk1eEJLRkIybFh5Wnh6N3YzUXJyWTFRYzVGb3hjbmdZeEZickQvQUpSbHo1bEZOdkJJWU9TY0FYbjA1V1QzeUc4WVdFT0JxYnFWQU03SllxaFJNWFZzbW1sajRXY2pGdGlINGtISXh4VlB0bmE3YUFMM3V0L1NOWEhnMzNDaTlJTnNVNkRaSWx4RGkxdkdCSko1QmVaZEs5cDFIMHVzRDNGemdDNGd4RFRjTkFHUUV3dVJpOHBlcG8xMEpMYytpWmp1bEp4SFdBdkxXQVREVGFKQXZPY2xRbTFhYisyMWtiNTdKTXZ5RU9ONEF2TWQ2cU5nYmxTbTl1Nkd1TEllNFp1RzhYUkJJdno1QkxwNDVyWGJnQUlaRzZEUGxiTEtVWlY3VzBobFRUU2ZTTFRDNGx0UTdqSE9lV0J4SmNSQWM2UVhDQUFCQWkrUUVaSkIzMkdyRGlaamRhQ0M3K29ObG95Sm5JNVo2S0F4b2F6Y2FJRHBjNGdpZDR5UEVqTlRObjFXdXB0YXlvYlNEYVNTSFRtTXRQT3l0d3NsZWVPVFE3QjJ4VmIxWXFVYUpzR0J3WVc5b1hBRHhOd0p6RWR5Myt5NnhlQk1nOENWNWpoTnNVZmlTSGRZMTRPb0c2U1c4Q0xDK2kzV3lDNDNCTUFneVIreVF2bHNzVHdYbkJUcmI5VFlVbWxPa0p2RFZKRXA0cGx4aTQ1Uml5emtpMVdXc3NSMHladVZLYjh0NlFmQ0NQdXQxVWp6V08vaUJTbkQ3d0YyT2E3d0pMVC9BTHZvczVSU3NTTkh3NmUyNk9mbDl5blppWmFPYWpZbXNJSSt2a3EvRDRyczgwMCt2b2p3anllazhyQk4zckgzbWxHdFlYaTN2N0tBYXRzMDRhcDlMSTJHRGt1U1V5ckpIdlJTNmJoNUt2bzFjcktXWDM5VHl1aFQ0ZURqV1NjN0pKWm4vWk5zcTNUMUVTVUxsQXVpVFRDVk9xNEJiTmRhYlpLOEFiSk5MNnFiVEZsQnd4eUtzcUQwd2hTM2drMGFmb3JMWW4rSjRGVjFNWksxMkd6dE9QTDFLYjAzN2tadW9md011MElRdEl5RGhWSWJ1THpybDNhSzB4ejRwdVBLUE8zM1ZZelJaSGljOHVNUHFNMExoc2NCWFRVZ0pJU0s1bit5UlVtbGxCY1pZeFZyNnpaVmUwOXJNcHNKZE1BRS9aU2NhRGx2SHdXTDZSNHlBNXJmbU1IdEgrbGpnU1R5bUxJOEUxRlAxWm9hZWhTNU0vdERhSnJsOVNvUzEwT0FEcDdOT0piRGVaRXpuWWQ1cHFOVnRPR3ZKZkZuRWpzdUZ5V2dFV0Y0SmcrRUtMMG14QnBWdXRwdTNnOENSbTB6ZUJidERSUnNkaUM1MUY1K1NwOHd5Z214SEpNUnJiNTlHR2xZazl2c1B2dzdLZFp6cVVrUEkzZkRTTmYzVEFETzMxZE9hanBrRTVhMm5MVk5Qcm1tQVpPNXZTSGNDQ3VWTVMxenVzc0NjeUxUcmYzNklxVFpUaGNML3dBT2RkdU0zcWpqdkhKbzk2cWZzN2ZucmFzTkg5Rk9ZLzdpRDZLdG92TG5UU1lIUC9XWkRSNXF3WnM3cm5OcHZyYnozRWRsb0FiRWd1djNjVjJUUzdKRjU1WDkrdjROaDBiYXlyV0RqMncwR1RtMHVNQm9Ia1Y2SFFpZDBScEpDcHRtOUgyMGFkSmpNd1FTN1hNSzkyVzJYRXhhZlEzOUZueWk5MlBjN2JOT080dWFUSUVKVGltM09RWElsbGlqd1plTThpYStTekhTMEE0YXNQOEFsdU9uOU54NkxSNGc1ck05SkhqNGZFSC9BSlQvQVBhVWxERXIwMTZJYzBxeEpNOHZvVmxKcHU5ZjdxdFlZVTJuVnk3NVR6Z2VwVnFhSlZROWdGRHVSU0hQN0J0Nyt5R0d3UHZtdVFLVFpKWmtDTFhWaUx3cXpENWQzdVZiWVdDTCt5aDJsUndWTFI5VXVnKzhMbFdsQWxkb3RRMWhvcGhZeVQydWtRTTBxaTY2Wm9DRSt3THNZZ1pJa1VCNktmaHhkUXFQOWxZVUFtSW9UdFpOcHRzcnpZdFBzbDNFL1FLbm90bXdXa3c5TGRhRzhCL2RQYWFQT1RHMWMrTWU0NmhDRTZaNUMyc1A1Y2MyK3FnV2hXTzFCL0tkeWcrUmsvUlFhZVN4UEVZTjIvVC9BTFkzUy9nK29Vd3UxQUVvSm1xVXRHTzJKZGNzcjhmQUJKTVdYayswc1dINHlRWkFhOWdpN1RhWGc5elFTWTRoYi9wWFhjV0ZqYlRieE9RV0UyaUcvRTBhYkJHNzJiRFZ6U1h1SmlEQTlFYk9PRGEwMEdxOCs1bThZVFNxUWFmV1Vta09GdmxCSkl2RTY2cUR0Q3N4N1F5blJlTGt5U1RmVStpdE5wVFRFT0F1Q1haODdOR2xpTStDcTZHSWM4aW5TRGlUb0NJRVJONHl6VGtPVmtEWXVjZTRoK0lkMVpwbWxQZm1DWlNjRnNva0RlQU04U1lHZGo1ZlZYMkQyRFZjNHRKM1FORE04ZlFqelU5L1Jwd2p0U1kwTURtVDQyWEhlb3JDT3JUeWs4c29LRmQxSTdtNjJRTEJwa2NSSTRjVm9laHZSbDNXaXM4WERpUUpnYzRIakNuYkk2T3REZzZBWXpqUXhjVHJkYk9pQTBRQUpBdVRtTXlCYmtsN0xjcDQ0OXd2bDdlKy93RGdkeE9PM1JBRnliRG4rQmE2bjdHWVFMbnl5blgxVlJzMmdhajNPai9LSk9tWjk4MW84TFMzUmJKSnF4eWx1OUFHbzJ3anNYZnFUU2tncmsyU2FyclJNS1hUVDVNNUlZeE5TMExLOU1NUUc0U3FlSURmOVRnUFFsWHVKcVNWQngyejZlSXB1cFZCWWl4R2JYYUVjd3UrSHdjMjUrL1h5UTdERmNkelBKQUxKeHJoWk9iWjJWVndyOXg0bjlMaDhyaHhINDBWZjE1MVdvNDhtalhlbXV5NXA1UnhoSXB1MDRjQnBLallmR0RJcDJtUVpHZDBMYTB4bnpFVE1PL01mMjk1S3p3N29zQkhGVkRIS3p3ejdJVmtjaGxJc1dDUkhCUE1wcUpScUFXMFVsbFNVRkxCVnBraW1Zem43SjZtVkYzcFU3RFV6Q0xGQVo4SWVvek5sYVlWcWdzYXJYWjJITHlHanhQQWFvMFllaU0rK2FTeVcyeHNQY3UwR1hlcmhJbzB3MEJveUNXdFN1R3lPRHoxdG0rV1RxRUlWd1loN1FRUWNqWlVPSGtTMDV0SkhrVm9GVlk5bTdWRG9zOFFmK29EN2owV2Q0alhtQ243UCtIL0FMd01VUzVjUkpjbzJKZUdndUp5VDlSNm9kcjE5NHRZY3ZtZWNyQTVFODFtT2FRNVRYdmtVZTM4WHUwdzkyYm5ieHVBUTIvSElBZWl5MkZ3em5sMVFBaHp3VEpCbG9kY0FjTEFTZVk3bHRYQnRWK1c5YTBOa0RnWk52TG1uS09BTFJBek55NCs4MWV1TGtzczJZV3FFZHJSZ01QMGVlSE9jNXdjN2ptQmVTQk92TldlQjJROEF3MXJYVGNpZDV3c00rR2EwTkxaNXZOeHA3NForYXNzTmhJR1hDOGUrYWxsalVlU3p1aERsWU0yM1pydzNNbTQwOW45bHlsZ25hekU1Um5sZjFXdnJVN0VhUkNhWmg4c3ZmQkxlZEFHdFkydVNxYmh0eUd4RElPWk1rNXlTcFdHd3JxdlpGbVd2eDdsWVVzQVhtWFplOC93clJsSURJUXVwdXpsOUN0dXF4MTJSOE5oMnNidU5GeHJyM3AxanZOS2RuYUVtUUVPZG5vdWtKTjU1WXNPaFE4VFdYYTFWUTZ6dEVzdDJvbjVhL2F1L3dBQnE2K1JwNzRrck5iUTZhWWVpZDBGMVIwM0RBSUhlNGtEeWxLNmE3YitIb21EL01mTFdjUitwM2dENWtMeWNWT1M5QlRIeTF3RDF0eWppQ054dFBwdzJzMDAzWVZybW5MZXFHUnpzMng3aXNwVXF6b0I1cUpMdjBueUtKZHdLdTVTZnFaMzZpeExoa2tsS1pVSXlKVVByRW9QS3J5Y1dydVhVbVcxRGFVZk1QSldXRjJyVHlKanZDekljbGh5bytSaXZ4YlV3OVUvbXZ3YlNqaW1PeWNDckNnUVJZL1ZlZnRWbGdOcTFHYTd3NE92cnh6VkdoK254NVBpMk9Qa2IzREM0Vml6SlpuWjNTS2lZRDVZVHhFdG52R25ldHJzbkJkWUE3ZUJieGFRWjhSWldyanVmQTVMVzB6anVqSlArK3duQVlaMVIwTkUvWmJMWitERkpzRFBVOFVqQTBXc0VORWVwNzFNQzA2cWxIbjFNVFZhcDJ2QzRSMUNFSXdtZFFoQ2hEaWc3WmIvQUNuSFZzT0hncDZyOXVrOVEvZEVtQjVFamUra29HcHg1TTgrei80Q1Zmdmo4MFZPSXI5a2NTRldPMmM1NE0zbTU4RS9TcnRNU1FQR1BKV1RaMGlPUzh0UmVwY210dWRYUkFwVUMwZktuUkhBK1NtaXFPSDBTcEhJSTdlNTVqSUU3VyswVjVnYUp0ekhIVHpWbTBObGRlOGNFR2RVcHI0cDhFODFycEZWVHBPSmoreWViaFFEOTFOM3djbHl5SEhUUVhyazY3V0FBQzQ5NTBTSE9UVDZzR1RrcldYS0s1WlZSeU9QZEE0cUhXcktQaXNkb0ZENnd1N2tCVTJhaVhIRWY3ME4xMFB0a2g5WlJOb1kxdEttNnBVZHVzYUpKK3c0azVBSjF6dzBTNnl3dlQzcks5TUZwTzVUSkpaeEg2anhJdjRFcmMwMm1qWEhFVndkdHNWY2NwY21TMi90VitKcW1xNzVjbUFHUTF1Z25qcWVhcm1ydE9RWkJoUE5BT1lnOFI5eCtFeTJZczVibmxpV3VQRXAxcDVud0pDNGFKenpIRVg4K0NBcU5nMk9DYmRvK3FEVFBCcDdoOWhIbWhxY0E1S21RVWhoc2FqeVA1bE9CZzBQbVB1UHdueUFmbTg4aU9IZW1xbEl0NWpqK2VDNXV5QmJCdEk4ajNIN0c1U3hiUDBqMVJTOThFdHBqOGFlWHZOY1lQY21LYTVYR3dOdlZzSTZhYnJUMm1PK1YzNFBNS3FFYWdlbjdmUk9CbkErZjVDcG5EeWlLZUhsSHRYUmJwZlF4TzZ5ZHlzYzZablBYZGRrNzE1TFd0SythdzBqOGpUeXlYb25RSHBzNE9iaDhTNldtektoTjJuUnJqcUR4T1hkazdSck9kcy91SGpmdWVKSHFTRUJkV2lHQkNFS0VPSkZha0h0TFhaRUVHNUZqWTNGd2xvVUlaZmEzUSttKzlONzJIaHZIZFZiaGpWb0hjZklqS2NqK0Z1SEtKaTZEWGlIQUVKTzdSMXpYQ3dQMTYyZU50bktLUm1OR3NqeWp6VGpLelRPUlVmR2JJSS93MzI0SDhxdmVIdCtZZSs4TEp0MFZrWHcrUDhBUDUvME53aFhOWml5NFlBTkk3aWxBKzVWQ2E3dENSNXJueEx1S1RlbnRYU1g5K2dUOU0zNmw5MW9DYWZpV2k4eXFaMkljVXk3ZU9aOEZJNmE1OXRMK1MwZEt2VmxxL0g4d29WWEZseHNVd3ltbHdORXpWb0lybDgvUCs0QzdhNENmVmRjNkVzTUtXS0MwcTlPbDJCczFLNmlWMWNGMmVYQlJuNFhrcndZVmQrRVRTajdDVXA1N1BOTnZkRkNKcVVSeEpaNjduNDh1Q3k0RUhLNHpsZTRQd2F6KzMraWpLL2FIWXFmcWl4NU9HdmVnMlUrcUZiSUo4bzgwYmFQZnZOUFFDTHRFOFJZL2c1Y0U3aXNCVXBPM0tqQzEzUElqaURrUnpDVFRiS1NrOENyYlEzOE9kRFAwUGwrRndjL0pTd3lVNEdBNWlSN3kxQ3J1OXlrcFpJWVNnNzNweHk4RTgvQ2NENS9sTmxrWnFaRjVzY3crRGRVSWJTRzhYSDVCbnp6ejgxYi93RHBIR1IvZzgvblpJdmw4eXFhVWdndE1FRUVIVzF3VjZYMEw2Uml2L0pyRUNxUGxjU0IxbWVtUWNPR3FKVHNrOXNtZHBWY25pWFpoMjlGY2IvOVovbXcvZXdUemVpdU1KLzl0VStuNVhzOVBEcVZUb0p2OUhGK293OU5EM1o0OWgraFdPZC84Rzd6YzlnLzhwVnRndjRjNGtuK1lhUUVaaDUzcDBtR3dkRjZteW1uV2hUOUJXKzJ6aW9naXY2TzliOFBURmE5Um9MWEhVN3JpMEU4eUFDckpDRTdDTzJLUVU2aGNRckVCQ0YxUWdncG1vRkloSWMxUTZtVjFaaWgxcVN1SFUweStnaHVJYUZtRFBWY0x5VVYrR0swanNNbTNZUkNkU1l6SFVOZXBtalFkN0M1OE01YVQ0TUxud2E1NUtMdlV2M00rM0JxUlR3aXVoaEU0M0NxNmdDbGRrcVc0UlBOd3F0VzRaT05vS3lpRGRwVmpDcFh3cXRCUlN1cFZzQTNZVkp3cWJkZzFkZFNrbWdwZzV2TXpqOWowNnJkMm93T0hNWmN3Y3dlWVdVMmowQkZ6UmVXbjlMN3Q3ZzRYSDFYcHpzT216aGtPZE1aOW80OFBzOFZ4ZlJYRlV6L0FJUmNPTER2ZlN4K2lxeFl3YkhnYkczRUZlK2ZDcG5GYklwMUJ1MUtiWGpnNW9QcWxaNkpQOXJBeXFUNlBEQ0VkV0RvdlV0cGZ3NXc5UWwxTnpxSk9qWUxPZllPWGdRczNpdjRiNHRnSnB2cFZJeWJKYTQ5MGlKNVNsNWFheVBvS1NwbXVqRlBvWHQ1ZnY3NzF5bTl6SEF0bHJta09CdElJTWdqeEMwVmJvamoyNTRWNWpnV085SEZRNnV6cXpiVk1QVmFMRXpTZUlubVFndUVsMmdPSG40ajJEb2x0UVlyRE1xMjN2bGVBUlo0c2U2Y3h5SVY0MWk4aDZBYlorRXJsbFFrVXFzQXpiY2VNbkVjTkNlNDZMMkNtNEVBZ2dnM0JGd1IzclcwMXlzaC9sZG1oWFBjZ0FYVjFDWkxuRUxxRkNBaENGQ0FoQ0ZDSEVJUW9RNDVJS0VMak9vUWtsQ0Z3dUVMc0lRb2RBQmRDRUtIR0tDVUVJVUtuVUlRckZUcFhGeEM0UTR1RkNGR1FGMElRb2pyT2hLQ0VMcHc2dUxpRkNBNWdPWUI3eEtVRUlVSWRRaENoQVFoQ2hBUWhDaEQvOWs9XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3B1YmxpYy9pbWFnZXMvZnJ1aXRzL3BlYWNoLmpwZWdcbi8vIG1vZHVsZSBpZCA9IDIwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFBQUFRQUJBQUQvMndDRUFBa0dCeElTRWhVVEV4TVdGaFVYRng0WUZ4Z1lHQlllR0JjYUZSZ1hHQm9hR0JvWUhTZ2dHQjRsSFJjWElqRWhKU2tyTGk0dUZ4OHpPRE10TnlndExpMEJDZ29LRGcwT0d4QVFHeTBsSHlZMUxUVXZMeTB0TFMwckxTMHVMUzB0S3kwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExUY3RMZi9BQUJFSUFNQUJCZ01CSWdBQ0VRRURFUUgveEFBY0FBRUFBZ01CQVFFQUFBQUFBQUFBQUFBQUJBVURCZ2NCQWdqL3hBQS9FQUFCQXdJRkFRWUVBd2NEQkFJREFBQUJBQUlSQXlFRUJSSXhRVkVHRXlKaGNaRUhNb0doUWxLeEZDTmljc0hSOERPUzRWT0NvdkVrWXhVMFEvL0VBQm9CQVFBREFRRUJBQUFBQUFBQUFBQUFBQUFDQXdRQkJRYi94QUFxRVFBQ0FnSUNBZ0lCQVFrQUFBQUFBQUFBQVFJUkF5RUVFakZCRXlKUk1nVVVJMEpTWVhHQjhQL2FBQXdEQVFBQ0VRTVJBRDhBN2lpSWdDSWlBSWlJQWlJZ0NJdkVCNmkxdlBzeXhtR1krdm9wVktiSW1tTllmcEpBTHRSdFlHWTA4YnFUMmQ3UjBzVzN3UzF3RWxqb2tBOGlMRWVhaDNWOWZaRHVycjJYYUx3RmVxWk1JaUlBaUlnQ0lpQUlpSUFpSWdDSWlBSWlJQWlJZ0NJaUFJaUlBaUlnQ0lpQUlpSUFpOGxlb0FpSWdNV0pvTmUxekhDV3VCYVIxQkVGY1NjK3RnTVc1clREcVR6QjRjM2lSeUMwaGR4SzV2OEFGSExSTE1TM2YvVHFSN3RKNmNqMldYbHh1UFplVVorUkg2OWw2TmhvZHIydm9DclRvVmFyaDg5TmdiTENMbVM0Z1IwNjlGc09FeFRhakd2YVphNFNGeERKczBxWWQzZU1QRU9IRG1uZy93QkZ2M1lmT21sM2N6WncxTThpQjRtK3duNkZWNGVWMmFUS3NmSnVTakwyYnM1OENUc0ZGeTNNNk9JWnJvMUdWR1RHcGhCRWppeTh6REJkOE5Eais3UHp0L09QeWt6OHA1SE95NXprMllqQzV6V3BmTFRyVkN3ampVWWRUUDhBNUZ2L0FITFZPZlZvMVNuMWFPcG92QXZWWVRDTHlWNmdDSWlBSWlJQWlJZ0NJaUFJaUlBaUlnQ0lpQUlpSUFpSWdDSWlBcTgvd05hclRJb1YzVWFndTBpQzBubzhFR1I2ZFZxV1M5dUt0T29jUGoyYWFqVEJjQkhvU05uQTlXK3kzNm8yUVJKRnR4eDVyaVhiYXBpcURoaDhXRzFRUDlERWtFUEkzdThibnEwZ3JQbmJqOW9sT1Z0YlIybkM0dGxSb2N4d2NEeUNzMHJnT1RkbzZ0Rnc4Ym1uZ2c3L0FOL3F1aVpSMjVtQlVHcnpGajdiRlZ3NWtYcVdpdVBKWDgyamVpdVZmRkFNR0lacDhCanhnV0R3U1NIVytiOFk5V2hkRnkvT2FGYjVIZ25vYkgySzEvNGxaUDMyRzd4bzhkTzQ5UDhBM0gwbFc1cW5qZlVsbXFlTjlUbHROMEdDcG1DeExxVlJyMjJJSWMzMUJuNzdmVXF1cFBtRDVLYlNGbDQxdFNQTmExWjFqTyswWGRZQTR1a0drNldsclhHQVM1d0JCamtTZlpjWHpqT0RpcTFYRU5IZHZMbXVpWjB1RFdpUjFFdGtMWTNaZ0hZSEVZYXBlQjN0S2VITWNDV2o2U2ZkYUswUTZWdXk1ZTZYL2JOVTh2ZUtQMG5rZVBHSXc5S3NQLzZNYTcwSkFrZThxRDJ2ejhZT2gzZ2JxZVREVzlUdWR2TDlRcUQ0UlpscndqcUpONkx6SDhsVHhOKytzZlJWSHhoeEk3eWl6LzYza0R6ZTVyUWYvRS9kYTVaUDRYWkdtZVNzZlpHODlrYzNxWXZETXIxS2ZkbHhQaG5nRWliM0V3cnBhcDhNOFcxK0FwTmFaTkthYmh5QzB5UHNRZnF0clZrSGNVeTJEdUtZUkVVeVFSRVFCRVJBRVJFQVJFUUJFUkFFUkVBUkVRQkVSQUVSUmMxeG9vVWFsWndKRk5qbmtDSklhQ1lFMm15QWxLRm11VjBzVFRkU3JNRDJPM0IreEhRanF0R2I4V2FCTnNQVkg4enFZK3dKVWh2eFB3Ly9BRW5mN21xbDU4ZmhzcmVTSHRtaTlzK3h0WEx5YWpRYXVGSjNqeFU1NGZHdy9pMjlPYWpBMUovMG4vOEFhNytoL3dBOUYxVS9FYkRPQkJwUElOaVBBUVFlQ0pYTnUwbUN3L2VkN2dtdlkwM2ZTZEVEenBrRTIvaFAwNkxGbWpqZjZXWThxaDZabVpqWHRQaVk0ZVl1UGNiZlVMWXNCMnFyTmJwMTYya1FXdXVDRDU3ajNXbllITm5BRGtmY0swbzQxajl3UHRLelZLUDZUREtNb3U0Ni93QUVMSE1EYW5ScnJqeVA0aC9YM1diQ0UrdlVjL1RxUHVzMk53elhzSUQ0TzdaNmphNnFNUGpDSTRQSVhLdGJPeGJjU2JpM2g3SENmd242VzU2RlVWWVNBZkw5UXJMT2N4cHRZU2Y5V09MYi9tNjI0S3JNTmlBNWtFUVJzZUQvQUdWa1l0UnN1eHJWbDcyTzdWbkFPcVA3dldYczB4TUFGcG1UWXp6YnpVYk9PMHRUSFlqdmFvQUlBYUFCWU5icXRjbVRMcFZYajZXa3Q2d2Y2S0RSZHBmZXcvdXJlemNhOUZ0OW8wZFUrRFdNL3dEa1ltbnFBRG1OZHA1SmFZa2ZSMS9vdW9ZdkgwNlJZMTdnMHZkcGJQSk93OXlCOVF1QWRqYzFHQnhyYTlTZEFhOE9JNUJhWUh1R3E5eUx0bGljVGlNVFViaDMxM3ZhMWxKdTFPaXlYRXllUHdtZDdMUml5cU1LTDhNNmlvcnlkbnhHSmF3QXVJRW1CNWs4RHFWbVhOdXplS3FpcFZ4bVkxR3UwZUdpQjhsTzB1MHR0TGpZY24zVnBtWGFjdUVzSnB0amMzUGxFR0I3RlRmSmdrYnNlS2N2Vkc2b3VlNWYyNXFGdW9oanFiU1JxTHdIT3RZYVJjSG1TQUxMUGlQaUNOUGdvT0RqOHZlRWh2RXpBblpTWEpnVC9kOG40TjdSYy95YnQxcnhMeFdjR1VURFcvS1ExeGpkd014dnVPUXQzcDQ2azV1c1ZHRm9Fa2h3Z0R6TXFjTWtacTBRbGpsRjdKS0xIU3F0Y0phUVFkaUNDRmtWaEFJaUlBaUlnQ0lpQUlpSUFpSWdDalpsZ20xNlZTaStkTlJoWTZEQmh3Z3dlRGRTVVFIT2NaOEpNTVIrN3IxbU80TGkxNCtvZ0UrNjFUTlBobmpxVWxnWldhUHlHSGY3WFI5aVYzRlJzZmhSVlk1aExoSTNhWWMwOEZwR3hCdXFKWUlQMFZ2SEZuNXh4bVgxNkJpclRmVFA4UWNKOUNiRllXWWh3NTJYVzhWMm94dUJZNXVPd3ZmTURpMWxaa0FWR2d3MDFHM0RYRWVnUEFXa1pwMjB5eXRQZVpXK21melUzdGFmWHd0ajNXV1dDTjZabmxCUFZtclZhdDlYUFBuNnFiaHlTTlFCaFE2bVo0Y2wzZEY5TnAyMWlYZWhjMEQ3TlVIRU9hVHZxK3UvcEtyNnZ3eWh4ZmhsK2NYMUtqU1pKSHFENSthcHhUSG9laEYxbnAwWlhIRkhQalNNR1p5U1hSRTcrcXM4c29ndEVyNFpob0hVRlQ4dXBCb2pkY2xOVlJHVWtvMFpLMkJCSTZSN1hLeFB5MEhoWnNmaXd3RUUyMm5yUEVLYjJSeWQxWUI5VittamMwMlJlcHAzTW5aZ081OXVxZ2syckdIRmt5NmlVdU15U3E0Q0QvSzNnRHFUdC83V3pZQ3EvRE1vNFpyV01jNHpVYzFwN3g0RWFqTy9KYUo4ckJiWmh1NXdyWEV3U1JNRytpU2ZGY3lKbUk0QVZiajhyYkl4RDM3aXdhNTJ2MEc1RmpzQ0lYZTJ0bnY4TGkvRCtyeVRqaG1IU2FrQnJmRTJrVE11QU4zSHlCZ0xWTVNhZUtxUDAxQTJrMEZ1bWRKZnFiNGpFK0VEWUc1bjBWOVh5ekQ0YWozdFdkYmdKTHlTNXVyWmpSSmNiL2huZm9zZUR5aW5yZHBBYS9ZRjhnTnRPbGtRSE82azNYRzZQUWgxcXlOb3c3MmpVSEJqQ1BDU05UaUkrYTNoRzE5L1RuNzdTOXBPNllXVW1ndVlkSmFEWnUxM1gyLzQ2ck96czZHdWU4a2dCMm9IVEEyamtpUnY3clZNM3A5eWFsUmphanJGcjNtQzF3UDVocTlPZUFwTFlpb3VXMmZXQndXSXFhbnVOT25UZERxcmpJRWZOcEhEcGtHWXNZaFN6U0xXRmpRYWdJRDNNSURBM1NTSWk1Y2ViK3lxc0xqdExRMHVtK3NpUVd0dFl6K0tQTGtyWk12ellNWVhORUVjdW1YY2t6NUM4ZEFVSlRUV2pOa2ZhMnBoV3lXdGdnQWEydUJhR1dnWEFnNytwWFJ1eHVkdXhkRHZIbG1yVVFRMGl3QmdhaEowbnlLNGRubVlpczhnajAydWVPRmd5czFLRmFsaUI0SE5NeXdrU0FZOFFNV01DUkpDMFlzdlY3Wmx5OGExYVd6OUxTdlZ6ckpmaUc1OVhUV3BhVzZiUEV3NHowOUQ5aXVnWWF1SHREbW1RVnNoa1UvQmhuamxEeVpVUkZZUUNJaUFJaUlBaUlnQ0lpQUx4ZXJGaUtnYTB1SkRRQkpKMkFISlFIbGRqWEFod0JCc1FZSUk2RUZjbzdaNVZrZE56djMvQUhkVG1uUi9lWDgyaWRQcElDMDd0QmlLdGV1OXRQRlZzWmY1dE5RRGMyYXdPUGg4NEFQM1dQRGRqY2RVQTA0YXI5YVpIM2VRRmtuazdhb3l5eWR0VVUyTXAwaTQ2R2t0bXhjQTBrZVlhVCtxeDBocCtXM3AvZmY3cmJHZkRyTVRFVTJOL25jeitqaXMxTHNMaVdmL0FMQmFPQUtRTHA4M0VnYVI2U3Nzc2lpdHM1RGo1TWpxS05OZTBtQ3BUYTRhU0Ewa2NFeGYyVjltSFpWeld1MFZOVDIzMEVSSWlaRHBpZktBdFpybHpmQzlqbWtjRVFWeE5TOEVjdUdlUFUwVEsyTmdXSHZLWUtvNXdjNlpJRmh4S2lhckRWc2V1LzhBd3JIRGFXZ0FibGNrcVJtYVNSRXBZVjlhcXhyaVRxZGZvQitJMjJzdXNabmsrdDlNMDlZN3NSNFkwTkFhSXNlTGNiM1Vic2l3dlkzdjJnNlcvdXZDSjB5R3QxV2tuVTF4dnhDWWZHMUhWbmtPSlpWZm9EWk1pbTF3WjEzUGpQb1ZGeTdIdjhMRjhjTDlzbzg2T21sb2EwazFqcEZWN29sODZXazh4dkd3VzNaZHBHa2wvaFlJL21ON3V0NUMza09xb2UzdFZtbUF3YnpUQURnQ2JhWTBtREU4eHZzb0Q4TStvUTE3bnRCdm9ZYnp3YWpvaHNmbEUrdkM0a2VnOXhMZlBjWFR4RmR1czJvSHZITjZ1QmhvOHdEUDI2cVRUckNvR09PNEpER3RQNWg0bkVqY3g3VDVYMTNOY3RiUk1seEpFV2tsNUVYQnR6dlBtRjhNb1Yzc0x6VkRMQWFSODhHK2dSWm82bTl3dU95eFJpMVM4R3c1em5CRE5MaDRXL0tTU1hFc0UzUE95MFhOOFozelhWWEU5MjEybWt6aDd0eVhYdUcya2MvUWhUczd3am1VdEhldkxRWWl4SGVXczEwQTJCaytxcnNLRzFNTkIrYWxiVEFIaDFHVE1ieVo2cWNGUnlraVZrdUVyVjNHc1JJK1V6QUJPMjBSc29lWTk1UkRod1M0UUxpdzVJOVlWalVHbWdEU3FHbTB4SmFDUk93MUQreVluTGpVYUplU05JOURPOGRKRVhVbkpFVktWbE5oYWpXdGU2WnF0RFEzYlltNUhtRXJoejRNbU9UNnJGbTFEUlZCRUJybTZUNUVEYjJBOWxsb1Bmb0RHWExqSHJPMXZQWlRVRWhMTTM0SmVFeExxVDJzcUd4YkxEOVhBQStZTFYwNzRiNTdwQXd0Und2SnBIYmVYT1orcEgxSEFYT08wV1dGdmRhblQ0ZEpJNnR2QTkvMVZWbUdPZlRiaFF4NWE4Z3ZNRzRFdDB4MGdncWNIVWswWjV4VWxUUDArQ3ZWUmRqYzlHTXd6YWtROXZncUQrSnZQb1JCK3F2VnZUdFdlYzFUcGhFUmRPQkVSQUVSZUZBZW9xdWpuVEhWWDAveTh6dWVRc3JzZjBXWEp6TU1IVGV5Znh5L0JPSlVQTUtGR3N3MDZyRzFHSGRyZ0MweGNTQ3NMNnhQS3hseXp6NTM5S0pMRitUN3dWR2pRYnBvMDJVMjlHTkRSN0FMN3FWeW9wSytUVWhZWjh5VFgyZEZzY1NYZ3lPY3ZpQWVGR2ZpeE1DNVVxaWROM1hQNkxBczBaUzAvd0RaYTR0SXc0ekFNUHpVd1NiWEEvd0t2cGRtTUlXdUZXa3g3bkNKaTdSd0c5STY3cTY3K2QxRXJ5UFJTemNuNHZ2aTJSNjkxMWtjazdWZGc2bURMcXRLYXRBbVNZOGRPZnpnYmorSWZWV0hZcjRmMUt3ZFhydWRTYVIrNUFBMWs4UElPelJ3Tno1THBsT3J3cEIyc3JjWDdSN3h1dG1WOEdLbmZvMEhQdjJxblg3dlZEbmo1ek9uU3dHUUkza3pBV3Qwc2JXd3JpMkRJSmJUSjVMaTV6blRGL1hoZFp4V0VaV0FEeGRwbHA1YVIvbHd0RHpETEg0WjlXcFZBYzUwQ21URzAyQUIyRzVnZVU3TFZpbkdhdEhvd25xbWEvaU1YV0lwdWM0bHp6SGhtOXdBTGdXSmE0eDVTdGt3V1l2dzRwVW10YVhrRno5TVhOdWRnTDczVUx0VmhuTndiM2ZLNHRhYlRMZnd3RDZibFNjdnhkSjFRMVFXa0NucDA2ZG9EUTBBamlRU3JmVmszdEZObmVhR3BWWUhhR3NuVTV2aU9vaHN4MU1HeE1YVi9sRmFtd3RGUUdYQXZiYndhZUltNGtrM2o2clhjM2JUL2FxZFRUWUFnajgxamFUdi93QUkzTjJsNS9nYm84aUhHU0I2UlpkWGlpeVN1T2k5N1MwMmZodXh2eWpnYlRiYzlaUC9BQ3RHZXg5SnozdGJJSUlQbUhDRGZtM0hrRnNlWjR3QmgxYjZqemVEY0Q2QWhhazdFdmNIR25xYzFzVGZ3Z2JBR1QraTdFNXZSay8vQUNXbW1ReWRCY0NRYnhwSFhyTjU4bGNmdGdaUXVZSkJJUFhWY0gxdnQ1RmEzVHI2Q2U4YWZSdXhQbVZKdytZc3EvdVQrSUMvQUpKSUYvOEFMUXBkVy9KeVZMYUdiVk5UcUxBTlZTTlpnandnR1pKL2xzclBMcVRHVk85Y0NkaTFvMjZUYmVCK3FyMzVMV29oMVE2WWdTKzVKQWlHZ0FURS9xcTR2eGIzdGFLaGJyTU1rdEZ5WUFNM2FyZXFmZ3B1amNjM3JqRU1aU0loMGgwMzhBa1NUNW03UU9TVkZiaHFOYW9ZRjJ3d09FZmhPM21DWldIOWpHRHBPOGV1b0pjNXhtQzlvdHZleGhZZXpiQ0dIUzhsMWo5YkZWclhqME5HKzlnTVpWbzRtcmg5QWlvQm9jZU5BTWtqa1g5d3VwdEM0cGljMU9HeFdIcmdUcGFIdUhVSHd1YVBkeTdXeDBpVnI0N2Jqc3ljaU5TcytrUkZwTTRSRVFCUTgzcmxsR280R0NHbUQ1eFpTeXRHK0pPTkE3aW1IUWRXb2pnMk1EN08reWhPVkluQ1BhVkdxME1TK200UDd5U1grTnhOaVhUdEk4aVN0M3dtSWtlY1Q3OUZ6dnRmZ1JTT0hhMDcweTgydExuQWFnZXNDUHI1cXk3TTVuVVBnMURTMzNDK2QvYUdGTDdwYlBVZ3U4ZEhRR1BXVFdPVlJVc2VUL2xsOVZzZmJkZWREbHRMd1FlQjJXT0l4Z0d5cGF1TmM5Mmxza2xRY1JqSFZYYUdmOEQxVnZsMkhGTVd1VHVlU3NzKzJWL2J3WHhqSEdyOWszQ1VCVEhWeDNQOWw5dWVVQlh1bFNsQzFTOEZGN3Rud0hLUlRmd2xPaVNKWDEzWlZrY0U0N0l1U01OU2xwdU52MFgxU3FMT3llUW9tSXBhTGpZL1pkbGk2cnZFS1Y2Wk1FSDE2cUZuR1dNeExPN3FXY0xzZHkwOEh6SGt2YVZTNEFVbnZRWW4zNkxUaXpkVmIweURpMHpuZmFqRk9vczdtcC9xYUljRGNQRVFTRHVadmRhTmwrYk9Zd3RZTGt3UnlaRnZTQXV5ZHB1ejlQR01hSHdLakpOTjhURWk3WERscHRJWEpzMnlsOUY0cHViRGpWTm9INU9EMElFK2tMMWNHV0dTT2k2RXJJZEdvNXptZ3ZNbTB4YVk2NnY2TDdyTkZNalVaZElEaEJCQnNaRWJqYmRiRFJ3Tk0wMnVndUlGeUJzNlcrM1B1dnJQOEt4dXA0YjRuTjNJNE5vSU82dGROMFdRblJyV0lZNnBEUy9jQXY4QUlFV0hrU1FSOUZubzArOExtTUFheHBzUDgzS3Jzc3E2V3ZhZm5GbzRjQ2JIZUxUSDBDdWNyWXh6QzZ3cUNiei9BSlpIQ2p2ZlYwVitMd2dhWkoxUWR2ek9tdyt3WDNqOG4wdG1CcUVPZVcyZ3RFZ0Flc1hWOWtqNk1semdCVTUxQzgvd2txTG5RQlk1em9oMENEeEd6dm9aUDBVb3lkcEZiWGtoWW5PUDJodE9rQVEwTkRxdCtTMEhUUFFGMzFObGh3V0FMb2VXdGEyYkhtL3BlWlh1Qnkxc0MwQThlUVBYbXl2WjB3MEhZU1pHd2psU2N0NklWNksvRVlwMUtveWs4YTlSTnpjeGI1cmV1L1JRc2V5clNmM3RGa3RqeEFmaFBvT0NvdUx4WXExaVpzQmIwSFZlNVptTlR2eWFjYVc3Q1NMRHpCdk1TdXBNTlVXR0h6TjlhcTJwRFhkM0VXMU5sdkRoeUpuZGZvdkR1SmFDYkVnSDNDNGwyVW9OeE5VYWFiQlVMcG1UQjVPcnFKQzdYZzZSYXhyVGN0YUFkK0JISzBjZjNvemNscDBaa1JGcE1vUkVRSGk0MzhTc1U2cGpDMy9waUJFN3VBTSt0bDJSY3I3VXVaKzFQcWQwSG5VR2thWkdrV0ozamdjTFB5SlVqUnhsY2luekRPNk9MYlRvMWlhVDJ0R2g4Q0FSWTdjV0V6MEN4WmJRZlNjV0Z3ZUNUcGMwZ2dqZmp6SzJYRDVSaEt3YS91R2FnYldHKzJ3NStpdEtXV01FUXh0dkw5T2k4SGs4bnZIclJ2alVHVldFWlU0YjZMTS9LSzcrV3RIVWt6OWxmMFdBS1NDdk9oaGg1YkVzOHIwVkdCeVhRSW43YnF3WmhvNVVzTlhwWXRDd3hTMFV5eXliMllBd0xJd0RaTkM5WTJESzdIVDhFWHN6RjBXQytITjVDeFBmZFphYmxhcFJ5T2lMVmJQZ1BLK3crVXFVNVdDNjUxY0hzYVptYzBkQjdLQmoyRU5PazZmUGVMK2FsYWtmQnNWSEpCU1dpVVhUSVdIeGZEamJjSGFmK1ZyL0FHd29ZZXN6VTgvdkdpV3VCTWpUZnhBRUdQUWhXT2EwSDZmQ2RqSUgyL3F0SXFZR3NhYnFoYS9RWCtNazdTUU5Jdk81QTI1S254ZVBLK3lkZmt2WFh5WktHYytGalhNYXh6UUphRFlqY3dmUHFWbXphc3lvME9pQTYzWFNlQ2ZWYS9uZERTOHVhVDhvQkZ2REFBNDZ3UFpRYTJZT1pURFQwTG9ISVBXMjRLOUg0MWFaSWk1cVF4N2RMVE13WEM3U0QxdEkrcWl1eE9seDhXbmp5K2hVOW1ETDJFa3dUK0c4ZWtkVklwWUlXN3hnMGs2UjYvNFZjcVd3Mi9ES2x1UHZPb2tpNGpnanIwMlU3TU1RL0ZVaTRiTVlRNENZTHlMMzV0UCs1V2xiSndSRFdpU2ZZQzkvWlI4cGErbGlLbEF3NXBZSE5Gb21RSkgwS2twSjdSVzllVERsR2FEUkE4V2dEVWVSeHg2S1JpcTVydExXZ2dPRjNBWFBrU3ZuQjVjeW5qYWJtdDBoeGNIdDRJN3R4Qmp5SVY5bmxhblRvdUpCbnk0MWJEMVVYWG80bXpuOWZCdVlkTVFUWUVHNTJIVmJKMmZ3bWtPOE5tdEpPMHVKQnQ1MlZmZ3FScVZPODZEd2plNjJyTHFsT2tOTWx6eVlJQWt5YnhBK2doZGxKK0JXelpQaERsUmFhdGJURExzYlA1cEJkcDVqKzY2ZUZUZGxxQnBVR1VuVXl4d0VuOHBManFNSHJmWTNWMHQyTlZFOC9KTHRLd2lJcGtBaUlnSXVaWWdVNmJuZVVDKzVOZ1BkY296N01hVHdIc09wNE1QRUVYMjUzOVYxVE04S0tyV3RNUnJhNi84QUE3Vi9SYXQyejdIZC9OYkQycS9pYmFIenZ2YWZYZnlXZk5CeThGK0NjWXZab0haek9tTmxzbHJwdVRNVE43TGFuOXFxRExPcURWTzBIYzdMbk9iWmJVcDRrVVgvQUxzZ2dQTFRNU0NSZS9senlwUnlZdEdxSEVpWUxqUGt2S3k4U01uczlGTlNPb1pibTFHcDh0UUUvZjBoVHFsY0RaY2p5ck4vMldvMG16WEVCeElKZzNIdGRiVmhlMXJEKzhrUndkbzQrdjFXSFB3cHdWWXpuWFp2ZE4xcm1Tc2dldFV3dmFxZzRYZUR5WS9zc2g3VTBIR0pjMGRTRWlwd1ZORmJ4TTJmVXZROVVHRnptbS9VS2J3NGpoVGNIaUQzY3VGNU8vcW9QTTdxaUx4YXNtMTRpVkR3bVlOY1NBYnRNRWNncnl0V1hQdTFtWllqQll2dmFiU2FibWdreDRadUMxM3FBRkhHcFpKMUZVeWNZV3FaMUpqMTgxSGU2b3V6bmFDbmlxWWUyem9selR1MmY2S2JYeEJsWDVadU1kbFN4dXpOKzBSYi93QnI3N3dFS3R4V05heHBjUnNKTWIyVkZoKzF1R0x0QmNXK29NZTZ6WTVaSnI2cTBXL0diUmlydEk1NDRXdVpwUU5OcjJzcUhVNGF5d2lidDFhWGROLzBDbXZ6ZWs0UkljRGFXa24zQUZsVjFNSlFGQVM5emdIRXRkcU90ZzZDVEpiYmI2clpnVTFLeFZMWnFlV1ZwRlVWYnVZREpQTVh2OURLbVpobG9jQlhhQVJwMHhGdHRyK2F6NDNGVWFUUldwc2E4bVJxSU15UUNabXgzbS8wVWZMYzJEbXVaVnRxMjZBL3FGdGxkbGkvc1VlRXhIZEVTUkk2emVQUHJIS3VUVkZRNnRUUzBiTmtBekVFM2hVbWR0QmNRMTBEcTBEMHNlUE5NUGduUE1NcVFSRzl3YmRTckxUOG5ldnN0VG5OTm5nSXVQOEFEeXFRNWkwNHRsUnNsMEVIK0VGcnJIN0dWTXhPVHVqeE9rN1dzcXI5aTdzRmdFbHdpMi96Q2Zza2VxOENyTmt5S2FsYXRYTXdHQmpMV0FjWmQ5VEE5L05ZZTBMM1ZRV2lDQVFBQnlZTWY1YlpadXo5SjFJTlliYXlYUnpBRUQrdjJVTFA4eURYNktiUUNOM0RmNkxsdnNRVVNsZGk2dE02WnVOOU81QTRCODExYjRTOW15UC9BSmxSc0F6M1FPNW14ZDVEY0RyY3JUZXltUWZ0TmVteHhoem5FdjhBSnJSSkk4NG1QT0YzM0M0ZHROaldNRU5hQTFvNkJ0Z0Zyd1F2Wm01TTYrcU1vQzlSRnJNUVJFUUJFUkFlRUl2VVFHamRxZXdJeFZaMVpsYlE1L3pBdGtXYkZvTThMWDZlU3ZvRnRCeis4WTJBSHdSWUM0djVycTlSa2dqcXFhcjJkWS81bk9JaUlGamZ6RjFueVlyOEl2aG1hVk00MTJreXhyQ1dreTBpOGZxRnJXR3hoalJNdEZyeDRoL2RkM3IvQUE5d2pxWnB0TlJyZndqVnFEZlRVQ3RaSHdjWnFuOXJlRzdnQmtFZlhYSDJWWHd6UnBYSWhXemwyS3JzRFQzTWs3UUpqM1dDbUtwYkRpWko1dnZzdXE1dDhQYTFKczB5S3dpOE4wdm4rV1RxK2graTByRjVTK1kwdWtHQ0MweUk4bFU0dUxwb3ZXU00xYVpRNVpqNm1IZTVvZVd1SmtFR0FmOEFJVzVVdTBWWnpCTHBCMzVJV3VZN0xITkIxTmtIcUk5bFk5aHV5T1BydWM1allvZ1dOWFUxcnBJa01zWk1jbzhNWit0a1pUVVVYZ3o2cUtSSU1FY3JMMmI3UXNmWEZERS92YVZjQ2s0T3VOUmNOTnY1djFVM0NmRGJHVlBCVnEwcU5OcDNiTHk4ZVE4T242bjZMWU1oK0dHR3cxZHRjMUtsVXNNdGEvVHBEdUhXRjQ0NkxzT0pVbEpGVStSQ21pNHczWXZCMG5GOU5qbU9pQVE5OXA2QW45VkN6RER2cEdIM0hEaHNmN0ZiaXZIQlhjamlReXF2RE1rTTBvdTNzNVhuZU5EYWJ5ZGczcnliUU9xNXptQkIzQjFPaDNreUJZZTM2cnJQYTdzbFdmcS9aMk5jMG5VRzZnQ0R2RUcyNjVibUdWMXFNaXJTZXpmNW1rQ1Q1N0xEeHVOOERhWjZDeVJuSFRJR0JEZ0RvZkJIWGFEYmNYRWJxM3lnVjhSKzVMM0I3anBEWUxwTnhBQlAxVEpzb2ZXWTZuUllYdkpFUUppZXBIeWp6UFJkeDdPZG5LT0VZM1N4dmU2UUgxSThUaUFKdjBuaGJvNCszZ3F5WittaU4yUzdOTnd1RGJoNnNWU1pOU1FJY1hIejZXVmRtM3c2d3J3NTFJT3B2ancrSWxrOFNIVGIwNnJkVVdoNDR0VTBZbGtrbmFaK2I4MVpUcFBjd3RjeXEwdzVzVHBPeEJqckVxNHkvS3E0WTExU2pWRkozTGFkUy9JL0RJWGNuWVZoY0hsalM0Yk9JRWowTzZ6TE91S3Z5YVh5MytEZzJaNXd5Z1lOS3EyOGFuc0xmOXV0UWN2d0dMcnVENldHcXZhYk5jR25TWnVQRnRHMTlsK2huTkJzUks5WEZ4RitUdjc2MTRSeFNoMkF6UjcydXFHblRHd09xWE4xV2tCZ014UFVMYjh1K0ZtQ1k3VlVOV3M2MDZuUUo1UGhnM1BFcmZFVjhjTUlsTStST1h1aXF5dnM5aHNPODFLVkpyWGtSTUN3R3dBRmdQVGZsV29SRllrbDRLVzIvSVJFWFRnUkVRQkVSQUVSRUFSRVFCRVJBSVhta2RGNmlBK1N3ZEF2ZElYcUlEeUY2aUlBaUlnUElYelVwTmNJY0FSMElrZmRmYUlERGg4SlRwaUdNYXdkR3RBL1Jab1JFQVJFUUJFUkFFUkVBUkVRQkVSQUVSRUFSRVFILzlrPVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wdWJsaWMvaW1hZ2VzL2ZydWl0cy9waW5lYXBwbGUuanBlZ1xuLy8gbW9kdWxlIGlkID0gMjAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUFBQVFBQkFBRC8yd0NFQUFrR0J4SVRFUlVURWhNVkZoVVdGeHNZRnhZWEdCc1lHQnNZR0JVZEZ4Z1lHQmdkSHlnZ0dCb2xHeGNXSVRFaEpTa3JMaTR1Rng4ek9ETXNOeWd0TGlzQkNnb0tEZzBPR3hBUUd5MG1JQ1l2TFMwdkx5MHRMeTh0THkwdExTMHRMUzB0TFMwMUxTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExmL0FBQkVJQUxRQkdBTUJFUUFDRVFFREVRSC94QUFiQUFBQkJRRUJBQUFBQUFBQUFBQUFBQUFBQVFNRUJRWUNCLy9FQUQ4UUFBSUJBZ1FEQmdNR0JBVUVBd0VBQUFFQ0VRQURCQkloTVFWQlVRWVRJbUZ4Z1RLUm9VSlNzY0hSOEFjVUkzSXpZb0xoOFJVa1E1SlRZNklXLzhRQUd3RUJBQU1CQVFFQkFBQUFBQUFBQUFBQUFBSURCQUVGQmdmL3hBQTFFUUFDQVFNREFRWUZCUUFDQVFVQUFBQUFBUUlERVNFRUVqRkJCUk1pVVdGeGdaR2hzZkFVTXNIUjRTUHhRZ1lrTTFKaS85b0FEQU1CQUFJUkF4RUFQd0QzR2dDZ0NnQ2dDZ0NnQ2dDZ0NnQ2dDZ0NnQ2dDZ0NnQ2dDZ0NnQ2dDZ0NnQ2dDZ0NnQ2dDZ0NnQ2dDZ0NnQ2dDZ0NnQ2dDZ0NnRW9Bb0FvQW9Bb0FvQW9Bb0FvQW9Bb0FvQW9Bb0FvQW9Bb0N1NGh4M0MyREY2L2FROUdjQS9MZW9TcVFpN05rSlZJUncya1RiRjlYVU1qS3luWmxJSVBvUlVrMDFkRXh5dWdLQUtBS0FLQUtBS0FLQUtBS0FLQUtBS0FCUUMwQVVCek5BRTBBVFFCTkFFMEFUUUJOQUUwQVRRQk5BRTBCVWRvdU05d2d5WldlZmhNL0QxMDg2b3IxZTdXT1RQcUsvZHJISlVZVHR1djhBNXJlVFdKVnAraEZVcldKTHhxeGxoMmduKzlXTlpidXF3REtRUVJJSTFCQjJJTmJVNzVSNkthYXVqcWFIUm5HWXhMU0Y3akJWRzVQNERxZkt1U2tvcTdJeWtvcTdQS3UxdmJuRVhjeVdKczJ0cEIvcU1OcEpId2p5SHpyeTYrcXFTWGh3dnFlSnFkZlVrOXNNTDYvNFpuaCtDV1JkdlNReDhJNjlXbjk4Nnp3aWt0MHpKQkpabjFQWWV3dHEydUNRMjF5cXpPMGY2aUorUUZldHA3ZDJta2U5bzBsUlZqUUJnZGpWNXFGb0FvQW9Bb0FvQW9Bb0FvQW9Bb0FvQW9BRkFMUUJRSE5kQVVBVUFVQnhlWWhTUnFRQ1k5QlhHZFhKV2NNN1FXYndHdVJqOWx2eVBPcUtlcHB6NjJacXE2T3BUemE2OUMyclFaRFA5b3UwNlljOTJzTmQ2Y2w2WnYwckxYMUtwNFdXYnRMb3BWdkU4TDcrd3gyTnY0bTZibDY4eEtOQVNkQm9USlZlUTVUejg0cXlpNU5Ya1ExY2FjSHRndURUMWNaQW9EQ2NiZjhBN2k4RzExajJnUkh0V0tiOFRUUEcxRW4zc3JtVTRqWW1Seit5ZVUva2F3MTZlNVdNRldGMWprazltKzB0N0J1RVlGN083SnpIVXBPM1dOajlhYWZVVktIaGtzRjJrMWM2RDJTeXZMK3Y2UFZzRmpFdTIxdVcyREl3a0VmdlErVmV6R1Nrcm8rZ2hPTTRxVVhobUQ3V1k5cjdITC9ocDhQbVpndCsrWHJXV3RlZkI1bXBxT284Y0l4MXJCc3o1WmdTYzAvZDNrZlg2VmxqQjNzWUZGdkhRY3UyV2U4QUJsUUNBT2NEL2lxNmtKVG1yY0VIR1U1K2hxZU44U3lXcmVGUm9GdFFMa2MzanhEekFNKzlZdTA5WEp2dUtmQzU5L0w0ZmM5bVRVWUtIa1R1RDQ3dVd0ZmNJaHZ3SjlPZGF0UFB1ZG1jY01RbnRramRWN2h1Q2dDZ0NnQ2dDZ0NnQ2dDZ0NnQ2dDZ0FVQXRBRkFjMTBCUUJRQlFEZUtVbEdBM0ttUFdLNCtEc1hsSGlWN0d4R3ZpL2VuV3ZuR25mQjlWdlZybHgyZDdmUFpMV2JnTGlEay95dEdrbWRGNjlLOUxUMVp4VnBjSG02clQwNmozUncrdjU1bWV0WTQzWExTV2RpU2VzblV6V0tia20yejA2ZHJiWW5xK0Q3UjRTMWF0b1h5NVZBMTAxalhVK2RlcERWMG5oTThPZlo5ZHR0b25KeCt5UUdVeUNKQkVFRWRRUWRhdDc2SlgraHFIWC9BRnUzMGI1VTc2SS9RMVBRb08wNHRYb3VXekZ4WUJCRUJsOWVvbjk2VlZWY1paWEppMVhaTmFwNG9MUHVadmlDc0VJQ1pwM0E4WHppc3RXOXJXTU11emRSQmVLRCtWL3NaMFk2Q1Z1OUlESGNlVGVYbldXTlgveGtaSHA3dXo1TDNzM3hwc01sMnlUL0FFN2lFcWZ1dnNUNkZmd0huV3loUHU3eDZFOU5HZEZTcHZqK1EvNmhiWXdEOHF1VTR2QlB1MmNXblZpMGVrankzL2ZsWEUwMi9rVXpqbXhLNFZaSDh4WlJkMnVxU2VjS2N4OXRLNXhKSmRXS0ZQeHIzSzNGeVhZR1pMeDdrMThzMDVWWGZtLzhtaWNTN3VOQkMrdjEvWnIwNnNzcEhlVGZjRHZGOFBiSjN5eDhqSDVWN3VsbHVwUlp1cHU4VXlkVjVNS0E1RGlZa1R2SE9Pc1V1RHFnRVZ3ZGlENlZ4Tk02MVlVVjA0RkFGQUZBRkFGQUFvQmFBS0E1cm9DZ0krUHc3WExaVkxqV3lkbVdDUjgvOXFqSlhWcjJKd2tveXUxY3l1SzdQWXdBbnZWdmVSSlZ2YVNSUHVLOCtybzU4eGxmM1BWbzlvVWxpVWJleFFuaU54Q3lnM0xialNDU3NFN0NONnpRVlNMdzJqWFZkT2F2Wk5HQ3hsMjh6cVFBV1o5V09qTDR2dGdhUVRydElpdFNTZkpuZU1JWGhuQzdpaG1GdHJ1Wng0c3B5cEJ6QTVzcEpBa2c3QWdjdHE2NUxoSEZGOVRwY2ViWklCSGVINGlObC95S05oc0pqcDVDcVpSM1B4SHA2U2x1V0RRY0V3Mkd2QWQrck04Nmt1NUI2ZUdZOXFsRER0WW5YMHNvNVQrWnNMTElpaGJhZ0FDQUFJRWVYU3RLaWpJNFNmSWpYSnJ1dzZvMkd6QjNHdnBYZGlKcTY0STkrekVrZm5SMDBXd25mREtiSDJnUkZ4QXc4eHk4aU5WUHlxcWRKUGxGbFhSYWZWSzA0cC9mNS8wVmRyQUFPaFFnb0dVbTFjUGhpZGNyZ0VycE9oQjNxdFVrbWVQcXYvVHpqbWs3K2o1K0QvdjVrSGpYQzdtRnZISkpza3piSklNamNhaVFTSmllZlFhZ1YxS1RoTEhCNE9vb1NwTzBoM2hlUENwNGlSNS9wMXFGT29veDhSaFVkN0xmc3J4dTJtUHRQZDBTV1VIa3BZUUdQdVk4cE5SbzZoU3JxVXVPUFl1cFJVWklzKzBtQ2F6anRaeXMzZUtlUkV6SHFHMCtWWWRYcDNSMURsMGJ1dmovQUtXVklYWXJYUm1KbVB1aWRTQit0VlNlK1R5WjVZd2NXKzJHS1dMS1pMWUdnaFpQbVNUUG55cTVkb1ZZVTFHRmxZcS9WVkY0VmdadWRwTVNRYytJZlRhQ0YvQ0pxaVd0MVUrSk00cTlSOHRsdHdYRmNUdWxSYWE0RS84QWt1cjRZNnl3aysxYmROK3ZtN0p1M3IvcG9nNjBuaDQ5VHZ0Qng3K1Y0aWh6VDRFVy9BMGJxMGNvQkJyMHFsVFpVdjFzcm52VWFFcWxDejliRmwycTdaSmFHU3l3TEVTWDNBQkVpUE9LcjFldWNmQlM1OC9JMGFIc3VWWHgxRmo3bFgyRTR4Y0xTN0ZrdU1CcVpnem93OTlEN2RLemFDdE9FN1RlRy9xWGRvNldPMjhWWnI3SG90ZTRlQ0lXSE0wQXRBRkFGQUZBQW9CYUFLQTVyb0NnRWRvQko1VUI1dnhMdGZleERsYk5pN2tHMllHMkNPclR6OHE4MnZVbko4MlgxUGUwMmxoVFY3WGw5RjdERDI3akwvVk5yeUFVa0EvM0VnL1FWbjJwZFRZNDM2R1gvbldzWFRtdEtRZVlKYVBRRTdlVzRxVFYxWnNvaTFmQ0R0THg4UGh5bHR0U1JJSE1ibjI1UlhZUlVVWDA0dWRSTnJCajhHcG1yVWVsUnA3ZURZOEE0Z0xiZ09OanZ0N1R0VmtXazhsdFduS3BEQnFQNStkVFA3OU5hdnVZZTR0aEVxemlGM2tkTjkvMXJwVE9uTGdraDQ2ZW43M29VMnVOMzJRQ1NOZlQ1VEhLdWtvS1Rka1YrS3hPK2tkZjdaMzlhaTJhcWRQODlUUDRyY3dmOWowOHdSc2Fwa2VyVDRWemxNWXJqdXIzd2hwVnVRTWFIcHpxS2FlR1pkYjJkVHJ3NC9zMk9KN0pZWEdZTzJ1R3kycjFvYUdQaUpBekM1dVNDUkliV1BtS25VMDBhbE8wZVVmRGFyUnVoTGJiMlBOOGZnTDJHdmQxaUV5bmtUc1IxQjVqekZlUlZvU2hocXhoY2I0UFI3ZkZsdVliQ0M4aTNPN3QzYnQwdE05M1ovcEtQN25ka0d1aHl0MHIwNmNvMU5QR1ZSY1graG9wMjdwemw3ZkV6RjY3YkJOek5ESFVCUkk5STVBYlJYa1NwUXZ1dmIyTUVxYmZpT3NMaG54THIzUzV5QjlrSFNUT3ZUMU9sVmR6S2RvVTh2MEtYU2NwWVZ6ZmRtdXlDV1NMbDRLMTNrTjFYNS9FM255NWRhOWpSOW5xbDRwNWYwUnNvNlpRekxrMVJyMHpVZVFmeElpM2oyay80aUkwUnNmaGovOEFNKzllWnFxVjZqYVBxT3lvcWVuVitqYS9uK1RJOXJRV0NNamVFS3F2QU9tcGdrN2JBTEV6cEVhVm5wS056WFRycW5lSHF5KzdPY2VGb1dnNVZWUmdjckVJNzVUSUNLZmlrZ0RmbUtiR3A3dkxKWHFwVXB4YVR5OGVpOXkxNC8yMXhMTmxHYTJEc0VpSS91R3JIemtDcWF1cDFGVHJaZVMvdmt6NmZzL1RwWXkvWCtpZHdMaFJ2bTJsOGx3MzlTN25ZeUVId2drNmlXalR5YnBYZEpSZFNxbk4zUzgvejh5VWEyb3FVV29ZNkszNStZTnppZVA0UzFvK0l0TEhMTVB3RmU0NnNGeXp3MVNtK0V5Ymc4VWwxRnVXem1SdFZQSWpxUEtweGtwSzZJU2k0dXpIcTZjQ2dBVUF0QUZBYzEwQ013QWs3VU9wWHdaVGpmR0M4cXVpL2pXR3ZXYnd1RDJkSm8xSHhTNUtGWEpQWHpyTWxrOVpwSkVmaUpPV0orVlRrc0Nubm9aekhnSFJocjVWVm5xU1drdTdwbFMxaERJZytWY1JzcDZWeFl4LzA3VUgvZ1ZZcnM5Q0VZb3RzSWpBaVJJNkdyVmNqUGJiQm9jRmRYTEczU0Q1YkdyNHM4NnRDVzY1TmxZMUcvVVNOdWV2NENwM00zaVR3Y3JjS2daWUg0UjZEZWdjVko1R1JlV2RkWTJuUSszVDJwZ3MyeXRnaDRpNTRXZ2dMTWpjK21wL0d1UGd1Z3NxL0pTNDl0L0ZycFB2MTFxbVI2Rko0SzkzSjV6eTl1bFYyTG5ndit5Zkhuc1hGMTV3UWVZNmVlbFgwNTJQSDdSMHNhOEdtZW44VDR0Z1hzQnNSM1RxUkl0dUZkajZLZWZuV2lXMXJKOGhEcy9VVkpPRVlOL2I1OEhuQXM0cit0TFdiV0h1aFVWaUFwV3lseDNSSkpDekxrbUprODZ5eWhqYnd2NFBScWFDTGh0YlNmenoxeC9meUxIRFlQRFcwUjJWSEIrRTNMOGc5U3EyMUJhRHBWY2ROU1ZyNTkyWjEyWlJ1MDVTZHY4QTgvNmFMaHZhQmtidTBzV0VBWE4zYXNVdWU5dUpITDUxcWh0aGlLU0pmb05Qc1RqSjVmbGo1OVNkaCsxb3pSY3c5MUI5NFE0OXdQRjlLbDNpNmlmWk1rcnduRi9UNzQrcGFXK09ZZGhwZEI4b09iLzFpYWx2UmlubzY4UDNSUEZPMnVKdTM4WmR1RUZSbXlwbUJIZ0dpbjNBSjk2ejFNM1o5VjJkcDdhZFIvTDlTaHdlZDczZGtYR1JiWldGdkJHZ2pNYzBUNFpIU2F5cFJpcnZ6K3BSclkycWJWMExlNWZWaVNCYkFCQW1BSWtBT3l4cVR1SnkvakZVWGFlZXBRbzJIN1hHYmFId2d5SkRBZUVaZ1krekU2UVowMW5yUlFsSkdwVVpOcE9SWlliQzR2SGFvbHgxUDJweTJ3Zk1uUXgwRmRWQ3BKNFZ5R29lbm9LemFYMVp1K3pYWkRENE5ROThvMTM3elJrWFRaUWVmbitGZWpTb3Ftcnk1UG5kVnExSjR3dnVhVzN4R3l4aGJxRTlBd3E5VGkrcGhWV0R3bWlWVWl3S0FCUUMwQVVCelhRVTNhREdaUmw5elZOYVZrYjlGUjNTM0dOdk9XT3BnVjUwbmMraWdsRllXU0xjdlJ0b0tSd1d4aGZraDNMek5KNUQ4S25lNWVvUldDQmZ0a2t4OWQ2aTBYd3N1UnA4T05vNlZKUkxGTzJScDBBa0hYMDZWTkl0VGJHdS9aTlJxUFBsNmRmZXUzSmJJeU8yNGlCRTcrZlNwYmlQY2o0NHk0NXlQU2Zwb2ZyWFZVc1VQVFFmb1BKeHRTT25WUWMzdUpOVDNsYjAxbitJVzVqbGNkSS96R2Zia2ZTbDdrZTYyWi9naVhyNDVUSElUSkZDU0szRzRtZlhhQU9XL3dDZFFrVzA4RVhOSlBwL3lEVWJaTGxkNFhKcCtHY0ZQZ3VYQm9OVmxTV2J6VlJ1QkkxSWpXcHBIbmFuVlVxZDQzdS9Rc1U0aFlRNU1PeWpLc3ZjY2hDR0pJeU1XQkNrUnRsTy9LSzd1UzVaNXRTV3ByeXMwL1JKZERQMyswTG0vd0QxcnJud1pGN3NKQkljNlpuV0lNeVdBRzJ3aXF1OVhRMFI3T2tzTld6MTUrbjIrcEh1ZnpDM0VGaFFQNWp3d3JxeElYY0VtY2hnNnhwdjZWRjczYTNVMU5VYURibTc3YmNxMzlYQll0WWd3eHpvaHlvV3pzdDNRWlFRSWFSeUdoMjNyaThIRC9uUGtTYWpxcmIwNDNkMjdXdXZQODl6Y2RodUx2aUd2Vzc5c0xjdFpUSUJFcTA2RUVuVVpmclZpazVMeExKNG5hVlA5UEpLbk84WCtkRFY0bTFDa3JPblN1T3lWekJTcWJwV2tZNytTR011blIweWtCbVpZbldTRnpLT2cxZzcxQlZMdnduclRycWhUdEYzOXVoZDhPN0pXYmVZVzh3VmpMK0lrc1lqYzdhZEtvcWFWVnBKeWJzdW5teno1YXVXWlBNbVpqdGR3bExWd0pZdGhWQ0RPWkxIbUJvVHZBM3JSR0VibnFkblJWV08rbzc1d2lQL0FBOTdJREZYV3UzWjdpMjIzMzMzaWVRQWduMUZhWVFUOWlIYXV0ZW50Q0g3bjlFZWg4VTQ2TFM5M2gxVVpkQWRsRWNsVWJ4OHZXcFRudFZvbncrbzFydTl1WDVzeW1JeExUbnV1WFBOaitBNmVnckxKOVdlWEtUYnZKM0l1STRwb0JvdjQrL25WVlNza3JQQkdWVlJScnV3UWNyZGRtTEJpb0dwalFHZnhGYWRKZXpkN25wNkRjMUp0bXNyWWVnQW9CYUFLQTRKcm9NSHh2RTU3aDEwL2VsWUs3dTdIMG1qaHNnaXU3MGJmSUNzNlJ0MnM0RGd0Ky9yVmhKcDdUakZJcFVtaVIybEtVWldLeGJYWGtZMC9HdTJOcm41Q0dNMi9wODY2Y3U5cFgzeUFTQjEvZTNwUTFRYmF5VjkzRWhmbnI2ZVZDNjF5dXZYdGRnQWQvblhMNUY3SWJWaURwN0Q5UE91ckRJVGtQMkwycDExQVB5MGpUOTdHcHhlU2lidVRyVGlCdVNmeDVqMi9LckVpbVUzY2pZbHRkRFBtTnFpeXlMdmthd3VIYTY0VlpsanBBUDVhbmw4NjVZc1Z0dTU4STFXT3dLOFB0Mm5kZTl1T3gzMldCMDJPc0RXZWZsWEpUVUZjd0xVejFsVHVhUGhYbVVYRStJWXJFdXJlTnpEWkFna2hKRXFRZ21KQU1rVlUyNmtTMkZDR2hxNHowZC80djhBWXJyT0dOMlFDcU1uaUp1TmxrekJBMDFPbzAvM3FFWTNWbWFhMVJxb3AwazIvUmRQVWxQaWliVnJDM2xhME14WXU2bjRUcjRRUnRwVW9wMlVYaGNsZGFzbTNVaXJ5ZGxiMTlUaml1Qld6bHU0YThTRkdzdUVjazZmMHdJSkExLzNxVm84eFpucVNycXlySmZCWFh4NkhlR3NQZXRvUXlLUVNSa0JON1dRQ3pNUXNuZjRoUkpZL0dUcVZhazd2YTJ2WGo0SloraGVkak9MUGF2cXFqTzF5NGx1NkxoWnJwZ2xjeThsQ3lTUVNlZXNWemY0clBremF6UXdxYWJ2YjJzbStsdmIzZlE5ZHVEVFdLdGFzZktKaldId3hKSmIySGwrVlVxTjNrdGRSUlZrVFFsWEpNcGNrVnZHK0Y5OWJZQURNVjBQVXhvS2tvU05lajFmYzFFM3hjeVgvd0RRUGhNQmR3NjJ5THdKQ2tEUWhqNGlmOHdFL1NrcWpqVGFTeVM3ZTAxYXBGMTZIaXVsN3IxL09waEU0MWNJZ3NTZnJYbmQ3THFmbno3emdzcldNWUtDN1MzSUZ0Ri9VMU50cFhrTjdTdGU3TkgyTjdKdGlXNzYrQ3RtWkExQnVlbk1KNTgrWFd1NmJSOTQ5OVRnMmFMUWIzdm54OS84UFVyVnBWVUtvQVVDQUFJQUhrSzlkSkpXUjd5U1NzanV1blFGQUxRQlFER0xhRVkrUm8rQ2NGZVNQTzhVSm56TllacnFmVFUzd1ZMM29NOHV2dEg1Vm51YnR0MWJxRnE4WTlUKzlLbW1KSlg5aDY1ZUdublAwcVZ5S1RSQXYzQUoxL1d1bDBYeGdoM01UcVJNUUR2di92WFMxTHFVMkp4WW1UdnB6blhuK1ZSdWE0cTJDRGR4TTYvU2x5ZCtoRE55bzhFWElPOWtBSGNEVDBuOHBxVjdvcXZaczVhNlpuV1J0WGJrWkpNY1hIR0lZQnVuWDBNZmhVMUxCUTByNEhySmE0eW91ZzIzTTZ3UDM3MTNrdHBSYmYzTmx3Mi9ad2x6SjhicUp1RXFjcWFBZ0FnYm4xZ1IxcmwwOEdUVlZKMTRXamlQVFBQdy93QUluYTN0VWJ0eFVGdkxidHhLc29KWjNFamNnZ1JHM3JWYmk3bEdpaENoNDNLOG41WDRSQS82cTJHZHU2WUtUOGVRNXRqc1F5aUR2OEpPOVZyd2NNOU5UV29TbldqZExpLzN4L0l6aVExMGhreWhpY3h0alBtWE5FTVhncjRvelNTSW41VGNVOE1ycDE1UWs1d1QyMnRtMmJlbk9GZ1hoK0QvQUpsbWEvaUZ0ZDBjc3N3WmllY2VLSTJFaVpyc1k5WlNLNjJwbE8wYVZQTHp4WWlMaGtXOFV4SmNMdXVRTExEV0NaUGhrRGFDZlNvWWkvRWFiMXE4VkdDVi9Yai9BRXVPei9adDhUZHlyY1JVV1BFVzhXVWt3b0FFTmNnYWlSdUtrb2I1WEtkVnIvME5QYTA3dStPblRQc2V0Y0o0TlpzaFV0SUJsKzBmRXhKM0piY2sxZHNWOEh4OWJWVktyY3B2bjg0TEs3ZHRvTXpNcWdjMklBK1pxellacnQ4RkEvYTFYUnJsakwzYXovVmVjcGdUS3FOU3VvZ3lKcnQwbGN2b2FTcFduc1N5WUs5L0VYR2QvTndvTU9jd1FxTzd6TUJwTEVzUU40bUs1R2QxdVhCc3E5bmR6VTd1Zk9MOVNUd0h0QnhMRVhHdTRlNUZzTUF5M2ZIYkVENGRmRVcxQjhKVWE3MUdFcHQzNkdqVmFmU3dpb1JWNWVuNVkwNjR5eHhHM2RYTGt4Rm5SMTVOR2hLbjdTejdpdTNqVXZibEhLVWEraGxGVkY0SkdBeCtBQ3VTQkRqU1QrZjYxbjJwUzlTbnRqc0dPcGc2dERFbjhwZjc2L010dXk3NEswMmUvYWU5Y0gzaW9SVDVKei8xSDJGV1FwUVQzU3l6NGlsQ2xSazFPTDNMbS9SK3g2UmhlMkdGYjRpMXYrNWRQbXM2VnA3MlBVOU9PcnB2bkJkWVRHVzdvbTI2dVA4QUtRZm4wcWFrbndhSXpqSlhpeCt1a2dGQUxRQlFET0lTVllkUWFFb3V6VE1EaUVqVDUxa2tqNkNuSzVuOGVrRFRhczhrZWxUbmQ1SVRYOWQ5OVBXcThseVdCbzRxVjEzOCtWV0ludHlWdUx4bW9QVDZtdWw4STRzeXR1NDNXZnBYYmxsc0VDOWRuVHpxRFpaY1p6MFJCeUV6elhia2R4d1RYQ0xZbWFhNlIzWE9ZMWdjNklnMW5CNm4vRDdzMEZVWDdvTW40UnAvN0g4dGF0YnNySG05cGF0eGozTlA0djhBZ3JmNGdjSnRXc1NMak84WHBZV2dQRG5XRnpFekFHdlRtYWdrczNJNkxVVG5HRVVrbkhGMzVGSmllQ2xycXVndU40Skp1TUZNblNRREpnQURhWjAyMG1kbDVGbFNVbExFbGUvVDhzQnMyLzVndVdJUStNdGJVNXBQeEtBMGpPck1BU1BXb1kzbXZ4clRxS1dlTXZIdmp6R3NkYVFLVFp1TkVaUmJ1aWJrRHpWWUE2VDByamFheDlTeU1hdE4yYStLZU0rNUhGdTB0c0ZTNHVLSllrQW94UElEbEE1L1NvTjR3WDA2VnBPVC93QlJNNFZ3dTdlUnJxbTJRdTZrTURNVEdpNmFjOXRkNm5HbTVadVJsck5rdVBiUDU4alRjUGV3YkNPTGh0SFIyc0Fna2xTREVRV2s1UkJIbFY5Tkt4NCt1bFdxU2JtcjlFN2Z5YkR0RHgwMlZWVVZpcld6Y1pvSWhTUENQY3pQU2lta2xiM1BLMFdpL1VOdHZqRnZNeEhCdUVXY1VIeFdKYlVzV0ttTXFyMWh0QnRFeFBoanJYWTJhdXpkVnAybjNjRmhZOTJWR013MTd1cnpZZDFYQ0M0WVZtQVpvT2JLRmpxVEdvMGlaZ1ZDZmlnL0kwYVM5RFV4MnE4a3MyVnhPejlqQ1hsYzR0c3EyNE9RdEdlWk9hQnFSdEFIWG5VS0tVSXU3TkhhTmFwcTZrWVU0L0czSHAvWkdHS2JESzR0TTlxMWRMUGFVRWtoSnkrTGNqUUxEZVcrbGRidkhHQ01LU29WbHZ0SzFrL2YwL29mNEppQ2dXOGwwcmZtRXRnVG5EZ2F1ZGlwSjI2cjFxRVArTmM1TmxSUzFrdHJYZ1dXL2J5THJqT05kbHRYTGlBUExXN2c1RW8wRWlwVlpjTW5wS01XcHdpN3JEWHhLckdrcU02N0NKODFPbXZvWUh2VXFjK2g4WC82bzdOVVV0VkhsWWw2K1QvZ2J0NHE4NDBrZ2NocWZsVVpwcytKM09YQklUaWQ2MURJenBjNmlRUjViYWlzMDNLR2VHZDd5Y2N4YlRQUXV4djhRaGVaYk9LaFhPaTNCb3JIb3creVQ4ajVWcTArczNlR2ZKNm1sMTZxUFpVdy9QelBRQlc4OU1XZ0NnT2E2REtkb01IbGNtTkcxSDcvQUh2Vk00bnFhU3JkZXhrOGZZaVlPZzVWa2xFOWlsVXU3TXoyTVdJOWRLaGE1dnB1OXlveHQyRHB0SVA2VVJyZ3VwWFhic2o2L1NseXphUTJQeXJqT0hOTEViNE9TS0hHYzEyeEM5aERRNDhuTkNKYmRsc0VMMkp0b2RpM3J0NGo5Qkh2VmtWMUcvWkNWVHlSN2svaFNRUW9BOFRIWUFiblhhdVNUa2ZLdVMzZUk4dFBHODk4dmZZT0habEdnSlZKOElSZ1kyNXhQblRkS1BQQjd0R2hRbXRsUG5IeDgvejZGWmo3aTNManRaVW9EQVVzd0FCRzVqVW4ycU43dTZOcmk0cFVtcnRlUy9rU3hlQzVzNmQ5QUdZWmlCcUl6K0VBZ3pPdjFxU2oxS0pWSlN0RyszUGxuMklOOXRNeVpqcVpTRGxVUkkvcUU3d05xaHNiUnBscVlVNVc1c2NuRzNMbG9Xd2lCVjF6RllZek1TM1BuRkZCMnNWT3ZlVG5GUDUzK24zSE9GM25NZU1JR0FCTGFBQ2R5ZW5PcHFGM2NqK3NVWTJhejBMN2dIRUxPSHhMdXl0ZWFTRUNud2FuYzdrOG82ZmhCeWtyN1ZjNXE5TE9yUlNVckxsK2Y5SHA5djhBNzNDSTBLc1psZFdFcmxCS3VqZVhoQkhvT3RYd3ZLQ3VqNXRTL1I2bDlWaXpYelRSNTF4TEMzRVczYjd0bEJjbFhaaGtqTm5pNUJKQ2pmV3EzQ1NTUjlCUzF1bmx2cVM4dUVzdnBqcGNxT05XV3NNaU1GdVpSSU50aXlrRFR4ckFnd054U2NWaFBOaXpSVmFpY3FpaTBwUHJ6bnlZM3h6R1hMMXRNUUxLcGJBN3NmOEEyQWNnUHRaVFBpMGpyWFczSlhra2tWTjA0emFwT1VwY3ZISC9BR2NjRjQzZHQ0ZDhzZU5zclpsa2daWUFFOG9CRWErMVZ5bEtFZkNhS0ZDanFxbStxdU9GOFN6N09jQWJGM0ZXemNVSmJSWHVGakRKTGJKQWs2QWtUdHNUVW9RN3l4elVhdU9pYnhmYzJrbHcvZnk5UjN0UkF2SmFXY3R0ZVpra3NTek14NWs2R28xLzNwTG9lajJmL3dERTV2bVQrM2tjWWExM2xwbDAySTFPbmlPNTlLakZubTl0YVpWcUU2Zm12cjBMWlA0WTQ4QWY0ZnRjbVBjZ1ZvbHA1TllQeW1YWjlhOTFZbldPdy9FbEVlRStyamI2MVYrbXJMcVEvUWFoY1crWkp4bjhONzF4TkZ0TGM1K0tCNjZMWFhvNU9QcVhQcytiOHZ6NEhwdkQ3QnQya1JtTGxFVlM1M1lnUVdQbWQ2OUNLc3JIcnBXVmlSWFRvVUJ4TmRCRDRwaGU4U09ZMUZSYXVpMmpVMlN1WVRpZUhJa2JWbW5FOTZoVVRNcmpyV3V2STFUd3oxS2Nyb3BjZW5NamNVc2JLYnRpNVczYmRjc1dLUkN1SWFqWVhHalN4QnRvVWl1MkZ4S0hHY0ZhN1lneEN0ZDIySU5tci9oekF4RTZhS3g4dVd0VFN3VjE3ZnAybjVsajJrN1dYZzVSaEZwb2dSQU9WZ3daanZFcnRBODZKN1dlZCtuaktDa2xqNmxKZmJDNHJFQjF5b0gzRG5JQXc2c0JJQjA5ZktvM3UzYzJTaXU3anRmeTVHclYxdTd1MlU3dklMazk0U1RIS0FZMjAzUFdOYTVqWmJvU2pLb3E2bEc3ZHVDSGROdFM1dUxKS2hiYlc5QXJBUjRsbVNUdlBYbHJYVnRhd1ZWZThqVVhlWXpka0s4RXlaUXpnbGdOUVFvR25pYjYxMkt3UTFGUk9WNDhHMy9odndQdjB4Q3VaTFdJdGtrTXFNd0lWNG1aR1VSdHpxMm1ybUxXMTNTMjdIMXphL3lLQy9tbHJUZ1d5cEtOUGlobDBJeXJySG1ma2FnM1kyMDFLckJXeXVmTDZza1lKNUFBY1dWR2tybWh2ODBqVnhVYlc5RFhDb25GNDNlL1Q1OEhyUEM4Sll3L0RIYXk1SWRNelhYMExNVkFKUFRwVmtiS0xhUG1OVFZuVTFDVTF4aEx5eWVaY1Z4OXhHVE4zNEN6L1R1Qm9nZ2lRVHVJUC9GVlNjb3ZyN0gwZEpVYTFOcDJUODE1b2pjT3cyS3Y1bXcySDhEK0VzU3VXZWVYTkgwcmlnM21DNUp5MTBhZi9IV2xkcnkvazV1NEc0bUhBdVhBb3pISmFKemtGWkRHQUlndG01OCtkUnEyU1c3NUZtaFU1eWV4ZTd0NTlCbmcxbXdodWZ6U1hjMmhVV3lGaWRaZysyM1dvcVNWNzNMM1FxeWtsQnIxdmN0c05mVTRtMWNzdTZPV2hsQkpBdEFhNW1QeEVpZHRCVW96dkpOZmlKVk5Jb1FjWlJUWDgraTZmY1RpTDk1ZHVQcjRtbnJ0c1BrS3JubDNOVkdHeUVWNUlrY050d3BCNlYyUEJuMWtyNVBkc09aUmY3UitGZW91RDg1bHlPVjA0RkFBb0JhQUtBWk5kQnd6VUJTOGJ3QXVDVitMOGFqS056WnBxN2c3UGd3WEZzS1FkUjVHc2s0dEh2YWVxbWpPNGkzOUtnajBveUszRVdvME8xZHNXcVZ5RmVUNm1saGNpdGJwWVhPcldHWnpDcXpmMmduOEtZUlZVclU2YXZPU1h1N2ZjZXY4UHVyOGRwMUhWa1lENWtWMnh5bnFLVThSbW43Tk1qd0s3WXNrUXJ4cFl5em1Ybll2SGkzZEliWmdWSjhtamZ5MHJwWlJTcTA1UWZuY3Uyd0Z0cjVXN2RZUVRHYmZ1eEFHVjIzQjZqME91dGRTVFBMcU9VSHNheGNyY1Rkd3d2TWt1RWc1TGdpUVkrWkJPazZIU3FtK2h1akZlR1cxV1hLem44K1IwMkN2V0xmeHVPL0gzQTBnUVNQdkRseUdsY3lsWjlTeU1JVkgzc01iZlVnWWRicHlYYmhSa1NWdGhrT1NkdDFqV1J2TmQzS0N5VnFqTFUxR2s4OVRyRjNtVWxXVHhNRHFHOE1jb25VUk1mS3V4YVR1SzlPY285Mmt2ejJMdnNoeHRjTFlkRVVwZGZKNHlDeXNWTFQ4SWthTU5DT3Z2T0UwbGd5VjlIS2MxM21VcjhGVGpjUWNSZU53dmI3MW1FblZReEp5cU1wOGdQbnFhakxMdmcxYWZ1NlZGeHRKK1NYUmVwTzRSZWUzY0p1QjdnQS93amJtVkU2K0dRbzFrRDRUMTUxeThvNUZOVUtrZHJzdmp3LzUrNVo4VjdRcWJKUzA4Sys2QVF1dk9COExEcUk5NjVLdXJZTFlka1I3eFRrc0xyZit5Smk4UUNqRzVKdWdETGRGMXRBZkltQ0NKODZyYzJ1ZVQwWTZTbkszZDIyOVZaZmNqOE80NWl4YlhEV2lxQ01xN0tTRDBKZ2c4K3V0V0tjMnRxd2VZcUZDblVkV1hpejhEa2NMeFVHNjdXbENITG5KQkxrYlpmdjlCcHlxdVVIeStuVTNhZlVKUzd1Q2VjMjh2ZnlKM1p5MnI0bFZ4MXBtTHdGTGwxWmROQ3YzaHNJTzBWWEhFdkhrbHJKVk81Y3RPOXUzeVNhWmFjWUZwQ3lXVUNTZFkxUHpNbi9rMWU3SllJYVJWWkpUcVN2K2ZJcWxzODQvZTFWTkc1eUxmZ0dFTngxU1BpWUQwQk1mcjhxblRqZkI1ZmFOVlFwdCtTUGFBSzlJK0RDZ0NnQVVBdEFGQVIyTmRBemNOZEJDeEwwTEVVZkU4T3R3YTc5ZjN2VVpSVE5WQ3RLRHdZYmkyQ2EyMm85Q0t5VHB0SHY2ZlVScUxCUzRnVkN6TjBXUUxoSHlvV1hPZUcyN2IzMFIyS2hqRWlBWjVEWGFUQTk2NDJZTmRxS2xHaktjRmRyeit2ME54YzRJVWcyR0FqN0RiZlBjZldzMDZEYjNLV1Q4OTFGU2RlYnFTZDVQei9NRmRqT0pZaXlBTGlzbzJuZFQ3N1ZSS1ZlR0RKS2M0TEtNM3hIRWk0WllUNWo0dm56OTZsU3ExSTh1NXQwUGJlcDAwdkM3eC84QXErUDgrQlIzN2RlbEJxU3VqN2FocmFlcXBLcFQrSzZwK1RHY0tXVnhBTWJFRHBWdTI0cGF2dWFpaytPdnNla2NNdWk5WkZwNHpDSXpUbE1hUXhqYzZjankzcXBxenVlbnJhTGt1OHArL3dEMTZGUHhiZ1Z3UGRhNGtDMEpBVmdZVS9DMDZkSmlLcGxIcWQwMm9qWFNpK1E0WWIrSUdZMzJMV3prRnRDRWNBZ1N3MHB1bExKWlQwdEdsZUxXSDU1WHNRc2VMOWtpMWFZc2lFM2U3WUNWalU1dXU5TXZEOXprNEtpOTlMbVdQZjJJNUYyNTRvRWtSa0lJMG5jRW5YVWZRMTM5eXdWM25TbHVxZVpJeE9JUGd0SllndDRTcVA0Mk1oanJCalFFQTY3azYxMUt5dFlxcTF0MHIzejY4SWpXY01KdVdyWnRzVGxnc0dXNTVxaGpMSUpneVJNVjJ5NEsxS3BsNTliY2YyV1dFeDdXRjd1eVdRL2JXNEZENTQxOW9qNVZWSnlqKzA5YlQwdFBYZ2xXaXNjVzR0L1pEd2VKVmI3UGNndVJJQkNzaGFkY3cyRTc2VjFTNjlTcnVGR1NwdCtIM2VGNkR2RzhhdDFrekJGZ2daYmE4cEFnUjd3S09XN0RPMUtNS0szUXY4UnZGOFdhNGh0M0d6OGxHVmN3STBYTVluVHBSdDJ5N2tGR25LMnlObjlDL3dDQ2NKdllsbC84ZHhGQlhPVGJMQUNDeUNEdHBNZFJYVkhkbnFjbHJxZWxpMUxLZk9FOCtUZC9rV0dJNFdjTy9lM256M1Bzak1XZzlTemFzZkxTbzdNM1piVDFYNmlIZDBvMmoxd2w5RndRWXprc1JBL0UxTGswL3NWaDAyL2wrdGNhSWJqY2RndUdlSTNDTkVtUDdpUHlINDFwb1E2bnkzYk9wdjRGMU4xV2srZkNnQ2dBVUF0QUZBUnpYUU0zQlFFREVMWFN4TXJjUmJOQ2FaVll2RFpnUVJOUmFMb1RhZDBabmlIQXhxVjA4dVZWT211aDZkSFh5V0paTTdqT0dNc3lLcmRObTFhNkRLYkY0Y1ZEYXl1ZW9pK3BOd3ZhQzZzQm1EZ2RkL21OL2VhcG5wMUxqQjRtcDdPMHRYTVh0ZnB4OHY2c1grQTdTb1JEQW1kQ0NEOHRqVVkwcXF3MG4rZXA1TXV6YThINGJTK052djhBMlNNYndTeGRVdXFQYTAzQThQOEE2L3BGY2RKUHBZd3pvSy9pVnZsLzBaN0NjQmRuS2lISElySm4yM0ZYYVZXYnU4SHBkbUtkRnlzMVpyelYva2FEaC9aWmhxVVB5cmR1ajVub050dkkvd0FVNExjK0sycGtlUmcrVlZ5MjlHZTEyZDJsM1A4QXgxUDIvYi9CRXYyTHc3dkVNNFlya3pLY3J4TzNNTVBYejk2SnAyd2VsVm96WC9MUTk4Y01wY2Z3bEF0M0k3NXhjQU9ZL0dyUDRHWTg5Q0R5cW1WTzZ1dVMvUzZqQ1VyTEh5YVdTck9Ddm9wY2Q0YmR3NUM2RE44TGFGVHFTdWgyajExRlNqRnBlNWwxRmVFcWk4Vm1zcitpWGU0Ymlnb3ZPV1FHTFZ0bkFzc1pXQUVRcnAwMUhVK2RUaXJNeTF0VjNrWEJ2R1hqejlSdkNjTnZGVTd5NGh6S1pETVZSU1BzdUZBT2JVbWV2WG1rMmkyaFNWUjJiZU1xM1cvbC9KRnVjUUZqdmJmeEt3QzVvQk1BNkFueTZqY2ZJVnQzVFJzaW5SYWsxMStweGl1RVh1N0YzdUhXM29XY0FHRk81MDh0YUtuaFl3UXE2dUxiMi91OGgvQjNnbHAwRFcydGtIVXJKRWlNeXlBd2F1TnpWMTBMNFV0TE9NWnUrLzMvQURBMXdOZ3R4M1ZYYktwQXlxU0JPa2xocWg4L1drT3RpTlZ3M3BTYWE5WCtYTG02dUl4anE5cTJIdVdoNGxFRUJkb2VkeVRPbmthN0tUWld1NDA4dWJKL21QWXYreitDT0NEWWkrTXJrRlFvT1k2L2h0RWEwcHAyOGl1di93QzhtcWNNcjZGVmpNYTExaTdIUTdBOHYzOWE3SjN3ajFxVktOS08ySTlobUVhalhrS1hJVHYwTExoV0ZlOWNWRkVrbUFPWHFhN0dMa3pEcTY4YU1ISm5xL0RNRUxOcGJhOHR6MVBNMXVqR3lzZkUxcXJxemMyU3E2VkJOQUxRQUtBV2dDZ0dTSzZEbGtvQnByRkRveGN3WU5EdTRpM2VHZzEwNnBFUzd3Y0d1RTFNcjhUMmNEY3FXSnFxVXVNN0hLZVZSY1R2ZkZOait6TnV5cGQ5QjlTZWc4NnByVGhTanVrUXFhbFFqdVpXNGJGVzdaa0xIUTE1Y3RZNXZ5UjQxZlh6cVllRWFQaCtLWmtnaVFlWjArYy9sV3FuSzhTRVpQYms1SEJsTEJnWUo1TEkzNjZ4OUtrcVdib2lxVzU0THpEY0ZzSW9sVlpnTlNSTmFvMG9KWlI3VkdwT0VObTVrYkg0U3lxbGlxS29Fa3dBQUJ6cWRvSmNJdDc1ckxaNXh4anRJTTUvbDdZZ2ZhY0hYL1NDSUh2ejVWa2xYVGVDRkx0NmRGMnB2SHIvQUVUdUY4ZXRZbndYck52dkFOTStxTkIwMTNHKzNuenFFcHBvOXZROXFVZFZMYTd4bDZjRzI0YjJnUlFMYkFLUUFBb0VLQjBCMkgwcXZjMTZtaXRwazNlSk03UVlXMWliQVVzQVZZWEVhSmhsbjUxZEdvckdPRkthcVhSNXR4RGh0OUxqQjd4RTVTc0tQRXNuTkFJRWthUk5UVjVMazJSa296NFNTNXMrUFVnbEVSdzVKdUZUczZLQ09lWURWZllublVGZE05S3JDRW9YVXZrL3hqRi9IdGRZclpMQlczVVNsdU9jck1SNWJWQkxQaEpWSzZuQ085ZkhyOHlYZ2NOaHJZaTVhN3gxTEs1RCtGdk5kTkk2MFRYRmljdE5Odzd4VHR3MWd1ZUhka2NWQU50VnRoeHJMR1N2SW53K0ZvaVkrbGNjWDB3VlU5ZFJwM1UxdStINThDKzRiYXRjUFIyTHExNWhFSVo1eVpPNTFBMXF5TU5xdXlxcENldW1sR05vcnpNN3hISEc5Y0x0TW5ZVG9QUVZ5VXJuclU0Um93Vk9JMEJyKzRxQjBuNExEbDJDcUNTVDdtdXBYZGtaNjlkVTA1Tm5xWFpmZzYyRWs2M0czUFFmZEZicWRQYWo0clhhMldvbjZMZzBJcXd3QlFCUUJRQ2l1QVdnQ2dPSzZCWXJnQ0tBVExRQ1pLQVEyeFFISnRVQTFjdzROQWVKZHVPTUc5akdSRDRMVEZGanFERHNmTWtFZWdGZUxxcW0rYjhrZU5yS3JuVTJyb1ZsbTdEQXF1ZGpwSitFSHlYbjcxbFUwak51emVLdXpXOEU0YmZZNW5NQWo3VXo3TC94Vy9UMGFyek0zMHRQTjVrYkRCOFBDam1UMVA3MHIwWXhzYjRVMUJZSlM0S3BsaG4rMzNCTGx6QlAzVzZFT3kvZVZRU1IrQi8wMVZYZzVRc2lqVXdjNmJTUEgxc2o3UTE2Q3ZIY3ZJOGVVZG1PU2ZoTU1ZTExsZ2lJSTAxL1B6cUVadTlqUm9OWE9oVjM5T0d2NkxmZzJCdmdIVHduWUVuVCszYkxYcFVxTW1rK0Q2eWwyaHRkNHJIcVdGOThWWmdqeEx6NkNPbzYrZFd5cGJlVDN0THFOTFhmaWRuNi93QU1tTjJyUjdhcGZ3eXYxREFaUkduTUdmYW8reFpMc2VNcGJvVC9BSktxN3c3RFg4NVc4TE0vWmUyWFVlU21SR25LcHVOMFZ2UTFhRXZDdHk5OGpOemdXSFcyRlhFd0YxSk5neXpSRXF3WVFOTnBQMXF0MGw1bXFrdFN2QzRwcDlMOEVyQlhNTGh3cFZlL3ViNTNHVVQ1S1oyNWJuenJ0a3VXUDBWU2I4YlVWNUlNWjJudU5vR0kxMjh2ejE1MXh6UzRSZERSMFlkTGxEZnhaWXl4SlBXcTIyK1RVcExoY0NJNS9mNjF3Ymt1UzA0YmdudUVieDhoL3ZWa0tVcGNIbmFydENsU1ZyNThqZjhBWjNoaTI5UVBFZHorblN0c0tTZ2ZMYXpXVHJ2UEhrYkhERFNwczgxa3hhaWNGaWdDZ0N1Z1VWd0MwQVVBbEFGQUZBRkFGQUZBRkFJUlFHQ3hIOE5jT2I3M1E3Z094YkpwQUoxTUhlSnJKUFJ3azdzelMwdE9VdHpMWEFka2JGclZWMTY4L25Wc0tFSWZ0UmJDbENIN1VXdHJoNmpZVmJZc0h1NEZBT0xacm9FdVljTUNwQUlJZ2c3RUhRZzBCbHIzOFBjQ1NTTFpFbVlEdEh0cldaNk9pM2V4UzZGTjlCNngyU3cxdjRVK2V0WFFvVTRmdFJaQ25DSENKRGNMVWJDclM1TWkzZUgwSnFSVDQvZ2FOcmtFOVJvZm1LaEtuRjhvMVV0WFZoeEl6dUw0RVI4SlBvZGFxZEJkRDBxZmF0VHFWV0l3bDFkNU5WdWl6Vkh0T0w1UlgzTGI4d2FqM1VqUXUwcVJ3TU5jYjdKb3FNaUV1MDRMaTVNd3ZCYmgzSDUxWXFIbVpaOXF2L3hSZThQN09HUVNKcTZOS0s2SG4xdGRWbnpJMWZEZURSR2xXbUNWUTB1Q3djVnhsTGtXZHRLaVFIaFFCUUJRQlFBS0FXZ0NnRW9Bb0FvQW9Bb0FvQW9Bb0JDS0FUTFFDRVVBWmFBWExRQ3hRSEpXZ09EYnJvRzJ0VUEwMWloMjR4Y3dZTmRPN2lIZDRZRHlvU1V5SmQ0R0R5cmhOVkdSbTdPTDBGTEhlK1oxYjdPcU9Rb085Wk1zOEZVY3E2UWRRbldlSEFjcVhJdVJOdDRjQ3VYSTNKQ3BYRGc0QlFDMEFVQVVBVUFDZ0ZvQW9CSW9BaWdDS0FJb0FpZ0NLQUlvQWlnQ0tBSW9BaWdDS0FJb0FpZ0NLQUlvQXkwQW1RVUFuZGlnRHVoUUNkeUtBTzVYcFFCM0lvQmU2RkFMa0ZBTGxvQWlnQ0tBSW9BaWdDS0FJb0JhQUtBS0FLQUtBS0FLQUtBS0FLQUtBS0FLQUtBS0FLQUtBS0FLQUtBS0FLQUtBS0FLQUtBS0FLQUtBS0FLQUtBS0FLQUtBS0FLQS8vWlwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wdWJsaWMvaW1hZ2VzL2ZydWl0cy9wb21lZ3JhbmF0ZS5qcGVnXG4vLyBtb2R1bGUgaWQgPSAyMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRQUFBUUFCQUFELzJ3Q0VBQWtHQnhNU0VoVVRFeE1XRmhVWEdCb2FGaGdXR1IwZUZ4WWVHaGdhSHlBYkhSY2RIU2dnR3hzbkh4MFlJVEVoSlNrckx5NHVIaDh6T0RNc055Z3RMaXNCQ2dvS0RnME9HeEFRR3pJbElDWXZMakF0TlMwdExTMHROUzh0TFMwd0x5MHRNQzB0TFM4dEt5MHRMUzR0TUMwdkxTMDFLeTB2TFRBckx5MHRMUzAxTGYvQUFCRUlBS2dBMVFNQklnQUNFUUVERVFIL3hBQWJBQUFDQXdFQkFRQUFBQUFBQUFBQUFBQUFCUU1FQmdjQ0FmL0VBRGtRQUFJQkFnVUNCUU1DQlFRQ0FnTUFBQUVDRVFBREJCSWhNVUVGVVFZVEltRnhNb0dSUXFFSFVySEIwV0xoOFBFVUl4VnlNME5ULzhRQUdnRUFBZ01CQVFBQUFBQUFBQUFBQUFBQUFBTUJBZ1FGQnYvRUFEQVJBQUlCQXdJREJnVUVBd0FBQUFBQUFBQUJBZ01SSVFReEJSSkJFMUZoY2RId01vR1J3ZUVpb2JIeEZTTkMvOW9BREFNQkFBSVJBeEVBUHdEdU5GRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVld4MktGdFN4TVZ6M3JIaXUrcmdvL3Buam1rMWE4YWU1VnlTT2wwVmdNSDQ0Zk9GY0xCNXJiWURHTGRRT3AwTkZPdkNwOElLU1pZSnBSMVhyQXRjaUlOZXV2NC95N1o3blkxei9FWFd1MnZodGZ0dlN0UnFPVEMzSWxLeHI4UDEzTVJQTk9zSmpBMWMwc1l6OVErbGRCNzFwT2s0MDZTS1JSMUxic3lzWm0wb3FIQzNReWcxTlhSVHVOQ2lpaXBBS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpbGZpSHFuL2oyaXdndWRGVW1KcUc3SzVlbkNVNUtNZDJROVg4U1dyRFpZTHR5RjQrOVZjUDQwdzdBNXN5bGR3Uk5jM3hsMW1KWWZWSit4UGMxZHduVFpocnBodjZnSGNBa1ZtN2FUWjZQL0U2ZUZOYzdkL2ZRNjVZdWgxREtaQkVnL05laXcybXVhNGZyam9yVzFZcmFFQUVHWGx1WjJBN1ZWd3ZWYjZzQUdVSk1ETkpaai9uWDNxL2JJd3JnOVIzejc5VHFnTmZhNTVndXQzdzdIVEtERUFITUQ4blJoN0RhdGwwZkhtNnBuY2M5LzhBZW1SbXBHVFU2R2RCWGVVTHZHMThMWkVzVms2YWFON1R4M3JubDZ5Q0NPRzU5LzhBTmRROFRXRXVXR1IyVlNkVnpHQklybG9ESk9VQmxIMUtkcTUyc3VwNTJPYk5aRnpTUGxUVDN3NzRpYkRQSjF0dG93L0dvcFhpVlVqT2hQdXAzRkwvQURQU084NlZoVW5DVjB5aXVqZitJdW8rWmx5Tm1SZ0dYMjNCSC9OcVI0Mjlsc2xoK28vaGhvZnZTM0I0bktVV2RJM1BCUHQ3MWI2bzAyYmdHeEt1QjJJTU1LWktwejNrd2J1VFlTeVZ0SjJmY24yMXEzaGNVWjBhWlB3QlMzRllrREQyckkzTUdPMUNRaEdZNkRaUlZPYXp3Vk9uZUhiMmUzTXpyRk5xNXBoc2U3REttWUlPeGdtbXVCeFZ3UU5ZMjNKTmRTbHFjSldIUm1iYWl2RmtRb0I3VVZ0R0h1aWlpZ0Fvb29vQUtLS0tBQ2lpaWdBcm0zampHdGR4T1JQL0FOUWo1NVArSzZUWEhlcEhOalhJWTZYQzU3d3Ayam50RkpyUEZqcjhIcHAxWlNmUkVveUlBcktmTWYxSHNrUjcvVjcrL3RWREgzVDVmbkZtZy84QXJFNnNBZWQ5VFgzRzlSeXRuaUNWWUlEcEpKMEpIRVNOTjlLVjRTNFdSN2JoeGRnTmJrbmZjc2V3aXN4NmFsVGR1ZC9QNzI4Rmd2WS9JR3RaZ3d0UnBLd2ROei85Wi92WG16ZEx6cTJZK2xJaUpuUS9BM3F0aXNXOXhiV0ljcVdWc3VXTnN1dXZ6OFZJYlRzV1ZpRlpnQVYwMGxzd003QXovVVVEa3JSU2Z2T2Z6M2pub3lYZnJXNHJXeVFDcDNFSFVqWGZRL21uZmhickFPSit1UVNaN1pkZC93QmpOSXZEeWhnY3VZbmdqUUFSejcrOWZPa1hWdHlJV1pQcFAxRWdIVC82MVpTYXNaTlJSalVWU0xXYmR4c3ZHSFVyVjIzNVF5dUF3TEhOcXZ1QkJtc2paUzBrc3J0R21wblgyaUlQelgyL2ZMYVFxWlFNckVhbk1UNlNCUHR2U3kvak1zaTVkSlRSWUVES1ZneUJKai9hcVRTbkxtYU1WSGhOQnF6amQvdU1NWmhnUUhCeWs3L2YrWWRqU0c5YUtzRklqVW4ycC9oZW9LSjF6bVBuTXUrdnZFMVQ2bmd5ZGJaenFkVi9tSHRQTlphOUhGNG5FNGpvT3dselJYNlJXRzFZL0VWYUdLT1VxZG9pZjdWUkx4b2RESko5bzRydzErTkk0L00xa1J5K1VtLzhnc2MyMjM0Rlg4TGkwUDBnRnZjNy9tbEdId2JIVlRIL0FEaW4rRTZOZGNqT3FlK2JmOGltUlhjVjVDN2dHYi9WOFIvZXQ1MERweEhxWlNCdUFSclM3d2QwbGJaT1k1aVBwMWtBZkhldGpYVDAxREhNeThZaFJSUlc0dUZlWGNBRWt3QnVhOVZpZjRrOVo4dTM1S3lXT3JBY2pnZjNxc25aWEg2YWhLdlZWT1BVbDZwNDJDa2kwQkV4bVkvdkhhc3BoUEd1SVYxYTR6TUpHa2FIWFg3VWx4OStiWUhsYWdUdlA2ZjJwVytNdU9zQUgxUURwb0R4cnhXWnprM3VldzAzRGRQR0ZuRlozdWQ0NkwxaE1Tc3JvUnVKbUoyMXBsWEkvQS9WR3dycUdLTXR3RE5ycXFqbjU5cTYxYmNNQVFaQkVnam10RUpjeVBMOFEwaTA5VnFQdzlEMVJSU3pxM1c3ZGdNQ1pjTE9XWS9KNHF6ZHR6SENFcHUwVmRqSm1nU2E1bDFyQklNUmR1aHdGSU9oMGN5TmdEdnJ5S2c4UmVKbXVMRnhDVklPZ0pYS084QXpOWlRyblVtRnZ5Z3BWRHFwSmt0UE8wajgxbnFWRXowbkRlRzFhYnUzbDQ2YmV2eUlzZGZseWhKSVgvOEFIdFAzK0RVMkd4N1dENXgxYTRyS1lIMEdORDJPKzFLYnVQbEkwQmlHUEoxNy93REpxZExraFVZREtFekZRWTJHaFA4QXE1am1CU2ZJNzBsamxrdmY1TE5xMnFXN2kzSUQ1bEd1cENrYUhRN2F6RlJOZVAxNXV5OTRNY0hrUjNyM2g4SmVabHZOYnpBQ0lNRE1JTUVBMVJ2WU83Ykk4eTJWNTFCQTd4bTIvZWdaQ1VXM2RxL3ZDSEdGNmkxcDRWdEhWUVNOTlBnOGphdElpTGlDR0J5a2twTVppZG9KR2duZ21zYmhiZ2EyYlpnRVNRZWROZFc3ZGh6VFRwdUtUeXJpWERvVnlycVlUTEprYzc4KzlTaE9vcHBybWppU3hqcXUvd0RBMjZqNFp2bHZWZlRVeUk5Sll3TkFzN3dLVjQ3Q1hNTVZlNVpKdHNUbkpFeVRJRXQrRFhycC9pRzRsb2xob29BVXBCSUowQlp0d1J2NzA2dzNYRkp0K1kvbUk0S3l3RWtpZnFqUS9IRkdOelB6YW1HSkpTWGhqcDB0NzdoRjByRnRjVUJWVkd0eXdZblZnWkJXTzIvNHE2YlhtSVNQMG1TUk1ySUU3ZTlUWTN3N2FGMFhyVndoSU9aUkxGVDdEbGZhcnVBdllXeW9XWFpqS3p0SjVNYkQ5NmlVZVpjck0ydVVOUlRjWUo1OE51b2h4ZmhxNjZOZVFuUWdaRytwKzUrQlNvWWRwOVhwN3lOdjl2ZXRoLzhBS0J5NDh0SDhzU05XRGtEYzVUc0IyOXFrdVlxeGRWU014Qk1DM2xFdFA4b243eUtUTFRSZlU0MHVFeWl2SHl4K0RNV0Z5dDZueW45SmowbjRQRmJEd3YwOTc3UU02aGRYTERRL0REYzBnd1hRcmh4QXNRQ2p0QlZ0Z044d1B0MjcxMTdwUFRVdzFsTE52NlZFU2R6M0o5NnRRMDkzblpIS25IbGRtVFlURExiR1ZSSDk2bnI0QlgydWtsYkNGbnlpaWlwQUNZcmtQaVhxaGUvZFlKbUIwQjdhZDY2ZjE3R2l6WXVPZXhBK1RvSzQzY3VzckVhdG9TSTMxM2tmM3BWVjlEdDhIcFpsTitRdkN5b3ozQ013NDNYMko3MUV4dWF3UnFwMzBrUnZYczJBVkhxSnpHVEd3bjlOUkVvWm5nZ0VFOFpSU0xIcHViUDRKdW5Zd1cxMFVrdHdlVDdmYXVxZnczNm9MbHByUm1VTWdIZ0ViZkUvMXJrdm11MFFZS25TZEFlNG4ycmRmd3F2VGVmVFVxUjhRYXRUeEpIUDRyVFU5UEtUM1dmZnlOMzRpNjR1RXRoaUN6TklSUnlZL3BYTXNaNXQ1Z2x5NEExMDVqUDZja0V3eFB4eHBOTlA0aTRwbXZnRm1Db1ZHbjBxQ1FTU2VHTzMyRlpiRTJ3OGhITE5teVdWMEF5YnRKL2FhS2ttM1lSdzNTcW5TVStyNjcrWHF3VzR0enpydHdxR0dpQS9Td0c3QUg2aVRTckU1WHpNV0JMR0F6Y1FvaUJ5TnhQc0taOWE2Z3R5Nmg4djAyNEZ3RVNCSEpqZ2FmNXBIaWNSR2FHOU15Q1I2anhvTzFVWjJLZDdYdGI3ZUgzUG5TOEkxNW90Z1pnSmc3Unlaclp2Z01OYlFPMXUyTG9IMHd4aytuZFNlL2J2UzN3Y1BMdFBpR01LeEluY2dDQk9udk5XL3dENWdxMXk2U1F4bGJFRFVnY1NkUk85Q1NRbXRLcFhuYm91N3I0RnE5ajdsdTJxZ3BuZjZpcE9iMUhUVXFKQUoyN1Y4Zkd1bzh0YlN0bUlVWlczSjN6U0IySmtVdk9MQUplNG9rNVFKWFhuV1FZRDFXYTJHdWtXYmdJWE5sekhRRXI2aUczK094bzVpRlFqL3dCTHh2bTN0Ris3MGl5eFFrQzFjTWdRZlF6RFVHZGh5TnF6QXVOWnZOYUs1aU15dE9tYk1wRy9iV2EwbUg2cGN1TDVodER5a1A4QTdSb2RNb0dhQ05Ec2FWZUxrVzR0c29yWmdTQ0lKUGNlOFJGRnU0aE9kTjhzOXZPOWhMWng3TGFlMkNBcEtramt3YTlXTWQ5T1ZRR1V5VHdmbGZhbzhQMG04ZGtneHM1Q2tuMm5jVlF2cXlPVmRTckE2cVJFVkhLelRIVVJid2JoK3ZOZUtobkMyd0Myc3d4QU9tVWI4VjR0WFdDdXlxRlpnQ0FyZXBKT3hFZlNkVG9heUl4Si92VHV6MVYyVU9YTW9vVWZ6TXBiVVQ3UnpSY3YyTVZpRzNjUFd4RjJEY1c1Nmx5NTFCSUxCUnVUK3JtaTdlTnhMdDBBdGFESzVRc1F5QWFTREJBblRhbHR1K3pzUUl5blFlOHdZNUdoL3BSZXhIa2xnc3FIUUpkWGYxQTYvd0MzelJjcDJhdWtsbjdZeDZHcTZiMWovd0FlN1lZRU9qb01wTURKSS9VMGE2YWNjVjFMQjRsYmlLNm1WWUFqNzF3eTFkRnU2TGFndXIyc2dYWVpqR3YyMXJiL0FNUCtzT3BUQ3NDU29JYVNOQ0Q2WWppSi9GT3B5czdIRDRyb1ZLbjJzTjErNnpuNWJIUVNhKzE4bXZvclFlWUNpaWlnRFA4QWp1MHpZTjhvbUNwUHdEclhKc3pKNjkrSTloMk5kNXJsbmlUd3ZmdHZjTnIxb3hMQVJxczhSU3B4Nm83WEM5VEdLZE9SaUdkYmhhREVSb2ROZS92VWVFWllaZDJERW5TU1JIZXBjYmdXaURaY3Z6NlR2M21LYTlOd1VqTzl0a21GSU9rbjhiZTlKUFF1U1N1aE5iQmFaUm1rNmJhRG1ld3JxSDhMdW5sVnVYU056bEI0OTQvYXMzZ2VySWx2UVd3QXhSc3lhbGdkQXA1V0tzWWp4VGZ0SUhXOWJTMmRBdVV5ZE40bjlxbURTZHpGcmxWclFkS0t0Zno5Q3Y0L3hCRjYrcFpRaFpkdHpycVB6V1h0NHhWVXVxUjVWeVZDcksrclNHWThSeFZEckhWWGR5YmtzQ0JKeTVUeVpnL2ZXcWI0L08ycEpCZ1FOTnR0TmpWSGU5emRRaEdGS01IMC9BeXh1T3l1OHNHRGdUazBVSGVQZVB4U3JHdGxPaE9vMTdmQTlxK3NDN2dLdXVpNkRuM25tckxkTUdjb3piQWxqL0tScVJINzZWTmkzYXBZUnAraVlZTGFTMnhKUXI1alQzYmo0RWJWRmlNVmRLV3JweTViVGxWLzFHWkJqdDMrSzlXV0NXU0JiK2xKMk9tbTg4ZkkycUM4aEhrMmJqemEzbllxVHFWR3ZNRDFWVmxxSzZ2M2gzdDRudkYyaXJQYWRnUUljd1BUSk1nSFdZTXg3VFVWbTBjcXNiYWdXMUpFR0dNdnE1M21BQ0krOWZHSUdjRVppRllnNnNFQkloaUFPQkkxcjVvNTFKVldDQ0ZYVWc2RjRuWXgrWm9INXRuMzlPOHRlZGJhNW9XdFduZ1hDUHBhQVRNN1R0WHZFWHdiWDFnb2hLbzJvYUlnR1JxZnRWZHNZY2pJcWx2TGdreCtrYmFIai9OVU1lK2F5QmxnalhVUVhBRE5xZmpZKzFTbmt6MWFkNC9UKy9vTWNEaUdMR3c3SVJjU1VJVDBrSG5VZ2pVR2xQV2x0NVNqQ0xsdUZrRWtrVCs0MW44MUZoVXpxR1p5cEdpa2NBQXdLcDlRdytVSTRiTTdCZ2U0T28wKzFYU01zNHFMdy83S056RThEUUQ5NmJkS09XMnhhMW5uUlQvS1pIOVJOS01OYmR5V0tzd0c1QUpBK1NOcWNXTU80QzdxcFBNajZkSkoycUhGSWZUcmN6dkpqSk16TmFWR0NoaXpwUDZST3hqNE5UMk1XV3Q0bFhYTVhJSmJ0bDlvMnBIWnU1WFdTZmVPQlBGV0Z1aTJ6algxSDB6cFB6VlRTMG1yZlQ2M0xic1BNbTJmcFVPSkpNa0FDUFluZnR2V2g2RjFFMjNXOGloM0VhVEJBYmRvZ3pySWlzemVaWUpQWUxJZ0E1UUJxSTFibjgxQmVESXEzQVRER0orTmdSL2VqWVc0eHFya2ZsbitEdS9RL0VJdmVseEI3LzVHNHArSzRuMDNxZHdXN2R4b0tLUU13SkVUb0NRUnNQYXVwZUdPc0xmU0FRU0J4ekdsYUlUdnVlVDRob094L1ZIWWRFMFVVVTA1UjlyeVVGZXFLQUttTHRxcXN6UkNnay9ZVFhHUEZQV21aaEQ1Z3dtQVJDbWVJL3ZYU1BGZmlDeUxiMkRtSllheG9DTnpEUWRJbldzRmhuc01TTE9IdFRvUm1CYy9VUWZWOENkdWFSVmQ4STlMd1dtNlNkV2NHKzdhd3R3ZUxOeFI1WkF1U3FqYUVuYzZqV2Y3VXA2eGk3ZzlEWHM0MUJFYUtRZHRhMldONnhrc3NsczJoSkF5b2pIS3gyRGF4QjFFZ1ZsT3ZrMlFGQ3FEbVppMmdiVllJM1BmWSsxSmV4MnFVMUtUYmpidTkyTTFqcmpPU3pTZmVyUFIrbmxoNWhuTE1MRzdINTRIdlhqcE5nM0hFc1FCRXh6N1ZwTDE1Y25tb3lvMXFGUUNKM0hxaldRQ0JWaE0zZVZrZWJhSWp0bkpPVlo5TUgxY3pQUEhPMUxzZXJKYVV0Qjg3MUtRUHBBTVI5KzBjVXh4R2UyQXJObXQzeUhkeEdoTzVCN2lZUHpWSy9JT1JWbFNDRkJQcVhVbVFkZ2RKTlF5MU95ejd4L0dSaDArK0d0SUpaaXd5d1NBSTFFRW4zbXZlRHZETmJZU1dBWUVIWGd5ZGRnQnBGWjdBM1dEUkV6cXN0cEExSW1ycWRYUU14MG5TR0ltWUhmaXEyR2M4VmRNdjRkQkROYTFRa0tWUEltWi9QRlJKY1VNWFk5MXlxWTloRWE3eWFpWEhvUXpacFZvMjNVL21hckppMUdvT3JIdEFNY0U4Y1VXR0tyRjNaZFVsUVZBSUlHcEovVE9nMDd4U1hxWFVCY1lBTm91K3UveDdDSUZOYkNDNHlMcVE1eWdnK2tiYnlKSkZTOVE4TnBtS2hnU1ZKVXhFUi95S3RCR1d2VmR6UFhiaXFxRUUrNDdhOEdwOERhVzdkRHFwUzJENmlTVC93Qi9IYWwzVU1QNVJ5a2FqOXY4MW91aVlrSWdZTUNBSXluNnRWTXNQeVJGWGVFSlY1dXcrdDR2eTFWVnloR1VzTXVrd1kyNG1wWDZoYmVKMDRKTUZUOEdOcXpkekdCSUFPWWFpRG9RRHhWZE1VQ1ltQi9UM3FuTWIxcElOWE5YZXRvR0RaVnVxTnlSTVR3UU9QZmlxZU82YXhRT2duSk9WVjEwUEFQUDlhaDZaZFpFeld6QW1YY2lRTlkrOU03R05ZT3JncTF0eVpNUkJId042a3kxS01rOGREQ1hHWm1JSXk1UWZTWjlNYjZjR3BiR0xrQlNCQTJtdWk5ZTZRbUp0RmkrVnpFTU5NM1pEM0I0UGV1YzNFQ21GRW5VZkh6VXVJVWRUY2U0YTZwaENXOG9DY3NnNVNSckJPL05hcndqMWMyMkNxTXVVUU96UnY4QUJqZjNyQjJQU3FpZFptZjhudFRicEYrR2FOWjB6Y0dlUDZuN1VJalVjdFNEaXp2M1Q4U0x0dFhHekNhS1hlRDJKd2xva1JJSkh3U1lORmFVN284WlZpb3pjVjBiSE5ZTHhoMTV5U3RwaXFqVGJSeU55RDI0cmNZcTVsUm03S1QrQlhHZXBYc3orbWNzRUFhNm4yOXFYVmxaSFc0TnBvMWFqbEpiQ2JxL1V3d2dDRHBQK2t3UWN2RU1EcVBhcjNoU3lWczNiekFSOUlKRWdEay9FMW1NUm94MzM1M3JYcWxwY0haRVRtMWJYamsreG5iNHJLbms5anFZS0ZPTk9QVi9rWDM3V3Jaa0daSi85bG9ubmIwalRUZmV2QlNidWRobUpUVnR3ZU14bWZ2Vm14aXphTnRtWEtxQ0NDRGxmVTY3YUUrKzlSNXZXeElZS1ZtMkpnRUhjRVZkR09wS1NiOHZmcUlNVVZ0czJRK25OTUFSd0lFODgxUFp4NGJQNlFXdUxDNlNVSUlqWDl0S2k2L2FrNXN3QUJnRGo1amYvdWx1RFFuUWFrR2ZZVktRaVBMYXd4Y1N1U0NEbWtEZ0tkLzMxMHJ6Y2NHR1VndUJFRFV5TkorRFVpSm5HcEl5a3ozR20rdS9GZVZab1Z2U3NBbWVZK0krTlBlaXhhVlVneE5uTUN4bEk0SEI5NlRYNG5mWHVmOEFGTjhSY3llcWMwL2o1SGFsTjY0R2I2ZitmRlhTTWxTcGdmNEREV3phOVRReEVSRWFsdC9nYjFPK0Z5T29VcmRYYnNwSjBnSGZlS3U0SnJhUjVxeDZKV05NMnAzK0lqN1Y5czJtaFV1emJ0WnN3UEpKVUdKK3dpZTlVZGpaUmkxSDMrM1VydFpmK1VLTXpRRk9zamNkOUlQNHIzaThROXU1RE5uQVVDVHQ2Z0RCajlXMVQyc0dwSUlhTXAxWUhXQ05JK05melZiR1lYS1d0S0FRMlNEN2s4dDMxcUVObWxZVCtJckUzUW9PYVFzSHZQSS9lbTlyREtxSXVRckFKZjNIRzNBNzk2U3FENXl6bDlMR1k1aVJ2OXExVjJXWXF6RVFJQnRqVWlOaFAzcTdaanBwT1JrdW91QVRsT2cwSHZTMjNpU0RJM3EvMWJDRmR0aDMzcFhscUVrTTFFNUtWa2E3d2gxRldZMnJrNUdqTkhPWFdZN1ZwY1AxQUJicUhNeUVFRGYwamd4c0tRK0VNSDVOcTVmSmk3bG0yQ0prVHQ4MWZ3Ti9LQzRuTGNsV0FNNnpzUnZWZHRoMFl1Y1c1ck9QcjYyR1BUc1kvbEIyY0ZZTUxzWUd4Si9CcE40clZQTXpxSWE0RlppT0RBMUk0SEh6VjdCNGdxUmF5bFluVW1WQVBBOTZaUDRaYkhaWWFGV1ZrQWFtQkpuZmVyeHU5akJyR3FiNTl2UXc0dWE2TkxmR2cvM3A1NE82UytMdklra0FUbWJjQWNudDlxMTNUUDRYMlVNdTdOM0d3cmRkSDZWYnNLRnRxRlVjQ205bjNuTHE4UlNqYUc0MXc5b0lpcU5sQUErQUlvcjZLS1ljVmtYVUxKZTA2amNxUVB4WEYvRWVKSUlZNlI2Ui9OSHg5NjdoV1A4QUZmZzliODNMYzVwa3BwRGE2eDJPOUtxd2NsZzYzQ05aRFQxUDltek9RV3VsRzh6WkRDZzZFZy9rMXFNVmdyZHF3dGxWek1wa3NkOWY3VE5YZW9CN2JGWFRKbUVNQ0k1L3AycFhmeEpZeHVSSHFCMWduYjlxeldzejFUcnlyV2xmQzhSZGpuMThzQTVXUEptTnRQZXZ0NUJNRTZwQkJBN0hUUTdpcGJ0cGR0Uk93NVB2WHJCWVo3c0xsek9PWTIrOVdTWXFyV2lsZnU5M0ttR3NCN3E1NFpTU0dCL2xnZ3oyMTU5cXA5WDZWLzR6VGFKdVdva25UTXBuWTl4dHJXenRlRkdJMTU3Y2UxZWNSNEVMYk13cHlnN0hHbnJJZHBkUEJ6MTdnWU1kSklnZTNiNzFDTGdFbzVsZmsvMnJjdjhBdzFMZnJiOFZJdjhBREUvL0FORy9GVHlNSHJhZmVjNHhWeUQ2WUE1amFxdHFaa2lkZFA4QXF1cUwvRFZSOVJZL05Nc0o0RXRqY1ZQSXhFdFhCbVV3QnRsQzVFa3JDbVlqMG5ualV6VWFPd0Z1VG1UTm15blVFVHl4M094L0ZhN3EzaGtXazh4RitpRGxqN1QrS3grSVhMc2NvWW1JNEJIYjVnelNKeGFlVHM2UFVRcXd1anhmdklBU2taaVFSSDhvM0RmMW1vY2FjcUE2TUEyWWpRblhRVjhKQWxBWk9YV0RwUGY1cUFZRzR5UUVqM0FpZmVwakVtdnFvckZ4SGpMaEQ1bDBNNkQyN1RXcTZYak02cGxnTm1NbU5SSWd6OGEwdnNkQXVFeVZKK1JWdkI5S3UyeVNBWWpqN1Zkb3dSMUNVcmxxNWgwYTJYWUQxc1ZKL1hvZHo3VW1QUjlHdVpUbEJnSDNPMVBMQ3VoMVdOeUo3bmtVV2N6Vy9LekVBTVdBbmN6b2ZtbHVKMUtkYU5zNVZ6MGJvZFVHd1VBSnJwdHdlWk1tdldBOVpra3lwTUFnQUhpUjNOVnZJbTRRRzAzMDJEYzZiZjhBZFhyR0J1M1c4b0tEc1pqK3Zhb1JhZGFLanVXN2xrc1lDNTVnQ0Qrby90TUN1bStIdW1lVFpSRHVvMStUcWFwK0dPZ2VVaWx3TSs4OExweFduVkswd2piSjVYWDZ6dFh5UjJSWE51cFVXcGN0RVZjNXR6NUZGZXFLQ0FvTkZGQUNucmZTRnhDNVhuN2Ixa01WNEVjR2JUQWFScU4vbXVpMFZWeFQzTlZIV1ZhS3RCNE9mNEx3SVp6WEhrNmJWcGNGMEMzYmlCRk82S2xSU0sxTlZWcWZFeXZid2lqaXBQS0ZTVVZJaTVINWRIbGlwS0tDQ00yaFhueUJVMUZBWEt6WVVHa25VZkJtR3ZObVpTRC9BS1RFL2F0SlJSYTR5RldjSGVMc1ovQ2VFY05iK2xCOTZ1RG90b2JJS2FVVUVPcE51N1l0SFNVL2xGZkY2VGJCK2tmaW1kRkJITXhUaU9qV25FRlIrS1VZandSWWJhUjhWcmFLTEl2Q3RPSHdzeFdGOEEya001aWEwV0E2T2xvUXY5S1owVkNTUk02OVNmeE04cXNWNm9vcVJJVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZGRkZBQlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQWYvOWs9XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3B1YmxpYy9pbWFnZXMvZnJ1aXRzL3Jhc3BiZXJyeS5qcGVnXG4vLyBtb2R1bGUgaWQgPSAyMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRQUFBUUFCQUFELzJ3Q0VBQWtHQnhNVEVoVVNFeE1XRlJVWEdCVVlHQmdZRnhjWUdSb2RHeGdiR0NBYUhoZ1lIeWdnR2hvbEd4c1lJVEVoSmlrckxpNHVGeDh6T0RNdE55Z3RMaXNCQ2dvS0RnME9HeEFRR3kwbElDWXRMUzB2TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TGYvQUFCRUlBTVVCQUFNQkVRQUNFUUVERVFIL3hBQWJBQUFCQlFFQkFBQUFBQUFBQUFBQUFBQUFBUU1FQlFZQ0IvL0VBRDBRQUFJQkFnUURCZ1FGQWdZQkJRRUFBQUVDRVFBREJCSWhNUVZCVVFZVEltRnhnVEtSb2JFSFFzSFI4QlJTSTJKeWd1SHhraFl6VTdMQ0ZmL0VBQnNCQUFJREFRRUJBQUFBQUFBQUFBQUFBQUFDQVFNRUJRWUgvOFFBTXhFQUFnSUJCQUVEQXdJRkJBSURBQUFBQUFFQ0F4RUVFaUV4UVJNaVVRVmhnWEdoRkRLeHdkRWprZUh3UXZFa1ExTC8yZ0FNQXdFQUFoRURFUUEvQVBjYUFDZ0FvQUtBQ2dBb0FLQUNnQW9BS0FDZ0FvQUtBT0h1QVJKQW5RU2R6MG9BV2dCWm9BNHR2UGxVQU9WSUJRQVVBRkFCUUFVQUZBQlFBVUFGQUJRQVVBRkFCUUFVQUZBQlFBVUFGQUJRQVVBRkFCUUFVQUZBQ1RRQUNnQU5BR1QvQUJEWWR6Ym4vd0NRRWV5bjk2NW4xTzJWZGEyK1dRNU9LeWlMMlM3VXl3dzk0eVQ4RGs3L0FPVnZQb2FwMEd1YmZwMmZoLzJLNFdaNFp0YTdKYU1Gb3VBY21VL01IOWo5S1hQdUlINXBpUWR3QVNkaHJTeWtvckxBaFkzaVNvb1lhNXRxeTZqVnhyaW11V3hYSllLdmlQSFlaY3V3MVBuV0czWHlrMDRkRmM3VW1OV3UwL3htSmtnSUtlT3ZrczVYNkNyVUkwbHE2R0docnFWMlJtc292VHlPVTVJVUFGQUJRQVVBRkFCUUFVQUZBQlFBVUFGQUJRQVVBRkFCUUFVQUZBQlFCbE8ySEZMMWwwN3Rzb3lrN0Fna0hVR2ZLUG5YUDF1b2xVMWdNNEdPRWR1RVloTHdDa3dNdzI5eHk5YW9vK3FSazBwcjhpYjEwYTlXQkVqVUd1c25rY3h2NG1JVGF0Ui9jMzJGY3Y2bkhjb0w3c3B1ZkI1N2R3NUFuVUVUQkhsMDErdFlLNmNNb1haNngyTzR5Y1Rod1cvOXhJVi9QVFJ2Y2ZyWGQwODNLSFBacmhMS09lT2NURnZFNFczTzVZdDZFWlIrdnlwTHJGR2FHSk4vaXF2YmNEUnRvOStWWmI5YkdWYlM3RTNjRlMvRVc3c29ldjA2VmdlcG02L1RiSzNQakJCUzZTSVBLcUcyOElyendRc2RjMVBwVXdLYkh5UFlYRFFGNkRhZVpyVE9JcWlYbkRNZjNiTGFHcGRoUGxXalRXdXVTZ3ZMTlZjOFlScDY3QnBDZ0FvQUtBQ2dBb0FLQUNnQW9BS0FDZ0FvQUtBQ2dBb0FLQUNnQkpveUF0QUdOL0VwRDNOdHgrVnlESG1KL1N1VjlWWHNpL3VWMlBCaVA2Ync5NHV4MEk2SDlCKzljcUZhWERNODAzeWpZZGhPTkhURHVlWGdubDFXZnJYVjBPby8rdHY5QzJtZmdrZmlHNENXcDZ2OWhWbXZlTnY1SnY2Umc3bUlXc1hxeFJuU0x6c0J4RUxpKzdHMTBNSTgxR1lINkd0V2x2aTU0THF1eVJ4ekVaOFc5d2JJTW9QcC93QXlheTZtOVN1ZVBCZEZlN0pKczNCcWV1dFlHOHZncGZZMmI4cVNOZ1luMGdINnpWMGtrOENTRWU1b2ZhazhpTjhFVzk0aUIxZ1U5ZkRLWlBMSitJeE9tL3BXaWN2SkxaWDhQdnZuTndUT29YN1ZSbHJueUxDVFR5ZWc4Rlk5MGdZK0tKUFhldTNwSG10WmZKMG9meWsrdFk0VUFGQUJRQVVBRkFCUUFVQUZBQlFBVUFGQUJRQVVBRkFBYUFQUGJuYUM5aGNSY1FuTXVjK0Z2WGwwMGl2UDI2cS9UM1B5czlGRHRhZkpxdURkbzdHSUVLMlZ2N0dJQjl1dGRYVDZ5dTVjY1A0WlpHYWtPOW8rSGYxR0h1V2g4UkVyL3FHby9iM3A5VFY2dGJpVEpaV0R5N0MzemJaclZ3UnVHQkVhL3ZYbWI3R3VNZEZWY2NjTTZ0djNkMWJpR05RUVIxRlpJV3lpMDEyaC9TdzhvdSsyK09HSndLWGwrSzFjWE9PZ1lGWjlKeTEzSjZtT3FvVDZhZkpGeTl1VHorM21jRFV4T212cFdCNGp3ek1zdm9uOW5jUjNlSUZ3bUNBUXBPK1p4a0h2cWFiZk9NWEtDNU5WRUcyYVVxRldKOHoxTlk2OTAxaGZrdmtzSmxaeERpak1SWnNueEhSbUhJYzQvZXRVRnpreWZxWGlxRnNxQnNCRlBuTWlxWFF5ejZrZVUwMkN0aVlVWm5XT1d0V1FYSld1V2NZMEZtQ0QzOUtsOHNTWEpiWVd3RUNqblNTNFJmRkpHbjRBMmg2MTBmcHpXSDhteXZvdDY2aGFFMFpBVE1LaktBV3BBS0FDZ0FvQUtBQ2dBb0FLQUNnQW9BS0FDZ0FvQXhINGhjQ1p4L1VXaEpVZjRpamNnYk43Ykh5ckJxNk42M0lwdGhubEhtdHpHRlRwcHpuOUpueXJrZW00UDJsS2pqb3UrRy9pSGVzaFZudkZISjVKanliY0d0ZGVydGo5eGxhNDlsKy9hbmgrTnR0blVXcjRFdzhBbVA3Ym16SHlNZTFXMytqZkI3bGgvSmRDY1pNeW1QVE5tUzAzK0lualZUSzV3dXVuVUhhUjFyaDFSMlM5M01YeGs2RmRUVFRmTVNWZndGKzdoRnhGbGJoUjFVbTNvb2RTUk9iTkd3bURQTG5XalQ2YTZFMm5Iai85ZjQvVWV2VHAyT3RrSzNoN1lLd0NFRTUvRUNUeUUrUTErR2FyVmRzay9rMXgraHlTeCszeVRiRnZKY1pyS2hWUGRxQytrVFBpUldJTnlTZDlOdHExdzBibEZLYk5kUDB5cUVNV1BudkMvdS9CUHdONFdBejR4VUFud0YwekZpZG9YeEZBSTM4NjNhZW1OS3drWFdhT3UzRU5Pcy9JL2ZlMTNxRlV0cTExUUdFOTJRZFRJekFUcEdrYTAxbE1KZG95UyttMXpxa3BMcDlybitnOWk3UVNVemc2QWdiR0Q5T3Z5ckZicFhGNWp5amdXL1RiWXgzUjVSV0cvREQwaXFzY0hNZWNrN2hUL0VRSk93SHJUMS9ZaU9TeXcrRkNqTVluK2ZTbjI0UXlqaERxTnBydWRLenplUmthbmdkcUxRUE50ZjBGZG5RMTdhcy9Kc3JYdE9PSThidDJzNEpsbEEwOHpQN2ZXbnYxVUs4cnlFckVpaHY4ZmU1YlZGK0l6bVB2KzFjdTdXemxCUksvVnlqckQ4Ukp1Vzh6UWlSOUJTVjZpVG5GemZDSTM4ckplOFA0c0x6bFZFQUNaTmRhblZxMlRTWEJaR2U3b25wZlVtQVFTT2xhWTJSazhKajVIS2NrS0FDZ0FvQUtBQ2dBb0FLQUNnQW9BS0FFSW9BeC9hUHNKYXZrdmFmdUg1d0pSdlZkSTl2bFdTN1NLZk1lR1Z5aG5vd2ZFL3c3eGRzTXpOWUtqWE5ueS84QTJBMXJEWnBwMXJMYXdWZWxObWR3MkV0aHlrbG1FVGtsb25iVWpVMWltN0dzckdEVnB0RE94NVNOdHd6Z3EzaWpNd3VNcEtyQ3hrR2t0SFV3ZGVzVSttMHFhYStlMGQrTmY4S3Zjdkdmc2FzWEFlOE55RXRLRUFNNk1BTnlJMDVhQ3Vrb3hubHZvb3cxdDJjeWVmd3lMZ01MWnpPYlJhTXdKU0NOZWtOK1V6LzFVd2hGdk1IK0M2NjIzQ1ZtTTQ3L0FQWGtwcmZFWDc2Nk1RaEs1aVZsZExhaFp6VHRBSTZlOU1wZS9EUnZuUkgwb3VsODQ1NTdmeDhtWHcxd1ltNnh4RjhJUUpVRlpERlNTRk9zQWJpUE9vZkw1T3hZbnBxMHFZWnozejFrNTQxeFJjUTF1MDNnRnNsYys0aWRmRE93alRYbFN5YndQcE5OTFR4bE5jN3ZIM0V4MXp1cmxseGlialdtRWh3Y3pJVk1Id2s2Z0hsMGFsYlN3MFYxcjFhNXIwMHBMeDFuUDNKMS9IaG55djNZUGd5M0VNS3dZRWhtWFhJSUVIWFFta25CVFgzUE42MzZIWGRCenJXSmM1ejhyeDl6UThIc01GS3ZLa3ZCRXdkQVBuOXF6UmhqaG5rTmpqN1pkbGhqN29XRkd3My9BSnpxTFpKZTFFVDQ0T2NHRGN1S2kvbU1UNWN6Vk5jUFVtb29JOHZCYzlwdVBqREtMVnNqdklIbmxIN211cnFkVDZNZGxmWm90czJMQ01FTDVkaVNTek1aSjg2NDhwTjhzeUxMZkpiMkNFU1R2VmZiTE1xS0l4eEpZenNvMnEzYmdwYzhrbXp4WWlRbk1RYVpLU1hCS3R4MFgzQU9Kb2dkbU03RDE1bXRXa3VqVGx5TkZOcXh5WG5EZUtDNkdZd3Fnd0pOYjZOV3A1Y3VFWHdtcExKWXFaMXJZbm5rc0ZxUUNnQW9BS0FDZ0FvQUtBQ2dBb0FRbWdDQnhyaTFyRFdtdlhteXFQbVR5QUhNbXE3TEl3V1dCNXMxNi94R2NUZmxMQTFzMlJJa0UvR1R6OWVma0s1MWtKWFBkTG8yNlRUcXlTYytqUTJPR1dWQWZJb1czTElRTlRLanhFRWJqWHlxeU5jWTlyaEhROVdhOWtIM3cvdDlpRGQ0aGN0V211ckRQY3VLaVFBTXh5eVc1VHRIdFRWeVRqdU5VS0s3YkZCOEpKdC9iN0RUOXAwV3phRjYwWEYxV1o0R2dDc0ZKSVBLYXMzTGJobGtmcDhwV1M5S1dOcjQvSlBPT3crSEF0V2prZTRKVE14SkpPMnJTWW1takdNT0Y1TTYwOTF6MzJjcVBabk1FTVE5cS9ieEhlWmtRbk5jV01yNWlNcXRzeXN2NjBzVzNsTTZkbm9Sc2hLbkdHK2srMWp5dkRUTWJoTENNV0JKekFPUUkwT1ZHZlVnOVJsai9NS3FTV2VUdlgyempqYXVPUDNlQmVHTmFaeDN6TUFKMWlSR1Z2ZWMyV0tWU1dlU3ZVZXJHUDhBcElhd2RoNDd6dXM5c1ppMnBBZ1pRZFJxSUpXbFN6eWliYkl0N04ySk1kc0lHY3Rod2RGQnlNUnFDSWRQODQ1OHRLbVBQS004NVNVRXJ2bnRmc2Jmc3p4bnZSYXRiUllVZ25kc3VoQUoxNmUwZWRGNnlzbmp2ckdoVVZLMWZKTnh0M1dPZGNxVDhubDU5blZ2aTY0YTA5M1RPUmt0anAxYjIrOVhhZWZwSnk4K0I0UGFzbUd2Y1NlNCtabUpKMUpPL3ZRNCtYMlZ2TDdMamgrZ0JQT3M4aVVzRm1ic2pYYmxVeFdCSnlJVnk0enRrWDNQUVZmQ1BHU2pza1BsVHdKN25uNjBQbGcrQlh4UVZJRzMzTkNqeUc0ZXdHSWN4Sk9XZHVwcUhBZUU1STlLNFppYzY2d0NJMEhJY3E3V21zM3dPckI1Uk1yU01GQUJRQVVBRkFET0l4S29KWXg4ejlCU3VTWFpEZUNBZU8yK1N1UnZPWGwxMXBQVlJHNG40WEZMY0daVElwMUpQb2xQSTlURW1QOEF4S3hsMnpZdFhiUmdyZEJPNC9LM1ExVGMybGxGbGF5enkvaUhFOFR4TEVLTHplRUdBaXlFVWN6NitjMXpuWTdKY2xpZ25KUk5wamVJM0ZuSmxXMkdTMEFCR2lybGhSL2JJSTlxMHlQUmFiUzFZVVgzalA4QWo5aDNpM0VRMXUyMWgzSjBBSzhtekFRM3o1aUtMYzRXMFhUME9FNVJ0U3gvYjdDY1c0emFOMDRTN1pOeEFVRE5yNFdZU0RJMlB2T2xPMnY1V05wOUhZcS80aXVXMTg0WHl2STN4QzdnYnJyaFh6STFzRlZDRWlRd0JLYWJnNkVpbXhGOEJWWHJLNE8rUEtsOC9ieWNkcGVCMnIxeFdXL2J0dGxGc2g5VEdiTUNtc2h4eTlhbWNFMzJOb3RaYlZCeGNHMW5QSDkvc1Z2Ym5qUVpEaHd4bnd4NXdSdlMyUzR3YmZwT2oyejlYQmtNYmhWV3lsd0FxWFl3cElKaFZVRnZUUG1Bck8xaU9YMmRlcTZVclpRZlM4L2Y0LzJHOERpTFFXNExpaVRidUJEQkp6RXFWOUlnNitkRWNlUkw0MnVjWEYrVi90NUlpMzNSV1VhTGNXRDVqTURwNmxmZkw1VkNROGxDYzAvS09rdzhxSFJ4bUJWU3N3MHNXQWc4eEEzNVRUeFhCVFpiN3RyUmY5azhZLzhBVUpzd1MweU1wTzJSU0FRUjZnVDUwNldYaG5IK29WUmxUS1B5elJZckVSSk03QTY3d1JJOU5JcmlUZzFZMHo1OWJCd200UHd6RDhSNHExd3dUSUg3N2VsYW9WK1NNSFBEam1haXhZUk9EUzJua0NLeVlJWS9kdUdOTmR0cXNnc3NvbVRjT3ZkSjRoNGpxMzdlMVdTZmhDOUhNRWIvQUJIWCtlZ29RckkxOWN6cW8ySDgvbnJUdzVaQmY0U3lVTWtSRzA4djNOUzFndWdtYXpzcmNESTUxSnphbmx0c1BUOWEzNkhHMXMzMFBNY2w3VzR2Q2dBb0FLQUNnRGxoVUFVL0VPRGsrTzI3Wmh5SmtIeThxelRwYTkwV0k0K1VST0RZNFNEdE9qRDZhKzlUVmFweDNJbUx5YVd0SXd4ak1JbDFTbHhRNm5jRVNLaHBQc2xQQlM0bmhPRnd5REphUkF6cUpBMUo1YW5YZXFuQ01Wd2pScG95blBqNFBQY1JqZTZLWnJxM2NPbDFpUXNGMFptSmh0ZGhKcWw0WEo3Q3FsV0pxTWNXTkx2cC9vVjJKdjIxeEFheXdLcG1kWURBOHpCRERmV0pFN2Nxanp3YTZxN0pVdjFWeStIMWovdjZsbmhPTjJNUmRSOFJaS1BwRGhpRWNxZEF5L21naUorMVQ3Wk5aTWRtaXUwOEhHcWFhK01jclB3VEhHQnY0ZzNGeEdReXJPc1FDeWdnTXJuWWdUTWJ4VGJZeWxuSm4vOEFtVTBxRGhsZUg5bjR3VnVPNEZhdVhwd3QrMjVnVE53NTFJTTV4RXpwcEJxSlE5M3RacHExMXNLc1h3YS9IRFh4L3dBbExpK0g5N2Z1RHZVa3RxYmhLa0NSNHAyUHBTU2htWFowSTN1dW1MVVgrQ2p4UkdaZ3BsUVNGUGxPaCtXdFZTZVdiSXYyTGR3M3lHS3ZxK1VBQU40c3phRE16TVQ2QUFRQlQ5bWFLZGVXM3g0RzF2WlVLRWJ0YmYyVVBwNkhQTlR5dUJjSnkzSi9ZY3UyZ3BEMjNCaFZjeVl5c1NmQUorSWdBYlZPQ3R6bEtPSkwvdnlTc0VVSWR6L2g5NkJhVUFIS1BDb0xrallab1B1YVl4M0o4Ujd4eXpRZHVzYzFzSUpCWnhrTERZbTJBcmZKdFBhc3Q5T2JNbmcvcUVFcmR5WGZKaHJSazBNeDROSlo0Y2JZdGJsN2k1bzZTWUE5ZEpQclZGdmdYT1Mrd0dCWm5DRFlEeE55bm4vMTVWU29iaU8yYUcxaExhS2NpaWVURUFzU2RKazdlMWFIRlFXRVJsWTRGdy9EeTdTZGwrOVZ3ZzN5S3E4c1cvZ01vTEhtWUhYMEhuUDJwdGpTeVE2OGNuSEQrRkZTV1lTNTJtUEQvd0EweWpoQkN2QS9pTUR6TGE5S1NTR2NQbG16NEhZUkxLcW1vNWtpQ1R6TmRpaFJVRnRPaFdrbzhGaFZ3NFVBRkFBYUFNNTJxdllwQUdzdENjNEFrSDlxNW12bnFJWWxYMFUydWE1UlZjUDR0aTFVM1hZc3UwRUFFbXF0THFMbkhkSXJqYlBHV1BMMjBZR0hzaUJ2REdmcUlyVXRYOWhsZmtxT0pZM0xjTjYwUWJiRVR5SURHTnVvSmoyRmMyZHpyc2s0dmpzMFZMYzJlZzRHOW50bzNWUjgrZGR1aWZxVnhsOG9sckR3UFpxc0lLUGorSncxeFJhZThnWU9qUUhYTklPZ2p6MnBKT0w0eWI5SlZmRjc0d2VNUHdlWGNld3JMYXl1dVJPOEM1aEJCQmNzWEkzelJBclBKY0hyOUhOT3pkRjVlTTQvSFJWY1V1aExpS2x6T2JaaFhVNXlSbEViZFdudzhwTkxKN1h3YTlNbk9NcFRqaFB0ZERmRStJdGNjRnJhcGRnRmlwMGFWQm5McUF4RVRHOVJ1eStoOUxSQ3RQYkxNZnY0L0l1QnNXU3FzTDRSZ3lzVlpDSGtmMk1zZ2c5REd3cUlwY1BJWFdXN21uREt3MWxQajhvbW0zWXVYSGRNWXR1V3pFc2pxL25sT3hCNkdtd25MS1puMzNWd1VaVlpYWGF4K1NudVlLNDEwSUZabVlqS0JyT28xTVRIcnlwWkp1V0RZOVJDRU4yY0x6L2dqaGhhdUZYWE9FTEFybThKWVNvMTZBbWFWTERJbS9VZ25GNGZ5UkxWa3ZtZ1RsVXNmSUNKUHByVDRLWjJwUERIclRtOWNSYmpnVGxYT1FBRlZRQVBZS1BlS1lway9Uam1DR2NQZXlNREFjYW5LdzBNZ2dTUHJVRXo5NnpuQlk0Vnl6V0FjcFRPRkZzZUZpVkNueEE4aVNCUGthYnlaSkpSVXZuL0FDT2RvcjV1NGUxZE9qRzlpTXk3Z01RbXg2R0NmV2tzV2VUeW4xcXJiWkg0d1ZPQnR5UjVtcUovQncyK0QwWENXUXdEODB6QWU4ZnQ5YW90NFJWQjh0Rmp3MFJiWStSTStacW4xVXVCMG5oc3NPRFdneXM3YkwrMC9yV212RTFsK0NLWThaWllyaWJkc1JvVzMwNm1yazR4WEJidWpFcmIvRTljeFdZMjh2UWNxeldXeVhncWMrUnpCNG92NGlJRTZhL2VOdm1hUnp5c29iZzBuQytHRFIzZ3pxQkdudlhSMCttLzhwR21GZmxsd0JXL0dDNFdnQW9BS0FFSm9BcXVNNDRoTXFETVdHOFNBUFRuVk5rdU9DdWNzTGdvNytLRjFBaW1IWGRUb1Q1anFPZWxaTEdweHdpbWJjb21TdnFWZUNTSThqSC9BQjdWeW5sVDRmUm5oSGtpcmpGOGFIWnhsMDVNR0JCOHhJajM4cW9uUGUzazZWS2FlR2I3QjhTY1lXMHR2NGluaWJvZkxxZk91NUd4eG9qR0hlRHBWNmFMdGJzNk04bHk0SGhtWWc3eVRyTmM3Zlk1WWsyZHh3cmNNeFNLanRsd2RWY1pKOFFCNjFwZUtwSFErbGF1VW9lN3dVdU1zM2JlSDFjc3I2RlQ1YkVkQ0t0amJrMjErbFpmd3VWNVJUWXZFRWhDb0tza0FFYUV4c2Y5UU5QbEYvb3lqblBLWW1JdWwzZHJtVkhnRTVWMEpPdVk1VEVtZVhNN1UzTDdLYXRzSTdZY3I3a2tpeXRwSFM2M2VLUWN2ZHFmRWQvR0NDRjAySTVlZFJoSmNGY1pXU3RhbEgydjcrUDAvd0NTTGhMTXFXejJ3VjhSVnMwa0RvSWdnN1J2U3FKb3N1eEpSdzhQeWpuQmhnR2RXeUZSdUxpb1lJMkFuTVRNYlRVSk5QSkZzMWxSYXluOXNrV3pjWE1NK3F5TTBBRm9rVEUvbXBsRVM3TFdJdms1dUw0aUVPaDAzNUU2QW5TZVhsVHJKUzN3bExzRXlsR21lOHpJRkd1M2l6VDUvQ1BuVGNZRTl5bHgwZFdjV1ZVcGxHNkdTUEVNcFl3T2tsak5RUzRKdmNTOEl5OTVtUm5rbzJaaXViSTVKQTE1K0dOZDVhandVV0tUVzFyejE5alE0amdXSnhGbEVHSHk1VlJ4OEtBa2lIa0dOU1lNL3ZSUG1KNXI2clR2V0lQTHljMit4ZUtSbHpJSU81VmcwZGRONXJMT0Vrano4dExhdkJPeFJheGQxbktUTUVRZlRYYlNzMnF5a21aNTF1THlXNlhreWtBOHRaMFgyOU5xeDN3VFc2SFpmWGlYdFJ4aWNaa3lxRHBsQjl6NWZLaXF4YlVtWjdVNHZDSExHSjY3MTBZU1hnenB2SXZlbG1HWDBtb3R3bHlYWWVUVzluT0VhQjMrSDhxOWZNMW8wZW16NzVHbW1yeXpUUlhVTlFVQUZBQlFBVUFjNWh0OUtqaGdVWEhVZEFNa2hZM0cvcDVDdVpybFpGWWh3aW0xc3pPSnd1ZU0wbU5qK1lIeU5jWGZiRjh0dGZ1WnR6SVJ3RGpRbnZWT3gyY1QxL3UrL3dCcWVVWEpaWFA5U0l0NTVNOWpzR1Z1RlQ0U3BrK25XcUl0eDRaMHFvN3BwSTlRNFBaSGNXL05BZm1KcjB0VVZzU050azJwczZiaGlrekZEb1RlU3hhbVNXQ3M0M3d3dXdQU3Mrb3BjbXNHM1NhbFFpL3Vabml1RE54bHRnRXF2OG41MW1jbW5oSFgwMXlyaTV0OHNvdU40UlVCVVJJKzlUWEo1NVowOUxiS3g1WmxycXN1WURUTUlPbTRrSDdnSDJyV3BjbXE2bFRXNUhMWFVqUXRPVEtRUU5HelR1Tnh2dU9tOVc4ZG81OFhOTnAvSS9aVmU2RFpqbUJJeTkySU14dTRPMFJ1T3NjNmhwQnVsdncrdjFHc1BncmpBdUZPUlp6SGtJOHp6bzI4RnZxNGx0YjdPTFhkNUhuTjNoZ0xFWlFKQkpKMzY2UlVlQWNaYnNyR1BQeVR1RTRmSXB4UkFQZDVTZ2FZN3d0b05ONEFMUlBTYWFQeVo3UGZKVlB6L1FpWVd3THJNV2NLY3J2TGFBa2F3UE1tUlVkc3RuN0V1TStDMzRQd0M5ZlVPYllGc0FySk9RdnFTV25jNWVwRUFMUWt5aTdVVlZTeG5uL3Y5VGVjUDRWYnNKbXMyWHVCUXA4RURPNTBKQlladEFabk5weXAxRkhIc3VsWlBiT1NqbjU4TDhmSmE0cnZXc2tyWVVOS2dDNCtZRUE2bWVuUUdpVWNvejErbEczRGsydnNoMUZMMkNmQUNBZGpJMDgrWDFwWkp5Z3hjcUYyT2VTa3RDMWkwWU0yWXJFRlFmbnFOcHJGczlTTFRIMStoV1Z1ampQNkRXTHdIY1dYMUYxU3BVNmVKUjZTZGpIeXJQR2x3YldlR2MzVDZCUXNNL2lBK1lNUVZMS2pLUFlEOTlLdzJSVVhoSE8xbE8yeHBDNFhGbVFxNmt3Tk55ZHZ2VjlFM0ZuTWxCNTRSdSt6UFp0ejQ3d2dIV05pZktPUXJwMGFhZGozV2NMNE5kTkQ3a2JaVmdRTnE2cVdGaEdzV3BBS0FDZ0FvQVJqUUJTbkVvU1dCOFNiNjZ3ZXZsVkRrc2lPU0c3bkcwSUt1c2pYVWVWTEt4TllhRmMxMHlyeGVJc2dadzJubkUvS3ViZkd1SzNGVGpENUdjUGZ0UHMvVGZUL0FJckpDeXFYS2VDRlg4RXZqUEJFdWhIMk96a2ZtVHA2N1ZwdjBzTFhHU2Y2blEwMHRzc2xsZ0xKVlF2SWJlbGJxWXlTNUw3SnFUeVRRYTBGWTNkVUhTb2FMSXRvcU1maHNvT1VhMW50aGhjSTNVMjduN21ZN2lYRHo4VDdWeTViNHZrNzJuMUM2aVozaTJDejdDRHk5S3ZybmpzNm1udDJyM016L0VlR01nQmJTZHEwVjI4bHM0MTJwdVBhSTFtK3FyQnpob1lhRVFaSTMwbUk1U2EwckhaZzJ5akxrNnc5bG1SbURES3NUTEFIeWdIZjJxR2l4VDl5aVRlRTRhd3kzRGNjOTVEZDJ1d1l4cExiYjBSdzF5UmI2a1pyWXVQSXR6aFRyWU4xaVZBSUNxd0trc1RxQUR1QU5TUlNKUER5TjZxbFo2YVJvK3ozQXJGKzJMamdwQmFkOHBMdDRGRyt3RWY3dktDOElweE1XcTFOMm5udFhQOEFYanMxSENMVjIwRXNJaVNwL3dBY2tNUXE2a1cxTGI2UjduYmVMVjhJNStwblZhNVdTYjUvbDY1Znl5UmdyMkx1M1hMUll0QmJpaFNxa2c3S3gxMWdlSTdEVUFUcWFsTjV3VTJ4MDlkYTIrNlhIeitWL2J5UnJQRGx3OWk1ZEx0aTh5WmNxbG1EU1lKRUVtU2R6T2dGSzBrc3N1bGZMVVhSaGhWNGVmQ3greUdlRThlRnUwNXU0Y1dMWUNoVDQ1Y3hvZ0RBRmpITWFWWEJSaW40TE5Sb25aWWxYUGRMejF4OTJ5czRoakZ1V0xtSnNSaHlqWkhXQXJ0bWd4SzdUdkhXa2tsaHRjR3lpblpmR203MzU1VDdTR3VHY2NacmE1Z1NxbUNRTklQSWsvbTNySGN1c0Q2dlFKU2VHc3NuOFhzRzR2ZXA0Z1ZWQUNQZzFQVGJmWGZhc2Q4VnRVankxOVh0Y0pMazBQWVhnV0hzV3hpTHJxYjVCK0lnZDJOaUFPditiNVYxTkhHbU5mcU5yL0J5VlZzZkpwYnZhTEREWHZsUHBKKzFhWHJhUEVrUTV4WGJJRnp0dGhRWWx6L3NQNnhTL3dBZlMrdjZFZXJENUlyZHY4UHJsdDNEN0tQMU5STFhRWGhrU3VpaHZEOXJMK0liSmhzUFBWbU1nZXNRQjg2bU9vc24vTEVoV1NsMGpXWVFQbEhlRUZ1ZVhRZTAxc1dmSmNQVklEZDV3QVpxR0I0N2pNWStGeGJNTllMS3lrL0V1OC9iNlZ4cFQyMk13TnVNeWZ4akhoMUQyMmxaamZZN2tldXYxcEx0UjhFemtVdHBuWTdtUnZKbjVjanA5cW9iM0wzRXdpcFBnZlcrUnlQbnVKckJic2J3dWpWQ2w0Tm4yWXdsN3V3N3NRRHFGNitkYnZwMmxuSDM1YVh3YXExdGpoOW1vdFBwWGVqMFJnNHUzbzVlOURsZ2VNY2tWc1lKMk5Kdk5DcFowdHdNS01wa05PTEt2aVhDVmJ4RW1zOTJuVXVUWlJxcFI0Um1zY0xkdlJVbHVwckZMYkRoSFhwMzJjeWZCaytNWVpyaG1TVDBwcTVMeWR6VFdSZ3RyTTNqOENWM01IeTErZGFvV1lDK2xXUjNSRzJ1S0RDU0pWVk9iTHZwT28vTG9OVHJWM2ZLTVVGcy9tTFd6ZnNMWTB0dDM4a1ppUVZCL3VBOU9YWFdweWtoNDFXeXR6dVczOXlmd2JnZ2U1Ylc4WEJZQmdvWHhFYTdUMUlFSGJXVDVyR0w4aTM2cHhoS1ZhWEhCc2VDNGM0Wm43c2Q3YVJYMUhpYzNKQUNLQnAxRXh5T3dpYk9qazZxMWFtSzNjU2VQc3NmTEhIeFY5YkZ3MzhVbG03ZFArR0hJR1JkQVlFeUR2cnJFam5vR3k4ZDRGVmRVclkrbFc1Umozanl6aTNnc0xZUnJGL0VSY3hCVXRxMGtEWUVtVGxQK1k2eWVXbFEwa3NTZlpNcnRSZEpXMVYrMkdjZjMvSkk0NWhjWGE3dXpnVUtXZ0NTeTVCNGlmelo5bDVtQnJORW95aWtvbGVsdDAxamRtcWVaZkR6MStDSDJrN1JLR1REUFlXK3lHMzNoUGh6T1kwdHJFazZrOUJTenNYRVdpM1JhSjdYY3A3VTg0L1Q3bFArSU51MWJhMVlzSUZnRnlxalNUcHFCdWREclNYWVdFam9mUm5aT01yTEg5c2xUZHh0eTFoMXRSQ1hpTG9QaGt4NGRBQUlHbnJWVThwWVp0cW9yc3VkbWN1UEgrNWM4SDRtTGdGcUJCV0dHbnVldFliTXJqQnlOZm90cjlSOStEbkRXOE9OTzllNWRCWld6QjJLZ01WQTBFS0lBckhxYXJQL0FCV0YvdC83UFA2cWl5VDZ3dndUR3NEYWE1eWswK2ZCeEp3V2NNWnhMS0Jycjh0Zm5xYTM2Yk1tTGlDTHpzOTJSdVhvZTlOcTN1Ri9Pdy8vQUNLN3RPa3p6SWVOZWV6MExBNEpMU0JMYWhWSElmYzlUNTEwSXhVVmhGeVNYUklwaVJDYUFLTHRGeFlXb0JFNmJ5QUJXVys5VnNwdHMybm5QSGNhbUlhV1VJUUNNNElPaDJCSFBsNlRYSHZ1OVI1WEJrbFBjUXNEYTd2UUlYdG5Sc3B6VHZxT2g2Vlg2c1pjU1JmQlJmRExQRmNLY0xtUkd5TnJPVWo1amthcXVjNExoY0dpdWxMbzU0UGhtUzRHdUw0UkJqck8wK1ZOVFJocWNrZHJUYVBkRGMyZWo0UEVoMUJIeXJ2VnlUUmt0cWNKRXFLdEtqaTg0aURRMk5HSXgzQ255cGRxWmJ2a2lCaXNYYlF3R2s4d1AxcXFVb3JvMFYxV1Q1YUlhOFZJbnAxcXIxbVh2VEx5ZDNSYnZEUUxtcUdvV2ZxRVhaUytlaks4WHdOMVowaFQwRlpKcVVHZHJTMzFTeGg4bVJ4dkR0eURQV2FzalprN3RkNmF3eXBzczF0dzY3aWR3Q05kRG9kSzBSc3dKZnBZekh1SDRVWFhJRy81VUFKTEVtTW9qYmZjNlZZdWVUUE43RnoxOC9HRFd0dzY5WWFWY3F3VmJkcGxCZlVFWnBNSFFhaWVyQ05LWXdMVTFXeDJ0WlRlWlo0L1FmVGhPTWRvdlhHUlFGYTdjekNDUGlLeUdFUVBMZjBGU295OGxiMWVsaXMxUnkra3NmdVdRd3VDeEZ4OFUxOE9sc0lHREFRb1hZU1JKQlB6UHlwbEdMZVd6SjZtcm9ncUl3dzVaL09SN0E0REM0cTljeGR0MnU2Z3FqREtnWlZBV1oxTWFIcHJVcUVaUGNKYmRxZFBYR2lheDh2eTAzeU5kbWNIaVVlNWlMdDZUa0l5ZDZMZ2R6ckpqd29vT3dGTENNc3VURzFkMU00UnFoREhQZU1ZWDlXVkhBc1R4QnIvQUhqaDFXUzExbnRxcXFvNk1SSk1DQUIxcXVPN09UYnE0NktOV3lLNTZXR1pyaU4yN2k3cHU1Wkw1eW9rZkNnSlBQWUNxcGJwdkowNmZSMDFmcE45ZjFaRXY0cDJJY2dRcWhWMElVQWJBUnNOL25TTjVaZkdxTUl1TVBQSk13R01UUG15aFNGVlJFNmtDTTVITmlkK2xWV1BKbDFGYzFEYTNubi9BS2pXWGlXUlFDNHlpU2JaSGkwNWpXZVhLdWJkQ2FmU2Y2bmtkUkZ4bko0eXZBY000amgxYnU4VXQ1T2poWU92OTFzak1OT255cWE5TFRuL0FGY3I5SG5CeGRSNmY2RzU3UFlEQUVoN0xyZGNmM05MRHp5R0lQdFhhMGVuMDBGbXQ1S29LSC9pYWV1a1dpMEFGQURXSXRaaEV4c1FSeUkxQnFHc2daM3REdzFMa0crckFqODl2VlQ1a0hVZWsvT3NPcTAwYlY3djJLcktsTW9QL1N0aC9odTZhZmwxK3ByQXRDczRVdUNqMEVtYURoL0JjUFpqS2dMRDh6YXQ4K1h0VzJyVFZWOUl2U1NJL0ViM2VYZTdqd0lwSjVabS9VTEluek5WMlFkMW1KZnl4L2RtdU1Oa054a2VKWXpLemhZOExCWTh3cWlQMTk2SnIyNFBVZlRLZDFNRy9LeVQrQjhVZWRUL0FEK0dzdGRyakxCT3Mwc2NjR3h3ZVBEMTBvV3FSd2JhSEVrc0pxN3NwWEJEdldkZWNhenIvSTlxU1NMNHlNenhYaDF3ZUszZUNycm9iZWFUMExUTVRIS2F5elNqems2Mm4xRVh4S0dYK3VQMksrL2dydHJLMWdya2d5aDFBOGxKMWp5M3BXbXVVYVlXMVc1amF1Zm4vSTVnY1lDd3p5ampRb1I5UnRKOTZXT04yV1JkUzFGN2VWOGxpM0ZCNGtjQmdEcDFnL3JUTzN1TE1zZE0rSlE0L3dBa0xHY0l0M0Z6VzFNODE1MGpyaTFtSnBxMWxsY3NUZjVNVHhmQmdhQlkxamFscmNud3owZWx1Y2xsdkphY0w0QzRleWlPQVg4ZHdybzZDTlBGUFB4Q1BPdDhZbksxR3NyYW5LVWV1Rm5wbGtSaUY3MjVtZndvN1dyV1VlR1dDOTRkZFlIaVArcjV0eXVUSW5UTFpEQzVmTXZuN2YyRXdhV1V3RG05ZllERXRPYUphUTIyWG1TQnJSaGJPV1RhN1o2dEtxSE1GMTRKV1BzY090NFVXM3VzRnVsYm5lQ0d1UEd4Z0tSbDVSRVZMakJSNUthcDYyZCsrTVZsY1lmUy93Q1JNWll3NllNV2JOOFd4ZUt0M2ptVGNua1NJZ0VRTk5oVTdZN01JaXFWMHRTN0xZNTIrRjRLekU0RjhOaG10V1dMM2Jycm15S1lDd2RFRXp0ekpuV2wyN1k4R3F1NzE3dlV0WEVWNS91UjcrTHY0VEJNbHhpSHVQRnRHWUZrU05TUnNQVGxOTGx4aVBHTk9wMUNuRmNKY3RjY21aWmJ0bERBaGJ3SzVodXdXSmc3bE5ZNkgycXBaU09odnF1bm55djIvd0NSakQ0aUREWlFDcFFrck9VRWlUcHJtZ2I2eFNQaGNJYXlIY2szbnNsNGF4YmE0dVY0V0NHTU56SkEwT3NuVFNxbkZ2c3F1dWw2ZnZYSmM4SHVzcVNZTnN5QnRyQkt4RzhhVlJaVzlweHRiQlBqeVNzYmdudm5LcEVxc0tDZFRydG1Qa2RKOUt3eHN4TGJQdm84cnFWblB5VXJDNVp1WlhEVzNYcklZVmU0U2krc0hMY2NQZzBtRDdSNGtRdjlSYzkybjYxcXJ0dFMvbVpXN3ByeVhPRjdSWXRvQXVNekhZWlZQMGpXcm8yM1B5VEcreDlHejdQMnNWQmJFdk03SkEwOVNPZmxYUXBWbU16WjBLdCszM0Z6VjVZSVJOUUJWWHV6OW9rbEp0ay8ybncvK093OW9xbWRFWkFPWWZobVFmRko5SStlcHFZMHFJWVJXOFp4VUxtRnVHVUVCVHpKMWllbWc5YVdmUGd2b3I5V2FpK3ZKNWZ3NnhjZk1YVnMxMDk2R0EwekFITXBISXlwaWVrVlJzeXVUMnFuQ3BKUmZFZVArVHV4ZVpIeWM2NTkxT0dhcFFoT0c0MFNZczJsZ3Q0anFSVmVYV2preXBWc3VGd1gyRTR0L2c1cDZWdGhlL1R5em1XNlgvVjJrL0M4U1Y0MTMwOTYwVjNxYU0xbW5sREltSk5zbkswYTFNdGo0Wk5mcUpib2tGK0hLUGhlSVBxS3FkS1hUTkMxRW4yaXM0aHdVdWN4azZSNGYyTlZUcVpzbzFteU9FVnR6aDdJb1VOSXk3c1BGTW42ZS9La2xFMVJ2ak41YS9DNk83Vnk5YUFMTHAxVW5UelAwcU1PS0ZsR216S2kvd0FNY3hLcmluVk1zTUFTekxsQjAxMSt3MjNyVFV0M0xRa1hQVFJjczhmQkdUaHQvdWJyV2xDbDhxS21aUDhBQ1g4eEJCak5CNmptYTBZZk9CbnFLdlZpcDg0NXpoKzUrQmwrSEtjQ2gvcWtWRVk1bU1zQ3NtTGNxUVRIVG1SNlVOTng3R1Y4bHEzL0FLZkw2WHg5eExtSDRlMkd0bnY3Z1d3Q0pXQXh6N2dnZzZzWjI4NkhHR095TjJ0VjhsdFdaZnRncjcySTRmZmRUbXUyUWx2SkFLUVZXVEVtU3BJSjEzTlI3Sk0wS0dzcWkwc1BMejV6a3I4WXVIdk8xdzMrNnRBS3FJYmJzVlVBZUZEOFBJNm5xZmVNSnZ2Z3ZnNzZvcUtqbCtYbGQvY2hBTmRMTUNGUzJZVXZjVUtvODljeE9VQWVFRXpVWXo1TEpXS3RKWXkzM2ovdUNydmt0NG1ZeTJhSjEyMWlTWitsR01qdXhSNFFnZTR4ejNNekNBQ1dHWWhaM0FZeG9OcDAxb3dJOEpZandPTmZ0RnlRdVZUQ3FHOGNRQUpiYlU2ay9RVWtrMitCZDFzVWwzOGptRnNnNW1GM0l1WWxTQTBtSjEwK0VlcDUwcmp5Tk96TFNheVhGM0NaTFZzZ21PN0JBMmdheWZlZnJWZGtPRG16bHZzZjZscG1ZSmJ1ejRpQnIxMEIrNWoycm1hdXBOS1RQUDhBMUNxTVpjRzI3SDhRdFk2MmJPSXRwY2UzcU13RFN1MGduWWpiM0ZkVFFXSzJHeXhaYU9WN1pGeXZZL0JBeUxDLytUeDhwcmV0UFd2QXJwZy9CYVlQaDFxMS93QzNiVlBRQUg1NzFZb3BkSWVNSXg2UkpwaGhhQUNnQW9BS0FLcnRIZ1Jlc09rd1lrSG9SU3lXVWFkSmQ2VnFrZWY4VHVYcllzM0VBZ2hSY0ViaWZFZE9wa2crZFV2UGc5SHB2U252aEo4K0gvUXBzWGhHVzUzaXlRVG1RN3dOU1ZQbFdleURrZFNxOVRoc2ZIeVFibU9iTkxHVEpCMW4rRHpyTE9nMlFxanR4RTBkekZCY0tuVmpOVlNXSzlweW8xT1dvYWZnYXdYRUNJUDNxaU9ZeUh1MDZaWWNaeGtzR0hRRWZUOWF1dmszSk5HVFMwcFJjV0dMeGJGVmFUNHRENUVmd1ZOamswcFpDdXFLazQ0NkZ3dkVXSnlaam5BbGYycDY3WlBqUElXNmVLOTJPUEk1aHVPQmxJZFFXVWErWS9lckkzOFlrSlpvbkZweGZER2VJOGV0ZDJwZ2lUQkV3QUkvZzk2ZU0xWjBQVG9iZDdXZnlROEwzYjJMdmNaVnVPUXM1c29NbldEcnJIUFUvS3RLL2xIdDlTRnNmVXkwdnRrYnV0WXdtR2JCM25iTmRPY2kyQkFFZzVmRVJLbkxIVTYwMHNLTzFzRXJkVmN0UkJMMjhjLzEvVWdZM0Y0TVdVczVickF0M2lnWlEwNmd2b0NJNUJZNUdsMndVY0dpdXJWZXBLYmF6akRiL29VT1B4MXBsRnExYk1adzdPelpuY3dSR2k2YUhrS2g0YXdqZFZWWkRNNXk4WVM4SWo0Ni9iWVpiTnM2Z1M3dm5JQTJBMEFVVU5Md1JVcHhlNmN2OXVCckd2YkpTM2J0M00rZ2JNUVNUc0FGVURTVE02a3pVdEx3SkdWa2N5azAwTVkvQ3NqWlhYdTIxTUhReHNKV1RsSm9hRWhkdVdjbkNYR0NsTFprUElZWlFHMGpUTUpPWGJuR2xUZ1RLazh2d0JLcWhMQmpjUGhCRExrQTU2aVN4alNOZ0RRUXM3c3A4QWh6NWxCV05sR1h6MWJOeWdDU1NkWnFBeTA4c21XTzdZV2tXMnplSStKdEpBSWtnYmRSclVOQzdtOHlid1dsbkF1dHU3Y3Z2NFpYNGZFVHF4STAyT3MrUVdxM0RQWlE3RTVSald1U2J4N01pMmlCQ1JBOXdHK3graHJIcXE4NFBPNitYK29hRDhKbG5GWFcvdHRFSC9jNGo3SDVVLzArTDlSdjdISWd2Y3oxYXUwV2lVQUZBQzBBRkFCUUFVQWN0UUJsKzBYQm1LVFpiTEVtT1c4L0thU1VUcGFQVktNc1RXVE9XWmUyVk9SR0FNRVFWNjdEL2lreGs2YWtveXlzc29NYnc0dWplRmMwQ0hHcW4wZ3ovd0IxUTRzNjFHcjJTV1c4RlRlczM4dTBCWTBHM3NLcmRhOG5ScXNwVDd6a2pyanl1aEJub2FwbFFtYXZSakxsTW5IakVvSk8ybno4cXJkTE0zOEppWFE5aCtNQXFVbm1DUFVVZWs4WUs1Nk5xU2tSdi82NVc2cnpJMHBvVllXUzcrRFVxbkVtY1Z4YXJkVjFZRU9NMmg2N2o1MHNxOG1mVFZTbFc0eVhYQkhQRkFxdXBVak1SbGVGTVpTQ1FNMjJzYXh5NTFvcWp0aVJacG5PU2FmWGFKbkVlRVdYdHJkdFg3YTJsUUI0ek13SUpKSUFNRW5RZTFhWEJkb3lWNnE2TTNDY1c1TjhmR0JqaWZGOE5lbTY2WENRQXFnTmtMQ2RpVm53NzcxRW5HWExIcTAxOWIyUmtsNWZuQlZXOGFqTVhleUdYSmxXMnJ2YmdLTnN3QnphYWtUSnBWaHZPQyt5dHFPeU0rYzh0ckpId2w2MmJwZHJTRldsUmJPWUlwSTBHWU1ET24xMXFWM2tXMVBhb2JubjU4amRwdzdzOTFHVlNKeTJRZ0lBRWFLODZSenFmSWswMUJRaTFuN2tTMjRZc0FGRWZEbklPZzJVejhXbW1nazBFVGswc0hQZElOZFpNc0ZXQ1FKMG1kejVVQ1NuaFl3VGNYWVl3elhRUkdWYzBLSVBJUnR2eUZTeXJkRkxDTzN3dVVNNFRVRFJaTHl4L05zQk1jZ0FOS0JWTEN3bWRoM1cwNzNmRU5nREFKemFRVHlIeXFTRytVbDJkNE1EdWJqS29WOUZ6NXBFYmtoaVRBalNldExnaWY4QU5oOUZyYXdOa0xoTEpPZGJqWm9TUUdiUVRIOW9XQi9EUTEwVXUyV1p5WEdGK3g2UGpPeXB2NEc1WWVCZFpqY1E4bFpkRUhvVkFCLzFHclpWS1VXbWVYdW52bmtYOE51Ri93Qk5oemJ1SVV4QlpqZHpibUQ0U0R6U09ZNm1vb3JVRmhGUnI1cThCYUFDZ0JhQUNnQW9BS0FPVFFBemNGU1NabmkvQkxaUGVJTWo2NmpZK29wSERKdHAxYzRjUGxHUnUzR3NNY3lpRHpXUVBXS3JjV2pweHZoTkVERVk4WjlHVXFaMkFrYWRRZjBwWEUyVjJ4d1JyTmkzK1oyZGVqUWZyRTB1dzFmeGI4Y0ROL0RXVHFFQi93QnhXS1Z3TDRhK2EvOEFJaXZnN0VhTXdQa1orOVI2YUxGOVJsNWFJZHl6Yk91ZGwvMUZEeS95bW85SXRqOVMyakYyNUNrTmNCaU1vR3ZYcnRVZWtUSFcxN3Nvc2NKZysrdHJMeWZFY3FtVE1qYzdTQkFvVUJQNHBKdVVWMlFzZFlZdWRNb095bmNBZFFDM1FublVLRDhsdGRpakRsNUdzUzZ0bFRJRVlSNHN6Tkk1QUFtQURNNlUyUEJFY3h6UFBId0lXR1FMQ3dDeDd6WE9BRHFzVEUvZWFaRkxmdTMvQUxIYUptdEZFeWJtV1pWemlJTUJ3U011dktPZFNpbmVuTGRMUDloY05iWWlRQTdCcHppNENCcEh3WlpKSTBrbU5kcWxJU1VrNWQ4QzJyajU1YVFKSTd2SnlqUTV0dCtZTkFrdnNJcnE3L0FJT1lCeTNpTUQrM2VEVWlOdEhkN0JCMlVaeG9DTXNTUE9EdEkvU29XTWkrb3ZKMWkxZnZMYWk0RkduNWdwSkIrWjZSVWlwcDlrbkgzWERKYlJaelFXTUFnYTdhNkEwQkJMc20yalp1cTFveVFwQmJMT1hUOHVtL3QwRkJYSnlUM0d6N0o4THp4ZUtkM2x5QzFLZ0hJR2t6MEJHZ0huVFJXVGo2elVOWnJ6K3B2VWFyemxqZ05HQU9xQU9xa0FGUUIxUUFVQUZBQlFBaG9BYmNWSkpFeEZxYUJreWg0bHdoWG1SUVdSbmd4L0UreHdKa0NLVnhOTWJ6UFluc2U0Mm1sMkZ5dVJBdWRsYnZuUnRZL3FvYVBaVzdQT28yanExQ0RzWmRQV2pheHZYU0hSMkV1SG1hTmpKL2lVWDNDK3p0eGJSdGdDUkpVK1o2K2UwVWs2MmFLZFpGY1M2R2VKNE1aOXhuaktRd2tIbnFKQjViN1ZWbm5CMGE3azFqSEJTZHd1Y0NHSkJSYzRpRkoyOEpCQmpTUWV0U2E1VGxqaGNCanJKVTVya01XSmhpSVZZaUJDa1JQdHRReWpPVmlIQW1PZGU3RE5uSnVBRFZqMDZ0SmprS25CV25MT0VkVzBLMnlRK1hPQjhXVVFZNmpjK2RTSktTenloTUxaZTJqRUFNU0FSTEZnVDE1Q0QvRFVrTnBzZndwWlVMTWdMa3lBQW9NZWNhSG5VWUs1UG5HUXMzTW9MRzNEeVlqVTd6dlJ3aUhud0ozYU9SZEtrT0FERTlOdW1sRFFKdVBCMnVQY0tTUWdhZkNKL1hyUmtWN1MzNEc2Z1pya0VremxBZ2UvV3BSZzFOemZFRDBQZytKTGdHcmtjZWF3YUN3MU1WRWdWSkIyS0FPcUFDb0E2b0FLQUNnQW9BS0FPU0tBT0dTcEp5TXZacVNja2E1aEFhQ2NrWitIZzhxQ1ZJYVBDeDBxQ2Q0bzRTdlNwRGV4NU9GTDBvRGV4d2NOWHBRRzluTDhOWHBVQnZaU2NjNEdIQktBQitwRzRxdXl2Y3VEYnB0VzQrMlQ0TVB4TGdvVndXWExjalJzdWs4aU9WVXVEUjI2ZFltc1o0L2NxY05oemJEQzg1WXNSelp0dWNheC93QlZINmw4cHg3andOVzdEWm1aMkRJUVlYa05aSGhPeG81RmNsamdqNG0zYVlRUVZ5N0FFVHJ2dHkvYXA1YTVJM3RER0x4RnQxRWtxRjVaZ0FaNnhOVGdYMUVodTV4YTNrSzVnTkk4UEx5R25wUmdUZXV5RU9OcW95cUMzbWQ2bkFqdElpNDI0WnlBaVRxZFNmbWFnUjJrekE4T3Z1WmduMW8ydGxNN2tiYmdmQUxrZ3ROV0tCanN1WGc5SjRWaHNxZ1U2UmdrOGx6YVdtRUpLaWdVNkFvQVdnQmFnQmFBQ2dBb0FLQUNnQktBQ2dCQ0trQkN0QUhPU2dBeVVBTGtvQVhMUmtBeTBBSXlVRWtXL1pxU1V5bHgrQmtHb3dYUXN3WTdqUFp4Mm5MVmNvWk50ZXB4MnpMNG5zWmZPa21LWDAyYUZxME1KMkJ2SG1ZcWRqRmVyUklzL2h3M01tbTlNcWVyUk9zZmhzdk9qWUk5V1dtRi9ENjB1NG1wMklyZXBreTR3dlpHMHV5RDVVeWlpcDN0bHBoK0JxdXlpcEszWXl4c1lBRGxRTHV5VDdGbUtnVWxxdEFwMkJRQjFRQVZBQzBBTFFBVUFGQUJRQVVBRkFCUUFsQUJRQVVBRkFCUUFVQUxRQWxBSExMVWdNdmFGQkl5K0dXcEp5Tm5DTDBvRExEK2tYcFFHUlJoVm9ESW93NG9BWHVSUVFkZDBLQU9oYkZBSFFTZ0RwVm9JSEJVQWRVQUZRQXRBQlFCLzlrPVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wdWJsaWMvaW1hZ2VzL2ZydWl0cy9zdHJhd2JlcnJ5LmpwZWdcbi8vIG1vZHVsZSBpZCA9IDIwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFBQUFRQUJBQUQvMndDRUFBa0dCeEFTRWhNUUVCTVdGUklXRHhBVkZSVVFFaFVRRlJZUUZSSVdGaFVWRlJVWUhTZ2dHQjBsR3hVVklURWhKU2tyTGk0dUZ4OHpPRE10TnlndExpc0JDZ29LRGcwT0d4QVFHaTBsSHlVdkxTMHRLeTh0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMZi9BQUJFSUFMUUJHQU1CRVFBQ0VRRURFUUgveEFBYkFBRUFBZ01CQVFBQUFBQUFBQUFBQUFBQUJBVUNBd1lCQi8vRUFEc1FBQUVEQWdRRUF3VUhBZ1lEQUFBQUFBRUFBZ01FRVFVU0lURUdRVkZoRXlKeE1rS0JrYUVVVXJIQjBlSHdCeU1WRm1KeWdwSWtNMFAveEFBYkFRRUFBd0VCQVFFQUFBQUFBQUFBQUFBQUFRSURCQVVHQi8vRUFEVVJBQUlCQXdJRUF3VUlBZ01CQUFBQUFBQUJBZ01FRVJJaEJSTXhRU0pSWVJSeGtiSFJCaU15UW9HaHdmRGg4UlV6VWhiLzJnQU1Bd0VBQWhFREVRQS9BUHVLZ0JBRUFRQkFFQVFCQUVBUUJBRUFRQkFFQVFCQUVBUUJBRUFRQkFFQVFCQUVBUUJBRUFRQkFFQVFCQUVBUUJBRUFRQkFFQVFCQUVBUUJBRUFRQkFFQVFCQUVBUUJBRUFRQkFFQVFCQUVBUUJBRUFRQkFFQVFCQUVBUUJBRUFRQkFFQVFCQUVCcWxuYTI1ZGV3M05pUVBVcUd3Y24vQUZDeFVpaU10Tk5xMldPNWpkclltMXRPOWx6MTNtR3pLT1N4bEY3d3hVT2twS2VSNXU1MExDVDNzdHFUekJGazhvdEZja0lBZ0NBSUFnQ0FJQWdDQUlBZ0NBSUFnQ0FJQWdDQUlBZ0NBSUFnQ0FJQWdDQUlBZ0NBNXppUEZJV0hMVVZJZ2pIdXNONVpQZ0xrRDhWejFha1Z0SjQrWjFXOWhjM0wrNmcydjczT1pIRW1FWHN5U3FHL21ZNlZnK1Y3ZlJjL3ROQmQyZWovQVBPM3FXZEsrSnczRk5VNXJ6SFN1ZFUwN3dDUEVzMlJqZ2ZaY1JhL3JaWVNxMHM3U0t2Z0ZmRzhHbjZNdnVFdU02aU9FeFRTTmhiR3dDSnZoR1Z6amNteEkwQTlWZUYyb3JHcjlpeit6MTNoYUkvRm82N0QrSzRjakhQcW5oemhyNGtUWHg1dVl1MW9JSHhXa2I2bGplWDdIT3VEWG02MGJycXNyKzRPcncrdVpLME9ZOWp4ek1adUwrbTRYWlRxUm1zeGVUaHEwYWxKNmFrV242a3RhR1FRQkFFQVFITjAvRmpKS3NVa1RDNGErY0c0OG8xTnVRNzgxaXEyWjZVaXFsbDRSZTFOWkhIYk80QWsyQTNKUFlEVXJWeVM2a3RwRzRGU1Nlb0FnQ0FJQWdDQUlBZ0NBSUFnQ0FJQWdDQUlBZ0NBSUFnT0c0djRyZUNhZWxObmJPa0d0dXpmMVhtM1YyMTRLZnhQcE9GOEpqSktyWFczWmZVK2ZPd3h6M0Y3M0Z6aWRTNDNKK0s4elJKOXo2cFhNWVIweFdFYlc0SW5Ka1VkNmJvOENOOXo2S3l0Mlp5dmxna0RoOWgzVjFiK3BsL3lFMTBQWThFWXdXSjVteWgwRjNJbGV5bThvdk1Gd1Z2dHd5dWlrR3hhYmZBam1GMFViZExlTHd6emJ1OWY0YWtGS0oxZUQ0NDdQOW5xYkNYM1hOMGJKNkRrZXk3NlZkNTBUNi9NOFM2c1lxSE9vYng3cnV2OEY2OTRBSkpBQTNKTmdQaXVvOHNvTVc0bzhIMktlV1J0N2VJNHgwOGQ3ZmVsYzBrZHdDRmxPcW9tbE9sT284UVdUbmovQUZFeXRibU1PY2s1Z3lSa2pXOUFDeVFrK3F3bGRZUjBTNGRkOXFiL0FGMk1zZDQyQnB5M05GRzZSb3M1MHVUeUhvMDZnbFJLNGNvNFNPU1ZPcGx4eHVjOXc3eExCVFJ1eVN3ZUs4bThtZHJuNWVUVzNPZ0g1ck9OUndXeU0xU3FMYU1Uc2VHWnFaNUZSSlV4UGtJdTF2ak1lV1g1blhmOEZ2U3grS1QzQ2c0N3k2blhNZUNMdElJNmczQzZpNWtnQ0FJQWdDQUlBZ0NBSUFnQ0FJQWdDQUlBZ0NBSURWVWtoamkzMnNqcmV0dEZENkVNNUQvTWt2Z3lzZmN5RFFQQXRjYzcyMEJINTlseHp1R290ZHpyNFpUVmFzbFBwOHppcENMcnpHZmNwUEJ2Z2tDdEZvem5Ga3R0VTBiclJUUnp1bEo5RHgrS1JqbXA1aUpWck5rYVRHRzlWUjFVYlJzNUVXVEZRVm02bVRlTnEwSXNWYzNVT3NvVlJvU3RGTFpvMlQ0bTZRdGNUNW02Z3BLbzVibElXc2FhYXhzeXl4bitvRXBZeGtBSGlCdG5QY0xnUEh2dEd4UFMrMnE2WjM4bkZKZkU4KzMremtPYTUxbjRleStweE5XNmFaMmVkN3BIbm5JUzc1RFlMaWxWbEo1WjlKU3BVYU1kTUlwSXlqbzM3QnYwc3FwTmgxS2E2a2VmQzN6UytkdVp4MzAvbGx0R3BOYkl3NUZwQ0dkS3dXRE9Ibk4vK2JmVUFYVlhHcStyTW8xYlpmaFMrQmU0QmdsYTBuN0xMNFpkYTR1QzAyMnpOTndWdlJoV1Q4TFBQdmExaTE5OURKMEdINHkrQ2J3TVFpOEdUUWllbThqWERiTTVvOHBIZTN3WFZHdTRTMDFWajFSNHRmZzlHdFQ1MWxMSy93REw2LzMzL0U3dUI3ckE1aEl3MnM1dGdiSG1iYUgxRnZSZWduK3A0RGk0dkRKS3NRRUFRQkFFQVFCQUVBUUJBRUFRQkFFQVFIaE50U2dLR3I0cnAyT3l0RHBMRzEyV3kzN0VuWDRCWVN1WUo0NmxKVFVlcFYxUEdNaE9XT0ZvYWJqTkpJYi9BQWFHNy9GYzg3dVg1VWIwNmxxNFBWS1dyc3NMR2ZmbitENXh4ZGljc00wRGc4NVRmeWdtMTdnT3Z5MlAxUFZZTHhaWnowYXJXUFFzWklUbU9yZTFpYjJQYXhYS3FiazkraDlMViswbEtNRXFjRzVkODdKUCtUWFVWRWNlajNhOUJZSDYzL0pYa3FjRnZ1WjJ0ZmluRVczUnhHUG5qYjR2TGY2RVNweFpvQklpQkhVNmkzd1dYTWkra1QzTFhoRjBwZmVYTDl5Uy9uNkZIUFZseEpHZ1BLNU52UzZycFBwYWRIVEZLVHkvTTFHWjNWTktOTkNQUk9VMGtPQ1BUVUZScEk1YUpkQkk1Mmw5RkRXK0RHdEdNZHkzaHBtZ0xSUVJ3U3FOc2xRMDdWWlJSak9veTBwNFdEVTJYUkdLT0djNU05RFkydUxodVV3azhqTTVMQnBuclFxdVJwQ2l6VkJpNzR6ZHBzcXFxNDlDODdPTlJZa2lSaW1PR3BZR3lBRndOMnU1anFyVkszTVdHWlcxaXJhYmxCN1Bxam9PQmNYSVAyWjU4cDlpNXZZL2Q5RjAybFhmUXp5dU0yYWE1MGV2ZjZuY3IwVDVzSUFnQ0FJQWdDQUlBZ0NBSUFnQ0FJREY3d0FTVFlBWEpQUkc4RXBOdkNQbUhHL0ZrazJhQ21KRWV6bkFhdVA2ZGw1RjNkdVhoaDBQcitGY0dwd3hWdU4zMlhrY05EaHNyeVNIUHZ6SUo1K2k0WVNiZUlvOTI4dXJXalMrK3hwOG52OEFCRnJTUGRHd3RlOHY2ZUlXdEZoNi9tVjFKU3h1Zm0vRUt0RzRxNXRhT2xlbmY5T2lLWEhvWXB5M3hhbU51WFlOZm1zUGhkYTA1T1BZd2hhWEQvSS9nWDJIc2E5dVpzbWNsb2JtYThFMjVhQlYzWnoxSVRweThjY2U4aFB3SVhPVzVKNXVKSko5VnkxSTFFOHJvZmVjSDQvUnFRVktVVkNTN0xvL2Q5RGJoM0QwajNaV0N4NjNVVTZjNXM5dXZ4Q25DT3FUMlBNZjRXbWcxYzBDKzF2WlA2RmF6cFRwL2lKc3VLVXErMFg5VG1pVlE5YklZQ1NBQmNrMkFHcEo2QUpnckthaXNzOHVtQ1ZJdE1KM3VxZHpsdWQwV2o2dG81ajUzVm5KSEdxVW4yRGNTYU5pcDVpRHRwUHNhNThXS2ptUHNXaGFJaHZ4Wng1cU5VamRXc1VZZmJ5ZWFqTEw4aEc2T3F1bVRPVkxCdlpNcHlaT0JkWUxVRVBhNGJnZ3JhazhNOCs3cHB3YVo5ZnBwYzdHdTZ0Qlh1UmVWaytDcVIwU2NmSTJxU2dRQkFFQVFCQUVBUUJBRUFRQkFFQnhuR3VMRS84QWpzTmg3NUhNOUZ3M1ZYOHFQb09FV2lYMzBsN2ppUkdObDUrTW4wZXBrK25nRnUzUWZweldrWWJZUjVsV2hDZFRtVlBFKzJlaVhvamtNZnBIU1ZHUmd2b05sbS9ETENQZXR0TWFHWHNXZUg4SU1BdS9WMmwreXM0U2wxWnhWTHVDZmhpZVlqd2V5MmFGMlYyOWpzZjBWdERTNmtRdTR5ZUtrU1B3MjdJOTBVdHdSdHFkL1RaVWpOcG1IRU9FMjlXS3FRaWw2clk2L0Q4U0VUZzQ3ZzI1YWpxdFlWSXhsbEhCQzJyVHB1blU3ZEg1cjYrWlk4UTR2RlVRbHAzdDlWdFdxUm5IQld4czZsdlZ5ajVQaU1WblhDODZEN0gybE41aWIrSFcvd0I1cno3TEE1eDljcEErcEMzcDRjMGp4K1AxM1RzYWpYZkMrTFJ0cmNPRFgzYUNXdTh6U2RkRHJhM1paVmN4bGcyNFRmcTd0WTFIMTZOZXErdlU5WlJQS3h3MzBPNTE0bzJpZ2NtbGxPZkV5R0hrOGswTWgzQ1I2M0RuMzBVNkpFTzVqZ2tPNFhtZU13WWJkV2EvTnY2TGFOS3A1R0gvQUNWS0x3NWZFb0t5bGZFN0s4ZkViRk1IZlRxeHFMTVRHS1d5bzRtdU1sM2d0RStlNUdqUWJFbnIyQ21NVzNnNEx1dEdqcytyT2tvOEhld2czdjhBQmJ4cHRIazFieU0xakI5SXdXcWI0TFdrNnRhYmp0ZGVuUnFyUnVmSTNkS1hOYlhSbXovR3FlOW5QeW4vQUZndEh6T24xVitkRHpLZXhWc1pVYys3Y25SeUJ3dTBnanFEY2ZOYXBwN281cFJjWGhveVFnSUFnQ0FJQWdDQUlBZ0NBMDFrMlJqbjlHbjU4bFdUd3NtbEtHdWFpZko4VnFDWE9KNmxlTlVsbG4zRnRUeEZJcm16MldhWjF1R1RNNG5ZYnEzTXdWOW15UjZURVkyT0x6WXVQTXFJMUVuazFxVzA1eFVWMEpjbkVyZGJLenJtRWVHeTdrR2JpQWxVZFpuUkd3U0t5ZXJEbmgvTUtqbGw1T21OUFRIU1NtMTErYW5VWjhreSszRGE2aldPUVZzMW5PdC9MTFAxT3lQaGdXRlBTWkl5NGIrV3cyM2UwTGFpbnJUUG12dEZWelp6aXZUNW85WVNHdDJzMTlpYjMwSnNmeVd0eEhkTThiN0xYSzFUdDMzV1Y3MTEvYjVGOUd4cWhZUG9KU1pLaW84M0pXVVV6R1ZiU1NHVVFDdGhJeGRmUFF3bGphT2lodEZveWJMTEJzVmF6eXVzdHFWVkxabkpkMmtwK0tKQjR3b1lKbTUyZ1g1Z2MvNTFWTGlNWDRrZEhDNjFXazlFdWg4MXhDaGRFNERkcDlrOXVoN3JsUHFhTlhtTDFPdjRWYmFNc0J0Y1pocno1L2dQcW9vdnhZUEk0ay9IcWE5Q3ltckptYWdaZ1M3VExzQmJVa2RkZE95MWxWY1A5SEhDalNuczluNytwdnczaVlCNHUxMWdSY2l4dDE4dTVIcHIyVnFkMG16TzQ0WTNGNGFPbHFLWnNrZml3a09ZNEIyOTdmc3V2YVN5ang0VlpVNTh1b3NOSFB4WXA0QnpNZmJVK3diaHhHNHRzN2w4MWh6Tkc2WjZzclhuckVvNTkvYjZIWFlOeEMyWHlTV1kvVGZ5My80blVMc3BYS2x0TFpuZzNmRDVVdkZEZGZINWRTOVhVZWFFQVFCQUVBUUJBRUFRRmJ4QTYwRHZnc3EzNERyc1Ztc2o1UGlUdk1WNDArcDl6UVd4VFZFMWxpMmVoVGhrcnBha3FFc25WR0NSR2RLVmZTV1dERXZVNEdUd3ZUQlhKNTRpblNVWjZKaW8waFlQREtwMG1pa2l4d3VJdVA4QU5salB5TXE4OU1TNXJLdUVoOUsyNGVBTEU3T0lzYkVIYlVkVjJRcGFVcEkvTytJY1RsVmRXalVXMitQTk5kQ0RVMUVRY1l3Nnh1TGl4R2gwSTFIcnQxVnBwdEhnMjF4SzJyeHF4NnhlU3pra2Uxb2FYaHZkb0RwSERyWTZOL0h1cVU0ZWU1N043eDJwVmsrU3RLK0xORTlWazl1VU5HL25KbmZiMDJId1hRbkdQVTRxTkM4dkg0RktYcjIrTDJJNHFjOXpHMlorOW5YRWJTZVJIWkhXWFpIcjBmczVXeW5WcUtQdTNmOEFIekxPaXJKaHBKYTJ2dkZ4RitXMWxoS2NtOThIdVVlRlVLV0hHVXBQemJENm5YUlpObmVxZXhrMnJPeEtqVXlIUlhWR3V0cGhKRzRjOXgyY0ZENkZxTlIwNmlaUllmV3ZqY0NEWWdyR1M3bzlPdlFqVWpobzdlbG1aVU16TU9WMXJPeTIwUFd4M0hQNlhYUkNhcXJIUm56bFNFcmVlSkxLN0dtWERYdHk1cE13ZHJkcGJybE9vRjlRUjZLbkprdXNqU056R1djUnhqenlXK0VWQmhKYUxodnRXNTJPN3RCYjE1TGFNdEp3WFZOVmttK3ZUL0JMZGhWTTUvakNOaGQ2ZVVucVdqUW5SYTZZNTFZTUZkVjR3NWJrOGZ2OFR6RWFkMGhHckkzQzVhOXZrYUQwZGMyQUlGdWV5ckxOVHB0NU1VS2thYTd0ZDExZjZlcE13WGlFc2NJWnlIYk51MDNMWGREMSt2WWxhMEx0eGVpb1lYZkQxTk9wU1dPL3Yvdit6cm1rSFViZGw2aDRMV09wNmdDQUlBZ0NBSUFnSU9OUjVvWGp0ZFoxVm1ET20wbHBxcG55ZkZZOVN2R3FMYys0dHBiSFAxY2F3YVBVcHlLdVdNcVV6bzFtbktyNUljakV0VWtPUjVaQ3JrZUZxa3ByTW1Tc0FOMjVuWDBKY1FBT21VZmpkU2pucnhyVC93Q3VlbjlNL00ydzFBY01wZGt2ell5M1BhNGRjL3N0bEtDNnhQbkx6aFhFNnI4TnhuMDNqOHRpVkhoemlMaVp6aHRiTzlsdHRTZGRGZU5XbStoODFkOEw0alFmM3NKUDFUMWZMSjVVc2F4aGFXbHhIdkNRUElQY3EzYzh6VkpQRWlQUjRrL05rdG1PdVYyaElIVE1kdGJLSlFXTWw5MGlWSzZYTTFrWkdad2RkeDF5MnRmY2FiclBPbEhyOEc0ZlR1cE9kVHBIdDVtNk9saWkxZjUzOVhhaS9vc0pWRWZmMHFMY1ZHSzB4WFpHVW1LdU8yeW81eVoxUXRZbzFDdWNlYXEyelhreFJ2WlVFcW1UTjAwU1lwbFpNeGxBc2FlWFEraXVuc2NrNDduTDFXanpicXM0N285cW52QkUvREs5OGJnNWhzZnhIUXJPU2NYbEhMY1c4YWtkTWtkbFJZa3lZQUMyYTl6RzYycHQ3VEhFYUxxcDFsTllmWHk4L2NmUFZyV1ZGNWZUelh5ZTVoS0pBSFo3dUdWMGJIQnpqbERqY2kzdW42R3lwT004NTN4MEpnNE5wUjJmVjlOOGZQOEFna1UwcjRjaldQTDR2UGNQRmlMRzQwNmxYam1PMFhzWnpqR3RxY2xpVzNUcC9VWGNkU3g0QjBjT2h2cjFCQzNVbDd6enBVNVFlT2h6L2hzRWo3T3UyNUlzTlI3MXJkam91ZHhpbS9JOVhWSjA0NVcvOVg3blFjUFkvbDBOekdUMDJQTWhkRnJkNDl4NWQ5WWF0MStKSFpzZUNBUWJnaTRJNWdyMTAwMWxIenpUVHd6SlNRRUFRQkFFQVFHTWpBUVFkaUNQbWpXU1U4UEtQbUhFdEVXUGNEMVhrVjRZWjlsdyt1cHdUT1RxV0xsd2UxR1JCbGpUQnByTkRvVk9DZFpyTUtZSWN6RXhxY0ZISTF5dFU0STFia0dRcTZMNmoybjlvS0pkQzlKNWtqcGNNWjVQVmM2ZUNMcVhpTmM4R2wyN0c0YUcyelBmenQvcEg0cnVvd3d0ejg3NDdlUXVLK0liNmRzK2IraUk4Tkt6Mk16ZkU1NVRkdzIxdDBXc1d0UjVmc2xibGMzUzlQbVl4d3lSdS91V2ErNUhyZSt0Ky8wU3ZUVW9iSFp3aSs5a3JyVitGN1A2L29SNTVpU3ZPVVQ5U3BTVGpsR3RyMU9EYklEa3dUazN4djVxalJESmNFaWd5bWl3RXRtbjBVdDRSeTZjeUtDcmRyODFOTmJIb1JlREtHUlJLSmFTeVdsSEtkQ0RZallnMk4xelRXRGpxdzdNNkNpeG9nMmwvd0N3NS83eHovZGIwN3ByOFI1VmF4VFhnK0gwTENHVEs5c3JDSEJwRGdENWdiY3Uvb3VtbmhQVkY1T09VTXhjR3NaMjlUZFBYTjhYTzFtUTZlSVd2SkQzY25qV3dPMjNkVEthMTlNRklVSk9scGJ5dTIzVDBNOFRlOXoydnlOYzJ3QmQ3THIzdm1kYmM2N3FhdXB0TkVXOFlxRGpscCtYYjNJcDJWK3JXaXdBZGYxdWI2cnkzVmJheHRobmU3ZDRiZTU5QTRYeE1HMFJPNHpOdnByN3pmeithOSt6clo4TDc5RDVmaU5zMTQxMjJaMGk5QThnSUFnQ0FJQWdQQ1VCUThVNFg0ek16UjV3UG1QMVhOWHA2MWs5TGg5MXlaNGZSbnkydmdzU3ZMbEhCOWhTcUtTS3VVS3AwcG1ncVJreEtFTm1wNVVsY2thWkJxSU1vVmtXMUc2anB5YnU1RDhGRStoTUtxalVTT3BqcHo0VFJmS0NCYys5Ym8zdWV2OEFCRktDaXRjejUzaTE3VnVLcnRiWGQvbWZsNlorYi9RaDFzcmcwdFpvTXVVVzNEZnVnOGg2SzBxemZRbXcrejFLbmlWYnhQeTdmNS91eFg0ZjVBVHpLeWxKNVBvcFc4WkxTMXNXZEppVEpmN1ZSWUhhTi9SeDVIUmRkR3Mvekh5WEZ1QWFFNnR1dHU4ZkwxWDBJZU1VRG0rYTIxZzdvZHJQSFc5eGZ2NnF0YW5oNmtkdjJkNGtwdzlubS9FdW5xdjhmTDNGVUNzRDZ4U1BRVUxLUnZqQ3paT29zS1ppcmd4bklsemV5a2xzWlFsNGlocVFUcnlHaTBndGpvbk5KNE5VYjFab3ZHWlkwa3k1cHhKa3RSYVJ5M1dUaWNzb1lKVk5VT1lic09uUTdGUkZ5Zy9DWVZLY1pyRWtXdFBpTEhlMDBOZDBJdTA2Vy9kZFVMaUwvRWppbmJUajBlVis1T3Bha1d5dUlMZHZvdWhTVE9hcFRlY3g2a1NMQ0FYWm1ueTcyM3NQVmMwclNMZWM3RzhyeHFPR3R6bzhMQkU4RFJ2bjVmZHQ1dm91eWx0VWlsNW5rWExUb3prK21EdTE3QjgwRUFRQkFFQmlYS0NValRKS29McEVPZW9VRmtqaitJOE5iSmQ3TEIzTWJBL29WeTFxS2x1ajE3RzlkUHd5NkhCMXNaYVNDTEh1dUNVV3VwOU5TcXFheW1WejVRb05UVTZjS0FhSktnS3lLc2lTVkt0Z3FlVTdIUGRZZnNwMGtTa2tqNkR3OVJ4TWpMTGd1ZTBoemlMMkJHelFkdlZkRVlMR0R3YjJWU3BKWTJTK0pVVThqN3VaSjdiWEZydlVIOEZ3dUwxUFVlN1JwVWFkTmNwWWkvN3Y2bU0wYWszVElNMEtvMGJ3a1Fab0ZLWm81SXRzUHhVaG5nVCthTWdndUF1OEN4dGJYVzF6cmZtdGxWZW5TejUrNzRSRjFsY1VIcGttbmpzL29Vd2hXUjdxa2JXUUlOWkppaFZjRWN3bXdzVFNadVpyeEdiSzJ5aHJzV3BkY25TUjhMZzBUQnRPUVpEZlM1ZHFHSDBGZ3ZRVkQ3dkhjOEdmRW03cHY4dlQ0ZHo1L1VST1k0dGNMRUVnZzhpdVZyR3pQZnAxVkpaUnNnZXM1STNVeXlnbFdEaVRuSk1qa1ZjR2JpU1dQVWFUSm9rTW5kYTE5RmFNY1BLTW5DT2NsalJ5T052eVc4WEpuSlZqRkhlY000ZjRZOFdUV1Fpd3ZxUTByMDdhanA4VXVwOHh4QzQ1ajVjT244blJ0Y3UzSjVMUmtwSUNBSURFbFFTalU4b1dJMHFna2d6aFFYUlQxMFpWV2JRWnkrTDB1WUc0dXNKeFQ2bnAyOVp3ZVV6aThSb25OSnN1WjBqMktkM25xVXN6bmprcTZEZjJoTWpPa0t0cERyR0Z5cHdWNWpKOUE4Z3FNRlpTMk9wd3lxSXN0SW5IVVdTeHE0UTQrSzMyckFPNzIyUDVLdFNubnhJdmJWM0R3UHAySWtqVnpOSG94bmtpU0JVTmt5TTZOTUY5UmlZMUtJY2dHSVZ5Wk5hZzFHMWdRakp2YVVNMnpLZ3BteVN0Yy84QTliQ0hFZmVjTlEzOWYzV2xLbm1XV1lYTmR3cHVNZXJMM0VjZmRyWXJzbE04cWxiSmRUak1ZbjhRNW5lMTE1cm5sdXoxcUQ1YXdpcUVsbG00bmJHcWlWRlZyS1VEZU1pVEhXQlp1Qm9pUTJ0VmRMSndpMXd1S1NVMmJwM09nV2tLVXBISGMxNlZKWlozR0JZV3lMekU1MzlUc1BRTDBLTnZHRzczWjh4ZTMwNjNoV3lPcHBwRjFvOGFTTEtFcTZNSkVoWE13Z0NBeElVRW1EbW9UazFQWW9KSThrS0U1SWsxSmRWd1hVaXJxOEpEdVNoeE5vMVdpanJlR3MyeW80SFJHNndVVlh3ZTg3QlZkSTZJM2lLMlhncVRvcThvMlY2aldPQ0plaWpsTXQ3ZEVsMC9CandwNVJWM3lMQ0hoc3RVOHNvN3ZKc2tvQzBLSEVsVlV5cnFXa2JoWVRwbm9VYStObVY4cmx6dFlQUmhQSm9MMVExeVlGeUVubmlCQ0I0b1FIdjJnSVZaNDZxNUJhUmhrd25QQklnbGRhdzJYUXZRNDVZemxuc2xNOXlOTWhWRWlCUGhjdlJWY0dhcXZFaFM0Ykw5MHFOTE5GWGo1bWo3RS9vVkdEVlZsNW02S2lkM1VhUy90R081YVVXSG5SRkF6bmRlcDFHRVFGcEZsckdKNTllcW1qdGFDRTZMcGlqeHFzMFhsSkNWb2tjY3BGbEV4WFNNWk0ycXhRSUFnQ0E4c29CNFdvVGt4TEVKeVlHSlFUa3dNS1lKeWEzVXdVRTVOVHFNZEVKeWF6UWhNRFVZL1lSMFRCT293ZFJqb2hPb2p5MGdVWUpVaXZxYU1LR2pXTXloeFREdE5sbEtKMlVxeHlPSTBaR3l5bEJNOUNsY09QUW82aDdtN2hZT2tlaEM2VDZrWjFhcWN0bTZyUlpnYXp1bzViSjUwUTJvSjJVcWtVbGNSSlVFVG5MV05OSExPNXlXdEhRWFdpaWMwcXhmVU9HZGxkUk9hZFl1NmJDaDBXaWljc3E1UGp3ZHZSVzBtVHJzMkRBMkhrbWhGZmFKSHY4QWx5TSs2UGttaEUrMVM4d09Gb3Z1aE9XaWZhNStadWk0WWlIdXB5MFZkM1B6TENsd0ZnMkNsUVJuSzRrKzVjd1VRSEpYd2M3cUVwc1lDdGd6Y3NtZGxKVUlBZ0NBSUFnQ0FJRHl5QVdVQUZxRTVQTXFZR1R3c1FuSmlXSVNtYW5NVUZqUStKQmtpeXdLTUZreXZxYU8vSlJndXBsSFg0TmZrcXVKMFFyNE9jcnVIanJvcU9CMHh1Q2lxZUhqMFZOQjBSdVNKL2dKSEpSb0wrMGtpREJUMFRRVmRjdHFUQnowVmxFeGxYTDZod2c5RmRST2VWY3ZxVERiY2xkSTU1VmNscERSS1RKeUprZEtwSzZqZTJtUWpKc2JBRUl5YkJDcEkxR3hzUVRCRGtaaG9VNEt0bVNrZ0lBZ0NBSUFnQ0FJQWdDQUlBZ0NBSUFnUENGQU1TRUp5WU9ZaGJKcmRFb0p5YTNRSURRK2tDRTVORDhPQjVKZ25VUjM0UTA4Z293VHJacE9CTSs2UGttQzNOWjYzQW1mZEh5VEJITVpJandobzVKZ2pXeVRIaDRISk1GZFRKVEtVQlRnakp0YkNtQmsyQ05NRWFqSU5VbGNtVmt3TW5xa2dJQWdDQUlBZ0NBSUFnQ0FJQWdDQUlBZ0NBSUFnQ0FJRHl5QVdVQTh5b1RrOHlJVGs4OE5Ca2VHRUdUendnZ3llK0dFd01ub1ltQ01udVZNREo3WlNRTElEMUFFQVFCQUVBUUJBRUFRQkFFQVFCQUVBUUJBRUFRQkFFQVFCQUVBUUJBRUFRQkFFQVFCQUVBUUJBRUFRQkFFQVFCQUVBUUJBRUFRQkFGSUNBSUFnQ0FJQWdDQUlBZ0NBSUFnQ0FJQWdDQUlBZ0NBSUFnQ0FJQWdDQUlBZ0NBSUFnQ0FJQWdDQS8vWlwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wdWJsaWMvaW1hZ2VzL2ZydWl0cy90b21hdG8uanBlZ1xuLy8gbW9kdWxlIGlkID0gMjA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUVBU0FCSUFBRC8yd0JEQUFJQkFRRUJBUUlCQVFFQ0FnSUNBZ1FEQWdJQ0FnVUVCQU1FQmdVR0JnWUZCZ1lHQndrSUJnY0pCd1lHQ0FzSUNRb0tDZ29LQmdnTERBc0tEQWtLQ2dyLzJ3QkRBUUlDQWdJQ0FnVURBd1VLQndZSENnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ3Ivd0FBUkNBRndBZXNEQVNJQUFoRUJBeEVCLzhRQUhnQUFBZ01CQVFFQkFRRUFBQUFBQUFBQUJ3Z0ZCZ2tFQXdJQkNnRC94QUJORUFBQkF3TURBd0lFQkFRQ0NBVUNBUTBCQWdNRUJRWVJBQWNoQ0JJeEUwRVVJbEZoQ1RKeGdSVWpRcEZTb1FvV0Z5UXpZckhCUTNMUjRmQlRndkVZTkNWemtxSVpKalZVWTZPeS84UUFIUUVBQWdNQkFRRUJBUUFBQUFBQUFBQUFCUVlEQkFjSUFnRUFDZi9FQUR3UkFBRURBd0lFQXdZRkJBSUJCUUVCQUFFQ0F3UUFCUkVoTVFZU1FWRVRZWEVIRkNLQmtiRXlvY0hSOEJWQzRmRWpVbUlXSkROeWtqU0MvOW9BREFNQkFBSVJBeEVBUHdCMWFsdUZTcVMwN2NzQzdyV3VDWFRyUXFGWEZQYWRpay9HeGgzTVI0NnV4UGFIQ1VvSS9OaHBKU2VUcXBPNzhiNldhbmJhd3FIdnNiL3VLNkk4aXNYNHFtTlU0TG9qWml0clF5Mm9KS1kwVkw4bGxKVXRManFVSVVyNWlyZzFXWHRwMGE3bjA5NnFXSkh0UzRHSXJuYkltVXF0ZkZCbzQvcVdoMDlweDlkUTB6cHk2TDZET1hYYmVyZEh0aWV5WEZxbXdxeXkwcHNrWmNKOVE1QXduS2ozRGhQSjRHbFAzNkd5cmtXUUZIWUVqN1Y4RnV1NlhNNzdiWkduK2FBRjRkY1BWNXRudGtOekw1clZ2SmlSN2txOUhvYlVPM1VTSHJtcWlhaWlCVHFlcHNPcFhHYldyMVhQWFFrbFpDVW5zQU9zN3Y4QVNHNzgzT3Y3clB0aXdidHRxUW1zVWJidU1oNkRGZ2RpMWwrVSs0bFJaU3B6MGxLU2xKTGZjU09QcmpXdjFPNmQ3UHY1cWhYN1kxWHRMY0NtVTZxRjZoVmQ2TkhxU0lUM3JoeGJqYW5DVm9VSEFGS1V5OGxRVU1sSjhhRG5VWnRqdEJ1cnYzZG05dnFSbFZCa00wOHltWVRmclBoaEFRRTk2dm05UElWd25Ibm5PaFBFZkVFZTBRQzhFY3g2RGJiV25QZ2kzU0hMci96Y3c1YzV6cnVNRDYxaXJ0WlJlb0N4ZHNHRjFEYSs0WWtOb0xiRGk2Y3NBcHpuSkdNK0RqeHF3V1h2TFdMUlVwK3JSNWJDMUw3MEtkYlVnNEk5cy9RNjFSM0syeXJkbzJnMVZhM1I0ek1Hb3dQaVlqS25FbHhiWUpBWGpPUm5CNDByRzUzVHJhVzcvcXhIOXJhaExNaUl0RVY2bVMvZ2hGa2hCS0hrdUwrVEJPTzRLUGI1UDBHc1V0L0dqRjZ1U21wY2NOODZ0d1RwbmJldC90VjNWR2dGbFF5RTZEcmtqVFdncHRUMVpKcUc3dEhoMVNxRXgxdWxDbHJYNzlwSTA0MjVtL08zMVYyZ2xTNTh4VWlUSGdPTFFwdDc1d0FqSUgyL2ZTTzdpZmgxN2diTVJva3kvS1BNaXZ1NGNpVlpFMUxyUzNQemZLdHY1TWovQUE1QjQxSldyWU85ZHgyVktadU9vSXA4WUJTRU9MVVhGU1U4anVDT08wSDZFNU9qRjFndy9FU3FPN2hLU09ZSzY2N2pPOVZMNXd4ZHJ2NEx6SlNwS2ovYVFma2Z0UVQzQTZoLzlvZHFWNnlibFVJVE5VZVplYUxFVko5TU5yQlFqUGtqbFNqbnlvL3BodjhBOEpxTGVtMDNTSlVMd3NGMStQVXI5M1JqUkc2dXg2WUNJTU5TR0dteXB3NENYNURpMG5nNFMyNFNNRE9zL3R3OXBic3A5NnZXM1E2Uk1xTHFTcFJhak5FNVNPU28vd0NFZnJyZC9vMXNmYTNwYTZLTnE5b2R4N3V0aW15RzdUWm1WdUJWSlVjT0pteVZMa0xKQlFwZmNBK1U1eU1jNDhuVzcyVzRRK1ZEcmkwZ0FhRWtEU3NhOW84S1ZHaUxpTXRxQ2xLQUlHcDAvd0JWNGJCYk8yVDFtN2d6YkszL0FPbW0xcmxwcS9YZGtWdXF3bW1aVUpzTFBhRVB4R3g2cFVrcEFEaGJVb2gwL0tFQkpyTzdQNGEvNGIxbDdsMW5iZTJiaXVTMUpOQWhDWFVYa3MveFNEQ1NHZmlGdExRVDZ5VUlaS0ZMYy9JbjFVSjd1NVFHbm02ZDZIczAvR2Z1N1pxRmFVc3ZJeExxRnVwanJVY2traHdza1lKN2xmbUdlVDlkVTdlUHBHb3RYc3E0RUMvVXdLald2aUhKTldyRExDQTlJY1U0NmtLZklEaUd2WFUwNHR0Qy9uRWRDQ0NuSTFZbmU0VGxxS3NGQkhUNzVGSXRzdWQ5dERTQXc0b0tHZDg3OUJTNWJPZEhiZTExTmNwdXoyNGRxVjcxb3NsK0dpTVZ3cFRhQU85MTFMYncrWkxZSUJVRkVBL0xuUEdsSDZvZDF4THR0bWUxZEVOK0lsdGFJS20xanRTQVNTb2o3blQyZFFOZHNQcFI2VHR5ZDA3RDNpdFdkQnRUYWFiUTZmQ3BFc3ZWS2U0NWh1TXFVTzhwOVJENzdxZ3BwSUt1L3dDWTRHc1k5cTdidVRxdXZpMXRpN0VsbHlkZEZYalV4anRjT1k2WENBNDZyN0liQzFuL0FNdXN0djhBd3hiSFpMUmpES1NkVG5QVVVMdWIxd2RmS25NODY5VHZxU2ExL3dEd09Pbnl2VE9qaHJlZTRRR3BXNDlmVlZCR2p5RUpmTk9qTFZIaDVTckpDVGgxOFo4a29QZ2FiQzhLZmNzQklNbUFsRHJFeE1LbHJVMEcvbUh6SldCMmdPWVV2dTdoZ0ZRVGdIR3UyeU9sRGJxMTdhcE52MjFWVnhLZlNhVkZnVTJLcW1SSEVzeDQ3S0dXd2hRYlM0RTlxQWVWRTVVZWRTTXl4WnRRaTFpemJJM2hpUzVrZGowNXNBU3c0OUI3dVBtUXRUZ2FVUjR6Mm5uam5XbXdHWXNTT2hwdlFEcDBxdklabU5wS1EyZE5NZzlCUUhxKy9NYXMzeldyVGxVV21YTmFWSEROTmxRcXJEUzJ0K1VwWFlYR25IUXRVcnVYMzRTaHNOdHN0ZW9wd2R5ZFdpLytwSFkzYURZU3Nic1ZXTkxwdEZ0aW5KVTVTQkJTVnBRSGtzTU1wU0ZGQVc0c2owMGQyU0FUeDJuVUhYTm9xeWxkUHN2ZE9WT21CcXFKZFEwZlRpUjZqRlRoUzRYYTJRaGFuMUJDQ3R4V0VOTmhBS2NuU1ZmamQ3eVZla3AyOTZEYVhGZ1VxUlZxeS9kbHcwMkJJUXNNeFM4cG1tc3ZyUWxLRnJ5WG5EZ2RvUzIyQjR6cVc5SmpNUUZ2TFNNZ2FWQWk3RmxncWJVY2pUekI4NnFmVy84QWlCeHVzbUJiMXF5ckhsVVN6N2V1ZUxXbDBtUklRNnF0T1IxZHpiTXdKQUFhQitic1FmellKSnhqVGNkT25YWnNmdnRFVFFZTTVxbDFkdHBLbmFjcVFsYVZKSXovQUMxakFWajNUZ0VjYXpWNmlhRzl0cnRvSGZTYVVpSkdUR1Mrd29PSmRVbFBjVmxXVHljak9PTkJyb3ZzdmRIZFdwczMxQnVKNm14WjFTa1E2WUdYVkFxVTJrZW80ZTA1QUhjRThlK1RyS3JKY2J5NGx4OTQ1UWcvaHdPdTJLalhmbitjNmN3M093cmFuZC9xVTJOc2VXbWhYSHUvYjlNazk2Uzh3N1ZHdzhSbmhIYUNlMHFPQmsrQm5XYkg0eVBVaW5jU2hXMTB2N2VYY3hVRGNrNytMMTU2QTkzdEppc3JJWWE3aDdGd3FWakhoa0grb2FGMThXRFZxVksvZ2t1bVBxcUVtWjhPbnRhUGM4dFNpUG1LdWVTQ2M4K05HbW1kRkZmcE8yRU84YXpoMTFKS0VTcENlNVlLZ085RFJ4OHFCOHVSbko4NnRPOFp1eFcxRlRXdXUzM05RTTNWeWMydEpSanNhUW1xMkpKMmxob3FrZWFYbldjS0plUU8wWThnajZhaUthaTR0d0w2alZHM3FDK3R4Q1NweFVaUGMyM3h5UXIySFBnODZjKzl0cjJhVERtV1pQMjJwbHlzMUZPQkhYR3krSFBUVUVxYmRUaGFjWnlVajVTUU1qZ2FydlRqdHJBcHR0dlV5SmEwaU9tRkw5QkRialNrK3FybnZ5bys2ZUFmMUdQZlExbmlsUDhBVGxTMW95dlVaT0FQOStWVjF3eVNGSU9lNDdWV2RwbjZGWTBCNkpmMUpkTWNJeW50VDJyYmR4Z0t5TWtqWGxjOVd0MjRiZ3Bsc1VtWTRxSSsydVJOQ1NsUldrY0piQkgxT01uUkkzQjJQcXRkbEduQzVLYlFuWFNSSGVxaWxlaUNmQ1Z1SkI3Ujl5TURWODZOT21QYWUzcUxMM0IzSG53WDFVK1F1SFYzNGFrT3FUSndGQnNZUERXQ1ZkdzRVQndTZENJVnlqejJRb1lLMUhBOHM5U2VnSGVyYkZ1bHVLUzJrYUh6cW9iWDdYMmxXNkc3VDQ5VGJZcWhKTVp1UUVwYUtSNUJKOS9HUDAxODdzMkpEdCsyWEszT2h4b3NadHNNcERVZ0tEamlSOHhCem5uempWMjZuYm50VnJjR1R0OTA4TW9ueDZwSkVlQkliaGdyY1JnRHZTamtvS2xaeHprRDMwdm00VmpYdFFJYkZ6WGU4dWRUM1pqMFZwdVMrUWx4YlJ3NTJKQkhBUEJWOWRWV1dFT080ZkdGQWtBZ25YSFd0ajRXOWoxK3YxdkVzT0piUWRnb0hKOUIycGR0d1RjdHhYY3VCWVVFeUcwT0JUanhWaENPZkJWOWZ0cXczWkx1bCsySUtycVpjYm1VejVtSEVObnRMZUFGSS95Qno5dFcycDNYWTFuMXluL0ZVV0l4UjRzenVlcDlPWjlPUXRDMUJTd3AxV1ZMUGtBcXoyNU9OZmQvWFpGdjZKRHRPZ1VsTWR1UktLeE1mVmtNTVp5UG05L2w0KytuY3pIQ1dVSWErQUQ4UjMyMXpXbFdYMmEyMnd0cFd0eFM1S1QvQUduUWR0TzFWT3hkMEtxcEpSUmFwTUlSNGJqTFh4NXlmbDhmVFJhL0RldEt1YnIvQUltVzAxcnlxRy84TS9kVEw4d3VNbkh3OFVLa09ILy9BRmpSUHNicDk2WHJDNlRSY0J2RkwxNFZaajFvcmROU3QxVlBjK0lXaERUaUVrREttMnl0YWwvbERpUVBwby9mZ1c3VVZDdDlZTTI4cTVBV2wyMDdKa3ZSM0hFNDdGUzNFUjBZKzVTWFNQME9yaUhHbUxrMjJrWkN4a2E2Z2ZiUGNVeDN5VEpWd3BJZWNXVXFheVB3NENqdDhPZHhyV2tvc0NWT3VHREJhZFVpa1EzSkx6NzNxbHQ3MUg1UHF1SXdNODRHQW9ZNEpIblhUYkxGUmlRS2hSWm5mOFN0VGNhSVpTVjlxMjIwRlNsRlFISUp6a2puUkJtUWFmSGN4OEZGYlFYVTk3cFpTTzRuSko0SG54eWZycWk5U20rMjBuU2pzL1ZON2QyWnFZZEhwUmJTcExXUzdKZWNVRW9aYVFPVnVLUGdEMkJKNEJPbU55ZXAwY2hHY2FWeXNpMUlaV1hFYVovYWhOMTdTYS9mZXo5djlOdTJsWmJUWE53LzVVbEVTUjZiNW84WktYcWs0eXNqQ1NHY3RoU2lBRlBBNXlBQ2s4bllMZHpmTGFlZ3hMQXFVR1ZUS2pKdHl5N2ZvZEhrTnRzMVJFR0s1S212eUo1eXFOQmpxZmxJSVNudVc2VUtVQ0cwcE9nZlNQdTd0VDFxN2N4T29xejlzSmRMaExFeWswT1hXb3JhWkQ4TlNnbDROZ1o3R1ZxUUFVZzRWMi9UWHhVdWkvYlNQYWYrb214VmRadFo2aDI1Y1ZMdDlpanJRNGlqUDFwQVJKbWVqa3E5WURQcDVJN2U0NDl0U1JiaTAwanc4WTEvT3JMa04zbTV6djVkc1lGS0ZzSGVQVWczVnFYYmwzNzRWcTNhVGM5d1ZSNkFtMEtJcCtKQm9zRks0c0NMRER6VDVaYWx6MXVCTWgwWitHaGhSS1NzQUxoK0tYY1ZVMjc2ZmR0N2V2dTdqY3Q1M0hOckUrNnB0UXA2V0g2Wk1iV2xwNkdoSVNDbHBvckNFQTVCQ1NzZm5HTkt0cE9temRUcFlUS2tVTGVXSlZKVW0zYVpSSXNPdFdlMHhHYmpVNkt0cUpGYStHV0RIWkJXWEZIQ2xLVXBTbEVrOFpRL2pNV3p1bGMvVkRDdGE3cTlUcHRaZ1c4bWJYZjRRcGE0Y09aT2NVOThNd1ZKU3BTVU1vWUJVUUNTVHhqR29yaklqbGtsUkFIZW5IMmZRNWovQUJHandFbFNraFJPS1REWStLeFg5eTVkZXFTZ1JFU1MwY2NCUjRINlkwMm0yeU5xV3Jvb0V1NVdaTlZweFVGVjZEVG5nbVFSa250Um5CSHR6ejc2VktEWVYvYk4xUjJiVXZoMXg1elRib2RqdmdoSGNNcEM4ZmxQMUI4ZStOV3U1S3BYOXZINGttc0pDQkxRSEljMk0vM3RQY0FudFdQY1pHUnBTdTF0TjJlOFZvOHpZQUh3OUs2VTRWdlRmRDBBeFpRTGJxMUtKNXRDYzdZUHBURlZYcUlwMjNzT3MwMmwyazNGcDdqcmkyR2FnVDNNb0pJUW52SStaUUhISG5TMFNONjVWUHZGeVpDbHFNV1V2L2VZNkY4S0dmR3FudXR1aFhib2xSbzlXdUNVODNsTGExRjRxS0VEakF5VDRIalZJcnRWaHhIa1V5aVBMZGRLOGwxWEpBMVBaK0U0TVZKY1NOVjc1L1dnZkVuSHJ2dkpTM3B5a2FqcWRzRHJSRDNwM0JnM0wzcm9qVHFHdUFBOHZuN2drY2EweS8wWXJaeURlVzV0emIzMUduTmhxMWFPM0dZa0VmS21WSkpHQWZxRzBLUDZIV1ZYK3phcFZtejAxcHU0VXBrTFY4c0p4aFlKR2ZQZCtVZisrdjZIUDlIazZYNWV5ZjRjVnUzVmNFWlROVXY2b1BWK1MydFAvZ1o5R05uUDFRMlZjOGZ6TkZYV295SW9RMmM0VjBwQTRtdk55YlE0NCtranhVaEl6MjMrdUtieXNsNTZNN2ZrZVV0TVNBNFdvNlcwaFBxTmQzWTQ1a2pqbklUOWsvZlViYjFQcFR0U2N2ZWx5bTFNdXZLYXAwYzRjZmt1S1VVbDFheVNSM0ZQQUFHRWpQalhuWDlqcmd1ZWRPVlc3bnE3c2FjNlZxaEx1QmFXR2s1NFFsdENBQWtZSEd1Ui9wdGZqUkdRM2ZNdUN6RVVWcDdhczZBM3hqSVBBVHdUejlDZENuYlMwdHdPRjBZR3VvTy9yNlZtRGQrbUpiTFFqSGZHUW9hcDlNVjliNFhWRnNpMG1xZERpcG4xT1pVbzhkaU1GWStJbE9MQWFhejdGYS9QMGJRdFhoSjBvVi8zclo5VDNUcU5adGEwS2ZjdGxiVDBCNnBYeGNUNzZXWTk1M1RQY3hGWWFIYVROWlE4anVTUHlLUFlFa3BSa3N5eHNsdEJ2VkNmc1Via3hidFRTWkFkbVFXNno4UzNHZklJeTRFOXdDeWtrWUp6Z24yT295OCtpSFpPS3pVN3IzQXQya3JqUGVrN1ZKcytkMnRxOUZLVXRkd1VqdEFRbENFcEFBd0VBQVlHcnNHUEJqaFRqanVTZE50QUJWQ1RjTHM3eXRwakgvOEFReWMvemFseHBkTG1icGRXZGxkSUUyb01wcyt3TFFFN2RLb015RXRSYWhVNUNrU1pNRUxCQ1NsVGkyV2xKU2VVRXA5OGFJKyszVjIxdDN0ZnVmZisxMFZFZHFxVTZMYSsyVUtDT3o0aVM0aGJDWklJT0JIYVI2ejJlQWxKQjR5TlhGL2JQbzJ0Tm1tejUxcVU2WE5kWmZxMU5haHZ1dU9wYldNT3pGSlEyQTBudEhMaXdCZ0RISTFjaDArYlNWZW5SNjNHMnFZTk9mb2pNS0s0RXR5bWZnUjJxUzJHMXA0Yk9FOEFjNEdjZ1kxN2NjZ3lscDVGNUEvUHpxUnAyZEdCVTYwUm1zNk9vYXRXUnRkdGRWdDJXcjJRdDFyYmFaYTlCbE9NcWxDa3hWSlJDWm5wU2s1K0psU2x6SFUrNWJ5cjZheE91N2FlOG9rdjRpZTJ0VFRpZTZJNjRRRk9OQTRTcnR5U25JOWp6cmFyL1NTTjFxRGFWTjI3NldyVWpRSVRrcGE3aXVFMDJJM0hMcmFFbU5EU3NJQXpnRjNBUGdBWUdzM2QzSUhUWFRyT3RTRHROWHJrblhHN1RGTHZkVlVqc3R3bVpSVjhqY1FwK2RhUW44eWw0NTRHclROMmNqckFiVHY1ZHEwaXhjSXc3bGFrdVNsRWM1SkgwNjB1OXQ3YVUxMlMyM1VYRnVLQ2gzTll3Q2ZwblREVE5tcTlSOXVLSnVNbmFpajBtaXZ0TGd4S2hHN1NxWTRqODZsaGExSzlRWngzWUErbWdWZUZTa1UrcWcwb3VmRUlWd2hJT1R6OU5GS283dFg1VXJIcDBldDBoOWh5TXgyUjJUSEtjZytWajlmcnJ6ZGxYRjhOclNyUW5VRTQvS21uaGVMWW9FbDFrTkRLQm5teG5QejExb1dicDBDMDR6aWx4bzZXM0ZBOEo4QWpWYXMvYW00THVJbEphTEVRay96M0J3ckhzUHJvbTJoWnNlNktxVXpiVWRxOG1UbEVhSTI0NFZsdytDbExZeXMvYjdhNXEzTHIxakV0TlB2TWZEbnNNWnhPQWpCd1U5cCtoOXRFV0xpODB6N3UwcksrNW9IUDRYaFRyZ2JoTFJ5c2pvblFuMXI4b3UwVm4waURJWW4wTXpwQ2tZUSsrNHBJYis0Q1NNbjlkZk5vMWRlejgxMlhSS1l3NmgxeEtwRGIyZTRoSnlNSDIwU2RxZDViR3YzYStwN2VSdHFrVEx3a1MwUHByNWxxL3dCMGh0Z2xhRzJSOHBLaWZtV284QWNlZENiZGg2VUhERWlNbGExZUEzei9BSisrcThLVGRETUtIc2pYcWRQbFZ5ODJqaE42eGVORWJTcE9EakExL2ZOT1pzZnYxdDl1ZGI3ZFd0ZGxIeGJCQ2FqQ2RjL21SeUI1VVBjSC9GNE9wZVAxRzdSSXJjaXpYdHpxVzNOWmJVNCtyNGxLV21VNS93Q0g2aFBhVmZZRW5XZnR0MnZmZHYwK1RMajFkNkMxT2FETXBwcVIybDV2T2UwZ2NrWjBVZW5mWUd5TnlwVlFUZmw2TzBLSENwanIwWjltak95bFM1SUdXNDZFb0hCVWY2aVFBT1RvN0x1MGVHMlZsV1FONnlLRHdPL0pjNXBQL0dnN1owcHA3aDYxT242ejYrMVE1TjZ4NWJhaC9NbFU5QmVhU2Z1b2FJZEMzY3NPNWFQSHIxRnVhblBSWlRmZXc3NnFmbVQrNXpwR0hlampjQzRLYzVOcFlqczluY2ZSbE9GS3dQcDQxUkpHeG0vVkdmWFRJc1dVMmhwWkFReStRa1pPVGpIM09kZm9mRWR1ZFNlWjVPZlVDcWQyNE9EYm9FWFVkZXRmMDZxcS9UdkFjazN6YmR0VzVScDlWaEliWC9xL0diWVJJWVNTVy9VTFlDVjR6NUk0MHVPK1VSMnQxNWtRaytwRWZVcGJiaVk2MWdJSEpXa0FjalBHYzR6cW85UGZUanVsYTB0dXd0MmJnRkdyRExiaTUzOFJWL0pwVVZwR1ZQT2hTaDJsUjRTRGdueUJ5TWg1UFdnOVNGMUttczNOV1hYSWNoYW9TVU81WmtwQ3VVclNmS1NCa0FFQlBPdVA3cEh1Tnp1aTMxRlNuRTljOWYwK1ZiTXpDVGIwRU1mRWNiOUtiUGFIcTkzSzZkckNPM3RPdDZrVHFhNUxreWx1cmpsaVNYbnlTdGFpajVWS0tqbkpHVG9YWGgxQTBpMTY1SGsxQjUyTjhTQ29xY3dRcHhYT2MrRHpybWU2bGR1TjVOdktkWEk5RitCcTdUZnB6VUlJN1ZGSThuNkgvcm9NYjIxMmczVGFVMm1WWjRJYVFrZWc2aFE3bXlUakkvVE9xc2U4Y1JUSmFJczlaVWxPbm9QMS9XdkVTWkh0azduS0JsZS9uVEs3YXlEdVpIRzRsMHVxZmdvUjJ3QklVZXgvQndGQko1N1I0K21kWENGUzM2L01ReVcyeEdkV3RxTTVHY1JsaDVLZTVLbEkvd0FJOER4a2tEUXVvOWJmckZkZ1UrMTdpaFUyaE4wZGxpTzlKU3RURFMyMmdHMjFsQStYMUNNZDNnWkpPZGRsL3dDNzlMcEVKNU5KdHVtTFdtcHhxazAvSEMxTkI5cEpBQ1VsUUhwQlJVUU9jK1RwcGcycUJ6Q1pKUEtoT3c2cUkvbTFXNWM5OTlaYmpJMytRQXFhdmE2VlNscFhPaHlGd1prWm1VcUxVcVJGYlFwdGF2UmtKY0MxZzVEZ1RJN3NaQ1JqM3hvTmRTKzdHeCt6K3lFcTBMMm9OWFZWNnA4UTdiTTlsa2p0a0FnK2d0MUN2U0RiWnlvcElVdFNWREJHRG9iM2R2OEFVNmx1bUZWTFhwTXRrSm10clc5SFU0NTJ5VmR5K0N2QkhxZHFzZTRUZ1l6cjgzTjIwaGRjTzBac0tqMTl1bEwvQUlyRHE4YXF4YU9wbjBpU1V2QUpLeWxSVi9PeU1qQ2lnSGpPdEhnU2JiTFlVdFJBUmpVa2JEK2RxRXhaZHp0RXhCQVVSa2FKT002MThkTTF2N2UzZGJVbTZsV2d6S21USFV5cEVjcktrcVRuRFRRSk9lM2dxT2ZjNnR1OVZXZVRiYlR0V1F3ek83U3FVaU12dVMyYzhKN3NjZ0RBenFzMVhiRzJPa2EyS2JiTnJ5NmhJYWNiN25wVStYNmpqcTBEQUp4aEk0SlBhT05EKzlOODZYVm1YWWt1U09FL0twUkdjKytkSkZ4Y1hjM3VXUGtvU1JqekE4cVB6YmlYcEtuVi9pUGZVaW95a2I2M3B0SmVjZTQ3TXF6MGRiTTFoOXhodDlhR0pRYWNTNEcza0lVbjFVWlNNcFBCNTAxTzRQVzVkblZGVFc5eU54NjhYWEppQ3FOU1dsRkVTRW9FOXpiVFpPT0QvVWNxT2NrNnpzdmZjU25tb0w3WktTblB5a3ExTzdlNzAwOU5LaFVlTFhndExRVVZNaFhDVktWazZPeWJkY2phQTIyVkFkY1o3VU5pZTZxbWVLcEk1Z05Nano3VXlWM1hiVDNxejNlZ3lFdUpIYWhDUnordjExYXVqUzh0cituenFUcGUrRlQyMHBya2h0bDJLNUpqSTlOVWR0L0NYSGdFOEZZR2VjZUNvZVRwZnBOM3NUSG1wcnNvS1NwSXhnNU9kV0dnM1l5b3JYSmZKQndBajJ4LzY2WG9KbldkMURyU2pvZFJyclZtZEhoM0JzcGVRRDU0MjlOTksyajNVNnNLTHRiMC93QjI3MFFhdys3VkZVcitIMnhUNHpJRHNxcHlTRVFrc0pWa1pVdFNNRGtkcUNvNXhxTTZmcUZhdlFuMDcwUGJIZHpkZHFqWE5WYU11NXR4cnFma3RycWxWbXZPa0tqUlBVeXQrVTQ2b29TRXBVcElCN1U1VW5HY2ZRSDFVSHE0NjF0dk5nNURyemxJMm9wOG10VkZzTWxUVTJxSVVHSTYzVmMvSzAyb0ZPZjYxWTl0YVlidmJLYnliMVRhanVmZFZsVStvVnhpZXUzOXFhVjhXZ3g3VGh5RkJFcTVKTHd3dGN0VFlVdEtHOGxwSWJiVDh5M0ZqZmJWSWVjWVNYVTRKQU9QWGFzd3VjYVA0cWdoWUFPUm50alRIMXE1MlJQcmwwV1RXTFMzNnBqVVNuMG1rR1pXVjFDY3QrYlNVckszME5TNUdFb01sdU1BdFlRUDVmeWhSSk9zWXFkc2J1ditLWnZOZWY0ajFpYnZXNUdnVlc5NmhTYUJhOWFFaHB5TFM2WTAybU1TK0VxUWdmRCttczkrT1ZuSkpPbjgvSGo2ZzZUMFpmaHRIcHgyMnFzc1hIdWM4dTNZMHlWSks1cjBRcDlTcVRYVms5eTNIRVliVXJQbVJqMkdsai8wZisxNm1PbWk5N0VnekV4bW9WME55d2xiNlVoUHhNZHNFS1FzWVdDR0RnSGpPUVFkRlpCaVhELzJUeE9GQ3N0dkM0NWtyU0VncXg5cURtLy9BRTJkVmR2V2UraTd0cWFqVUtJeUZoNmZRaWlmRUNnUG1QZXlUamdja2dhQi9TcGRERnNVWkZMb3Nvcy93K3FTRkpaUTV5d1NzS0tmcW4yeU5iY1M3Y2cwMm50VFZTV2hJaFNaU1l6bE1rNFVHQ25DQXBMUk9Ca1o4SG5uanhxZ2I4OUt1eEY0MkxWTHR1N2FpM0txNUdwcnJ6a2xob01UQXBxRXQ0OXN5T0VMZEpXZ0FxV0ZIQlAwR2xpZndMNFVSVGNONGpKQkdjN2p6cGNFZHFScUZGSjZqY2ZQK0drQ1R1UGJkMjdrVXFXcXJ1T3FiQ25QaDNVWmJTNlU0N2txUGc0eng5OU5KWTI3Tm0zWmFqZGkzSlVRcG1JdFFTMGtkdnByVU1sU3NEa2thVWJjYm8wcVZ4WEV4STZUdDBHSmxTam9jZVpvRmJlN1dYeXlvb2ZMRTVJN1VOaHhLa0F5VXRLT0FmQ2dTTXJaNnZya3NPK0pPM3U0OEYyazF5bFNWeEtuVDVvSHFSblU4S1FTazRQdGdna0VFSFdlM3ZoN2lDSThKQ2tjd3hnZ2ExTkhMc0JCRHlmaHp1TlIvaW1xNmpvRnJVQ3EwTm14WkxLSHB0U1NsNTV4UklZUXJ1QzBuSEorVG45VDl0V3ZiK3p0dkdMUDc0TFFudmV1aGJxSG5DMHYwRXE3bHBTZlphaHdWSE9NNTBubThIVlRRcE11aVRucXV5R2tWRkNuTzEwZURrRStlUE9yMDF2WDhCQVMzR3JaanVCQlBDZTQrUFA3alMzSmJlVzJoTDdSOEpSSkExR3UzMXE3R21wS3lwbzFNOVhWV2VjdXhpQlNiTy9oajFjbWhGSnQrT1ZMN1VPSzdXMG9VU1ZLUGdaUDVqemdhb1hVTjBRN2xiQ3lvZEN2cSs2Y3pKcThKdVdxRTFLY2JhU0MyWEVwY0tnQXBRSVVrSEhhU01qZzZIKzV2VWZkTkUzY285NVUydHVLbTB4YUhJY3Q5b0tDRklVa3B5RmNld0g2YUpWVTZpM2VwU1FxdTcweVhxclYxSlQvQUwxR2NDQWxDRWhDVStuakhhbEFDUWtjQUQ5U1dtMTIrMndMYVZES0ZLeHlrN0FlZGRPZXhuaDlNaHYrcktTaHdaVUZBaktoakdNQTdldEJLazNEZUZrTk1QMkhjenNTb3BmVjhPV214L0w5aXBCSVA2SEhrYWthalI3OHFiOGNYWkRsc0Z5S0g0N1BvcmJiS0ZjbHhDVG50U29nbkl3TWcvVFhvMWYxdHRiM1ZDUERweTJZMFNQOFBUR2xkb1VoSlZndXFBeU84anpqNjZPZHpVMm9YdlZSZXRwVnlTaW1UNkszU2xHSStsVHFHQTBFT05PSlA1VWtoUkkraC9mVjEyTXN0OHJhZ1R2dHZuclhSVU42S0ZlTXBIS25IMHgwd0tVVytLQlRxcFdrdVNxV1hmUVBxTFIzWjlSUTQ4Z0E5dUFQbEpQMThuVnpzaWgwMnNVeHgranVSbkJGYlJsaFdVclhuakNCakJLZmZualVWWG1hWFZON0k5azIvS2RWRmNsTEszVTRDaXlqempISEpHQisybWwyM3NUYk9kWWlrVWEyVnR6NDB2Si9tbEtYR3ZCOEFudUp6eVJxTzRHWjdzaHBLU3BXTWdacWF4dFF2ZTNYMDRTam13VGpKeitsTG5JdC9jdWtQTTFlelZsaCtLNTN0aFRnS2NaSENrbmhZNTVCemtaMXNCK0RaYWM5KzFiMTNucTlDWXA4eXVQVTZteDJXc2hQWkZqcVd0UUJBd0Z1dWxXQndPQjdjNXlibTJxdTNYSGFsQWovQUFjRlJVdERjNTVQcXBhSEJPT0N2bjNBL3dDK2lQMFY5V1hVMXRsWmsrbmJZdng1VUdjK2cwOU5XYmRjUXlwT1FYRW9TUm5JR01FNE9NNmh0bDBWRlBOTUhLRStXdVQwcGI5b1hEcWI3QkxGcUlVNHJHY25HQm5KUGJXdG8xeTBwU0V5b25jbEtrcGNCVURrbkE3aVAxL3kwaDM0L3dCZFZLcm0wMjMzU25Rb2dtM2R1TmViYWJkYWJaRGpqZm9sTGFsSjV5anVMNFFWRFB5aFNmNmlkREdSK0lyK0lwWnNXSmN0WGpXOUxwajhoWGErNVNFdHNMVWcvTVBKT0JuNjZxRFBWL1VONE92YTFlcTdxYWFqVTJuYmZXMDRta1d0U0lSZEVxZjh4YmtOdUx6MnFVcHpQQndBMmsreDB4VzdpSzF1dTh3Y0dtVHIrWDUxZ3QwOW1IRmtFQStEelowK0VnNm55cCs3cjJRdTNaTHBWdEhZRFoxeWRDcEZJL2gxSXVpcTBGb3JudzZVaEdKa21NaEFLbkhWRkpTTzNLaDZwV0FTbkJXTnJkN2E2NE4yNTE3Mm5jNTJwMkZoMmpVRVI2L1RYVlUrcFhYRmlTVzBTL1FkZC9uT1RKa3NDTzByNW5rTXNyV2tCVDRJak4ydnhjTjQ3OHRhcjIzWmRud0tOQXFNSjZJdDMxM0Z5MjJYVUtiVVczZ1IyTzlxamhRSHluQlR5QWREM2JicmgycTNacUcwdlQ5MUJXbFJyY3NUYmlzdFRJTWVEQ0MwU1hvN0lhZ29lVzRTVU50cnk2dkJCZFgybFdRbm41RjRoczhsMG9hT1ZlWU92cDg2dFMvWmJ4bGJZQmxTV2NKQTFDU0NSNmdWbzkwVVd4ZUZKNlpMWFkzVFlmWnFrOWh5YVlGUWtMZmRwa2VTNnB4bUd0eHdxVXN0TXFiUXBTaVNWSlVTZFl4OVEyN2V6bTh2VVp1UnVkTnZGNXVvVk8rWkROR3BUVWNxYStCYUpaUzRwMHF3Z0JMU2NKQU9TU2VCclh6cWc2d3RuOW5kbEs3VWtYOVM0ZGVxRnZ5aGJNQ1JKK2VYTGNZVWxnZ0p6aEhjVXE3andBTmZ6K1J1bmZmU28zQ3FYV0xwcGxSTWJLcHFoT1I2cm5rcktRcnRLeURrL1VmNWErWGxFYVZFOEp4NEk2NzBhOWx6YzYzWEZ5WUdTUXJDUWNkTnpyOTZzVy9rUzFxUFoweHhxcXN5VUxaUGMwdjg2Vlk4RGpuOWRLMWFMVzVlNFNtNkxJcmtrMHFudnFWSFJLVVZJYUpHUGxIdWNBREgwMDVsa2JVemJqcFNxdmJ4VEplcHJCTXA5MXNPNUk4a2dnOGp4ajJ4b2ViclJCR2RhV0lNVkV4ZzlvRVpoS1ZQZ24zQ1I4eCttaGZEMTdFQnRjTnZLbG5xZW55L3pXc2NXOEpydjB0aWMrNzhEVzZSdWMrZENtcGJHeHBzSkFrVlozMU1jcUdFZ2ZzTlFWTzJYY29kZmVqeUpaY2FRa0tMcXZ6RW53blJ0ZGxScnZva0dWSVFpQVljTU1kaVlRYUxuYVZFRXFBd3R4Uko1UE9COXRjY3BkbVVlSWo0K21QQ1NWRlQwdDU4ODhZQ1VqeGdlYytmMjBZUmVaN1dXMUhQa0tEdjhLMkdTcE1sdHZCVDFKKzQvV3ZmWWZZRzg5OGQwYloyYnQ2RTR0ZHcxbUxUWTRiSGIyQjF4S1ZMemoyU1ZFbjJ3ZGYxSDJ0YTF0YlRXRFI3Q3R1T1c2YlJLWEhwbEtqdE41L2tzTkpiUmdEL0FKVTl5dlljazZ4eS93QkhYdEdidm4xSFZHNzZyVDJKTnY3WlVreTZmSVV5Q3BOUmxLVXl5a0x4eVFqMVYvc05iQ1gvQUNvbFBTekhtMHQ1NzV2VWplaXNrOW9BQkJCSThxVWtjOFkxOGVlWEdpbHduVStYV3NtNDRsdHo3eTNEUitGc2E2NTEvd0JWMDJ2T2xWQ1dyNHlRcHhTR0FTUStnZy9NZWUxUGpJOS9HazEvSEczaDNHcFd6bEE2ZE5scnhsUWJtM0ZyamRMaVUra3RENHFhMWorYWt1NXl3eUFvZHlranVWbnR5Qms2Y1NoMENveDZzdTZhd2h1S0dLZDhNd3doUVVvSjd1NWExcUhHYytFak9OSkgwalFWZGVINGgxNzlaZFhqS2wyanRzWDdac0ZiNk81aDExQ3NTSlNCL2lVNFNBZnArbXFYdkxvakpCQnpuVFBYdCtmNUNsRnRob1Bsd0g0UVBvZXY4NzB4WFFqMHpXTDBYZE1kSzJzb1FiUzdIamlYY3RYZEFTdVpOV2tLZWRXbyt3UHlqUGhLUU5BZnFJNmdMQjZwWjBPMUdiMFlWYWtpNWtRNE5QaXZGYTZnMUdjOVNaVUhrb3lmaG0wbzlOdEovd0NLNHZ1L0tnWmNtNGJCbzEzMjY1WjlaYStJZ1NBb1RZd2VXZ1BBL21TcnQ1S1R6a1oxUU52T2pHM0xMMy9HOGRLajBtSFM2YlFVMHUzTFdwbFBEVWVDanU3bE9aOEtVckFCNDhKSEoxNWt0UzFvQ09YSVAzUFhGU1Ezb1NWS2NXckNocUIrZ1BuMXFnYlI3TVN0d3JjdU96YWdZNnFQWGJsUkp1RzRJa3RZa1Z1SjhyN05QQ2UwRmlPeXg2TGFtODhsekh1ZE1sNkVhTEVSRFlhUzAyMmtKYlNsSUFRa2NBRDZBRGo5QnFNc0MzSzVibEROT3JMTU1TRVNIZTR4SFNVdUtXNnB4YmhKQXl0U2xFbmpqQ1JrNDBFdnhUZXA4OUgzUWx1UnZvbDF0aW93N2RkaFVJK3IycVhVSkk5QmpIM0NsOTMvQU5tck50aXJBQU81d0IwMi9tYXFUWC9lSFNPbXArdGZ6MS9qVzlXVGUrbjRoOTZYemJkZVRPcHJFaEZNcG9RNkZKWllpa3NwQ2NIZ0tVbFMvd0Q3czZCbG1YcGJsZm9NZW0wdURKLzFqY2xxOWVVNnJMRFRBSENrcDkxNTBHcDB1Uk5sdlM1VHluSFhYQ3R4d25sU2ljbFIvVTVPaVQwK01Sa3VTNTZzRjA5cmFDVDRIazYwS1pIWmdRUzRnYWdVUTRVdWx4dWw3YWhxY0liSjJ6MEhTamZZZTJGR2VjRTR4ZlZmSTlSK1E2TzlaK3FpZmJSZjM3NmVLSHRwdHBhdFlyVnd0TzE2NHFlNVBmbytNbURFT1BRVTRvOEJTeGxRVDVBQUo4NnFPMDBtSTBGTlBLQmJlUUV1YytPZlAyMU05UVZIYXBkRVZkS3J0Y25NTFk5TmhicS9VVXRTVWpDRTVQQVNDQnJNRk1UcDhzT0J6UUhXdXFpaUJiTGVrQkFTa2pvUHhhZDZBVVM1cmkyOXVNWEpZOXhTcVpNWUpMRXVGSkxicURqR1FwUEtlTThqbm5VVW10dzczaVRhZE1VRnkzc0ZMN3BLaUY1eVNWSDYrNU9xdFVLbFdxN1ZwS1l4V1I2bmI4aUNjYWtOdlpNQ2t2T011RUtjOVREaEkrbW5Nd3l5eDRoMVVNWXgrdFk0aTl0M0M1R09qUnNraFdmc0tzTzN1MTBhaUxYTGd5SGxUSEVLUzR0c2tBcFBIYndlUWZmUG5WdzN3Mk51bmF4eGlEZHFJNWxQMDFxWXBxTytsWmp0dUpDa2hSVHdEZ2o1ZmJYVlpWeVE0cVZKZmhwV2lRa0ljT2NLeG4yMUlibnc3Vm4yNDdVSVZaa09TbG9JK0VjYko0QS9NVlovYkdoSWZtU0pRV3BlZzNCcHlSWmJiRHRaUkdiQUdEc04vd0NlZERIWXkxSzF1aHVqRHM1bFNseEZySmxER1NFRDJCK3BPbjN0NjBOc0xmcGxPMi9wN2NLTExTZ3A5Rm9ESUkrcXZjL1hTTGRMRjExTzBkNEpEc0JoU2xLYUNVS2JieW9LQnp4OU04NmNDcVFvU3FkUU4wSkNWRlVTU3BVMXRZSUlWNXdSNTg0ME80bmE4ZVloQ3poR0J0OXpXTXlaRW40c1pJQklIeXJqdktJL2JkNmlCR1p3RVpEcVZIeUI5dGZDcEZHa0tMenJTZTVYbkkxeVYvY051ODdnWFZwVGJiWWNYMm9VUUIzZnA5dGRUY1duT0lDekRTYysvZnFqSHRMUlJRSjZXOEZhNzBaZDJ0NzdNcUh4VmFlck5RTDFSaytwT1d1VXBaZVY5RkVrNS9mUUtoVjE2K2I4UmFWbVcwdWZLbUxQcE1nZ2VrTWNxVVJ3bElISko0R2c3ZEY4VldWRlV3cWJ3cFdWK212SXpwcHVqYmJ1djdNMmRNdTNkQ2tMZ1RMb2pJY2pKZVZoNzRMSEFWN3Q5eXVlM3pnRFB0cGJkdGpjQ0lYbmlDczdkTW56Nit0YVAvVC9BSE9EbDlaSUduN1ZMMi9zdlB0dWhUSkVmYzZQSmxvNGRoVW9CUWFPT2NrOHE0OThEUzViMVQ3enBjR3B0TzNDNVBRNGhRYmFRQ2hTQjl4Ny9ycGpiK3Z1aHh6TU5tUkkwRkMyL3dDYUlyUVFWNUg5UkhLang1UE9seHZXYVprbDU1NVpXcFJKVVZmcjUxUXMzTXFjVnFTTWFkQnJqcjZVRmRhaVNrNEdoNkdtaTZiZDNLRFNOaktNR0w5alY2Uk1wNkRWVnRLY2JTbDFBR0dYRzEvMUl6anU5OGsrTWFrYi93QjEwVjJHb1FuRXBWMmRvU2tnSjdjZTJsdnMyVGJzelk2bzEyaFQ0OU9yTkVrS0VobGIvWTNOWkNTYzQ4QndBOGZYdCsrb2picXJiM2JnVTgxT2dXTFdaVVRIYzNKRWNvYVdQcUZMd0QrMnJVNkNKamkzTUJLRW5HRGdmNHEvSGJrdElEWTFPSzdOMXE2dEhxdnNQbmhaN3NLOTlXVG9tNmdaMXVRTG10bEN5NldaakM0UUhLdm5DZ1VEM3hrWi92b0w3OVNkd3JWcGpsVXVDenA4UmhKSWZmTGZja2ZxVTV4KytycitIM1RxYlJLWTV1bmNiVDdyMVdkZFZHWWJaSzFKYlFDRWhJOTFIay92b3M3YjBzOE11T2pVbkFUakJ5YzU2ZVdhK0ttSVplRFM5Q05UUiszUm5QYnhVTVJLN2NMdFBLQXB5UElYQldwTFRvT093cS9xS2djNEdrazZoNUY1YlcxWXV6WVJtd2dmNU0rTG50ejlGZzhwL3dDaDFvTFU3c3BsMk52VXNSY0Job09KTHJIYVVnZ2NFSDNHbDAzeXBGTXFUY3VrVkNDMjVIZVNVcVN0QU9jK3cwSTRjdURsdHVBYWt0NVNkd2Q5ZXhxbk1XSmJDZ3lyQjZHZ2wwcjdFM0gxUVZCeTdicGFXM1JZcjNZeEZiVVI4U3NlZTRqbnRIMEhrNmFLVDB5MnJhdE9hVlRhYkRaUzJBQ2hFWUJJT1A4QVA5K2RERG9kM0RnYmV3YWx0Z3AvdVhUcHFqSHhqdUxTem5URlYrNktaVXFYNnJVZ0pBR1ZaVjQwUTR0bVhGMjRLU3lvcFFuOEtSdGo5U2Q4MUJieWhoZ0J6VlhVK2RBaTY3RGNicURzV21kc1pTR2lwcHhLaDZaVUR5bFNUNHo3RWFBbTQzVWxYdHRhck10eHlLVFVXSE93dEU4QTQ0SlAwSU9kTUJ1TldXb2JpNWhkeWU4bEpVcisvd0Rsb1AzNVpsaWJ5ZXJKckZHU0pTSFcybXAwYjVYU0NRQWtuK284K0RvaHcyNUdKQ3A3Zk1qN0dvWjBxYXBwU0l5Z0RqYzA3UDRLWFV0MFYweWp4S3JWN2xac2U3bDExdU5VSkZaS0l6VldmZEtuRU1mRksrVjBGUVc1NlpLVG50ejdEVzBFTGNlQmMxRml4NkhXV3ZRY0pWRGZTSEZva0JDZ2hUaUMyTXVIdStSc0o4cXlvbkNSbitTamV1WmFWblUrbmJUV2RLVElod1pzcWZVaVNWWWt1cURhR3lTT1ZJWmJTUHBsWjBiT2szOFZqcmo2TDZjYmY2ZmVvQ3B0VVJjZFNFVzlXbXhQZ05sU08zdWFaZXo2S2trNUJiS1JrWkkxcTVaUW9CMXZJQ3Z0L3FzdGN2Q283dksra3FJMEI2WnBqdnhudXV1Mk9vYjhTeVRiTTZVbWZhbTA4Wk50Uklva1lTN0pRcjFKNjBuSndTLy9BQ3M1OE1EblJ4L0FqdVcxOTQ3cTNuczJaU0lIdzBxTlM1OUVoMUJyMW1JN3JUanlHMXFRa2p2N2ZVR1JrWjhhU2ZvMS9DSDZrK3J1Qy92TmVGVU5zMjVVWlM1QnVDdVJsTGsxTnhhaXBTMld1Q3NGUkpMaWlsSnp4azhhMFIvRHA2RWFIK0huMUFQWGZWTitrMWltM0RRVFNIMm5LVjZCYWtxZmJjWldjTEk3TW9VbkJHY3FCKzJsUjdpZmh5TmYweGtTQVhzNHh2cjJ6dG55elMrN1laMGg4eTFJUGhuT2M2YUhyamVueG9XMUNXNHdwMVRxdElkZWJRTzVNSzIyR1FuanlFZ2twSDc2NGJyMmVlcXR2VksxcWRjZm90VDRqckw3YmZIL0FCR2xORlhhU29aQ1ZISGoyMWFMWm1RWkYycmM5ZHNQeWgyU1czRGpDUU1wN2YwL3p6cFQ5dHR0cTlBL0hQM0R1R3QzMVBxY0p6YVNMSmdVcHhSUXhCUzY4aG5zU2dLd3BSOUpSN3lBVDNZOERSK054UzdJSFBqSHhFZlRiYnZYMWZEZHVDZVFaOHRUbjcxeTd0OUdWWmV2aWdYQkZ1T3J1cXB6a3hxcFUxMHRJYWtRblk4cnZDRXBBRWg1eDE5T0E0UVA1YVJuNkpydmYwT043aGRiOThiMjd2V2hHb1h4VWVOV25xVFUzRW9ZaGxVVnZLRkpRb3BXNnRTZUdra2hKVjI1SkIxcEp0NzFDVE54THlOazNWVEtYSmpxVENjbHV3U1czS1UvTmVmYllnS2JQZDN1dGxnK3FwUlNmbkh5K05JLytNQmZGUDJmNnA2SFRyaHJZaXRWZXpJempDSFpKOU40c3Z1dGxRenhuOHZIdGpRemltNFNMaFpGcWhoUVhuQkEzODhWK1RiekJVRXY0VW5wK3hvSmRRTnY3Yld0UjFVS3JVR2pTR0RFQ25XVzRLTzFva2ZsUEhuR09SOWRMRERtYmwxKzVqQ3MwTXYwZGtBTXpINVhhRUo4QnYzS2lNZVI5TlRQV05lYWE5WjdDYkd1b3lWUE5oVWtSMS9sVVQ4dytoL1hPaWQwSTd2VSt5Sk5LdEJpaTBkU0hvNm9iczJSR1NwMW91RHRMb1dRU0NNbis1ejlRaVdtM1BXKzArS3Y0MUxKSEtySjVUMytkYUY3TStDclh4bmZWcmxLNVdHaGtnSEJPZk9oUHVQdFZjRlNSR2xNWEJJY2xJWGx3U3FhRU1nWS9wVUZsUk9jakpBR29DMk54WkczOVlNU3BWRVJpRTlpZzRyQStuQjl4cDRkNzl0MFUyMXpKbVI2UXpBZ0o5RVNZeWNmRXEvTmhYUDV3UHA3WTBya0xhS0h1YkxaVTVhaUpMdnFMV3cwdEIvTGs0VXJHY2dKNTl1UEkxUEZtdnFCanoydVVKR3d4blhiN1YxWEM0U3NuRDhNRGgxV01uWG1KS2RPOUNTUnVKUTQrNXJkVmRsbHlQS0JaZGNBT0U1OEVuOWZmUmVvMVhtT0lLS1JjTHlXRmdCU0V2bEt1Umo5RC83Nis3aG9NemE2blUrNlJBYXA2WDBMY3BEalRhZjVqYUZGQ2xnRVlLQ29FY2pDc0h5TlVtdzl0dHdkK0wvZnVHM0xnVlQ2ZVhTWnowYU1FcFU0ZjZXMEp3TW43WVNQOHRFSEZRcGtYeFFmRENCakoxQituV3ZDR2JyYjVuaEp3OTRweUVwMEk3N25VZGMwK0g0T1hRMTAzZFZ0MzdpenQrNlpWSmsyMm1xYS9UdjRmV1hJb2JaZUx5WFZMOVA4eHlnWSttbW4yMzZQT2tpSlMwVm1KWXRYam1zeC9SbzFQbzkzelhuSkVseC9zWWlMZFVqMC9XOUloMTFLTStpa0tKS2p3QkYrQzN0RXJaKzc5MG9uK3Nic2RkdzdkZHBxVlhraExUU21aR1BVVVRoS01CNDVQdHArcXh1QlpFaURSM3JaWWVWR3RwS0YwTmluUThNS2tCc045NjN2a2FRMzJkNlIycVVTWENvL1RUN3dwR3R0MHRpSHVUbjZaSXh0WExudGo0bDRzNFQ0dGVpc3pDd2dnSzVRcklKVjVaNkQ5S1hPNi93cytrWGUybVNibnV6Ynk1WGxVMk9ZckVkdmNOMXAvdmJLVzBmTDZYTENuRnF3c0VudEJVUms0MU43bzlIR3d2Unh0ZkFxbHUyaFdxaFhLdmNFRzJMWnQ1aTZHME4xR1RMZURUYVE4OHovQUNraElVdGFsZzlxV3lUb3RNYmt1MVdqMHkzRTI4cVFtbFBLZVF1SExTcDExNGxTZ0ZGbExwQ0VxVm5zR084Z1p4NDFXdDRLRHVqdjF1cHRuZDErN2YwMlRibGkzSkpyVTZnU2FUTmNhcUx4aHVNUis0S2FJUFl0ZnFISXh3QUJvNi93L0RkSUttazQzMXgyck5ZUHRXNGlhd0JNZEpQS01nSEdOejA2ZEtWL2NCenA1cVRONzJ0Q0Zma0tzRDFVMXliRHZDbXV3Skw2MEFzc1U5U20wdXpublZxUTJTaHBMYUNTU3NqR2F0Ym14WFQ1UWhVTG51bS9ya29rRzBFeDJMc24xOWlESUZKcVQwVjZTN1QwTk5xRHNrc2ZEdk5yV2xJQVZqQUlVTk1EWGVtN2NHc1dnMXR2Y2w0V3N4UktsdXczZGQ4dnhJY3FuVk80b3lacGtvak95RnREMGd5aHVNdzAyMlFsS1dRcnVINWRVOWpvc3J0bmIyYjJiaVVxdzM2elpPNU1tR21uVWVOZGlYNUVKSVFpVXVZbVk0SFZSbm02aTJGclV2dURyVG5PZlRDU0hIQ0ZsVHFHRTU3aitmT25LTDdYK0trbktaNmhqYm1IN2o1VXZuVWJaY1RicTZFN2J3SzArZ3pZc0t0Ulk5ZG9acDB0djRwZ09JYlcwc2xUS2dGWUtGSGdqMkkwc0Y4VWFKZDl5RzE2V2xRbE45emtzSldPMVE5L205dmNhTjM0dk12ZWkzTjg3RXIrOE54VVNzWExYdHVtSDZ0VUxaZlVxSzY4ek1rdEFoWlNudmNEUmFDMUJLVXFXQ1VwU0NCcFVyRHVaMlJjazZWVUpoU3BTZ2toYXNIR01nNTkrZFpqZExOR2d6blZ0SndVbnAyOUs3SDRRNHBmdmZEc1pUNitieEVqbUp4djEycGlFMlBCZzNCUlU3d1ZLcjFpTzdTa3VPcGpTc2Vpa0lLV21tMUtCd0VnSXprZlVmZlF4M050aDIxYWVpb2xweHBwMUpVRVBBakdEOS9QNjQwU3RwOS9hbGIwTk1LcVNXWDRqYnlYRXNUaWxYY0J5VWhXTTRPT1I5TkJyclIzcmR2ZWROcTBKYUVMZEt5aHVPa0paWlNTY0piQTV3QnhxcEhoTlRId3NLUE1Uc2RoUmlmZFA2UkZVbEtCeUpUbkkvUWVkUjIyTzVGNFVOZFpoV2hXbldJRmFqZkN5MlcwRE1ncFVGSndmS09mZE9NaklPclRiK3dGWnIxNnlxYmZ1NGxDdHRNQ2lDcU9UNmxNY3psUUJRdzEyQXFXOG9rQUFjQVpKSUFPZzdZMXgxS3AwNk5US1hKU2xTQ0FGTm5BV3JIR2l4V2J0L2o5Q01YZGlteVpNdERLV21LdlQ1ZzlkbHIzQlNmbFdCN0E2TSs1Unc2cEJXRUw2R2xNenBiMGNTSTZTcEJHVGpVL1NxdnVzekV0cXo2ZFNWVlo1bVE2dHd2eGt2RWpQSVFzRUhCeUNlZnZvYlRyb3FsMVV5UlNVeTF5WDZjdzIxMkxBS2cyUGtTQmp5QWVNZWVkZE81OVlrVjV5SkVqVkYrU3hCZVRGaVB5VUpaV3BySndWQUUrMzMxUGJUYlFXa200bFAxS1ZLVVZ1SlFzRlE3dkdUeW5qR2YxenEwMnpHdGtRcWVWekVhNUhmTkIzcDArOTNKTVdNbmtQS00vL1dubC9DdC9FMjJqL0M0NlU2aHRlTm9hbmQrNEZ6WEs3VnJubHhxaTB4QWd0cFFsbUxHTHVGTGVXaEFXcFlRTzFLbmUwS0pCMDFtem4ra1RiY1gzZDBlQnZKc0EvUllEb0RhcXZUcC94UHcyVkQ4emF4a3BCQU9SenhyUHU3T21DZ1VheTVWNDJkUUpFbUtxTkhiWVRPa0ZMakJHQzQvMnBHRjVHVWhKeDI1emc2QWQyMXFxMnhjVXExb01CWmtMQlNFTDRVaEl4OHlzWnhqVlp5ZEttT0FwU01IVVoycXFyMmY4TmhsYmo2bEZ3NkVnNjU5SzJaNjl2eGdheXFsMTNhSG95MnBxdDhDYmFycVpkNXdJenFJZExmZWFPRDZtTzBxUWhYY29jQkpBQkkwR2Z3K3Z4WDlwdWlycHl0N1pxOUtUQmtpSkFXOU9oVUYvMTVTcHEzRktLNURxaUd3Y1pXUW51T1ZwVC9TZFo4VW5lL2YrczdaRFlGTjdWTTJrdVY4WEtvc1J3b2p5SHNqNW5RTUZZQkErVlh5NTV4blYxcVBUelZySDJVajd4WFBRU2lMV25seGFJcHQ1dFlVcHZsMHFTa2xTU0JqQUlHYzZIeXBMYmZMempLODV5UDVnRFdxTnM5bThad0VQT1lRZEFCako2NUo3MXJGc3IvcEEzUk51RmVMTmwzTkF1QzFYSlR3UWlwVlJodHlNRms4ZHltemxJKytOUFRUcjh0aVJhNHZhbVY2TElwenNZUHNUNDd3VTJwc2poYVNQSS84QW5uWDhudDRRbUdXVFdxWTZTaEs4S1BkNFAvYlR6ZmhMZmltd3JJb0RteEcvVzZpWU5zVXFRbW9SRFBaZGtMYzdPUkdTRUE1U1ZZT0QvaEdpeTMzVXd5NmhPU0tVdUllQm1JTWxQdXlqeXE2SFUvTEZiWDFHL0t4VDRrYjR5ZEdqeWFrNnVTaGwxanVYSGlEOGlFb0JCY2NVY2VlQVNmWWF5Ry8wc2pxaHFERzNPMnZTcEdmOUtUVkhuYmt1TnRwZnloTFlMTVpzNDgvTXAxWDZwMFE5L3Z4M2FqVHJtbTB6WUMzRTFKcDl6THRlck1WQWNVa0RBYmJRazRRZ2ZyazU1ODZ6czY3Yjd1SHJ1M1NjM2czZFlLYXNxSXpFYWVqdkZLRzJHaGhEYVdoOHFRTWtuSGtuSjFVc3R4RWE0YzhvL0NOaHZWZ2V6aS95b25PMDBCa2FFNlp6L090SUhTbzhweWMycGlJSFNoWVY2YmpmY2xXRDRJOXg5dFdlM0ZYWGFrNWNwRlBVMmhUdmU0MEcrMERueGoyL1RUVDdJZFA5bXdyYnI5eFN0NmJXc3FvV3ZDRXFqUnFyR2NWTXJieE9BMUhLVUtBV01aeXJBR2cvdUJEbU4rcEptZXE2N0pVcFlmVmtsMVdUbFdUNUpPbmdYOW1lc3NwVDhQblEySjdQcEZsQmtMZUllUi8xMHg1ZWRmZEczMGNwaVVsdDViYTBxejhweGc2NmExdkxMdXFFdG1XcnVTQjRCMVRhWDAzNzJYa2cxcWxXZyszSEE3dlhrL3kwcVNmQ3ZtODZJL1Q3MHVWaTViN3B0cFg3TGFZZW1UVzJXV0VxeWdaVUIzcUk4anllMzMxU2Rac3JLc3R1QXI3QTVQcHBUUmJicHh0Ty93Q0YxaGFXc0g0MUpJVGdkY245TjZxbGtQM1hJZzFDbTIzUlZPTlNWNUxxbXVFbjdLOXRWOS9ibmNxemFrNVdKbE43bVN2dldFcjdzRDMxcUh2QjBsOU9PME96OVJGSnVha3dhNVJpeDZVS2JXRXZUcGZjY0tIcHNuMG15ZklRTWtEeXJnblNPN3dYYXd0UzZIUTZPKzg2U1VBSVNWWi90cW1idktidUpqQkNTQ0JuWE9QbnRtaUxmQ05pazJQK3BCNWFWcFVTTk9YSjc4dXBJcXAydGVrSmJUZmEyb0EreDlqcTFxaHVWdUVSQmRVWEZEaEtRU1QvQUcxWGVtenBwdkRkM2NoVVNxenpTcVN5NkZTRnVZU3RlZU94c0h5VDlmQTFxeDBzZEN0QkZ2eW05djdSZ2orR3d6SW5USnJxQXNJU09WS1c0ZVNmb05LWEYzRUZ1c0w2VU1ndU9IWENkaDZtaS9EODZjOWExT3pHK1ZBMEdkTTlNK2g4NnlmMjMvamUxbTlrQzRhclRaU1l5bngzcWVZVWxzbjJ5Y2EwRi8xT21idFdsR2xiVnhJdFVsMVp0U3BWQVpXUFhRVXB5VkFIQXdmcm8yM2J0cGF6OUhkaVZpMjRNcGtBanNYR1NvSDdqSTg2UnZxaDNNaTdCM0FoRnZ1T1JvTHJoVDJzT0ZLb3kvY0FwT1FQK21nY0hqR1J4VE1ReXpINVY0d1FTQ0NCOU1HbHVSWkxVdHR4dDVYSmhSVUZmOWM0MzhxOUViZVhySnE3OVBWWms3NDZFcGZmRFN5VkZydDhrNDQ0eDUxVjV0d1gvR2xyWWJpdW9TaFdBa01rNC9mWGxZM1VnaTVQVVJTYTVQZWZlYUtTaU0rc3FXRDVCeDVHckN4Y0ZTVzBreUtGSTdzWVBxTjgvYno5dEh4TW1SRmxEeWVYMTBxSi9nUnA2TW1SSFdIQW83Z1VhTEk2QmVuMjNOekhOMEtpNVU1RnZ3MEprMHlsUVhzdEttaDFKU2xmZGtLWXdEbFBrOGM2c1BVM3U5QnVwdDM0QjB0U0tjeVZGcFNGQWhzcXh6a1l4bjZIVmlvWFVBbWhiZDBxbjNMYkNZRWxFWkltUTFLU3JzY0hrWkJJSTkvMzBOdDA3M2c3eXQvNnEyNkdFeVp6dm9SMUJJSGFwUndDVDlCLzAwaXJrVFhYbW01VGhkNUJqbTllNTY0b05MZjVtaXlEb1R0UVpxZTRMOVJRV3kyNFZxNFNoc0h2V2YwSG5WU3ZHM2QwYWZTMzdnbTdlMWh1S3BzbEsxd2xmbCt1UE9QMjA3VnY3QTJkczliY0YyaFZodG1aRlFISlUwUjBMZG1PWTVLbEtHVXBKOWhqQUEwTWQ2ZHg2dlZKdlpVcWd5NGhMWlN5V1VCSlA3alJWbTV4NHNnTnN0ODJ2WHRWVk1WTFNSeksxb0c5QlRraTlyam1Hc1JXL3dDRU9WWENtMzA1THkwTjR3UWZZSFRuYmgxK24wVzJYRlFJbmUzRVlJYmpORUFLQUhBU1BHZmJTTFY3Y2FUdFJjek4zMEo1TERYeGYrK3RKSGFoWVVmem42S3o1T21Ib2UvOU92VzJFVG84aElVR2dWQVk1T1BycW54VmJINTgxRTRKdzJyR0IwQkhRK2ZuUkdMT0xFZndTZGUvWFhyVktxODY0N2twVW1wM2ZFYllhbHFXcE5QY1FrcWFhUEFRdkhCejV3ZENDTmZzM1oyOWFkUmFkVUJEcFNuQ3VBZ09GSVpYbktrajZENmFLbC8zZkFVeTZwRWtKS3h5QnljL1RYVnQzK0dOdUYxZzdlT2J3M2hkamxtMnBEY1Vxa1ZGeUI2cjlWZEFJUG9JS2tnTnB4OHpoT004RFBPakZwa1FvaktsejFCdGsrUklCeGdZR3BKb1ZkWFEzREtzY3loK2RlOUIzbnBLVExyS2FvMHRVcEpVZ0Z3bnRTQndDZVQ1eWM0ME9MKzNWWXVaRHRXaVRHMU1LQTdDZy9LQ0I4M1BuR2ZxQm9aYmo3TWIzN0NWaDJORkRsejBacFpEVlRwUnllMEU0RGplY3BWK21SOURxMTlCUFQ5ZmZYcHZ1MXRteXd1azBDRzB1VFhhbElhVUcyMjArR2lVZ0FLVWNqR1FUanpvMkxOYlk4ZGR6THdVMGtaNWgwQTZZM3llMjlBRVhBTElSZ2dueW9PVTI4YjV0WGVaTjEwYWp6MVIzZ2tQRnVNc2h4dnozY0RrZmZURnlOLzQ3RnVJcVU1bDlpTzRuL2lTR1ZJUXRYMEJJNTA3TzZIUWp0L3RSVG1VMGF0TGx0MDloQ0dtUGcwTmdKUU1CSUlKL3dEdzFDN1lkS0Z1ZFRVOTl1N3FHNmJTcHFrR2ZHOUxBa256NktNNHdPUG1JOEQ3blNuTzQvNGZ2QlE0V1R5TjZGUU91QnRvUnY4QU9yTVZvTk5MdzVrazV3UnQ2VUtlZ1hvOXJIV3JXbGJrYmhTcE1Hd2FkSURhaWdsQ3F3OER5eTB2MmJUL0FGdURPTWhJNUp3NEcrRzEremRvMmczdFhRZHY2UEZwOFZzSmJoTXdVSTlQQjhnK1NUL2lKejc1MUZYSmR0NzdlYm13TFJzYUF1MTdGcDlxNWdzcmloaEh4WWNDVzJHa0FsS1VCc0hJeDk4NU9xamRlNEZjM0V1eE1CMXRVeVpKZVNpTUdVOXkzbGZRZmZPczV2MTR1VjNtSWNaVnlNalZLVW5ZZE00MDV1L2Foa2xicFQ1MGduVUgrRzFlbDc5UXlhZDArVWRTS1RWV1BYbFAxS1dCR3Byb1gya0xjUHpFS3lDbElDbEVrajc2YlBwcC9DaTJaNlBhY25kemY1dVZ1RGNVR0w2OVB0d1U1TGNFUEo1Ui9MV1NweFhkakJYaEk4bEo4YVBWVDZMS1E3UVhwbTR0MVBHYTdHUXMwMmxTT3hsZ3BkUTVsU3dmNWkvazdmb0FwV09lZGRGLzM1SzNLdVNXNjNIUXd3eTEvdk1kcHdxU2c0d0NBVGtBL3dEYlRGTjlvOThtVzltQ2wvUkk1VjRIeEVkeXJPZGR2aHg2MVJZdE1aUHhsUE12ejFBK1ZIeWc3cDFkcmFta1M3NHA5UHA5V2ZnSVhNcGROa2V0SGpGUXlHa3FBK2J0R01ueG5PT09kTEgxRGJ3UFhGYzFQc3V3MkRKcVQxUllTeTRoYVVkdUZoU2xMVW9nSkNVZ251SndCcXQzUnVCZHBwMytwOXAxajBtbVFwYno3aWhsZ0VrOXFRZmZIT1Q0KytnVHVaS28xSWNEcjFXRTZWSTQ5U1Mva2Q1UEhPY2VmYlVObzRlbGlVSmhUMXlrZCtvMzZmUEpwemhjTHUzaUo0cnpvYVFmbVNQVHRXclZvNzExUzBiUHBrbTRYbWFxbGxoSW1QeFhnVmxvSnhsSjVDandQcGtjNkVPeDI5bGtibmZqS1h4VUxTcTdjeHVac2hUQ2hEYXZuYUtKUy9VU3NleFNWRDlNNTFtL2JuVmR1NXNWZElVaWU1L0QwdDlraW51THkxSWJKNTQ4ZDJEd3JWdHF0MzJEUXVvYTJPdGphRzhwRU92c1VRT3hLZjY2aEhrU2tLVWxMTTF0c2haYXdvZ3BCNTdjNDhhMGV4UDNTTmNDbWNlWkM5UVFObERvZkxGSzE5NFNsVzkxQ1dSenBPY0VWcVBkTzExNHM5UnpGN3g3REM0azdjcW1Ta1ZLS2dIMDRMTkxlUTg2NzIrTXY5bytZRTU3VHJPai9Tc3JYVXhjR3l0K010OXZmQnJWT2VVQjdoeU04a1orMlZmMzBiYngvSGN1TCtBeG9WbTdKMDBWUk1kQ0o4dWZVMXJaRC9hTzh0dEo3VmRuZDQ3bFp4NTFuNytMWCtJQnVaMW9XcmFsbGJqVzVSWWlyZnFyOHVES3BLWFNzcWRhRGEwT2R5eU8zQ1FSZ0Q3NjBTeUx0N0V4VGJTaVNzaytuem9KTjRjdkRjTHgzbStWS2Q4a1orbEp2U3FuVWpHRERMem5hZnpwN2lSK3YwMWFMZDNBdk8wMzBPVXFhcENlUFQ3Q1FCanlCem5YbFlWajNWYzlJYXFkT3RPU1dVcUtYSmlrQkxTd09PRkt3Rlkrb3pxVmwybGNWSFF2K0lXMC9qR0dYMHBDZ2dZOThlQm9wS2NpcWNMU3NaN0hGTGNUL3dCVTJrbVZCYmNRay8zSkJ3ZnBvUlZvamRVTzRya05NR29WZDk1bExnSmp1UHJLTStDY0hqSkhHZnBxL1dkMW8xNmh1S2h4Sml2aG4yZlJlakVCQ1ZKVndSNDRHT002QkZMcFFTSFpLdlFVaFMrMzVsSEs4ZVFOZU5icDdrS29GaHNzci9LTXgxNVFSak9PZlA4QTY1MFBWYklUcm9XQnIzcGd0M3RlNHhnZ3NLZERpZW9VbjlSZzBlTnhONzl1THh0RjF0bE01aWMya0lpTnV6QTZ5aHZ5cFBQSSt3SEdqaDBZN2pVYmIzYkNqTFEzSGNROUVXSEQ2STdpcGFqa0VuMy9BTzJrVURFK0ZMK09ZUG9CdDRjbnlDQU9lZjhBcHFlbzkxWFhTVzNIS0xkRXhMeTFEQ1VMK1h1Si93QXovd0RQYlE2NVdJU1kvaHRLNWRRZnBUeFkvYnl1Rk1EMDZMekRseDhLdFFjK2Y3MXRwK0hGZFZvYmo5UmJ0Z3g3eHFWTC9pbHJ6V0kwYU1VK280aEttM1ZwUVZKVWxIQ0R6ak9NNHdjSFdoMFRiRGFheDQ3Y21WYnNhUzVsU1V5NmtoVTE5MVFRcFpIZTczS0o3VXFQR1BHTllJL2dZNzU3aFNQeE45dEtMZHRjTWlKVVhLakFTVks1VVZVOS9IUHY4eVU2M3B2OXh1ZFUySVZhYmtLaXRvU3VLeTAwNHB0OTFTWEFvcUtCeVUvS0FrL1VuVmx1WEk0WTRlVnlBWkIweG9OZXBwVjRydXRsNDk0bkZ5YlFTT1VKUE1BU01kcXVMYzJEVEtRYWhIV2xpSTNHTWcrZ3lFZ045bmZrQklIT05aMGRMWDRwblZOMVQvaTBTK2w2QWlMUmR1cU0xVTVyMGQ2ajRsem84ZHZ0UmwxV0NFbDBqQ3dPY0hCSUkwNFhUWFVybnZLdjNYZmsrL3FuT29JcXpsSnRpM0hIVXFZalJJdUdseWxBbzdsTGNlUzloUlVRRUFER2NhU3ZwOVZGamY2UnR1TWdKSGNkcW15UHNwU21pci9JK05lcFV0Y3RETDVPaFRuR2RqbE91bnJwUXFPd3pHNTJrcDF6dmpwZzZiVThtNy9WMXRSdEZWYWxSN3dWVTVqRkFpTnk3dHFkT3BLNUVLM295K0VPelhmeXRBK2UwWlZqa2pIT292YXZjYllIcWMrTW1XUlFhalRhbEFaYWtINHFsUFVtYXFNOWtzeTJ3UWt1TXVZSlNzWlNjWTB2Zlg1dFp1NDNSYnA2YmFOS29EMXFkU0c0VUprMVdUSmRUVTZSSVUwMFgyUTBFbEVpT1JFU29LS2tsdEtuQmhXUm9sZElGNDdxYmlkVmw5U2QxN1poVXFxV0xZTnYyalVXYWRWaExZa1NrK3JLZGZTUWxJUUYrcWtwYjVLVWprNTRIbHE3dk5UQTE0cDVzZ0ZPTlByNmExN2V0a0o2TVN0c0VZem4vRkpWK1B6c1BjOVB2amEyN0lOUWh2c3VRcXZFY2xQeEV0dW5EckRvOVQwOEJ4ZnpINXNBNEhPZFo2Mk4wdDcyYnk3MjBxeGRwMmhYcTFjYzF1RERwYkRQb3BCUGxhbFpJUWhDY3JXczhKU0NUOU5iTi9qZjFCaWcyWnRWVy80RTNVVnF2cDZJekJNUDF6SmNjakJTR2twOGtyVWdKN1J5cklIbkdqTCtHbCtHcFFlbmkyS2p2RHVsWmNCbS9yMGJVdWJUNDdYOHFnUVhGOTZhZTBNOEsvS1hGQThsSVJuQ1RrZkxSUGxYMVI1UnlFREp3TmEyV3kzMng4UGV6dG5PcndLZ2djeDBPZHlPdzg2Um04ZndKTnRhSlpOQ3QrSnY1ZGRLdTl5bDkxUmRxZEdUS2lTSGtsUVc1OEsyRXZ4V1ZGSlMwTzl4U3lVREFVb2hLcDd4Zmc1OVlsbVZXU0hyRFJkbEhndnROU25iU2xwZWtTVnJDTU5OTXJJZFdlNTF0dFNrQmFBdFdBcFdNNjNZdSs4MTM1ZWo5aWRQR3praThFUTZpVTNWWDVWV1JBb0RMN1NTbjBINVNrcmNscWIrWUthWVNRZ2xYZW9Fa2FDR3huWFp0MVZkeWJtbFJtb0ZXcGRtWEEvSHFkejBCTEtiZVZKU2hJeERxVXA1dFV0YVN0MWhwaGxwYXdwdHhRVGd0a3NEZHJoSXc0RTRVUDVpc3JSN1J1TkM0cGxiZ2NhVWNaTzQ5RC9pdjU2Ni9ZRi83SHpINlR1RlpWUXR5Vi9GSEcyNlBYSURzU1UwbE9DbFdGZ1pUbk9NZU1hKzN0ejU4bG8wK1VDQ2xDVWdMSEg3ZlhYOVVydDJkS0hWck1Pemw0VzVSTG1xcnR0c1ZtcFdiZE52QitaVDRieWdoQWt0T29WOE80VktBOUpSRGd6eWtaMHZXNnYrajhmaFdiNk1PVmUydGxYcmJlbWR5V3FoWU53dk10RlFKQjdXdTV4bFdDQ01CT0FSalZHYkVZa3YrSXRPRDVVOFdMMmdtM3h3eW9xeDNPRDlzZmF2NXU3cnZpaDB1M1pOUGtSMEtrU2NLei9nMWQ5azYraUdpRkxkZi9vUzUzNTU4ZmZXcFcrSCtoOVdGVzVNaWRzbDFsVnVucUpKUkJ1KzIyNUNSOUUrckhVaFg5MGFCbDAvNk1iK0kvdG5GVEgyK3Vxd3J1WWpnaGt3cmdYRGRVQjQrU1MyQi84QXZhcXo3ZEdkaGVFaFd2WE5ORmc0K2ptN2w5OHBDY1lIZmZyVkkvMjNYYmJOQVhJb055UlhBc3RPRDFVSWRTb2dZK1lLR0RqL0FBNlRyZG05YXBHM1BrVnFOVjF5RlRBcjFYOGNsUlZrblAzT21KNmlmdzRQeEIra2V4SnU0WFVQc2pVcU5hOU9XZ1M2MjFVNDBpR3lwYXdoR1ZOdUUvTW9nQVl5VHBROXhLci9BQllGNmx0U0gvUkdVT05ORWpRMnpXNStNNTRicDVrN2VWT0Y3djhBQWxRRElocUhOa0U0OHZTakZ0enVoVVk4Z0podmZFdHlXRkNhMHZqQ2NqT0NQZjZhSXQ0ZFFHM2pWdUpwTFZnemtKalIxL0NwVFhGb0NIVkFmelBHQ2Y4QWw5OUp0YjE1MU9sc2ZFRjExbFNuQ01LK1hKSGtmNWorK3Blb1g1THVKQ0czSkpKSEIrYlJSeTBPdHZiQXA5TTBJamNYd1pjSTZrT2RNSEZUZDNicFRwMGwrRlNtUXlIM2lscGhKeUFUd0JrK2YxMVlkbHJjYW9LSFpWUXFManowaFlLbEpSanQrMzMwSkxvVkVnTm9IeEFVNG9oUlVGZzQwVXJEdWhFT2xRdTFrS1FJNlJuT2NuNjZsdVVmd29HR2hnS090VnVIWi92bkVoWEtYbncwNkRmQkovYW1tMndzemF5V0hhdlhGWEhXR21MZWZkUkJ0OXRwRG44UUl3eUZsMFlES2ZLZ25LempBeG5PZy9kOXhQVU5DWHFqR2NhY0tpcFlkanFiN0RrOGZNQm5qblhyWmZVQld0dnpJazBXcUtaRHJYYXBKT1JxajlWWFV4VU43NnpHclUra1I0UmkwNXFLMjFDSGFsZnBvQ2U4L1ZTdkpQMU9nc096d3BTZVlaQyszU25TNmNTM0MwdXFWa0tiSTN6dGpwaXF2ZG00VTY4Nmo4SkJKVzQyNy9MTFpPUWZiL1BURjdVYkFRWjhDTGRFcWlTbkpDSVRhMVI1cmdlOUZ6dCtjakF3QVR5QWVSbms2WGJhT3JiZk14b2FXQTQ3VTNIKzZSNnJJd2xJNStWUVBuUDIwNUd6Mi96ZHUwSlVCVktiY1pkVWxLbkVIdFdUNHhueVJxbHhLcVJHYVREakRrU2R6MXF4N1BWTVhvdVhXWjhhODZKenA2NDc5cTdyL28xNVdhNUNkdktreVdGU2FlaVREVElUOHk0NUdFS0FQaE9CeG9MN3MzSlFJYUc1c0tZUSs0c1k3UmhRVjlBUnBrcDBOTzUxRG5YSlJyMlZNVlRXVXR1MDZTM2w4c2s0SHBnbnduZ0g5ZUJwV2QxYUNJRjZNVktxVXdKYmd5TzV5TzR2Zzgrdyt2NjZYYlZhbjRrbEtwR21ja0VIT2FjK0tPSUIvUjNERFFGclRqS2NZeDlmS3JSYVZScmxkQ0dLL0hhbm1iREpEanlNT00reVNTUFBIOTlGamJmcDl2V0JXb2RHdGV5cHpWVXJEUWFnTkNucTllUVhQSFpsUElVUHA1QittcHY4TTNabW05WjNXZFI3VnQrbnJYYmRQYWFuM0ErcEdBaU16Z3VKSTl1OWVFRFAxMXNIdWx2ZlpEbDZxcytoVWFsS2dXODBqMTU4aUloUWt5RkFvYmlSMUVkeVVJU0NweDFHVGhJYlJ5U1F3LzhBcCs1WHRzbnhDakcybS9yV0hjUisxTzI4S3RzTk9OaFJXQVZET3hPd0EvT3NHdDJiSWwyVEprc3lXSG84MkxJVTA2MjE4cTIzRW5DaHg3Z2ovTFU5MDQ5YzExMkJYMmJHdml1eVpGT2xMRFNYbm5TVnNrOER1Si9NUDExcWxlUFJyMGVicVV1YlV0eE5wVVVxWXVydkpabVcvVVZSVkJwRGFWT1NIa25LRXFMaWdrSUE4a0RKSU9sOTNXLzBmYlorNDY4emVkZ2IwM0JUaE5sSitGbzlicExUeXBUcWo4cmFQUlYzZ1lCVVNRTUFFbkd2eDRRZVZGTE1zYytoMUcrYUhKOXJuRDEySTVDVUU3Z2pZL0toenVkdmxIVEVadHluMVAxcHJvN2hFWmRTVHlPRkU1d2tmY2thUlBxYnB6MjZsMktwZFNscFpZYmVLWkMwSDFBRG5rNUhCeDl0YVR5L3dKOTlhTmRjT0hVcTNUNVZCY2tvUlBxTkprRmNodG5QS2cwdkhlY2VCblF3NnBQd250MGRsTnlGVUt6N2VxOWJvajhWdCtEVkZ3RTk2ZTd3aDBOa2hDeDdqUHZwYXR0dGM0ZWwrTUcxY3cyT00vYW1DTE80WnVUQ3d1UWxSVU5zL2xRbDJqMkkyZjI0c2FIRjI1clZHbEpkYlFaTTlFNXYxbHVFYzkrU0ZKd2ZiR2lLMzBtN3BWQnRNK2xXdXVSSGVTRnN2TkZKU3RKR2NqS3ZHbFEzZzJscmUzTlNseExycEw4UitLVmR6bnBkdVZEM3o3L3JydTJ6djdmS3JXTFRwOFcrWm9hV3lRMEZTRjVDVXFVa2UvMEdwWjFpY3VSOTdiZUk1anJ6SE92bFRURjR6WnNzTkVNaEJRbjhQS01hZkkwUWR4TG9EOHN4eVNudVFmemUzMDBPN051cTVyTHZkMjlZaUE1U2FaR1c1S2RENlFZNjFBcFNRZ25LaDl4NDE4M1hmRVdwdHFLamxRNTdncmpHaHZNclQ5eXpKRm9VMlFROVVHVk0rbWprcFQ3cVAyR3A3TmErUmdwV25UR3VlM2Y1VmtMMlRxcmZwVE0wbnF5YXZpRzR5NUpDMGxIWW51WGtaQTgvZlZPM0F2bW5WQmhicnNoUGVqSkJLc0hYRHNyMGkybEhwOE1Tcml1V1NsOVFiZG1OeCsxaHBYdURoSkF4K3VkZTk1ZEhkOFg3U0o3MnpkWWZma2lZNUZvOVBrTnFkY21oQjdTc3FUK1FsV1FPTUFEbjY2cUJxd056c0pmd2tFYWtZRlFPdHZoQVVVNVZnNUExMm9FN2t2MXZjNmNuYm15SURrMm96M1VvWllhT1Q1SHpINkQ3blRNYks5TEZ0N1FXVkdpYnMzaFU1TlVVMmxVaGxqdWJqeDhqOGdJSGNzajZuKzJqWitITitGVlY5aHFlZDMrckM1WThhdHpGOTZLSlMxaDVjVk9QbGJlZkdVb1BrbExmY1JuemthWTdjYmRHenR1U0tiUTdacGpMRGlDRnlZclFMcVJ6aFpVckpQdDc2QmNYOGRzc3ZDMFd3ODZFblZTY1pKNjRPRHA2YjFVaXlXbzZUS1dnbHdqQUhRRDkrOUtRbm9Yc3JkSGNtZ1dWWnQyVmx0eXB5MnZpaWdoeENHZnp1SENnRkQ1TTgvVWpXZ082aXJkb050LzdOcWJRMHhxUlNxTWlCQXA3S01KWlpTZ0pDTWUzSG5IbkowbmR5MUdKV2I1cHQwVExscU1XUlQ1UWtVaWJUWnltRklkN2tuSyt3ajFVa1pCUVRnNTB4aTl4MloxdTFpclR5RlNIR3NJSEpVc0tINThueDdIR2txN1gyUzdHWURxeWQvaFBRNkRmcitsTGw1bXJ1UytaS2VVRGNkelNvM1J0SXhjTnd0N2YwcWp4a21weWhHaXRsWVFrS1VyQ2NxOXZ1ZnBwdk51TFQyMy9BQSsrbG1leTJVd21JTGFwOXdWS1BIeS9VSks4QlRnVGpLODhJU0NmeXBIMzBLdGlOajZqdW5mNmJzck5YWEJvVkJxQ0pMMHhLY3JmZVNRcExMWlBIbkJVcjJIM09pbDFFZjdNN2pwazJ5N25rTjFKMzBHcGo5TWZtOTJFZDM4dFpRRmZseW5JOWpnNm95N2tweU1pTTZ0UmJKQldFblhGZTdkSWViaDhxK3AwTmZsTnBUVzdkWGh4a3BjbHNWRnBNZ0lSbEpVMm9CWUJIa1pCd2ZwazZNMWRmdGkycVdMT3Q2QzFEWWdRVTlyYVdVb0dmZmozNUdxanRCVTZmWlcwY205cm9wM2RVbm0yM0hYV0VoSWpzcklDQno0QUJCS1I3cTFYTjhGeDROTmhWbUpWWFBSY2VMcnFrdmZNbEpJNEE4OG4zOGFTaVZSa0JrREtWSCtDaVFPUm5PMUE3cXB1eGQyVjAwNXRaQ0czZ0VJQi93Q0duSCtXdWpwdWcydC9xMGkrbzF3SVRXWDVEa1JwQUdWdEpTcnRQYWY2TWdaSjhueHFrNzMxYU9tdXR5WWJmYXRDQ0ZKN2NKV0ZEaFIrK3FGMGwxeDFWNDFLTEtsS1lRSldlMTVlQWtnK2ZPbktQYlhIK0hsbEJJSUFQMU8xVmxMOE5mTW9acGpib3ZTVTNQbVFBNjRpS2hYYTR0S2lTbkFHU0IrdWcvY3QybVBmNGVwc3JEVWhzdE9CdzRVci9tNDhqUm1wVnUwMitJOWJxVGpnZ3RVa0pTODc2ZnFtU3RhZ2xQYWtIbkpQay9UOU5KOTFVWENyYlM3M0tMOFVTL0RlV0V2dEw3U2dwT2NaK2g5eG9qWU9GYmdVSWRXM2hMZ0lTZTVHOVF0dnRxZjVSdURYUHVadk9iSnZlcnpaTThvU21UZ3RoWHQyZ0RqMzQvNjZFMTlYQmIrOGlrTVVpNFpGUGNCeXAzQUdEbk9SbnlSOWRjSFZiYmJ0MDJURTNqbzl6d2xrUmsveFdtdlRFdHVMQkdRNGhKSUtpUEJTT2NZUHRwY1lXNmJrUnhJVEt4MkpLVTVQNzY2RzRiZ0dSYUVGdlZTZERwc1JUeXU4UUFsdEw1NWNBRHNEM3BrTjhiN3RhRFNJTkhibG1RL0hqSlpNczRIZDJnZWNlL0dkUXV3SFVUWXRuV2pYYVRjenFIYW85VUcvNFJIS2NrQW9QZW9xd1FsSU9QdWM2SGROMjl2SGNTbHNWV3N2S2d3WDA1WUswL3pIaGpQY0FmQVAxT3VxRHRkWWRtUElyVWlHdDUxcFhLNUVwWHlxODRQYmpWOURGdFphVXk0ckt6MEd0V24yN3BLQ0ZSbS8rTGZKT0NSNUNpTGVXNTFXdDZpdFZHbnMwMy9mZ29obE1kTHFWcHpnbFdlUUQ3ZTU4NkU4S3JVQy93RGRDSTN1TElqUW9TWkhyUzBvVW9OcUNRQWxBSGtEd01EMjErWHB1QlQzR0hHNE5IVXcycEp3cFVndUR6eGdId1B0cmkyVzJqcmUvZDh0MGltRnhEYVhrbDExcElLbEhQQ1U1NHlkRUlVWkVTT3AxWng1OWFEVFNpVElTMDJubVdUK0U5dXVmM3B5SmNleEsvWnRPZXRKQWNaRFlQeFBhRW9EWTRDQWp3a0Q2YXF0eldQVGhTbndaTWRCVW5LRk1OcTd2SDVUampYSFZyWHV6YmFndlVlMlV5b3Nhbm4wNUtVNVdFcUhudVVlTlVDWHZqVW1pS2MraVE0b2s5NU1rcENqK3cwc29TeEtkS213ZC81dlQyQkloc0pTUU1mbFEwM1dwazJ6cXFKRWRzdGtLQ2xOZG55dUE1d1NuNi9UNzZsZG1yQXFlK04zTzArMEthKzh4R2orcEplZUFWNkRXQ080a0FCU3lyd1B0cUIzaXIxWXV5U2lvTERyanFIRWdSZ29xTGd5QmdZNTAxL1JsWlRXMnUwYUlzcVNxSExxaCtKcW9qdEV1cWNVY2hDbGYwOWd3TWZybzFkcmtpMVdQeHM1WHNQODFrOGpncUp4SHhpQTQyRW9BNWw4dW5ONWZ2U3NYdlp0WXNhc3F0ZTRFbjFrdllQeUh0ZC81aDlDUGY2NTE0Tk9pUmh1SElVNHVNOTJoRERad3ZrOXBTVThrL1FFWk9qL0FOVGUzSXVHYzVFaHgzSDMzVjRpT0lIekZTandBUjc1d05OTjBmZEM5bWJNMnJGdUd0VTltZmREMGRDcDA5MUlVSXl5a0V0TUE1N1VwL0wzZVNRVG5IR2d6M0dVS0haVXkzeGxmL1VkVCsxQzc1N0lIQmZ3MURYeXNLMXlkZVh5OC9LZ1YrR3R0dHU5dFIxWGJmZFExYTI0bXhLUmFkZmJxTXB5VUJHY2VhU2xZVWhBVWZtS2dyQU9NYy9iV2pXOFg0Z20rbDlUaS9UYnRldHlFMnZNZW5VYjVBampBVXB3L000ckI4OEQ2RFEwdWVrTVFJNVlLdjVoVGtFZTJoSmQ5VGtVMlVwRHpwN0ZKT1VxK21mT2tBY2V6TCs1N3FSNGFUMEg2MDQyejJlMnJocUtWb3k0cmNsWDZkSzBlNlg3SHAvVUYwZjIxQ3VDYlY2UEdvYVhXYVpPdHVzT3dwRGp6RXB4U0hsTFFTWERsUktndktWS3p4cEJMUDNadHJvWC9HZXJjdTdYcmd1S2NZaUdhcFdhdlBVOUxrdzVTVXJMaDQrWlRaQXdNQUVjY2NhTk93WFhSY3UyWFRoUmRrN1pvc1JoOHR6RnZWWjU1U25raDExYXU1Q1FRRXFBSXdlY0huUStwc2FpSW4xTzhaRWh5cFYycU9qK0pWeXFxOWFkSUNSaElXNnI1aWxJNENSZ0FlMmROY25pYUJCak5zZ0tXZXAyeVNSK1F4UzdFNFhsUzVianFpRW8xeDEwL1N0UnR3ZGs2RHZsZVczbTZ6TjJ5WS8rbzlXWFY2WEhpSVFwcWF0Mk90b2VvVjhwSFk0bzhjNU9wemJYWSt5dHFieHZLK2JlRTFjMitxdzFWSzRKTWoxRWV1aGxMSTlQajVVOWlFanQ5c1o5enBYUHczT3FyY3E5NE54V1R1VGI2SXRPdCtxTnhMY3F2cS9OVUkvcEpLbEtUbmp0VmxJUHZqN2FlVGIyMHA5MVZXSmRVcVVwRktZYWM3WXdPQkxkVVFBVHgrVkdEKzUwOFJrUkhzU2t0bm5VYytZOC93QTZVWlFlWVdXQ3JRWkg4TmZDTmg3TzNHbjBHK2I2b1RVaWJiTlJYVXJVWElaQ3pUNXFtVnNpV0VLQlNYRW9XcnM3Z2UwbnV4bkdwcEN0eXFUTGRaZU5Rbk5Ocklha3ZRNHJ3ZlQ3RWhsVGFrRS9UR3J0MkZBQTR3T001eG5RaDNzNmhkdjdBM0JpV1JYZXBtM2JPbEtoQngya3k2Q3ViTWVVcy95MWR4eWh0SGJ6akhjYzV5Qnhvb1ZhNUlvWTQycC9BNWlLRk84dlI5SzNTMjlvdXdOWDNkdTZnYlp4WHZTcjFuMFYwd0RVNmRrdUdDWkNXME9kcmkxSDFGcmNXb3BKQUhjcnUxUnRsK2tlcTdZMDBiTjdjMkxRZHA3VXBzNnJTWis1VnVKWW4xeVZHZWx2T01SYVUyRXUvd0FLQ0l4YlF0MVE5UWVrQTJsYWxkNFpQcHEzeXIyOU0rdkxnQnV1V25CYmlxdHZjS0RUSElNU3ZxY0MvV2JhWmNKNy9SS0VndnQveWxsWUErWkt0RWlwVWlqUzFmN3pUR0hWbit2MHgzZi9BTFE1SDk5ZmhJU2thaW9WUjVHZVVMMHJIKzVlb1RkeHVnSXNqYnF6cnp0S203d1hnNWF0dVJoVFJBdVNkYjlPTGpyMGRudlNneGxPdHFla1RLby9oUmRsSlNrbEVWYm1yNVkrOFROb1c1Wis0ZlVpNWVDNkRmczFGQTJYNmZ0bUhIbzhpZlJJK2ZUa0JoTGpiNnFlVkpIWW9xYmNrOXlYbmxBTFEwM29CdnhjUFRmdFJaenQ0ZFFWL3dCdTIxUnozUmxUcnJuc2hsWWNTVzFOcDlmS2ozcFVVa0k4cEpCNDFRTEg2RU9sU2tWSC9hL3RidFpBRDlXVEZtd2Jnb0UrUzAvSFlSRjlCaE1SUzE5OGVQNkNpQTAwdEtENmlqMjg2OWw1dFNkSzhlQ3BLc3JCd08zWC9YYXFGdGRmSFZWdERzN1RLMWNGdVQ2SkNrM0xGcDFFc3k1YU9sQ2JiZ3lISFYvRVZpck9LY2NlU2pLVUsrSFJoQlUwMmxhc3FkREtXT2R6Nk5UYW5NM251SzJIUzA4WElraWhSSG9yRE1aTGZjc3ZmRU9MSUtTRlpVVGp0R1RqblFmdkhwZXZUZFJwTmpibGRTOTExZmI5bVVoYzZ4NkxUWThHUlBqb1dIRXhKc3M5MHFTd1NFaFlRb0tjU08wcUl6ck9EL1NXdnhsRGIwS29maHk5TDl3RlUyVWdON3QxK25QQlB3akJ3UlJXaWs4TFVPMHlDUHlwdzFuSldCVld5WEZCSXhydjZWY2l1dHVMd284b3pqVTB2bjR4WDRtZFMvRXI2bFl1eGV5VDRrN1QyYlZWdDBaYmlpaG12VDA1UTVVM0J4bHNES0dBcjhxTzVmbHpoYnVvbllselkyNDNyT0Y2VUt1T3hvYmIwdDYzSm5yc01GU1FTMnBRR0F0T1FDT2NIalErNmVyOG90dFZ1UFYyMldIRnRnS0xieDRVUngyNC93QzJpVGM5d3diOGcxRnFnYmZzdDFPYStvS2xSSGl0SWJLZnlwYkpLVWM1VVZlZWRLOHREejB6VlhLbFBUdlhVZkRTSUZzc3FFUndIT1lha1kzUDUwbys3TFZPbFRISDRoQ0hXaWVFKy9PcERaN1p5dTN4NmRTcU1oK05CQ2hnSkh6T2ZwOXZ2cTFOYksxSC9hRzRtdnh1NlBIVDM5bU1vWDlpZnNmNzZaRFkrejdLY3BrdDlYcFNhaXl3UkZpcU9Hd29qQStVZm1VT1NQWWNlZEY1VjRXekRUSGlIbVdSdjJwZXRmQnJjKytPWEc1SktVQldPUWFjeHp1Zkw3ME1adXpPMjF1VUlDdFdtRk5PTm50ZGNUbGF2dmtuUVh1dXRSN1NucWF0VUxWR2FXUVl5em5zSDIwM3ZVcGZsVXZXenFWYTllczZQU1c3ZHBKaFFQZ3FVR1Z2cUt1NHFmVjVXbzg1VVR4NEEwc1ZzMi9RbmxWUjZ0c3RKY1NWRUxrOXlpdlA1VXBTUGI2a25RdXd5SkttMXVUTWsvOEFVbjh4UjNqSnRodHBwdUEybHRXM01nREk3WkkzODgxWGtia0Y2RzJaelNtL1VUM3Q5Nk1CWU9jRWZialVWVjVrK3R4eWlrVXQ1d25nclFnblJWc0d5TG0zWG9qTnQzQkRwYWFYQ3FDM21IVXdFTlBLS2dCMnFXa1pLQmpoUCtlaS9GMkwyN3RLWEhwVjNYazdTSURzRlRpWmNLa2VzVXI3ZmtiN0FvSDVqeDNldzUwWmx6NFVCWE13Z3E3OWhTNWJiSmZyM0dLYmc2RUE1eHA4UngxOHFUdTEzcmpzKzVZaytkVFpERFlYOHhXMlFNSFRDMi91WkdndzBQc1NnM2tEQktzNS93RFRVUHVhS2JTNGk0amo3TWhwSVBZdkhPTTRHUWVSb09WU3UxZWxQSmVnNVhHV3ZIcCtjSDZhaWRaUnhDbEsxSjVTUHpxZUhKWDdPdWR0RHBkUW81OHgwK2xOTGFQVUhWTElxQ2F2YmxWQndDWFBVQVVPZllnNkcyNys5azY0SlVtb1NIeDN2dUZhempISjg4YXBGbnQzeGRyUVRFcDN3ckpQTDczR2YwSHZwbFB3NnZ3MnFyMW5kWHRwN1UxK3F5VjByNDFOUXVSeHRHRXQwOWtoeDNKOXU0QUlIM1hxcXhib1VXUWxEeXdjYkRlaXQwNHB1azYwT1M0N1JDU01sUitIVDU2bXRmdjlIUjZOSGRoK2lSbmVDL0tSNmR4Ym1xK1BMYnpmYTR6U3hrUjJ6N2p2NWN4OUNuVElieWIvQUhUSHNkdWpUN1FwVmp5YnAzQ2Zqb2FwMXNXYlJETnFERFFPVWxZVDhrWkdlZTVaVDlmR2lyZDkzMlZzemIxSm9DN2RxU0tlV1V3NFRGRm83ajdjVmx0QVNrS0xZdzJrSkFBSjg2WHpaK1hWTmdHTGhiMi9zdWhWK3JYUGNFbW96N29yMXhxcHlua3JWL0tiZVNxT3QzRGFNSjdVOGNjYVlHUmpLa2pUeXJtaTZTbXA4ck1oUUt0eVRqVHRqT2xTTnhYUGNObTI3VmQ2OTFlbUIrZ1VPa3BYVnB6MHU4SXFwTFNVWlVwYTJQbVNTTWs5aFYrYkdPY2Era2RWTzFGWTZnb20yZTJWRHZTN3JtZnRscXB5NDlCZ05Pc1VLRTRBcEFrcmNVRXhuSEFSOHBQZXJHTWFFL1doc3oxamRVTk1vVmd4ZDFiWmxVK3BWWnRjMmtVSklZb05KU2c5NlpVNVR5dmlxbXBCQUtHQUVORllTVkFqalZac0hwdzJMNkM3U3ZHa2I3Mzd1VmRNeTRibE15bEtvdFpsSmtYaSs2MmxLV1MzRENlOS92Q2s5cWxKU2hCR0NBTlQ4d0tmajNQVFdxTGNlTDRuL0ZqbEdwTzVKOHFjMjM5K05yYXBUSjd0UXVsRk9lcEU5cUZWb2xhZFN3L0RrdVk5Tmx3RTRDMTVIYVA2czhhc2sxTFNrRkpTbnRVZnk4WU9zM2QzdG1MOXQyaFc5Vjk4OW02UFlWRnJWOTB6L1V5MDZKWDByWnR4SWREMGlmUEFCY25WRXRObEpkV3RTRys0cFQvaTF5MzExczduWFYxTjNSdVhaajYyS2FhQWFEYWNaY2x3b3B6WHFGVHM5YWNoSzVMbUFFOEhzU1BPVG9aTGtSSWFPWnhWRzQwYVkrNkV0cC9USHJUcTlSTnVkTTFFc3VYYzI5dGtXN0tpTnRrSmJuVTFwYmo2aU9HMEp4bFNpZllheTl1YlpXM0xsdUdkWDdYczlpaVU2WEtXNUNwTUtLQTFGYUtqMm9TQjQ0L3p6cSsxbTU3K3ZWNWlzN2gzdE9yVDdUWWFqR2U2VmxLUjlCNFQ5eU9UNzYvRE1xS2ZsUlYyV3dCd2dFOGFRcnBkeE1XQTJuQ1IrWnA0dHNWeUUxaFN5U2ZwOHF5dnIyM25VWFVaRVczckwyY3JkU216RmhERVdueHZXY0tqN0ZLTWtmcWVCcDR2dzR2d2E5eDdiYWs3MzlaOFZxbHZ2ZWtZVnJvbUF2dU41eVV2T05raGxQMVNDVkhPUGw4NmRmcGwyLzJtMlAyamkxQ2dwWXFWYW5SMC93QVNxYjZPMVJYams4OGhJT1FsUDduazZJdXlWclZiZi9jNkxhQzZnODVBYVVaRlhkYUdFSWpweGtjZTU0U1Byay9UU00veHRjYjA2aXp3R2tndWtBcVRrbkJQZm9PcHE1YzErNnZLZThRNFQzMkhjK3RXQjNvdDI4M1UyWW84NnAzQWl5NFQwOUtiWW9rTmdJaHlHa2c0OVpLQjNoQ3UwcUxubEtSbFI1MEdhOXNyRjZRa1AyaS9GZ1U2SzhsZnBUSW9QKzhBcUtzdFArVnBKT01ISDBJem5UcVYrKzlrYmczc1JzTlNiK3AvK3VOTnA2SFlWR1lwemp6c0pncEpiYVNRbjBVZHdRY0lVc0tXcEpPRmRnQThyNzJzbzFXdEduV0RlRnNJcTFQZkQwZFZ1TFlTR1k2VmdxQlVGZnpVdnFXVkxMcVNWSnlFZ2NrblNyejdJcmJjYksyd3c0VzNralZYUlIvOGgrdFpWRzQ0bXhaaXk2bm1aSjBJUG5pczFkd09vRDRpTTgyKzg3NkRLVTQ3R0FGS0EvcHduejlTZEJPNjdyTlZjY21TWFN0RHFWS0gvbHdmYno0MDF2V0QrSFJlZHF4M2JuNmJHNWR6VXhrUFB5cmNTVXVWS250c3VkamlnbFAvQU9jTkpVZTN1VHlQSkdNYVUyOWVudmU5cVlpb1AwR01hZWdFVEcyNXc5ZEtRQ2V6MHpqaytQSjg2dzUvZ3VWdzFNOEthQWs1UHhaME9PeHA5aTNPSmMyUTZ5b0VVUjYybnBxdHFpVzF0M0l0cUxPdWFyMDlxUzY2NnR4OTVwZnA5NU9VSHRZUU9RblBuSHVkVGUyVkVuYmcxZFZGa1ZGeVBTNFlBbVZKWUt2UmF6K1ZQSHpMUGdEOXpvWmRPTnVLbVhTNWJ0VVQ4UE1udmV0VjNYUmhZVi9oeVRudEF3a0RPQUI5OVBUWlZxYlFXRmFiaUZ4bVZyVUVMUlZGeEZkc1lJNVgycFFjTFVRY0FxQjk4WTB2eW96RWk2cGhwY3dNYXJXZmhIWElINUFkZDZzcVliZlNIRmpUT3czTlVtNU54OXNyZHRKdXd0dm9EY2FQRWJLR2dvZHFsZTVVby8xS0p5VHBhOXc3bW9sTXEwMnVVWm1NekxxajdTS2k1MmR5NUNVQWhJS2llTURPQU9CazYvMjhWK29wOTQxYXBVZGt0UkZ6WEYwNWhUaFY2YVNUd1Q3bkgvWFMzYm9YOVg1bFppVW1teUQ2amozcUZYbE9BQ28vOU5mYkx3Ni9KbXFQaVpCMEo2RUQ5TkFkYXR6L0FBMllRVWthZmF0SkxPM1BzMUZJYXFLM1hISTh5SWowd25DMDlxVWpPVTUwSXQ4dHphTGN6emxOb1RUNkVCOUk5UmVBT3oyNCt1bFkyZjZ0WWRyTk83ZVg3VTBNTXBXVnhYblhBTzFLdllFK05YdXEzNUF1WktZbGx5MFRuWktlOEtZZEM4RC9BQkt4KzJwUC9TMXhoU1F3cHZtR2NwT08vblFSbDV5VzhFTkRKVWNWV3VvYS93QXRzR2I2NEJaWkRLRkhHZUJ3by9mUXM2ZU4yS0RIcnRRbDF1ck5JRHJnYkdWWTd1UHJxM2JoVzg2MjhsKzQ2UWlZR3ZuZlErZ2xLY0hINWZjL2JublVhN3ViWUZvVTlUMVpwTUZsTGFFaEVYNFpDUWxQM0FIQi93QTlQME9FaVBiREY4SlNsSzAwcHhjNE91QVlDblZnSGZ1YUs5MDcyeTdTdDltRlRLK0VpYXB0TExNZFk3bkZwVUZJSC8ya1p6L2ZRYjNkMnd2bTZLbXU0YXZrdnVvK0pDd3ZLaDNjak9jbkpPZ0pjWFUxVEd0N1dyamhVb0dNMjhHMklpSEQ2ZU1nWkNUNEp4N2FmcmJ5em90eTBabStiMm50eFZTWXlIa3dVdWR4WitYSUN1TUUvYjIwek4yR1paNExhbEtPZHdEMHp2Z2ZlalBDTmlqTnVrcUFjY0J3VHZ5OXZtYVRTcWROTnkxOUNuTGhLbWtQREFRcHZ1S2dmZms0R29XbDlHdTMxcVZScXYxZWNweW5vWDNWR0pNUWhmY2xQT1VIR1VuOUQ5dE5kdUJJalVJeVZ3RkxsUE9Kd0dneVNHODV4bFF5Qm5RcXV1eHJ1dXVnQ0pNcWNDbnkzbTE0YmRkSmJTRDdGZUIrNUExZGhYbTlvMEI1RVpIMC9uV21xOTJhd3kxcFE0bkswaklPTmo2ajdWeC83UTdFdUdSNkZ0eDQ0Z0JvTnc0eWtEdWJTTWo1c2pKUGsvdjQ0MERPb0dYUm1LOFlWSWlPTVJWSXlGZHZhSFhUeW9qN2FyVGxWdVBadmRENFc2NGJxVU1TdTRQUjNjdE9veGc5aXZCMTdiMDdvV3RlOGlPMWJianFZVWRnRmJrbjg3ajJPU0IvU2tEQUg2YWZJMXJhNXhJU2M1d2ROUnIxcFBjdkhJQ3drN1pHdWhHS0hGdzFVeWtKcHNPT3QxeDA5cUVJVGtrKzJBUHZwbE9qYWcxelpha0M1TDNwWHdicnFWcllhY2RTbGZ6SndGRWVVNEh0NTEwZE9PeFcyRnNXc3h1ZHVaUGIvaXM1SU1DSXRYYjZJVnlrRFA4QVVVL01UOU5TVi8zWFp5aVlOdk1LbkpTMjRYSktWNERYSEhHT1JualhpNXpuQ2tSMkU2YmttcVZyaUphbEttUHJ5ckJTRWpvRGpmeisxUSs2Ty82b0tURmlTQVlVaVZtVVFydTcwSFBQYVR3ZmYzMEtIcW5Idm05R3FEWlVWY3VSS1hoS1VONCtZbmtuNkRISjE1Ynd4NU5LZWpXakdoSStJY2pOUHkxQlBjNnQ1MGR3Ung0d2twQVNQK3Vtbi9EeDZSNmpZVkllM1EzYnR4Y0dvVDNEOEJUNXFPMTRNZ0RDbElQS01xNXdjRTRIR3EwcDYyV08yS2xQcUFKMjh6NlZLelBuM0dmNExRSVJyblBUSDcxNmJjOUhvbzFFYW5waEJNMUxTWEhKRXBQY3R4UjU3Z1A2UjV4OU5EUzdyZ3ZUYkc5a3ZVVlNtWkNaZVhVT09GYmIyRCtVcDk4LzM5OU5OZWU1MUdxMU9yY0dHM0tnc3hKUzQ2SmFIRk5yZUtSaFNnb2VCbklHT2VPUU02RS9UdDB5eUwzM1NaM0UzQWlTb3R0MDlmcnhuSFhGRjZZOEZaYklKeW9vejh4UDlYQUhrblNFeGZFT0YrVE9PRUo2SzY5Z1BNOXFZRnJDbStSa2E5RHNSVERiVmRQRHgyempiNmJzVzJxTFVYMkdwVktvNnpsRU1xeGhhL2Nyd2NnSGhPUm5ud1RvRndNU2FUMlFKUFlmQ2xBY1ovNzZndXFQZVc0cXpzU2kzN0lxSzQ4dGFnbjQ1eGpJU2dxK2JDUHFRTUQySE9sNXQvcUNxaUpjZCtQY3NSYnFNdFZTbnZLN083ajVYVWV3VmtZSSsvR2tXTzNJdXFDK2pHQW80VDJIU3YwcWE4MlFITW5JQXozcGtyaEtXNFBxemFnbGZlQ2ZtNHgvN2FYdmVlNkdHMzFGTWhKUzBGZk9uakNmMzE1WE4xRjA1VUJYOFdxNGFIYWNJN3VCOXRCbTZOeWE3dXZWMDJYdFZRcE5SbVNGZHE1S1d6NmJLZnFWZUJxN2FyTEpjbStPdEhLa2FrblFBZVpxT1JPWmJqOHFqblBUclI0c0Nzb2lWVTBxaHVOT3JibzhGK1U2Zm5XbDU5cjFIR2lTY0R0eW54NHpvcDB5b1VPRlFXMVZTcGVrOHJ6aEdRaytNblVaMHBkRHQ3V3hicmMyNHk2aDZRMmt1OXdJU2YyUHpLL1U0MVl0eWVocS9wa2x5dFU3Y2RDdlRRU3pTVklkakpLajlWcEp6eHhnakdoTnc0cnNydDdMYUpLQWxKMDB6bkZEVzJQRGhoSEtlWTZtcnQrR2QxRDdFZjhBNVg5YjZmOEFmUGRla1dSRWhSbUpVR1RjRlVhaU5WOHJVUFRZaXVLSUhkZ2tLS2lNWTR5VHJiT2lPVXMwbU05UkZzTGdxYVNJamtWU1ZNbEFBQ2V4U1NVa1kraDEvTGJ1UjBSYjRkUysrZEwyWm8xby93QU9xMU9aOVNiVktrU1k3Y0pSNWRVcElQY2p1d0VoT1NWSEFBNXhwMytIMTBVN2lkRGRIWlZhZlU5dUZVSGdnZXRTbksycG1qazQvcGhFclRnZU9UbldwM1QybjhMOE4yMXBjdHptV1VqNFVBcU9PK213UG5XY0o0TnZjK1c1eUp3M244UjAzNmVlSzBuNmlLeGZkQ3NCaTR0djY2SVRsTnJzQ1ZXVXBjWmJjazB4dDRLbFIyMVBBb1M0NGpBR2NaQUlCU1NGQWEzL0FOYzRqUnBNVGErMmY5NmNZWDhKVWFxVDZUYnBCN1ZxWlFjclNEaktTc1p4akl6blF4dURjdmNEZDExcWdYbmVUcTRVZDlSVEZiWVEybDF6R0FWZG9HUW5ralB2cmdlb0ZLcHNSK0lxbk9QT0FkalR4WGpuMjRBNTFpL0dmdDN2TXQxS2VHMDhxTWFxVU1xenVkTmNVODJIMmZXMkszelhRYzZ6c0VuQXgzenBtcFhaRGZtbjdNYk8wZlplM2JwYXA5UWJkblRhcGQ5enRDUTNMblNYMXlYVkpaYXdpTWh4NTFlQWZrWmJBU2tLUE9qejFGZFdtd0hTaHNuSTMrM3czRWowNmdOTXRtTzR5bjFINm0rdEFMY2VJeUQzdk91ZjBvSGdIS2lrQW5TUWJsVzY0bGhicnJCUU9jS0tkRFhaemE3L0FHcTljZGc3bmJtazNuVDdBb1V0dWgyZlhweW5XbzcvQUhwVTFKZ01yVUdTOGtxVXBmcWNkcU80ZHlrcFNHajJhKzEyZGZKSHVONkFEaC9Db0RseWV4SGV2WEYvczRpeFludnRzSjVSK0pKT2ZtS09HMm5ScHVmK0l4dmhUL3hFZXV2WldCU2FSYjlPV3JaclpDY0Vlc1d4bDFtWlduaUQzT0xWMkVNWTdFY0Vwd01Lc080TWpyd2UzU3RDb1g2aThxREdrdnVUcDd0cnMveGR4TWhsS1V0VXFCVG9aRU9LeTRweFJNaWU2NnBTR0Nwd3NqNUMxc3ZlbXg3VlNWWFRkTWFPc0hsS25DcGFqOWUwWlYvbG9iOVMvWHR0L3RCczdVN3YyOGp1M0hYK3dNMGlqSml1cFFwMVhoMThrRERDUHpLUGs0Q1J5ckkyWjNpN2g5aktYSktBb0Q4SlVNL1ROWmsxWkxxOG9KU3dvZzZBNE9OYVRMOFcvd0RGR3IzNFovVDA1dFpTcittMWpmZS9Hdmk2TEdxTlhSVW5iRXB5bWcxOFk2K0VwUzVKVVFwU0VoS1dpOFZMUW4wbWtsWDg3TWh1dFhmYzY1VllxRHNtZFVKaW5aRTJjOFZMZmRXcnVXNDRzNUpVU1NwU2xlZVRwM2Z4RDluYiszaXVTczcrM2xYSmxZdTZzU0Z5NnJVWHlWS2txK2dUNFNFcEhhaEF3RXBBU01BYVNkdHRLSnkyWWtWOVVkdFJMUldwSUtsNEJDRkh3UGJJSDEwVXNGOWczeUVYNGh6ME9keFMvd0FWV2U0V2FRRzNob2RRZW4reFZvbzF2VDZZL0ZwOE9qdE8vR09xYmFVMnRTa3JXa253b2VmK25QMzFNMHV2YmdXbk5MMURXbUdvdEJLeXR3RXFBSE9RZWM1R1Q0QTE1MmRXbFVtdFFxM0JvN1I5Q1IzUE5ZVjJrWVNNZm1KVm5ueDVCUFBnaDEvdzdmdytLaHV2V3BHNk85OUJmUlIwT0tSUzZUUFlMUXFLU3J2QzFJVU1oa0U4RGp2UG5JQnlDNG80anRuRGR2Y21UeU9VZE9xajBBSFUvd0M2azRMczNFZDh1aVk5dldwUGRRSkFTQjFKRkxUdDF0TjFMYnRNZnhTME5zcXJXZmlsNVZNWmFLVURQL01vQkordm5Wd25kSHZXaGFEUDhVTzJNOWxLVm5Qb3lXbEw3UnpuQ0Y1L2JXeUZEMmxvVEVKdWxVK05IaU1SbSt4bHBsc0pTa0FZQUFIQUgyQTFXYjRzbURFZFZIQ1VxOGdrZVI5OWMzcjl2RWg2YVF4RVFsUG5rbkh5SUg1VjFuWmVEbkl6QVpWY25WcjY1d1I4c2cvZXNlNmp2dHV6dHpRWiszMS9VZkRNNHBTOHhYSXBVdENrK0NqMUJrRWZVSFFpdkNvMG1vdDl0Q2lxVXQ1d2QyRUFnRW5uR1BienJWemY3WUd4TjE2Sy9RTDB0MXFZaGFGQnA1YVBuYVAxU3J5TlpxOVNIVEhjdXhGM0tqVUZMMG1teVZLK0JmU3JCS3NuTFpCSTl2OEFwcmJPRE9QTGZ4WHlzcnloMGJBbklQb2YwTkozR2JIRkhDRWRjaHRDWG1jL0VjY3FnUFBHUjg2OU51cSttaVNrb2pQSlVXU0ZPbzcvQUpTQjdmcG9qMUcvN0czRG10LzZ3VUNlbVVzcGJiTUY5S0dtMCtEd2M1UDIwdGRIcTF3TGRTN0drb1NoRG1EMnB5a0hCeGtuZzQrbW04Nk9PZzdxQTNlaVI3M3Vhc0x0aWd1WWNqU0ZSZStWSlI5VzBLd0VnK3lsZnNEcGp1MXh0L0RUWmxUM2twYjgrdmtCdVQ2VU5zSEhhK0tTbUpIaUxEZy91U1FRUFU2WUZMbjFTMjlOdDI4Sk5xMHlncWp4MkZoTFpjVjNyV2c0K2RST01IR01EalVKYmUzMUpxODFobU5GOU5EVGFmVytKZUJEYXZwbkdDZis1NDFxYmVYNForek45TXBrWG1heFZKWVpEYmt0eWFHM0ZoSXdDUWhJQlAzME5ibS9DNDI1b05QY05nVm1xUW5FWjdFeUhROGduNzVBUCtlazFQdGs0UWxndE1yVW5YVEtjRDhpZnRUbEc0UG5Lbm9rU0RrY3VDTjhtbDIyL3dCbDdVcWxFS3FUVjFUWjVVZ1I0cVVCb0tUNVVjSzVWOUI0K3V0dS93QUdMcFRzemFIWVZHOUEyMVZSYTlka1pMU25aY292UHJodHFPRjVJQWJTNHY1Z2taNFNPZFpjOU1mUXp1MWZYVkRhZXlGU3A3Z3BkVHFQZE5yY1JLdlNhaU5EdmVVb2o4aDdSZ0Fua2thL29Cb3pOclduYjhLM0tLaHFMVDRFVkVlRXlDQUcybTBCS1FQMFNPVCs1MDVXaCtETlFKeUZaVDBPZFBXazcyaTNaMXRwTnJaTytwQTZEb1ByVWhQbE5RMlhKRHJoQ0VKeWUwOG42ZjhBcGpVWXFSU3FtNjlFVXloMVRPUFVTdHNFSUpHY2ZyanpvSmJrZFhsaldQZTdrS0JXRGNiSHFMZGtDbko3dzBwS1FsdGhLajhuYUZaVVZKejkvT3FHeitKRnQ3YjlRRXlzYlpWeHlTVUtUSmxNU0dzY3F5Y0k5OGNEUDIxUWM0OHNiYzhzR1FoT0RnNjBoSjRPdXJzYnhReVZaQXhwKzlNbldMTnNsMXBjcXAyL0FDVWdyY2VVeWxQYW4zSkl4Z2FFTmQzZjZPYWJXelRHTjVhQTFWbVduWFVRNmJYdzVKUWxJK2NoQ1NvcDhhVjc4VFByY3RQZlhZS0xZZXdqVjF5YS9VNmsyMjdBanZxaHR4Mi9jdTlwdzhGRWdkdWNEa25TK2JlOU9kdTlObHBOMjRZeVhya3VSQ1pOd1ZsYUFYRkp6a3R0bnlsb0s0QUg1dTBrNkpIaWhoUUttWEFvZE1IT2ZQNVZYVHdlaGFBWkRlRll5Y2pHUEwxb3Q5UW02ZHdkVHR5cG84VzQ1alZ0UUpEbjhJalNWQXVPZ2NLY1dyMkpIc1BialVEYTlsMEdqdXBaYWdxV0VBQXBTck9UNHo5OVQ5bzJiU1dxVzFHZ0tJV281VXBTUVZKSDArMmlMUnFEUjQxR2JrdTB2dmNhT0VyVTJDVHBla3FremwrSTRjazBWWmJqd21RMDBuQUZVdC9hNStxdE5tbjBJb1V2NWdWZXlmdWZBMUhUTmpsL0VxNzNXMG5QS2U3eHhveDA5RDlTYlU4MCtsbHMvTDZZd000MVVxMVRJNHFqL3JWUWQzZjgzOHhKNS92cU5NR1VyWWFWTDd5MXNEUVQyRDNWZzNQYUVPUE5VWFJKWVRsc0s4azhjZjhBdHAvOXVyVHJuVDMwL3NVbXhiaHRlaWJrMzBXakFjdTZjR1dZYkJXbEpjSVAvR0xEYXk1Nk9RWEZrSnlPVG9SZEVQUmJ0WnRiZE1HazI3RVJKcHREWlMvVTVNNTBQT3FjeGxEYTFISVNyUHprRHdrYzR6cDA2NVFiWDNGY1lwdFJueXo2TGFuR3hGa0FOTENzQTl5RkpLSFBBeGtISHRxeDdNdUUyclZMY255RWdaSkRlMlFEMTlhV09OSmNtVXdwbU5xVHFydGp0bXN6Yi8yVzI1c25kcCs1dHdycTNLcXRnV0xkMG1wVkszYjZrMTVoL2MydnBSZ3pZYW9UVGNVRDFDVzRzZFMxRndkMkNsdE9GSDNhbnFPNmdOcTQ3RUs5ZG5xZ21EQXBNT3JPSXVWYk1LUlFhYk1tZW1HSXpTWEhwVTRvS2tOTStzcEszRm9LajZhT3dLSnUvRFd4RzFWMDJ6WU4xYnpXN1RxdFZaVHliVHRhczFJSmRma3V0S2psMkxFQ2poN3RkVWxEaUFrZ3FWMjg1MEJ1b2ZZTGNhdjd0R3E3cGRRZDlSYlJwdG5UbXhWS2lZUk5IS3lsSlpnS2FhUXArYzR2MDBNL0VaVTMzTFVuQVFEcmVFT3RPa2pPYXh4MFNZN1FiV2dvT3dCL0Q2Zy9UMEZQSHRCQXRkbHVSY1ZzMWVETmFseDJ4QmRnclNRaU1TbzVHT1FGUGVxY25QY1FWWlBzT09yYm9Ic0RxaHBrbXEwZXFydG03RkpDWTlYaXM5MGVRckdBbVN5QU8vUC9BTlJPRmo3Z1kwbk5sN2c3L3dEVFZhMVFyZDFibVVhbnNYQmJjQzZGdVZHYysycWtVR21JTFNaVlI5RUpEVE1oYUkwZVBIWXd0OUk3VTlpZS91SUg0dUg0dU5HNlRmdzEzdDBMQ2VrVS9jVGNOci9WK3k0a3RrTnV4WmpyQ0Z5NW5hRHdJelR1VGpoTHpqYlo1U3JBbTdXcURkR0N6TFFGcFBmK2FldE1OcWtyYXdobktWYWZuV1h1N0c1TjQ3SWJvVjZrMHBjU2JNb2RXa1V4K2JCayt2R2NkYWNLRmRpeCtkR1VuR05VT3RmaW85VGNSMDIxT3JsTE1OUGNqMEJTVWRvQitwL01mNzZEV3d0dzN4Y3RCWUwwbVJOK0VjOVZMVWpLMHFVZktsNThxT0NmcWRRdTZkdVRwZGRNMmVvSk1sWlV0Q0U0N0Q5Tll5MXdyWldaYW0zbUFVN1pJenAwcnBpMldKaFVCSkpDbEVEMS93QVVVcXIxalh6ZThyNHFmTWdSVVo3Q2x1Q2NINzVKNDFDeDk2clJ1U1hVSkZYcXJVQ2ZEYkFhVTY3eThoWEI5SUQzejVIUEdnL1dhbkd0Nm5HSXBlQ2xCOU1mVS9YVVBzdmNTNTI2elFiWmlQcEtWRlNwTENWOWc4a3B6NFBIblJxTnd2YjBzTFd3M3loSTB4Z2Z6TlF2KzQydHhEYWdrcVVjWU9vOWNVd2M2Z1JhMUVEajdrVi81UXBKa3hVbGFnUm4zR29CRzk5UTJmWWZUYU1adUUrK2t0T3ZzTnBIY253Y0Q5TTQvd0E5UzlTcVVGMXAxMXAxY2pnaFRTVWtsWS9iUStwVnZEZkxlZWxiZlRJcmtLSUYrclZDNGtvSVlRZnlqUHVyZ2Z2blZlMk1xNXlYdndwMVBrQlY2Y3hDREtmZGtKQ2xhREF4cWZ0VElkT1Z6VkxleXg4MDZKTVRDYWVMWW4xSWw0cUpPU1VrOEtJT2ZzUHRxMTNSc1Z0SkJnTy94aTFVVmlTNk9YWjhsUitZKytFa0FEOUJvMFUyQnRkdGh0dkF0MmdSNGtaaGlBRXFEYmlVaENFK1FsSTVBUDhBZlM4N2s3eVcvY1VaNlRiTlJiZmo1Y1Q2blBCR1JnRDYvZlNuZGxYRjY0RXhVOGlNN2pUZno3MFFiVXA1aExBVnpLQTI5S1dicWUyMm9kdDNaUUx4dE9NeEdwbEprSWFWQVpUd0VwZDdsTDdqOHkvbUpCem5nRDJHbUcyNDZ6cVlnc1FKN0NGc0ZQWTUzcitVZ2UvMTBKNytwOUp2NjFYb2svNGhoVFRSYmFLRmpJL1krZWRMZFRwRjMwaS9HN0ZodXZ5NVM1YVdXRUpTUVhTb2dEQVA2NjBHMU11M1NBbERqbVhHZ2QrbzMxNzBIajNJY0p5VkIxczRlSTFIL1lhVm9CYnU0Yis0RkdmN0hFaVl5KzQvR2lGd0FMQ2xaengrWldBUFBzZFZ5OXIxbVZPR2lsSmpzSWVUSVVKRWRlZlVTMzJrNGJ3ZUNEZzhnNUdvUzBObDl3MjJhZFpWbGlUVUs1UFVrT0xZVmhMWUkrWWQ0NGJRbjNVZE1QYnZUN1pYU3haajFjcVZjYXFseFNXTVQ1OHRRRFRSVjViWkN2QXp4M0g1bGZZY2FYNzVNdDBYbEMwNVhzQU92K0tOdFRGc3RLV0ZibkkvV2tidjk2TFVINWR2WEZISzJua2todDFKR01lNHo0UDBPbDd1K2lUYmJyd2pzcVc5RExvTERvVCtZWi9LZnZwbGVzV3ZwcXR4dzYxR1dsYU1xYlc2M3lCakJDYytNRFVUMG9kSkYzZFdGeVZLdVUvc2lVbTJrdE96S3RNUVN5bFpKSWFBSDVsa0FuSHNCay9UVFpZN2cxQnRmdmp2d3Q0eVFlaDJwTzRwYUY0Q1BDR0hlWWFqcU91ZklVU3JVc2E4NzJvTnZXOUhwVHpzdVUwaGEyMjBBbnZlK1ZwR1Q0dzJncSt3Vm5HanovOEF3L3JUdHFndFRLelc1emxYQ0F0OTZHNGxNZEI0SmJDQ2s5NmVPU3J6OXRFN3BIMkhYQnQ5TjlYSTc2c2xxZklSVDFIaHN0QUpaUzRueDNaUWpHVDRQZGpSaHJObU15cVE1SG4xRkRpdzUzb0RLU0FNZU9UL0FKNnlqaUhpZHhMNUVWekE2bW1pRWhRaGhzamZPVDNwYk50dGdOakxZcmpsMFVXaXRydTlvS1VKbFRhOVp4UkF5VnRrNVNnbm5IYWtGSUFHZFRzRTFPNW4zSmM1VGpiRFRwQmtwVi94VGp3bjM4K1Qvbm5YM2VkdnphUFdYS2pTcEMybjQ3aHh6d1VuZ2pQMzFXSGJ2cW9XbGhEYTJrc3J3aEJXTzFJQitnOGZYOTlKL3ZFcWVvdlB1bHpHd0p6ajA4cWsvd0Q1MDhpVTR6MnFnYnlXeXphTFRVZWdMS29xSFM4L0VlY0t3UVY5eXVUNUdlU05GN3BtYmZ1TzJXcXZNbVBTcDAwS2VXQ3Y1R0dzK3c5Z0FBQm9ZYm9yWExncW16UXBLMW9WODZFandRZEZmb1VwMVJwdHJ4WVVTTXFkTmtSMEJBejh2YVJrSjQ4Z2ZUVXQva0tWdzJWbjhZVVBuVmRrbHVTT3dxeTczT3cycUEzRWFiK1FNNENGSXg0KzJrZC8yQVZyZURxQi9nMUdyYnROaUxmU3FaS2FPVkJCUGhJOEZSUHVlQnAxTitabDB1U1hKVlZocFNubHRBOTBqNkRQai84QUhRSGJwRlMydDNYcDlka3VKVkh1S2xKVzA0MlNBaGFGbktWSC9GZzU0NC90cVRnaVRNaVc5NXlPUnpsSngxMXFXOCtCSllRbGVtb29xUGRBdXlWbFcwaE02a3ZWR1FsQUtuNTAxVHExS3g1T1RnWlBzQUJ4b3Q5RFBUVlpEOWNmckM3YVliaVFYQWlLeWhvQkszUEpVcjY5dnQ5OVYxZCswMjRiZVloQnpLZzJFbFFQaysramQwMFY2SGJsZ3hZMFJvK29ISEF2QnpnOTV6bjZuUzl4VGQ3akZ0K0pEcWw4eHdkZStwMHFpMnkycE9FRFVVelZOdEszcWZFeWhrS3drY0FEL3dDSHhxajNaWkYwWDVYSWxuV05SRnpLcE9rQnFNeTJCbFJQc2Y4QUNCNUtqd2tET3BLeWJ4bjFXZTNUVUpkZWtTRnBiWllqbzdsT0tVY0JJQThuT09QdnB1dG45dDRHd0RETStSYVQ5YXZ1dnNFc3dXUUVvaU1aSGNsVHhIWTBrSEhlcmtrOEFIM0djQSt6WkhHOXlTNGtjcktUbFpIMkhtYVg3L3hFamg2UDRqbXF6b2tIcjUwcXFlZzdldlk2N2Y4QVdHK0owS1pBVkZiVENrMGR4UlFIQ01yYmNLa2hTTzFYajJWNSsydTJiYTFkanRPU1dwQ2lXaDgzODRralRSeDl4OXk2aElxUjNKaXduL2h3K3hLaFEzbTI3Y2lNcVhoRHIweHhKZWVkN2UzK1drQWhTaUFrY0hRcnZLeHFUWHJkazdtN1VQVFpsdXFsUHNLWEppTGJVMzZTK3hicUVyd3RjZjFBcEtYQ0JrcE9lT1MxZTFiMklUcmNrM0t5cVV0cEkxUm5KVGdianFSOXE4Y0VlMG1OZFNtSE01VXI2RWpHZGR2STB1dGR1S3UwS1FYNEV4WWRSOHlpVHdySjhFYThZM1UzVEp6aWFMZHlmaHBLRTViZGFYaEt1ZURydnYybHN3MXVTbEtLeW9aK1pYSDY2cHUwV3gxSXYrNkRmdDBSRXVSWUVwU2FaSGNHVUxXT0ZPS0g5UUI0Q1R4a0UrdzFnRm5jZHQ3cXl2S1ZnWTh5VHNLM0ZiVVZjWU9LR2dxeVhCY0ZSdVNuaHVpUTVFaHB3RWxhMFlTZnBnblZKc214cnRrYnpVV3NQMUp5a00weDB5VXZCMEpYSWR4Mm9hU3JQamtxVjdrY2UranZVcllndEJUWGZqdEF3QVBQNmFHKzVFR1A4TThrSnhnRXBXUFBkcWsxZVp5Wnh5T1ZSMEI2ak9tUjVpckxMemNxS3BoSTBQZWpremJGT2VocCtLZlV0NHBKVzZ0V1NwWDF5ZkoxUWR4cUNoVVY1dVF5RnBUbklWNHhvUDJiMUpYTGFWVUZ0WEZVUzgyakhvT3VuSktmSGFUKzJwN2NucUFiZXQ1OStrTWw1MWJSS1d1MDVWZ1o4RDc2b3lMTFBUY1VyYnllWTdrNXpucm1naUlVcUt2ZktmdDZVdHZVOWJkdTBGcVNsK0szOEFWS1U2Mkc4K21lZVJySkRxSm9WR3RMZXVmSHBDRnBwTWwzMTIwRVlRMnRYS2dQWlBqUEgyMXFWdTdlRnpiZ1dwTHBsU2h3MktuVW95MjJtSkQvQUdwYWNVZmw3MUh4N2FSRyt2dzRlc3E2cjhjbVRkdWxUMFBPZi9uTUdvSUxDVWNZNVVvZjlNblhYWHNpbVJySzA1L1VKS1VhWXdwUUdmTVowT085SVBIMWdsM2lNMEk3QlhrOUFUaW5lL0NHNkFyTHFGbnd1by9kSzJtYWhVYWtoVXUzNFV0anVaaFJ2YVF0SkdDNnJIeTVIQ1NNY25UY1VpNFdFeTNhcTVJYmJTODh0VFlLdUNNa0QvTDJHb2ZwOXY4QWdiU2JRMDZ4WjhVeFhZMUhaaWxwYUNFcEtXZ2o4dzQ0eDdhczloV2RSMzRyVTZDdHVRejJqMDNQVTc4OGU1K3V1ZStNNzdOdmw0a3paYTFGSVVRZ2RBa0U0eDArZlU2MXB2Q3RpWjRaZ2VBaHZsR0JyalVucm1wTmkvYVFsSHFPSmxFandwdG4vd0JkVjJ2M3BhbFFLMjI2a3BwNWZoRWxIWVZuNkErTTZ0RmN0dGlPMTNIQnlPU2p4K21ocmZOdlFseDNSTFlCSHVNZWRMa0NSRGt1RG1iSHFONlptR2txSE8yYWlibllhZTlWQzhGUUJKenBQT3UyMTJyd3NHWkFwN1NWU1VOTGRTNTJnbHRRQjVIN1owWnI1dXk0clVjTk9ka09Pd2lTRzNWcUpVMzlpZmY5ZEJQZldvWFBkY1dIdDlhVk8rSXFkZWtKaXNMOVRJYkN2ekxJSFBhQjUxcjNCVUorRGRHcENGREFPUWM0QUExSlBvS3BYenc1OXFlWmNUa0ZKQkhmU2duK0ZyMHR3ZCtOM0c2aGNjb1Q3ZHRqL2VaRVVJSUQ4bFJBUTJwSjR3Q01uNmhPTmJJV1RhTkxqUkVSeEdTaHRwQVNFb0dBQVBBQSttbHA2VGRockM2VGJiRnBXcEd6Sm1KUklxazA4bVU5akJVZjhJSHNrZUJwZ2FOdWhRNGFPeDZZeTBTUnlzRVkvd0F0TDN0UzRsa2NYY1FsYkpKam8wUVB1Y0R1Znl4U3B3ZHd1bmhpeStDbElEaXRWRWRUMCtncVl2U0JCZ1JmV2pvU2hTRW5uNjZwNnFJaXBJVzdtTWt5dTBNTUxmU0hPOCtSMi8wNTlzNHpuVTNlRnlwck5ETFZJcXNlU3BaK1Z0cEhmbi8wL2ZVQmJEYjFNcnFhaFE0YmprOG9kVzVVS24yT0pqdXU4SDBta2dKeUUvS0ZLSGNQT2M2cDhHV2JoTmJNaGQ3a3FiNVU1UUJ1bzl1dTFFTGpQdlVaTGFZYmZOazRKUFFmenJVUEZ1NnM3RTNiRnZHM0pCUTR5NEVQb1FjQnhHZm1TUi8yMFlkemQ5Szd2TzFGb0ZKbVB4cUg2U1hIMG95aHlXc3A1U28rUTJQSGIvVWZQR2dEdVErekt1S0JRWEp5WEZLa0lTVWtBY0R5Zjh0RVd6YWwydm9TMlFPQWtESCtXdnErSjcxQXNQOEFUbUhTRzNEbnp4MkhiUFd2ayt4UUg1YUp6cUI0Z0h5OWZYdFUvVDdGaS9DRXFhUWdCUENjZTMzMVJOeUxacEVkdGFGTm9KR2NmTC84eG93eEk2cE1MMDFyN2xLVHpqMk9oWHZLNVNvRk1mZWlUMjNWSXlGZWs0RmRxdm9jY2FGd09HYnk0RlMwNUtFNm5jNDlUVkYyNE5OdkJvcUdUb0JwUzMzN0ZSR2tyK0dVVXJTckxhd2NFSDlkVDlpVkdWZTBobXFYSFhuWnRRREliVTQ2dnVQYWdkcUVmWUFhb0c3ZDJvb1NtWG56M3VTbmV4cHJ1d1Q5VHEwOUtWcWJsN3hiajAzYjJ3YUVYcGs1NVFsTFJ5M0VRbmxUaml2WUFmM1BHdHU0R2l6blhrSlJrODJ3N21sZml4K00zR0JWZ0ViK1FvOTdWN1hiajdrM0JIdHF3NktYbmdrS2NjQndoQStxMWV3MWQ3bnB0NmJRVmdXcHVIYlRrVjNzUHBMVUNwcDM3aFFHRCttblAyVzJqcy9wNjIvYnBNVmJmckphQ3FwVWxKd3A5ZU9UOVFCN0RYSHVuUnJSM2t0eDIzYm9zU295WURveTFQU3lrRnBSNDcwODkzMDEwS2poMXRxS09kWC9BQy9sNlZpSDljY2tTU1VvL3dDTWRldnIvaWxEb0ROcFZhbG4wS2twRHhVcGJnVXJCSjl3UHQ5dFZLcWJGVUtzVkI2cC9DOXZyTEtzSmxxQS90cWYzajZlTHY2ZTY2dDJvdnZ6S0srdi9jSjdTY0FBK0VySDlLdjExWFdOeUpFTnBNVm1wUHBTZ1lBQUJ4cW1nSWprb2VHRFJBOHpnQzJWY3dORjYyZHphWHRWdHRUTE50K09pb3pxd2xUVHprWnIxTXVxQTduU2taN2tnY0Q2WXllQWRGYTZPcURiSHBrNmRLcDFGNzZWNWNhaVdyU2xLVlVIbVZOdnpDVWdCRExTc0VxZGNBUTJrakp4azRHc1ZPbC9xUDNUNmVOdzIwVUM3WGpFVzhTMVRaYXZWWlc1akhhQ3Jsc3FIeTVCR002S082Ky9PK1A0anZXWHM3dFp1UHRtN0kyanBGd3V6cXJSNlZPTGFWejJrOTNkVVZPZmtTMm5oUDhBU3Z1VjI4bkdvZUg3bkJjQWJiUEx5cDBIWWVScDM0cTRJbVdqbFpkVGxLanFzZnQwcHIvdytOb1ltNG02VjVmamtkYWxtdzdhbjErTDY5aFc4NmhUcXFEU1VKRFRVbFhlU1Z5bkVsS0VrQUFGWklBeUNHSHFuVzd0cnVCZDFRczI2TnRHNmhUMlVRMkpVMmd6MktzbW55WkVnTXN4cHppQ0kzcWtxQjlKbHgxeEp5a1pVRlkrK3B5MjYzdTVzVkwyZHM2OG1yYW9OUkRjVzVuNGROOWVVS0dsSitKandrRGhENjBBTnBWZzlvSndPN0JBeS9ENTZOcUhSTHZHL3dCYzFrenJVdDZueTBxMm4yalZNVXFMYmJUVFB3NmFpK3lQbFZVWFVCU2lvZytsNmlnQ0NTUzNSNUMyM0V0cDNPdWVuK3F6T2Zib2syTXRibUFoT2dTUjAvVlJQOHhWazZydWdhMzk2cnNxOVZybDV2d3Bxb3laVXhtcnlnNVRwSHdvd3pMY1FVNFg4RXo2cTJtamx2dUNEMmdoYWpnditObjFjcjZ3ZXArbDE2d0V5V2JCdENuZndPd0tRdHd1TFloTnE3MVNYVC9VL0lkSzNscjhrcUdmR3R1L3hkT3E2azFEYmFyOUxHMXFwRWl0MWFHcUpkVlVoUGVrbUJCWGd1dy9VOWx1akNWaEp5bENpUEtzYXhJM2dvdEt0eEw4YW1NVTVEYlN1MVRiRElBYklPRDkxZnJyM2RMMFl6NkFrWjdqL05EdUdlRkpFaFhPdGZLZ0hLZTUvd0JWV05pdDA3VnNHelFhcSs0aFpBUGFnOXFpZkpHVDQxOGJpNzZiYjE2bFNHSVZNVTFJVXNyTWhhc3AvVEdxL3RSU0xZdmZjUk51WGxWSElsT0tWdXlWSVNDcFdNWVFuUGpPZlB0alZnNmllalMzYllvU3JudHlmT0ZQY2JTNDFVSUNTNHduL0VIRUhsT01qeHBlOFdLSkFiZkpITjVaclJaSEViVnJsaUtuVnpHbXVBZTJ0QjZKRHF1OW00VUswcmJVUzQrVW9kZEE0UW54M0g5dE11MzBoMnh0YkdZcE5DU3hOcVJiQmZsTkR2V0NmT1ZmOWhvQ2RLMWR0VGJEYzU2UFZhMnpJVjNBTlRHMEhzS0RqL0VPUDMwNkZaa05mQmk1YmJtZDZaTGZENkZkMkVrZU5mcjhtWWhJWmpFaElIMTg2TTJGOWlRRExrNDhSUk9jNFBML0FPSTdldEJLb1hCL3M2bUxhY2dvRHpRS1hGT2ovb1BiNjUxTDdXVzljbTVWVk80RlRuQ0JTb2dKVElMV0Z1NDlnUnoyNXgrcDFFdFdZOXZSdWxHczVtZDZjWDFQVXFNa25sS0I1QVBzVDRINjZMdTVGY29WbjA2RnQvYmtRTlE0YUFQa0dFNVNPRG4zSEgvZlFscUNscU9YWEJsV0tQS2VUSm1JYWJHLzJxaGJubCtuQkUxbXJPS2tkcWgzTXVxK1VaL3ErK2h2YWQ0VlZ1NG5LUldaWWRSSUNsc0VqOGl3TTRIMkl6b3pXTjA5Ym9iNFVkZFJwY0F3NmM2NS93RDFpb2tvYUo5K3dmbWM5L3lqSDMxYUdlai9BR1YydktLMWVWVGxYTk9ZT1VzcVY4TkZRUU1ma1FlNVkvVlEwdkx2TnRpSVV6SlhsUjZBWlA4QWlqOGxjU0lFcWFBNWgyb0JWYXZ5cXZLRUNHbGJqcnkwb1laWlFWTGNVZUFPMGVTVDlOSC9BS2IrZ1RjbVM1L3JqdkNJZENpT3pXcFVlbnR0QmM5eHRDZUcxcjhNcEpQS2VWZnByaDZmN2gyeHR2cWNqdldwYWNHT3BjWlNmWHgzQ0NRUi9NYXpudFVmQkk5aWNZNTA5dDIzWGJjNm10SW9nYWRVdHZoQXg4M0hzQjlkQ3JyZnBFSnRMTU5CQ2xBSEozR2FYMzBzM0I4TGNHUUQrZmV2UGIyblFObXJBc3paZlpUbzNpYm0zNXZiZWMyTGIxUC9BSTBhYzVDcDlMakpjbVRQakRrTllMdzVYbEh5QUVFNEdxRitJVjBaWGZZOXNVZmVxaWQ5VmkxdTNXcWhIdCtzZy94YWhzbEpMeVpFRUhKTFN1OEtlU2tvT0FTVWhReWUrcFNwZElPMWUxb3Mzcmt1S3QyUzV0RHRwVExoc1NwV1hka3FqMXk1WGEwMUtkcU1OdDVqNWl3WkxFYU9wS0NDQ01yT0NuUXYvQkkzdDM5Nnorb21UMWxicVZXbjdnM0ZiblR6VktMUWJLTTlwVXhyc214SWpic3g1d1laa1R5aDdLbGpsbGxLdm1DaU5hOUg0UGhUYkt3WkF3OEVqNCtwSjFPZTRyQkhPTDdneHhESktGY3pYT2NwSnlBQnNBT2gvd0IxbkpzWHRsWCtxRGV5UnRYU3FsR2JwS0lDNVZlZGx4VXJTR2g4cVJnWUFXVDRJeGpUVldnbXlPblN5MWRObHJXNDFEcFNuZlVibXNxUHF5SEZFQjFieHo4eXlrREI5Z01hWW01YmEyR3AvVVBmRG0yL1J0V05rcnZlcXRQcCs1TFZkdWVqUFc3RXFFcGhiOFJoTTFpUjJNUE9wQlBwQk9PNVNlN3NKR2xsNnQ2RFZhSmNzeWxWeWl5cVhWWUxpbTM0OHBzdE90THg0VWs4ajlmQjl0WnJ4bkR1Y0Y5dUl0SkRKeHIwSkhVMXJQREYydEY3aGwxcFE4UWRPcVIycHFiVWswTnEwNGJOSGpNcGpOUlVvWlFud0VBY0RVUE9xYkRrcjBXMmdmNVpPUXJqUVk2VU43WTllMitaZzFlZWoxV1NXOEZmUHluSDk4ZzZ1ODY5SVltQjB1SjdRdjhBbDQ4bldYWEczcWRjSVYrSVUyc1BoS2NWVnR6SlVkNmJKRWQ1dExpZUNrSHlmcG5RaWVxTGFMblhHbUlQYTZDcnR6emtmOThhSlY0MVdueUpFNm9yVWw0cmN5Z1k4Y2FDbHkxUjJMY1NYaEs3SGc1Z0t4d0NRZFIyeU1vclcxVXNnSlV3VnE2VllOemFhek90U1Q4TWhLQUdjcFRubk9QT2RFcm9YbjdnVm5ieWxUcUJSSlljWVIySmtKWUtBckdVOEtQQkdQcDc2cCt4MU5wVzVsNnhxRmRxMHlZVVZLWEppQndIam41RUhIdG5rL1hHdEZ0b0xlc21sVWlMQmh3a1Iya0lHRXN0QUpRa0RnQURnZjhBdnBXNDE0aVJaYlo3Z1d1ZHhSQ3M5QU52bm5ldlZ0dFlsTis4cko1UjBIV2xkM3oycDNJcWRzU0toVWJUa1BQQlpjQmFBVVFuNmNISk9oaHREMFNibWRTTFVPdTNYVzFXM2JWT3FDbklNdDlvcWxQZVVyYmFRckFDQ2Y2bGU0NEI1T243M0xwME55T0RUMW5zS2VSeGtmWTQwTnFIZWRkczJhS0xFYU11REprZ21NaHJ1V2xYc1VZOGZjZVAzMG8yVGpxNnMyNWJjUUpRczdIVTRIVVlPbWZ5OHFQSXNVYVN5Q29aeHJnMUdVTG9NMmx0K2xvamZ4bXRPRUl3Skxrd0EvVE9NWUdvWnZibVIwOEtsdFFiaG0xR2h5WkNYV2xPdDk3c04xWEdQbDVVaFhIM0IvWFRETXpaMVNvYkxMdHJzc3E3QjZqbmQ4NnYxK21tRzZPT2pWVHRVaTczYnJVOUswczRldCtqdkk3a2hYbE1sd0h5Ui9Rbi93Qzc2YXQ4QVczaXYyZzMzK25sd3VOSEJjVWRRa1ozejBQYkcvcFFlL1Q3UncxYlZTWkNRRmJJVDFKL20vYXBYb0Q2UkpXM2xCaTd2N3BVNGk0WnJBY3B0Tmt0ak5OYVVPRkxIczhvSG4vQURqeVRwaHI5ZXR0cTJKVWE1cm1GS2l2dEZEa3RNMUxDMEQzN1ZIMy9BTCtkRC9lN2ZtdTBXRGNWaTdWMEtUSXZLbXd3L1RhVk5aU3dhdmx2djdJVGpwRGJxOG5zeVNBazVKemprRFNPZ1RxcTZnS0didTZtdDdHS2ZLZUtIaFlOdXpIa3h5Z0hKank2bW4rY2MrQ1dFcFNENDdoenIrZ1hEZkRsdDRYdFRjR0dubFFuNms5U1QzcmsyOVh5ZGZwempnQVdkUWNuQ1UvK09OVHBSQm90V3M3ZENzVkduN2U3Z3ZWdCsya0thWFNZTUVOeDZaR2RCV2lZeTB2K1k5SVNsdFRhWCtRVnVjZU02bnRvcExkbnhwOHFSSGdRb3pFSnRpcU1TeVZpRDhxZmg0UGRuaERUYWlWcDVXNjg4cjNKd3RXLzZyQzZWN0xSRXBld20xZTBGYVlkUUtWdUpDM0VXN1VHSGM1OVJMVE1YNHVvazg0anVxVWx3bnRWd1NkRURwNDZobXVxVzl0d0tXMXNWY2RKcUZtUklWYnRlWFZxT3VuNFJOUzZsRW9SaVE0Skt3MjY4QXRJSzBGT0JnZ2xnVWdMUVFyWTB1cEFpeUVsaFhNc0E1eG5BMCtmeXlhcG5VRHNsVWI4dFM0TjB0amJicWZ3dE1xa2lDYVBVME5zeUtrNjIzM3Z1d21COHdRaFJLZlJQei9JckE0d1JMczNlVWNXRFNuNGJ5VXRyaE5xVUZESHpIODNuMzdzNXp6bmc2ZHB0TkJWYmxGVkx0c29oVXBaazJiU2EyMlk3cUhVQWwydHppNE85Z0pVdFNna2dLeXJ3VnVKQ1EvdS93Qk5DOXdiYXE5WHNLYzRhbmJkUGFlcTF3MXNzd21xOUplSlhqMGtoSVlkRFpRcnZWanY3MEJRN2lWYTVmOEFhejdFVTNKdFZ6NGVUeXZaNWxJR2dWNXA4L0w2VjBCd0I3VVNoRGRzdkNnVUhaZmJ5VjVkajA2ME01MTRVeGNYL2VaclFWOVVyUGQrdzBNZDNieXA4SzNwVWlQSUMxcGJKYWJLZVNmYkI5dFZpbzF5dVVLdXlyZHVabCtuem9qaGJsUTV5QzA0MHNmMHFTckJCLzY1NDFROTBMNG9zQmxhNmpXRUpaUUNwWUsrRkg2YTViYXRjdjN4TWVRZzg2VHJvYzZkRFhSckVaQ1d3NHlvRkt0ai9ONkhWdzNkV2F4YUF1Q1EwNG1hNDk4aktBVktHRllDUUJ5VC93QmRFQzB0dnR6cWhSdTZwcUVORDdZQ21wYXUxWkdQOEl5cjlqalY3MlMyelEzUkdMdXEwQks2bk1SNjBkSFp4RWJYeWxLZm9vakJKOGpPTldpNW93b2tMMUhpQXNPQWRnMFV1TjZRZytCSGEwQk92VDBIcDNva3pHUW9mR3JKOUtvbGg5T3R0MEY5VjAxK00zVXFtOG9MOVY5c2xwa0R3RzBLNHo5VkhuNlkwUVc3TlFtQVpLbTIwZHYwR2MvVDk5ZlZEcnoxUVY4TTcybEpBQ2UwOEE0MU56cVU2aUtHbXlRb3F6OWhrZWNhb094N3Rkd0hFckt6dGpiSHlxNFNZdUU2Q2g5ZEZIUXBDZzRuQUE5aHdkVWVOYzkxYlgxWVZtMlo2ZzBwZmEvRVVTVzNSOXg5ZnZvbjNpSkVGa29sSVFqc0dGQStmcG5RdnVWQm1OS1Iyamdubm5qVWthTklqTExFbE9teEJvNjIyMU5qOHFzR2liWTI2TWUvR2c2MjRHamorWWh4WEtGZlE2aTc3cTdjeDFUYkx5Rkp4NVI0T05DSzJHN3NtWG8zUXJQVXBQcnQ1bk9qOHJTUi9VZituM09OSEsydHRva1dNaGMxSzMzQW41MXVEa24vQU9lMm9yakV0ZHFTbFNSOFIxK1ZCM21seFpCVHNrVUJyOXRhdlYxbHhGUG9MOG9Lenlsdmo5TlFYVGYwM1ZDaTE2VGYyNU5TYlZWbjNWTjBxQVY0UkJqNXdDZjhUaXZKOWdPT2ROYkx0aUtoSVpReW5KVC9BRWp4cXQzSGFNUnRyTHlRQ0R3VWdhc1JlTG4vQUhGVVJvY29Yb1R1Y2VYYlBXdkhJMjZvTDdWN1VxeEdXWXhXZ0ZheW41VkE4SFhOVTdRZEk3WkRTQWsrd0hPcTBtNjZyYUxpL2dwaFNFcEtpeXBaS0ZnZlRQZzZuclYzWGpYQVcwdjA5ekxpdnpsUVYyL1hQMDBPVENuTEpXbFFJcjQ3S0NDY2lxdFhLSlY3ZFdxZlNaajhWWkJTU2xSR2MreCtvMVVxdHZqV0xXVTVTNnM5NmExSi93Q0w0eVB0b3Azelc0Y2lHbGhiWStkZnk0R2M2Vm5xUVJYTHNuS3RlMUtYSUVrSUsyWEN5UUNzbkFUM2ZUVEp3L0VSY253ektUZ2RTZW1PdEM1d0NtUEUwQnJodUxlcXYzTHVwUllkcXdKVlFrR2FrcVpqcEtsZG1jRW42QVp5VHBuYmNxRnhRbVVPdUlDRi9kWGRqVlc2V3VuT25iYTJteW1vU0c1TmJtdGhkVW5Kd1NWWXo2YWZvZ2VQdjUwYXFkYWRDYVJoN3U0OXg3SDZhZzRwdkZzRHlZMFZId3Q1SE4vMjEzOGgyNzFWanN2dWptZE85VmRHNkc0bEhlUk1qdk1rTitFclp5TkNtNDd1a1UxMmFpYkJEY2FRVm5zWnlFSUpPY1k5Z0NTZjc2TnRYcHRQWmJkV3B4Q0doNUtpT0Jxb1A3U1ZMY210eDdZcytsS3FFeW9QQnBobGtaN2lmK2crcDl0SE9FdUplSUkwZFVXTWdxWmVQS1J5NUJKN0hHNDlhSDNTMldaeFhpUFlTcEE1czV4Z0RYWHlvQ1UzYXVwZFNtODlGMi9zaWhTS3RVWklMVERjY0VlaVBkeFJIQ1VqeVZIeHJXN29oNktMRjZNTnJrMnRSUUp0Y24vejY3V25QbVc4NmVTaEJQSWJUNEE5L0oxNDlHSFJMWVBSNWFqOVg5QmlYY0ZUYkM2NVZuRWorVUIvNFRSUDVXeDcvVTg2Sk53bTV0eXFZOUJzaXFPMDJuTFFVaXJ0Y092SEdNTWs1N1U1L3JQN2ZYWFluQVBCd3NWdVE0Ly9BUElRTTUvdEhiMXJsZmp6aTlOMW5GcGpKYkd3RzZzZGZUMXFEM1Z2Mm5VcXZzV3RjTUo2REZVaEx6RldscC8zTjFZUExTeU9VbjlkZUUvZEM3SzNiaXBOcTB4dHlLaGZaSXFzQTk2RW8veE5nK2NEVitObTBtZmJEZHIzQkRUUGpwaXBaZjhBaXgzK3I4dUNUbnordWhQZVczRjk3TDI1SWliUHdVenFHNENIS0d0ZUZSRWs1VXBvL3B6alR2SWdwa0lVV2xjcXNmSlhwMk5Kc0s1dlFscEVoc0xRVkQvL0FBRHVUM3FPdHRWQ2sydFUyYitWTXJ6RmFkVW1QVEgyL1VkN0FjRlJIOUp6NHg0MHZ0eDlDMW5WbXVTcXBiZTRiOENDKzhWUjRVeGhSY1lIdWhSK3h5Tk1YdGl1MUs3VDZsSy8xb2RhVkhXRU9SMkNFUHB5T1VISXlNL2JYRkp0K29OeUZvZ3BwOGRudlBwc3ljS2NTUDhBbUo1SlBuOTlLYnFIV2tKUStuVWREdjhBT3REak93NUxxbkdGbkJ3Y2pRWThxL25Xdkt2WG5XSkxndHFKSGx6RzFmendzdUZ4SkhuS0VKd1AxenFPc1BmL0FIMTJWdjJOV0JhdEd1YU1pZkdmbTIzTWxQTWlVNGh4SzIwcVVoV2NoUVNjSDNBeVBJMHpDZHFyY3RpMm4zTE5wQ29zYU0wcHh4NXgwcmNjU2hKVVZxVXJ5ZU9CNEhzT05KNXN4U3R3TjRMeWpWU2JZOVhqVWNWUDFxaFZHb3kxSWJiU1N0UDg0Z3BUM0VESjk4NkR4N2V4YldRNEFuNGQ4NmZUcjlLYVUrMDlmRjB1UTA2bFlaQVBMeWs1eDNPbUJwMC9PdFl0dHZ4MHVscXF4WVZKM01yOHV4THJFa3RWKzNyaHByK2FmSkNpRk5lcWxQYitpbGxJQTg4Nmx1cWpyWjNTM0V0U0UxdHJkalZJdGlvdHFXeEtvTmFTdVZVMEpQOEF4VnVOSzdtMnMrRWdqT0QzWjhhejk2d3FlejFWMlhFcmxzN1kwdW1WYWpRaTFFcU1SSk1pb0pPZTlwNWVFaFkvd3FXQ29Ia3E1MHVld20vVzV2UmxmanRBdmF4NVV5alMyMUlkcFU1SzBCQlVqdDlWdjJVUmtFcEJ3U0JxcmRtWmw5dGl4YTNpbHhPNmR1WWRRQ2R2THZ0VlhnWGlUaDJ5OFJOTHU3U0hXVjdMMVBLZW5NbjErbFBIYzF6eUx4cFUxK1pkcjdkVWpoVGl2aVhjaWIzS0dlNVJQY1Y4bko1Si92cFBkeDYyeEZ1NlZSYWpGUkJkS3U5SmVkeWxhZmJDajVHam05YnU0MjQxTHAyNUZoV1hWMzRNbG9IRGtWYlFXMnJ5b0JXT1Fmb05CSHFzMjFsM0JiOGxxWFMzNHRVaElMc2REN1pTVGo4eVJuNjZBOEtYRjVxV0lrdDduQjBJSkJLRHQ2MXNIR3ZEMW9sSmVtV3BBUzRrY3dDZGxqR2RNZGQ5S0RyOTdPVzlmNkpjTnhwYW01Q1VwTFpDZzRDY0VESG5JNDB5ZGN1RzhxQnQ1VzZFaERrdHQ2RklFV0s2Q3NzUCtrUUZEL21CUEIrbzBvMnhHMjcrNkc0Y09nMW11SXBzSkx5VEtseUY5Z1NrS0hnbjMwOG00OXFDMkxkYlFYMGp2U3R0SzNsOXBkV29ZU2ZxY0o1UDc2ZXVJR2tSSDJsTmFrYittbUs1ZHU2bnJwSWprcHdWSEE3L0FNRkpOUU5tdDRhcDY3ZEpwd2dNVEcwcGVYTGVTMzNKQnlNazVWNTU0MFVyVGxiMDdaMmk5UjYxVWhPaHNvSkNJczBuc0gxNXhuOXRmbDAzUldiUnF4alB0b2VZYkFKVWc0Q3VQSTBTT203WTYrdXRXNEpGcTJMS2ZwMXZRMElYY2RkbVJzL0RGUitWaHBJLzRqaXNFZ2V3eVR4NS9UTHRMV3o0cjRTbG9hazloKzlhakhzVUNBdi9BTnVwUldydWRQcGlxejBxM0RjTjFYSXArZ1JYNU02ZFZBaHRpTzBWcjdVcHlTUVBBNThuZ2FlcXorbVcxMXlZOTg3dVFreVpDRWQ3TkpVNEMyRkgzY0E0WDlrK1AxMWU5b09tUGFYcFRzOFcxWXRzc3NyVTMzeTZpL2hjcVlvK1Z1dUh6NC9LTUpIZ0RWUzNBM1NWRmt2TnN2RHVhQlQyanhqN2F5YmlIanQyWXBVVzNwd2pPNS9GL2lteUZFTERDRnVIS3dOU0trci9BTnpvZE5wU3FiVFdrTXR0SjdXbTJ3RWhBK2dBNEdnQXVaY08rMjVjSGFLMVpSUy9NV3BjdVoyNUVXT25sYnBIMkdBUHFTQnFQM2EzU1hIZ1NhZzVMQURhRHo3Y1owVWZ3cGFMYjhpeDZ0djdYRUlmcVZlbnVOUmk3LzRNRnBmYWxJK2hVdktqOWVQcG9kYTdVcU5GWGNIOVNDQU0vd0RZN2ZUVTE1VzZseDhOazc2L0ttQzJrNlI5bjl2cllhbzl1MENLMCtCM3VUWkRhVnlwYWp3WEZ1SDVsWlBzTUpIdHF4N1Y3SHdMbTMwdFRidWpLSzNLdGNERER1UDZXdS91Y0ord1FsUkorMnBhVGZqUkFib2NCTHpxbTFOcGNDUU8wRStDcjZmcG82L2hyN1lDNDkvSkc0dFpIcU9XN1NYWEdRUHl0UFAvQU1vZnFlMHI1KzJ2ZGhodTNmaUJwTHhKeW9FNTdEOUtwM21ZYmJhWG5rNkFBNDlhTHY0alhRSHNyMXdiWHliTjNNZ1VoYzMrSFBSTFhtemFFbVJQcENuQWtMVlQzRUR2UXRTRWdGS2d0R1NGQUpJQjFVOXFyczJvNmNLdHU5MUEyN3Q2MWJWcFdEc2piVkd0aUtqNFphSG9sTVpuU0pDVUxqcVVsMzBuWG1XM0ZFNUNrblBHbWkzTXNPbzNqVDBPVUtzcXAwNWxoMURNcGwxYmJoU3Z0NzJ3dEp3aEtnQ0NTbGVNZ2daR2dSVXRrYlRyMXZTN1gzSzI5bTFRTVNWdFB3cWhHZllZY2pLYVdqNE4rUXBhaEpoTk1LY0pVa0F1SEdVZ2pYVjBkS1MyRWR1bGNoWFdYTWl5RmxJd2xZT3ZtZXZxTTBsT3l2U2p0L2FqbTNuV2IrSVphRlp2aXhiaXBkUnZHOW9jS2kveFNtV3hkOVVmUzRtVFhZN2FpNzZMRkxYRWFiV1cxcGFXRnFjQ1Iya2xMcU50anBrNnZieTNPMmh2U1JEcGUzZlR6dFBTVnpONjJ5cVJWQlVYc3FaYVVwSHlUSXdob1NvcEk3eVZKS1Q4Mk5RZlVMdFYxenphVHVCWWZTSGU5c05XcHY2WTR2T28xd2xpcVVCS0lnaHlaY0JtUDNlb0pVUnBEWVlXRXlFbE9Ra2p2VWtWM1pmOWxkRHY0SnRseGJtaENaZWZVYnVQQnJEOXV4eUhaVW1DeExhY2FnaHNmTW9OdzRFS0oyK0E1S0tmYzY4VEliRTVvdHlFOHdQVHBWMnlYU1JIZVM3RUpRRURKeHVUc0FmV2t0Nmtla3Jxdy9ESDNNazB2ZGVpR2RaOVRucWR0NjlxU0ZPVTZhaFJDZ2dyL3dEQWR3UmxwZUZBblZEcW5XY3VuVlJyMW1GbHRaU2xCUmxSS2ljZjVhMFY2UHVzT3EwV1F6K0hGMUtiWVV1NXJsdWpjKzg3dDZzNnhkekRyOUd0K0MybFVpUkJqS1hoSzVJYkVYQlJoTFhjbkdWT1pBeHMvd0RCMzZVdXFUcDdpOWIzVE0zZjFNMjZ1bW8xTDRPMzM2dWgrUlNHbzh4Mk9GbGZZU3RsUWI3MGs1S0FzSlVUak9zcDR1NFd0bHRaWGNYV2xLYkc0UU1uMXdOZld0cTRaNHhkbXVKaHZFSmRQVW5UNStmYWxiRy8xQWZpT3k1dGRRMFFnRmZjckFIM091dmJqYUhkRHFHcVgrdEZMYi9oZHZvU2UyZklhSlc5L3dBeVVIR2Z0b2lWZjhLemJLeTdwcDF5MnhkOVZxaUkwZ0xGTHE2ZzhsYWg0ejJnQlJIc0NDTk1kWWQzMkpZempsRXFKZ0pOS0lZYWlxYnlZNzRTRHlqZ3VKNS9NTWdxNEhBSjFrQ1prS1lVaXhBcUt2eExXa2dJSGtEdWZ5clQxeVVOeHlKZzlFZzZxUHIwRlVYcDc2Q2E1dDY2L3VGWHQ0WXNhbnZQSVdXWjBMc2U3RWpCVWtkM2FFWjR5b2ozeDQwZkxWM1prV2RPa2g2bHJmcFRiR1l0VGFlQ3pKU1ZkcVV0c3BCVW9xVndCKytxekozUnVtN3FteFNyZmFYVWtUTy8xM2FuUnczRFo3UngzT0RPRG4yQUl4d0RxU2tYUlZyVmx4M0trSU5RcWtkZ0psR1BUa3VNTk1LT0RoeEg1ZTRraEtBQ3NuNkRKMGJWd3JZcmdVTzNCc091QWZpMjZkaGdDbGRmRWQ1WnkzSFY0YUIweGtENTlhNlhlbzVGY1ltU3JwcFJvOUppSVB4RXdJTHBqLzhBNjVhY05vSTQrUkpVckp4alYyMjhYWWxtVmVQVmJ5dUtHUk5kU0lLaTZNbEtoa1lCNXlmL0FHOTlVNmpYdHNkWGFPeFRhdFljWlR6TXhVT05Sbi81M3dxdTdCVWxIS1d5YzU0R1NlQms2T1hTQitIUHQ3dnZ1VlM5M3F4SXJLNlBhdFVEcmk1ekNmaDZtOGxKSHc3T2Z5cFNjZDVBR1B5ams4VjAreWpoaThTdkJiWUtPWTdwSkgxNlk3MStQSFY1dDBVcUxnSVBmOU90TWYwMWJFMGErM0U3ajNQUmtJb0RRQ3FjeklhN0JMSTU5UlFPUGtCK3ZrL2J5ZVpXN3Uyc0MzWk5lRjJRbHdvYlJLbjJGZHlWYzlvU2dnWVVvcStWS1U1SkpBSG5YWGRrMno3YnNxWTFjSzJvOUphaW1PKzBoUEhZcFBZR2twVHlWSElTbEk1Sk9Cb08xVnkvTHJtaTNWVVpLcXBGcHExVy9UWEFqMGFNMzZSRGJraEpQWXVlNGtZYlIrVnNaVnhnazdWd3B3alorQjdaN3Bia0FGV3FsZFZIelAyRlo5Tm55dUpaWmtURkhsVG9CbkFBMHpqT2ZVbi9BQUtrS3p0Tk0zQmwxQ3UyM2RjcWVxVElSTHFkblhXNTZ2OEFEWDNHd3RLR1hVSHZoTENjSHNTb2daOGE4SmR3N2dRTFhxVzJOWnJkYWhLbVU1Mk96TmI5TlZUcHBVZ2dQTXFJS0pRUjVCeDNjY2pWbmpWV0YwczlPamR5WFJRcW5VbDBXbW9rVjcrRVJqS2xQT25IclBFWjdubEJSNUk1T0JnWTQxUnJSNjlPbFBlMmExWTkzdjFXMTU4eFNSQmpYclJINldYRnE1VDJPdXBDVXJQc080SDZhZEc1QVNBSE5EU0pQNFplZGVjazI4a1lKOUQ2amZGRFcrdW1YcEY2VU5ncHZVKy9jTmR1aTk2TTZ6SnBGODF1WC9GSzNVYXN0UWFqd1dXWGY1Zjg5MVlaK0dTbEl3NFRsSlNGcHJUdlVOTTZPTnQydHZyZ1hGdVhxUTNscmE2emMxTHBkVlphYmpUNUNRMmxLNUx4N0ljR0l3MmlPMjQ0VHd5ZXdMVW82TWZVeDByU2IxZzArNXFIVnV5c1czS2RxZG9WcDlKZGp3cWtZNjJXcEVxTUQyUGxBV2V4M0JVanVLaHp6b2I3WTJMMDZkQm5UdkpxdTVGbDFmY3kvYndxRE1lOHBydHZtcjFLNXFrdEpVbHR0c3BVQkdIYXIwMDhJU2tEdU9kV2NBak9hQ3RUbmMrNXZKRE9CcmorN3lUNjkvcFVsdFRhQ3R1NmpiKzJQVUpkVmxYOVByOUZsVFhLcmJNeHhneDUwWnY0anRtTmw1d3ZzSnhodWFwU0ZkNEhlZ0tXa2kxME95cm8zSXJ0SnBmOGJROUpvYm9xS3FUSlVWeDBWRjdDeFVKaWYvR1UybFhjMDJlQ3NwUEhiblN5N3BWdmVmOEFnZDJWdThkcnJlNmZLREVnSWRvTzM5dVc5RVhjMThTSDFwYWlSVVNBMlk2TytRNDIwcENBNDQyVkVxU0FBdlRPOU05eXhlbUM3ZHV1aE81S05WcTVkOVIyMmN1QzVidmNuQjV2MTQ2a3R2OEFxcWNQZVVsMXowMjhjQktRTUFEWGtubEhlcFYyOVVtUTJ0S2ZEUUQzMVY2NDg5czFiTjN1aG5hVGN5RzFjRGxGWVhka1dNVzBYSFBiRHo4c2s1UHJrL255YzRPUGtIQ2NKR05KSDFEN0xDeVpNcTFyOXRHSzJ0azVMYjBWQ2tyVDdLU2NZSVBzUnJUaTJMNHN1OTB5M0xNdTZsMVpNR1VZMDVWTXFMY2dSM2dBUzBzdHFQWXNBZzlwd2NIeHFxZFFmVHZZZlVQWnk3V3UrTXBwOUFLb0ZUamNQUlYreEgrSlAxU2VDTllaN1QvWkRENHhIOVFnSzhLV25xTkVyOGxZNjlqOWEyN2dmMmdTZUhIa3g1Wks0KzNjcDh4NWR4OUt5L3R1NjJvRFFocmRBUWtEQUFBKzJOVkxlaThWUFF2Vml1Z0JEeUN0SlBuMjBRT29UcHF2VHB6dXRWQnVhTXYwSFNvMCtwTkFsbVdnZjFJSjhFZTZUeVB1T2RBUGMrVFVvZE9rT2VrdDlsU0Q2aVFuSzAvY2ZYR3VSMTJlZGJMb2JmT1FVclFkUWY1cjYxMXhiWlVHNlFFeklhZ3RLaG9SL1ByMnFScGU0TWlFbHMrdjJrcHlmbTUwVHJZdXE2S3pIYWRDL1Q5VkE5Tnh4T1ZGUDF3ZUJwWmRtS3lkd0wxaTAzMVF1UEZDblpJeno4dmhQN25HbXl0R0V3M0dRc0xDbkZKK1lINmV3MUZlRlAyUnp3MlZjcXlNL3dBODZzcldsVE9WNEpybG1XUzdPSHhNMTkxOVp5U3AxWklKUDI5dFFsV3NoYW0xdE9NSjdSL1ZqMjBUbzBjS2JCS0NUakJKOXRjdGJvYVhJeWxPOER3TzA1enBLRTY0TGVLbk1rOXpWSk53NUJ5N1VGYVpDZjI2cUtxdlQyNHBaa1NBaHhwMVlRNDZydEtnbEI5emdIZzQvdnhvbFc3Zjl2VmVHSFV5dTFmWVFwbGZDa3EraEdxMWROT1EvVFpTM282ay9QNlNtbEQ4MlB5cUgzKy8vWFF2cVZTbTI1TGJrTlByV1cvbGNXcE9Db1o0enlja0RqUDAvVFQreEhzMXlzb2VDc1Nob3BKMUNoMEk3WTZnMVJia1RITGo0Ym95MmRpTng2LzRvK2V1NjhTNmg4S0dQWk9vcTRnSDBCcDg5bUIrWWp4cXAyZHUxQWFqZjcwLzNCUStVQUE0QngvNzYrcTd1Q21xbnRqdG5zU2pBOTlMQzdRR01MQjE3VVhITUZjcWRxSE83dFNmbzdhNWNSRGpxVUt6Mi9YSnhyODJOb2wwM1c4cVV5U3pDRG1VdVp5Vks5MHArMzMxMFgxRlpycFJFZENWZDZnRHh4azhmOTlGbmJlaDB1MktKRnBVRktFSWFhQ1FFREEwY2xUMHdyU0VJVDhaNjlxSHowbGtlSnphWXJyYjI0UTh3bkNlNWVPU281SjF6U2R1VzFzcVF1S25qMktjWjFkcVpJS2tmSXBCQU9Tb0hYelBYNnFWL0tQMThmMjBtZTgzTUx5UWRhWGszSHdqOFIwODZFRSt4SDZTNnVWVG5YV1ZnNVNXMWtZUDdhL0lWL1hUYmc5R3NxVkxhU005eC80Z0E4NC94Y2FJdFNTeWtsS3lQcGtEem9mM3JTWjFRbE14YlZndXlhaEllUzNFaXN0bFMzWEZIQVFBUHFUby9iMXZ6NUNZN2lPWlNpQU5OU2FtWGQwY3BXRllBR3ZiQXF3VXlUTHZtcjBGMncwdlRaTGs5UG90TUp5dnVVQ25JSHVSblAyMCt2VEoweVcxc2pSRVZ1VkRROVhwTWNDVktJejZhZVQySisvUEt2SjFVK2cvb2xnOVBGcW91Njl3aVZkbFRUNmp3QjdtNmFsWFBvdC84M1B6Syt2QThjc1V0bFNQa0o0T3U4dlo3d3NxeDJCcHFTMkFmeEJQL1hPdjFybUhqM2lwTjR1eXhGV2VUWW5PaXNmcFZHM25wejA2aXc0OGF2dVJWcWxwTGNKcUdIek9WamhvcEpHUm5CT2VCam5VSmFOZzFHRlhVVjdjUGNXUlBxTVpKa05VWm1VbG1QRFNlTzcwMjhCUjlzcTQrbXYzcWt1dTFiTXR5RFY2dlNLMUtxQmtGdWxKb3JxbWxwY0tjS0szQncyakhrbjl0SlRlMitBcXRWY3BOUHVsVXh1b3l5MG1pMjdKY2t1VFh4eDZSZUdYWlN3ZU8xc1lIdVU2MktISERrUG1Vc0pHdlRKK1ZjNjM2OHV4YitsaU5ITDd1QVFrRWdEeldkaC9OS2IvQUhhNjBOb3R0RU9RYWJVUlc2aWxKSmgwOVFLV3NlZlVjSjdVZ2UraHgwemZpZDdJZFFXNXMzWktWY1VTTGRMQ2xxUkRhQk1aYU9NSVE4cjVYRm5uaFBIQnhuUysxRForSFI3dXA4SHJIaFM3QXRLb05wY3BMREFEaGxPWndXcExxZTVFVncrZTA5NmlQNmdScXk5VFBWRitHUjBvYkF6cVJ0cmIxdTFDdXZNSCtEVStqd1N1VXVZUmhwMTJVb2R5ZTFXRDNkeFBzQWM2aWNURVVud282Q1NmN3M2L3RSbTJ4Ny83d1pkMWtKUW5IL3hwR0VEL0FPeWpxcjhoVFY3bTdLbHllYi8yOWl0UjZ1MWhiakFIOHVWZ1lIY1BmVlBnWFpSR29hR3JvdDUwVkJJeE1EcnBDdlV6enhydjZSK3FDbjd4MkZiTkdxYk13VjV5M0dINm11UkhMU1M2RUFMd0ZZVWZJeWNhTUVtM3FIS2ZWSmsweU9wYXpsU2xvQkovdm9iTGhNRlFSTWIrSWZJL09qZHJ1cmpqUmZ0VDRLRmI2Y3d5TzM4eFdLKzFkTnQzYzJNMWJsZlZHcGxCQ2lhcXFVa0ZMakdjRnRlZlBmeW5BNUlKeG9uN3IxTFp1Ylo3dGkybmFLWXRNZmhLanRvZzA1VERMU08zdEFRakNjQVlCNEgyOXRSSFJKdFRiWXR1UnVyV3EySzJreVZNME5wOUJMTElHUXQ0REdGTEtpVWhmUGFCeGpKMUpiaDFlaVRaejlLVk9qQ1VIQ29zQjlJV0VqT1BsejNZSUJPdU0vYVplSmM2OElEZVZOb09tQ2RDT3VtbS9YNVYwMTdPTEhEdHZENlczeGh4NFpWbkdjRVlBOUFPbEp0UmJlclZwUzNJOVJnclRGYWtLUyt5NE96dlFuL3hFakp4a2MvcHFKM2QzRHBFbUxTSzdDcFVhZDhCY2NGMk1sNkdsMUpTbDREdEFJSnlRU0FRUGxPRG92N3F4cVJPRGxKa3NvY2p5RUg1d25CR1I3SHlOSjFMdUpHMSs2cmxuYmRlcmNNaUhVR1pVNXVTc2xGTmJRUzZwYmhHVDJoSXlwUThaSHVkYU53amZsM2lJcElhL3dDUktjK1JHTy9UWHYzcEQ0cDRGTmttdHJqdllhV29EUFZPdmJyaW5yMlozd29HN1ZCVlRicWlPMHU1R0Z1SWZoUGZsZUNTUUZ0cVBuakdSaklPZmJRNTM1Z1VPWFVvOHlyMi9FcUVhbnZoeHlMTFJsTG9CeVFmZkJIR3E5V3Q5SHIxczlqZHBXNXRCaHJVcFJZcEtvQ21TUWxSUWxiYnZjcFpXY0ZXU0RrS0F4b1E3cjlVVjMxaWdHQkZ0S1MzSmVTQTdOa3gxQmxJT2ZtU0FNcjRHUU9QT1BmU1BCNFJ1QXZSZmpqa0NqcU9ZNFNjNmdFNE9LMTZOeFUxQ3R3WWtxTGkwQVlJVHFyc2NBblh1YU5PNGZVUHRUSlF4dGZ0RHM3VEo3NjQ2SFBTRk9aWmpRMGtkM1B5K0FlTzQ0SEhrblMxNzQ3WWJvN3dialJMMHQrOERNZUk5QjBTcWdsaUhUMFpBV29FNFNoSGRuT2NsV0I3OGFIdGI2ajk0V3FLaXhkc2FBSVRVcFIvaTljYmFTNU1uT0VmTVZIL0FNRkNFOEJJSEFHQVJwbnVtL2J2YXkxZGxUVjdxblNKc3VXaFVoMXViSS9tS1dQbFM0Yy9MbmtoS1FNalA2bldwVzZ5dmNNc0V0TEE1c25DaVZxVnBxVlpPQjVBZlByV1Q4UjM2SkltQjE5c3V1NmhJQTVVcEpJd0U0MU9PcDYxRzdkOUZteHoxTlN6dXR2TkFyRXg1STdtb2M3MG11N0hPQ1IzSG43L0FMYVpicDBiMjY2YkxSUnR4dHpEaEduZkVMZWNJbWd1dXVyd1N0YThudU9BQU0rQUFOVnZiL3BlbVg3RGJ1RzZhVW1CRlUwRnhhWUVZSVI1U1hGZTZzZTJwcTk5b2tVYWlxUmJzUkNuWXBTUUZzSit2SUJQbmpQR3NndTNFNzB5V3FNWmlsWk9xZEFnSHBzTVZzRmd0OXhldFBqekl5VXF4b0JrcXg1bnY1Vjg3eTlXTnN4bm42T3VsVkJVdGFzTU5odEpEMlBQWW9FakdQZlFRdmEvSU5iSzVrRjR0ai94QXNZS1Q3cFA2YXNPNXUyQWw3ZHo2cTVSSFhheWdxa3RLYVJsYUZKUERhUWprSng3RDNKMVZOdnB5NGxIWnVhQlN6TWVZV3BWV3BzaU1RVU5uSHFCU1ZqT0NPY2tlZEdMWkFnT3hqSWpncVdrNE91K25UeXBCdWwxdk5tdkRUTXhJOEp6QjJPVTVPTUh6RkRCN2EvY0xxdHU1VzBlMmlnMDB0SVhWNnc0aFhvd1dNNFV0V1B6RStFb0hLajlCazZmYnB6NmE3TjZmZHVxZnRmUUtoS2t4cWUxaFVpb09kenI2eWNxVVFNSlJrbmhJSEE5L2MxbXhHN1EyYWlTcW5aOXNSNGNPcXVmRlMwc0pBVjZwU0FGSDlCeGp3TTZ0VnU3clJLeTZYbzBrS0pUanVDdVNmMDE1dW5FNnJoQVJFaUFwYlNja1kxS3R0VDlxZGY2V0lrangzTlZFWUI2WThxSkV1b1Vpa2o0RnBBYkNGY0xKenpwNlB3ekxXaFd6c1JWTnhxbTRHLzQ3V0hGaDkxWEh3MGRQcHBWbjZGWldmMjFtSGRGMnZCNVRrVklVOHNCTFRKUENsRThEajNKeC9mV3hHelZnMExiUHA2dGphYXJwT0tWYkRKbGhMaFNyMVVwUzY0c0VjZytzbzgvWEduVDJZdzNETWVscjNRbkF6M05JZkgwa0dFM0dCUHhxMXgyRldDSmNRbjM4d3VYU0pUYkNuaEdpdXJWeUhDMnJ0S214K1FIS3gzSDdaMVN1clhxWjZPTmcvNE5INnB0eEtaUm5waWxtanBreUhFdnQ5MkFweFBwa0ZBeUUvTWVNandjYXVsaFNwMUpxYUtQVVpEc2hjOWx4eFRybnpLYlczaFRnS3Y2Z1ZPRkl6N3ArK2xmM2MvQjAydDZrZXV5djlUdlVqVVhyeXQ2ZFJveUtMUXFvLzNJcHJxQVVPUjIyOGRxV3lPMWZxZm0vcDl5ZGE0Mi9jUkRDbVBpV1ZhNTZmeitaclBtWUZoa1R5aTVIbGFTallicVBUR2gvbldqcFlsZW9Bc3lvYitXTmZGS3V1a09OZkZVYXBmeEJMaGZVb0lRZjVxdTFNZFNnbERaY1VTb1pLbEVENWRLc3JvVjZaYjc2cTdTNjRxNXR6Ym4rdGxtM0N4VzZ6VWFXeXFKVHFqTGViZGFVN0pRcFNtMHRNdnBTNjA2MG51ZmRCV1FVWUp1L1RydEx0MTBEOWVoNlE5cEhaQTI5M1NzdVJYNE5wVkNVWkxORXFFVjROT0JqMU1rTXVvSkpRY2dGUEhHTk5QY1ZqV0ZKdmFMVXdXelYyb1NwVE5MYWV5NUliWVNFdEZ0cFI3RWhEaFFvSEdPNEk4QUhSeTMzSHhtMUI3QVdEZzlzMG04UjhOTHRzcHRWdFVTd29jNmNqWEJ6blBtRHBXVlhWbloyL3Y0bFg0bzI0dXlPeCswSy84QVZHeGJjcGRQdlp1dVBLbzBlNElMVXRxWlVxYzFNRGFzeUtqS0RFVlQrRkpETUg1aUVxR0h2L0M4dkdEWCtsZWdwWjI2Y3Q1dXZ6cTlYRzZPZ0lMVk9RL1daZ1REQVFBaFNFTm9RaEsyKzV0UVNNWUJCVjRYZGROKzdYN1MxTzdLM2ZzOWRiblJTeFRLbmNUVHI2cWErdnZRNHRJWWJDM1RsVGJmcGdCdDEzc1FrZktwUkkzVEZXTEUyeTZVTGZ0NmtWeGliRTI4dEJtRFVKTGFGSkNuSWtmRDYrMXdCU0NweEN5VXFBS1ZFcFZ5TlhKeTBNeEM0NStGSUpQeUd0Q2JUT2JtUy9kMGFPa2pUcjIrWDFyUExxczMyMkxzVHJSdlBhRjJ6NWtXa04zQW1OQXFGTGNDa3NUU3cxNitHQnlwb09GUStYeDh4OGNhcDE2MFp5K29penRkdUpRV24wTElqdklEVDc4WWM1eXd0U1ZkMk05b09RRHlRZFVUY3l5cE5jdjJYdTNNcWJzaXB6WnNxYzh5K00velpDMU9MVUZlZU80Z2ZZYUY5YXR0VzR0eUdCUnFJN0lxV2NPZWkyUTRuN3FJOFkrcE91UlJ4bERtU25DMjJPVEpJSTB4cWNmTEZkZXQ4RXFUQmI1bk1MQ1JuT3V1QlJYdDdZVzdMR1JYVXpKcnJ5NVZWUzlUS3BjRTFjaDVvS1pCZGZMU1FFdk9lb1BrYlg4bzR5UWtCT3BtTmVsYm9LMjdTUmRjcWpVbVBTUXR1VlhuR0dwY21RZ2pncFNGSlcwdjVndkFUMitFQTQxL3RrZW1yZXlsR085TjNrdUNueEVmTi9EWWg5ZGpBOWxsOEZDdnBoSUp6NDBjbDJKUUlsUGkxT3NPdDkrTUJiOFZEWmNYNHlSZ0FFL1lhb1R2YVZ3L0RWeWhSV3JxQU00K2UxQlR3dkxLeU9ZWUhXdXJvQzZhN2w2eDZ4RmszR0tmU0xhcGhablZwRk5weW9zb0ZSV0cyTUxVbzlyaVVxVWx3Rkt1MFo0empXcGpFYXg5bjdDVEdZUkZvMUNva0x0Q1NjTnNOSkg5eWY3a2srNU9zek5vTjFiajJGdnRtOUxDclh3eGJIWk5pU3lleVcxa2ZJc0E0STk4K1I1R05QaHRkMVo3UTd0V005VzdnZWp3UGhVSVhVWUZRdzRFSy9Na3BHRDZnNHlrZ0UvYkkxdFBzMTQwNGJ2TUlwWVh5dTlRcmZIbCsxWjV4Wlk3cENrQlRxZVpyL3gvbS9uVkNUZmQvd0FxOGx4azdiVlNkVjVicnRXdGlFMnkyNDFUb2p6cFQvRVpUWldGZkVCT0VvYVZnREdCL1VRVGJSdHk4SjdGTG9WSXRPWFE2YkhxamRRckZVcmI3YTU5UWRTcnZPRU5sV0M0cjh5MUVZUjhxVThqRWRXZXBUcC9ya0NjN2IxL1JhYlZhblRseElGYmZoS1ovbWRxaTJuMVZveDhxaVZBSGdjblE3L0NvdU9aVXRucmlwOXkxR1M1V3hkTGs2cE56NXJraDhmRU5vVUZxVzRvbFhjb0xHZUI4dU1ER3RKalM0VHJvU2gwS0oxMEk2VUtrcWNmZ3FlUXlFQkdBZCt1bWQ4YWZjNXErZFhPOVBVRHNxaWoxN2FEcDBlM0ZwQ2tQcXVpbndKQVJNWmFTVWRpbVVuS1hEZ3JKUVJ5RThjK1J0Ykg0bHY0ZlcrTlBmc2JkQzRJbHF6aW4wNmhiMS9Va3cxc0s4RktsTFFXd1JnK1NQR213VTYyb2p1d2VlTTZUbjhTZmJQWWFCdWJzL3VKWHJSb3N1djNGdVpUcmFuMHlWSFF2K1AweVVWSWtNdU40L21lbmhEb1dlVWxBNTV4cSs2Q01uY2RxSFFYWXpvRFNra0VaK0pKT2UrbzJydjZBT3BXeXR4ZDlOeXVuL2FDNXY4QVdLd2JXanc1RnUxWmhEaTQwWmJuZWwrSXk2dmhiSUlRdENRU0U5eXduNWNBSG05TEFtVWQxTnpXWVZOcllYNmlXMndPNXJQbnMvNVQ3cDhhR3U1VDlmNlpwbHI5T1hReDA5VzhpdVhhOU1teUpFc21IU3FUQmpla2grWElVZ0ZicSs1NXBDRzA1SjdpZUFOVGk3ODZvOWxxS3UrTitvdG5YQmJjTmt2VitiYVRNbVBMcGpLUmxjbjBuaXBNaHB0SUtsaEpTc0pCVUFySGJxUmdLYVNBZGFFM3VGQ3V5aVVEbDI1VC9ka2RkTkJuZkZMVHYzMWtVTkc4Ykc4bStWajFXUFQ5dHFpcUJ0THQycUgvQVBwRzg3cWVDbUYxUnBnNUpZYVNvc3hpZmR4MTQ0QVJvWVYrbEszSTN2YXJuVTFUYWh1L3Z6Y0ZNVTFUOWhMUXJQb1VXMktiNmlYRU0xT1FoU1FwQ0ZkcTNTNnIweXM0RGE4Sk9ubzMwMlBzUGRpaHg5d3FDM0ZlZFhCZFhTcS9UZXd5WWFaRWRUZnhVUjhBbENpMjZyQzBuK3JJMHNxdHZkaGJWcE5QNlZPbnEyaHQ3RXR1cXhIdHh0NVpxM0dxbFRwa3BHQkhoVEZZY2xWS1cyU0ZPa3FaanRyeW9LWDJwRm9LU1U2VXNSM0pYdlpqekZZS0JvZHNqdVBQdlhGMG8zZS9zeHUzWGQ0dXAzZSsyNkxhbHByY3RxMmJUc2FsbUxRalcxZ0tuTVFtV2tkOC93Q0ViQ0dGU0NnRlR5bnh3RzlQTnRKdkx0dnZsYXpONDdaM00zVXFlKzJsYUhFdHJiVmhYS1NVckFPRGc0UGpnKzQwck5Kc25ablpIOFJuYU9rYmMxbW55NkJVdHRLcmJkc1c1R2toNUZ2UFIwdFNCSWJIT0ZQdG9kU3R4WHpxVVZGUitZblRSV250enQvczR1NUx0cHdiaE5WaW92VldyUHZyU2hwZyttbnY3UmdCdHNCQldmOEFtVXRSNVVkUU9xU2taT21LTXhBdHcvOEFHUVU1eGdhbjF6blVtb1RxdWEyZC93QmlOYWw3NFJXM3FLeEhLdXpJOWIxeU1OaGcrUTZWWUNjZnZ4bldQTjZwWWZVOEdtMXBhVXBSYlE4b0ZRUWZBSkhCT01aeGdaOGFaSHJtNnVsOVFseWxGdlZkVE5xVWxhaFEyQ01mR09jaFV4WVB1UndnSDhxVG5ncU9sUnI5eU5PcFdjZHhKNDdkY2NlMTYrUnVJT0kyMm9iWUlhR09jZmlVYzk5OERwODY3RjlrdGptY09XWlRzcFpDblNEeUhaSTlPNTYvNHFqYmNVV2w3ZjdrVm11VTVmYUttbHJ1YTlrbEpWa2o2Wk9NL3BwaTdJdmY0cHB0eEt5U01aU1NPZExCVzYwNG03NC93YUZFUEZRV2tEbElBem43RDc2SmRpWEU5SFMzaDg5M0dDZkdzdzRoZ095MHBlYy9IZ2ZscCtsYXBsQnp5RFNta29sV2oxQ0tGcGNBeHg5TS9wcjJxa24xWTVZYmE3aWNEQ1NNa1pHVDl0Q20yYjJrSldvNFVsU1NPNFl4M2ZmOVAwMVpFMzI0NG91UHI1d1FudHdDQi8wL2IzNDBwSURJYkxid3dUMW9ISWlMOFRJcmd1OTFDVlBNa2dnSEI1NEovd0RiUWF2UlRhWkRyTHVDbDFKS01leEhrYUlsMFY1VHdBS0VJeUNRbEt2QUh0b1I3bFZWb0FPbFhMYXdVZ0hnWjBRc3NZaDdBMk5UTnRsT0RWWHRhOHhBcXo5TWNVa0ZsekFCUGthdGMvY1NQQ2lGZnhxVXBDY25CR0JvZmJlN2Z4NzAzQm16NXRSa0NPKzdoaHBnOW9CQUdlZkowUnExMDJXNVVvS21IVXZxQlRoUlRLV2hRL3owM1hEK2pzU2twZVVRY0FuQSt0RVd5a3B5cmZ6b1gxZnFKZ3VYL1I3YlptZ3BmcVRhSEY1eGpueHBwTFZ1WHZpOXdkSGZqUDNPa3gzTjZFWmxQdUptOHJHdXFjWFlUeVhrVTZjc0tUbEp6OHFnQWMvcm5ScjIxM1YvaU5MUkhxWUxFNk1rTnpZeTFZVTJzREhQMk92WEV0cnRNMjNzdTIxZk9BUGkwMUI5UDRLRm54blBFUThuUTdkUlRDVW0vbW9nVTFKN2lBbjVBRWdZeC8yMTBPN2gwMWFGSWtnSlFjSDVGREtmdit1aFJGM0x0eUZGUTdVcmJsMUZheW9xa01WRkRTSTZSK1VGQkhjc3E4OTJRQmpHUGZYekt1cW5YREppTTJoUko3YjhsME1JaFB1SWRXOHM0d3B2czVLU1RqQjV6cXkxd1BmNC9EN2R5U1VLUWY3UVFWakp3TWo5S1JISkVBenpGV0ZaR2RUbkdtcDFvanRYSzdXYW14U0xjb3o4eVZLZUNVTkJCS2lTY0pBK3VkTzcwaDlJZFAybWdOMzVmMVBaa1hKSmF5MjJvQlNhZWdqOHFjLzFuM1Y3ZUJxRzZHT2lvN1FVaG5jdmRTS2wrNnBqSVZIaHVmTW1sdGtmbDU4dWtlVC9BRStCOWRNeVcwNDR6enJmdlpuN01tN1lFWGE2SUJmUDRVNDBRTzU4L3RXSWNhOFhvZWNYYjdjci9qL3VWMzhoNWZlbzZZcFZOWlU4bHBTMGdFNFI1NC8rZWRjRE4xTnk0Z2RpeEFza2NwUzREMkgvQUpoN0VhOTdsa3ppVzRGUFU2MnBXVkdRa2ZLZ0QyUDYvVFZmWnRPcy9HaW9OdE5JYkJ5dFRTeWxUaCtwSGpIMjFzTWw5OUx2STBLUTRzZU9wa3JlSUhiL0FEWFBmMWswUGZQYnl1YlhYZWwwMDJyMDl5Sk1MS2xOT0JLaGpLU09SajIrdU5EbllYcEU2YWVoQ3hKVnkwU0FweVZDZ2sxVzdLei9BRDVyalk4cFNRRDZTZkh5TmdaOTg2T3NidlZHU3Q5cENIUEJDVGthakw4dEduMzFhVSswS3E0OGhpb3hGc0xjWlBhNGtLU1IzSlBzb1p5RDdFYUp4MUtRZ0J3NkhlZzgxSlh6RmdBS3hvZDllbWVwRkkxMWg5ZWxuWHJhYyswNTlHZ3diY2ZaVjZvcTFPVEtuU204Zm5Td2ZsanAraTNDblNPN0RkTTI0dlYzZTc4em9rMlhwbEVwZE9tZWxVTnpydmxHYjhHb2M0WVE0U2hLd09RbHRDc2Y0eHJSM3B5L0NLMkcybG52WEh1L1ZaVzQxVE05VWlJbTRFa3c0L3pIc1VXU1NIbmNZeXR6T1NPQU5EcjhWV1ZhdlRUUmtWZnBzcmk3UjNDdlBFR1V4UmxvYWl5b1JIcHFXKzBCMnBVTWhDSEVnS0I5OERSNFhGS3NNeFU0enQrNXBNajhMY3F6THUwaFRxeGtuSncya2RjSnpqQTg4MEJmd3F1bXF2Si9FeXU2L2FKdmhjdDZVU3hLU3FtMXE1YXJKSlpxVlVVY0xReWtIQWFTY2dEbjh1ZnByVnFWWHFORWZWSGwxaUsyNG5IY2h4MUlJNDkrZFpsbnFUdHI4T3JvNmdXUnRMR2JFMVhjN1ZMbWNSbDJyVk53WldpTWpHWEVwUHkrb2ZsQUdjODZCTkw2ZVB4bHVveUEzdmhRcmlsMHlGY3FmakljRjk4aGJiUk9FWnlvZVFBcndQT3BuYlp6SG1rdWhKN2JuNTlxcVJlSjB5T1pGbGorSTJrL2l6eW85RW5Hdm5nWW9WYmM3a1hIY0ZQcHUyOWhiMDNETTI1ZzBaaHFDeGFOc3VVNmZQSzBkM1k2ODZwUzIxSDZOajM4NElPaUxXdGh0bDlxcXVpdldaWUthWFZGdGd2VHBRS3BlU25DZ3QxU2xLVXJuQk9lZFhQcEoya2g3VzJFMU9ma05TYTFNUXFSVUpSNFBxcThnZlFEd1B0cTBYL0ZwOVlwcmpOWGpOT0JTZmxVZnpBL3JyK2ZuRlBGN2N1NEZxQ0ZJWnlRZVU0Q2g1Z2I1MzF6WGVOcDRhdU52Z3BYS1dGdkVaSkl6ZzlnZkw1VXRlNXR1VjZmUzM2alNKUzIzbG9JU1hWZHlGZlR1OXgrdXMxUkIzZnBPOVZmVGJFS2JMdTUyNFVNMDZKSGFVKzlJa0xXY3BEWXo2aVNuakJCQkhrYTFmcjZZc1NPNURCQ213TUlWbnVCQjFhUHc4dW1YYkNsU3J2Nm5FVzRpZGMxVFdwdURLY0dUQ2pOL3dBditYL2hLc0VxVjVQQThBNmFPRStPV3VFN2JKZGRhOFFrQUpTUDdsWnlBVDJ4a24wcWh4SHdvdmlCbGt1TDVRa25KOGpwOWFSbUYwRTljZDQzWmI1bzFzVW1pWFBVNDZucWhRS2lFSDRJaGY4QXhHMUlTcExUWGpLRHkyZmx5Y2pUTlUvOEsrNUtUUUJIM3IzWnFFeW91Ui81NktQRFRIWllYNzlxbGdxV0I5Y0RUNjdQVXR5SzR1OFpLVzNwc2xJUjNyU0NwdHJ1emdrL1U4NCt3MUpibU55cHpTcFQwZHRjZjB3bFFHRDI0SE9QcWRMRis5cC9FbDF0eUhZcmFXMUpQeGNpUVRqZmM1T2xmclB3MUNzN3ltbExVdEIyQk93K1c5WTdiOTlDOGpwa1lONTJWM1ZxQklmQ1piOVJpcFU2d2ZJSldrRGcvWFZYdFMvUDRoZHRKckZZVC91dEpQTk1TbkNTdk9TcFN2ZjZEMkd0S3QyN1hwS28wbW15V2tTb2twc3BkanJHUmcvWDc4NlNUZW5wNm8xRHVLUTFTRktpK3NnbUhJN2Y1Wi81Rm4razZhZUVlTkhPSkkzdTg5V1hTQ0FyYklQVDE5TVVtOFljT1M3UGNFWFcycHlnZE4rVTl4bk9uWHlweDdJM1B0YmNTd2FaZGRIcUFaWmt4QjJ4d0EycG9weWtvV0FQSUk4ampRcnZDL3BOM1hwVUxTc3VySlRHbzZXbHozMVllVTRwZVQ2YlF6Z1l4bFN6NEp4cFI3TjN5M1l0aTRZUFN2YXlWb3ExWG1oYXFpK2NwZ1J6a3V1SUh1b2djS1BDUnpqSjA2M1RWMHJQMTBMdXVqVTU1cG1TMHBwMTA1S25rZy9teWZISUp5Zk9sKzk4TlF1RUZLbXlYUXJ4QVZJR000R2RDZSttUUswYmhmaWFSeFJEUWx0c29RM2dPS0p3VkhHb1RqNVpxMjdVbzJvZFlacXJzNnFDZkdYM2h1YkxJOUZlTUhzRFlTbm5KK1lnL1RVTmZPMzlsWFl0Mm9TNkJFVzJwd29ROTZRQ3dFbmo1aDdmWTVHcjVMNmUvd0RWdGd2Tndta0pDaUNweC9LaWZmbjM0MVNkMkZVbmIrMlYxSVB1UjIwWUt5bEpVZ0VuSEkrblBuNmFRSWs4eTU0VkZlVVNvNEd1M2xwVEl0bTNwYVVwYllLZHprWjI2bk5DdmZ5Mzd5ajJjMUx0bXNQc2ZCUDl5ZWU1aDRFZHZZOG55UmpPRkRsSjVHZ1ZzNXZpa08xRitwUGZETndwUzIvU1U2UG5keGtJUWY2dk9jK3llZEh6ZHpjS2swdmJTdFE1OTFVMWh5ZFRIRVVxVTQ2U3c4L2dGSGJnWlZrNDRIdHpwWHVsMjNIMytvaWczUGVkb0lxOXR4NUxJYWd5OE14Nms2TXFXQ1NuQkNWRTVLdUQ4b0pBMXVYQjBCdVRhVmlaaFBLZENkTmM2K3Y2Vm5QRlYyS0pTV29xdHhsV05kTkFOT2g4NmJUb3djYzM0Nm83RXN4NTFVaGhWYWJtVkJJYno2ak1mK2U1NDlqMkFjZlhXeWU2ZFpyQzZaRnJsS1Q2RWlNLzJ6VnJHVmVrcFFVbGoweVBuNzN3eW5ISGFNbk9CckorMWR0ZG5ybDM3cG5VTHNwVHFVM0JWVG5vVmNzbW8xUnloeTBLSzhmR3d5RkpTaDVQYVFSa0pjOGhYdnBpNzJzdnIrdENoSnVYb1g2allrdVBMWnl1MmR5bmhQTVlrQWdzU1hPOUtsRDZMenp6azYxR3dzUjRFRmJMYXVjTE9TVWtmelNzNHZVeVFxYXk2cEdpUnNmUHZtdEM3RXQ5VnNSc1ZtdXVWR2Vwc052U0hFSlNFL01WS1NoS2ZHVmtra2trOGZRYTRkK2VvN2F2cG8yMHFXNm03dDJSS1ZTYWJITGpqc3VRR3l0V0RoQ1FyeVNmKytzcnQwK296OGNuZFM3YTdadXdFQzE0OVZ0bURGVGMxQy9qREtWeEppMlIzZWlwT0E4MHM0V0IzWlFYTUUrTkx0MGk5TjI3dlhaMWh5Tm5meFZOM3JxZ1hoUndhakNzUzVVRm1teW1Va2ZQSFIzNGxxQnljRWhJSGtxL0xwai9BS284aU1VeDIrVWJBay9GbnVCdDh5Uml2ekhDMFdZK0pNcVFGakhNUWtZQUcrQ2Qva2tFbWp0dEQrS0xTYnk2MTUzWDF1SmExV3FzcXMwczJuc0R0blNXd0tuY2kxdVk5VnB0WkhwTUxjd1BXWGdCS0NUa2tEWHpYTjEveEhhajE4MVhmYThLNVRhcnVYUzZwRDI4MjEyOG9FMWY4RG8xd1ZLT0pNdUc0NTRraUZFTGFwRDZzcExxaUJ3MWd1VjFEYkhkQkV6WWxXM05aMlR0NjhLaGFsRWxMdFdDaEtFVHZqZ3lvTklSTFIyK2lWdUJBSnlFcEhnREEwc08ydTE5NWREL0FPSFBXdHhyMTZncVVMbHMxMkhlTmlUR0dmaks5RHZPUXRURWluTFFvNG14cGFuL0FFZ1ZrckNWcUtsWVNDa0hHbDI5Uk1STWxLbkZLNWxZV0NRQmpJNmFuYlBYWEdOcUxUZWVYSkV0bU9VdG9UeUlDazc5QWNhNmRjZlhOT3JzUEM2Z0t2ZWRRNlcrdERjUzBhMXVhaTBXN2hwbHpXYzJwTE5RcEtuakVXeEtpdko3bXkyNnBTVU9JN2ZVU3NxUVVxUWRkM1ZiVUkreUhTalZiV1JRVTB5clYrWEZvVExiRGlsc0dJanVXbHVPb2trdEpZU3JoWHpkemlpdkpPZFYzOEtMcDIzU2pJdUhyaDZxSzZpcTdzYnFzc3JyTDdRN1k5T2hveDZGUGlvSlBweFdSOHFFODl4NzFuT1FTUGZ4YWQ2SExnNmtySzZlcUU0aHgybTBvelpMWGQ4b2xUVmRqUGZ5TzBKWmFVcm4yYzFZNDF2RGpIQThsYlo1UXNGS0NjazRPbWZwaytsS05tc0VVOGJNcmNBNWtmRTVnQURJMVBscG9PMmFYOXV5Smw4MUJ1RENBU3BYTWhhaGtOQW5nY2VWSDJIdm91Ylc5TTFBMnpRNVhaTk9hbDFGMFpMQysxS0VLOSs3SDVsWUk4K1BHdmkxNlhhOWtWT20ycFRwUWt5RU0rdTg5MmtBT253NnY5UFlldzFlRTE1cVNDWTdpWERJZndoMVNlNUtzZjFESGdmYzY0MVZFRnZnZ3JXY3FIVFFHdWdKTjJkbnJ5UHdqYjk2NDYybHRFaUd3dUljdVpCSGFRbE9NNElBeDJqNzZvbDAxQ2sybFRwTmV1V3B0Vkl4SC9VSzVneWh2SnllMGYwa0QzK2cxYk53cjBoMHVLbW50UHFja09xN0VlbWo1bGZVNXp6NzZCblVQUllXOTljdDNiNm5JVkZoQ29JWGNDV1hzSkxTUjNPTnFJODVBNS9YUzJ4YUZQdnBVOGVScFIxT09nMXI3NDZnMFZsT1NLSm0yOUtqNzRwRjNVZHgxRklkWi9rS2J4MnZvemtLNTlzKyt1UGNEWkRlUk4wd0xxc25lNlpTYVpIY1NwdURTb3g5VnRXQ0ZMN2tLNUdPQ1NDQmo5OUdqYmlrVTZsMm5Gb1Z2MDJNaHRodHR2MGtvN0V0dGxLU29ZU09jSjRBSDIxSXV6U1gzSTZxY3pIN0hIUXd0cE9VaHZIbndPZnFQMkdkZmtYYVR3eEw5NXR5K1hsL0R0OVQvTTBBbktUY1dpeThuS1R1S0FkMTNDOUlxY0hiZW9YblZhblVxZytHbTZpY3Z2TXVxeDNMU0I4cldCazRVa2pIT01BNnV0azFuZERaMjRtN3h0RzRKS0tqSFNVUHZ0bEpRcG9ISVE2a2orZWsrNDQ1NUdOV2lvV1haTlJrTlZxUlJZemRSUUZGbVkybkJ6NDd1NVAyOXZwcURkZEJvTlNjYkxoVkZrQktqM2tGT0U4NUovekdyakh0S3Z5cGlaaVZLQzA2bFdjNU9mdDVWNGlXU0o0SzIxQWN1d0hUSG1PdGVkNGZpdjhBNGdsZXJUbTJXemZTSEJxTlhMZ1JIcjBDUTQvR2RDaGxLd2hRQWJQdVVxSjdlZk9ORVRvZjZHdW8rOE4rWVhXbCtJaHVDbTRMd3BLSEJaZHJ0UEJVU2hLZEdDNkVKK1VPQUVoSThnNVBIR3FUMDdibzNIdHR1QkFwOU9sc1NZdGVsTVI2bkhVUzJsQ1ZLT0hFbkp3cE9mQjRJeVBKR25LaTdtVWUycVlheFhxeTNGak0rWFhsY1orZ0hrbjdBWjEybndOeHhHNGhzcUp6NnNFRDR0Y0FFZGF6M2lTR3UzSDNXR3lsUE4xQStJK1hjVUErb3JyWTJRNmlxdEkyaTZmYlgzRnVlNzdZcXpxS1pkRmxVMTZHbW1UVVphY0RVbHhIODVPY3BXbEtTaFFTY3E0QjBJS2xZLzRwdSsxWWlkSnUrVzhyc0dtMW1rdTFXdE9TeEFoS1ZUUFU5RXNTRnNmelhrS0lJTEtjRlE3dlVWMm5HalR2WitJdGIyMDFQbkRaZmJLSTdKV3J2VklYRkRhNWJpaWNxRFNBTzRrLzRpU1Q3YVZiZWE2ZDVlcVM0cWZlZlU1WUZIbFJJY1pTS2F6T2FXMThLMjVncVNoTEtrNEtnY0tDczkzandNYXV6dmFYdzNFeVE3ejY0d05BZlFuZjVhVkhCNGRtdXRCdExQTGdaQlg4U2dmSURHQjVITk1KdVJkKzRQUkt4UnJVcy9yWlRmVjFNUjQ3TlAycVhRWW9naW5vVWd2dlBPTUtCZ1IybU85ZnJ2SEhDVXBTcFNnQ2VMeXNxMnR5ckVoVnk2OXQycDlJdUtsSWNsVzFXNHdkUTZ5b2Q2b3lrcUhDd1BuYlZ3b0VZNE9rbDJkdGkwZGlybWIzSjI3MnR0U3BxVTJES2kxV25GYUI2ZkFVaFJXY0t3TWR4QngyajZhZDNZL3EzMm42dUxWbVc1UmFxbWszQkhieTlUbkhndGJEaWNFUE5LSC9BQkVwVmo2SGprWU9kWHVHdmFIdzd4QytXV0Y4aXhweXEwT2FYT01PRWJtMUVEcWs4NndlYm5BR25sanQ1bXZycHo2RmVqclorN0krK3V6RzJ5bzFUZGdyYXBzdVZXWmN3UVczUmgxTENIM1Zoa3FBN1ZFZk5nZHVjWkdsUC9GaDYvRVhYRW1kUGV6RnhCZEtpU0ZJdXFweFY1VE9jYkl6RlFvSGxwS3Z6a2NLVU8zd2s1dG40ai9YamJ2VDFaTlE2WTlrNjhFWFZNanJkdW1vMHhTaWFZSGgzT050REpLWDNlVDJqL2hKT2ZKR011S0hXYW94TGp4WDFQSjlSOVRqbnJvVjhuMFZoWGc0eHg3RUhTYjdUT04xQmhkcnQ3bnhmM3E4dXFSNTQzOHFldlpod1dWS2F1RTl2QTNTTWFaLzdFZHM3ZldpVmJjTzY3cmFia1ZGNVVkdFl5aHBTTzVlUHJqMjFQUGJMVXVzVTljS3FzelhHbkFBdFFrcVFvNElQSGI3WkhQMUdSNE91N2J1NVlNVnhBbUpDMEtIQ2g1MFhLTWFiVUlTWmNZSktmcHhyajI2WHFkQmxaYkhMallqOTY2Z0tlWm9EbHlEdm1nTXJwcnBWRm1OMTIzcFV0SzBNcWFRMUxjOVJzSlY1SGpJK242YXFwbnpMRHIvQVBxM2RjTmNJT0wvQU55a3JHV25oL2hDdkhjUHBwb3BsSVF0a3FhYVBuMlBqVkozSjIrb1YyVWg2ajF5QWw5aDVKQlF0UE9mcUQ3RWV4R3YwSGlaeVU5eXpmakI2LzNEei8zdlZodkRMZUU0QTdDcUZUNjh0c0pRWlhiakFEaEpQSDZha0dieExaN0RLemc4TFBnNlc3Y21WdS9zWGViVmwwVXZWcW16WE95a0plU3BUMmMvOEx1R1NTQjlmYlJmMjUyaTNjdWltb20zeE9hcEtuQm4rSHhQNXppUVJ3RktPRXBQMjVPbWFmWklzYU1tVXQ1UGhxR1VucWZsdlZkTXNPT0ZITHFOL3dEZFRWelh0RlpaVVg1QTdpT1NmQUgxMEVOMk54cDFScXJGcDJ2SzlhWkxXQ3R3RElqdForWlJIMVBnYU90ZDZYYlNseGxvcnJ0V2tLS01LVUtpcEovc25BMVJLVjByMlh0L1VuYS9hQ1pRZVdydmVFMllYaW8vVEtoa2Fsc3M3aDZNQzRGbFN4c09YUW5wazUvU3ZqcTNCcVI4UFUxWU5nN0VlaU90VEZyV2d0SXllZVZmKytqTXd5RGh1ZW4xQUU4SGtFZmZRK3NpNjZkUjFLajFQRENzWUNrK0RxL3dhakVuaEx6VHlYaDI4aEtzbkgvcHBadWlaYzZZVmthVVhIZ094YzlLOExudGh0eUlIRUFQTktIRHFSeWcvZlM3ZFErMTlRY1pkcjFwejFRS3pIUVN4SmJHRXZBZjBMSHVOTWxMcmFvREJrUkh3dHNudGNRNE1nL3Q3L3JvZGJwTHBkUXQxNlF5a0tXcEo3UVIvd0FOV2ZBKzJyTmxsU0xiUFFVYmVZMCtma2FCU1k2MElJejhKL0trNW8vVTlkMUFXYWZkdExjYWxSMXFROHFPU3JCSDFIa2FlVDhGVHFGMk52ZnFoUlRMM2xNcXJ6a05mK3JxNmsycnNRN3puc0pIYjZ1T0JrL3BwYjdENlI2UHVOZHIrNk4rVGhGb3JhZi9BTTFLZ2dQbEovT3BaeGhJOGZmOXRGcWs3bmROKzJBYXBGcFhsVDRyc1ZRTEtLUXdwUlFvZUZCU0JqZ2p6azYyZUhmcmRDdWJUa0dHdDVhU0NwS1FlUko2OURrOXZ2U0Jlb2oweTJ2UnBzcERJVm9GSEFVUjlkdTliaUpWazl4SG5uT3YxUitYbFg2NlJ6cE8vRngyWm0yMExUM3p2NUxVcUlnSmlWcE1WeGZ4Q0IvUzZFZ2tMSCtMd1I1MHdsb2RkL1NkZkUxdW0yN3ZuUlZ2dUhEYlVoYTJlNC9RRnhJSCtldXBMWmNtYmxDUThrRlBNTmxEQkhrUlhKOXpnTHQwMWJCVUZZTzZUa0h6RkZoeGxENmlIRTl5Q01FS1BuWDV5T2NjZU1ad0Jyd2hWMmxWRmxNaURVbVhrTDVTdHA0S1NRZmZJMXdYWmU5djJqQmNxbGVtSllhQ2ZrNUJVNGZva2VUcThwMWxDU3NuVHZWUnBsOTlZYlFra25wWFRWbHlZY04yWEJRVnFTMnBTV2tua2tEMnpySGY4UVhmZjhXcmFTcVY3Yyt5TjQ3ZHQ2MGtUWGxyWWt6VXR2UkVBOEJSZjRLdllKYnp5ZkIwWmZ4SS93QWVIYnpwK2lTOXV0bzBOMW02RGxCaVJwUUxjWDd5SEU1N2YvMWFjcSt1TlkvYmg3djlZdjRoMjZ3cFYyS3FkeHZTM3Y4QWNhSlQyVkNORUJQOUxRNFFNWStkUko5ODZwdHRPVHBDWHRtazlWYkgwL2VtRnAxRm1odVJsL0U4dkdBblVwOVRxUGxWN3RUOGRMOFM2SGNrWjJQdnMvVkVwa283b2p0TWJVSGhuR0FBQWVmR25SM29xTjdYZGRscTladStkRXJkWlhkVE1abWlXcklncVEzQ25CckpTNnIrbG9BRlNFQWR4VXNnYzg2dkg0U2Y0REZ2YlF2Ujk3K3BpSzNOclJLWHFmUm5FaFNJbnVDYytWZmMvdHJUZWZ0NWFkVlpnMFdSYk1KeURUbmt2UmtPc3BVRzNVZmxVa0VjS0gxMFVqekF4TERzVk9BTk05L01EOWFWcjNhbTdyYWx3cDdoSldSa0pQUUhQS1Q1OVFLUS9wbi9BQTc3aDMwdU5HL1BXZkRQOExRa0xvMXJ6RUJrdU5qbEJkYkJ4SFpUd1Vzams4Rlp6eHF4WGgwMGJIeGJtbXg2RDEzWExSSWFYajZGSWkxTkxqY1FmL1RTcjNBT2NmVHg3YUovNGtlMzNVbGUxbVVTTjArUlpGUVNtbytsVnFSRmY3RlBOcUdFcXdTQW9CV005eHdCenpwYjJmd3dldVN0dEpxc3pjTzNLVTQrTzVWTlhXSlN6SC81Q1dtd2drZjhveCt2blJkcFVWNVBPKzZjbm9PbjFwVmRhdnNSWWpXMWh0RFNRQUNvNytnVHNCNTcwcjlwYnZCZE9aYmJrZW1yczVIZGhRNDhIVTh4YzFXdUNRbW4wMXQ2YTg0bjVXV2tsUklINmVCOTlMenVmQ3FBdU9MUnJJcVFNcWZJU3pDY2JYOHJpbEt3azUraDVQN2FlZnBndFdCdHpzMC9iTktweG4xK1EyMmlyVmpBTHJ2ZDVDZjhDY2tnQWUyTTUxL1BTNlc2RENqaDhINGw1SVRnNU9LL29VaTVjNHdSbmJYSXhTNTN4Wlc2azZJODNSNlRFQkRhdlRhZGtkb3pqeHdOWC9wTDNDT3h1enJWbTNsSEFuL0NPTnpBaHpLZTVhbEtLZ2ZmazQvYlJXdWUzU1lCVFVhVTRoYWxraHd0ZG4yeGs2RG00TkErQVplYkVVRktlSFF0R2M1OXRBb3Q1ZG5SeEVjUUVZVUZhRFhJMEgzcTI0MHk4M3lnNlV6ZXkxKzBHczA5cU11V2hiVHpBQ1hFcjhISEhqeDlOU2QzM2RGZGQ5Q0RVR1hFdG41bFBPQUl5cnlja1k5dit2R3M4bGRSdFQySnZDTlJaTXRTcVBVUVF3RnIvd0NDNFBLQWZvZkkwV292VWZFcnRNUktSTFN0UGJrQUtIMC8rYzZzbTBYaXp4dVZsQVUyNXFGZGNIcDY1cWs3QWpMZjVsS29pYnFWeU5QZGJMYTJrcHpsWlI1UC93QTgvdnBkOTk1ZERicER5Wk14c1pRZTNKQXdSenEwME9zM2h2dGNMbHUyVzZJOGVPNGxNK292Snlsb2srQjlWZS8wSDl0WFc1ZW1mYTJrMEIySFhhZi9BQm1VVTVla1ZRK29GWkhzbjhxUjlCN0RVc0JvV2Q5TGtuUE5uSkNSa2p6UFFWN1VobHh2dzBZMDcxblhiTjN3cEhVaENsVXlXeVpEYlRkT1JJVWtlSENDb0ErK000L2ZXd1d4a2lrVVBiS0xhelZRU0dtMngybzd5Q3RSSHZqKzQvWFdjKy92U0xhOVNxQXUzYm1ISHQ2dFJGOTdEc0JzSllmS1RrQmFmR2MvMURCSDMwVWVtZnE0cmJVbE5rN2twTk5yVlBDVXZOclhqdjRHRnBQZ2dqbkkwNWNhSWE0bXQ4ZVhBeXBMUXd0Qi9GanY1ajBvZlo0aVlUTDBjZ0JSVVZERzJ0Tmx1SzVWWUNwQ0pzWlNVTjVXaGFWZmtTT0NjZS82YUJsKzE2QlVxSklicVR6RHJ5bXkyVUorWkMwSHdSbnlram42KzJ2YmNUZjJ1MVI1UzRkVlU4QTM2WVVGY0pIbmozSEgvZlFDdmZjSjl1V3FHbDhCVHl3dDBkL0pUbndQb1A4QXJwUnRIRDdUaXdwbEJTZDlhcWUvdXhIaWxaeURwaXZUcVBqVy9KdDZMVGx5WTBDTWtNOWp5d2x0RENoZ0ZXZkNSMms4OGVORnJaRHBVdG5kNW1nWG5SekovZ1ZJZ3FUSGtQcFVnU2xLN1FGSVNjWVR4M2R4L05ueDc2V0dkZHRHM2gzbXQ3YUNvcUQ3VTJwSWVteDNGWnl5emhaU1I5Q1VnWS9YV29lMFRkTGhXTEZnUVMwbGFRRXBaUmxPQVBBL1RSWGpHYmN1SHJMSGpNa2gxWVVmUkowK1pPdUt0MjIxUUpjdDZXVUE4eFNEM3lrNXg2RHRWWFoyVnQrak1xakpiOVQ1UDVhbEo3dTcyeGpWSHBlNjF4N0MrdGRHejlXUkxwcmo2MVM2UjhTVnhIMXBKUXZzeC93MWR5VG50NDdoenE2OVhHNzZOa05ocTVmNGNaVFBZYUVlakpjVmdMbFBaUzJjZVRqNWxmOEEySDIxbmYwNGRWczIwcTRyYm05RkxrVUdvekQ2VXRSNWhQdUh1OVQvQU1pbGZtK2g1R3FQQU1MaTl5QzVkV1hWQW9Wb25KK0lEOFdoK1dPK3RBK0xlSmVGSVY2WXM4OXBQL01EbFdud25aUDFweTNQeEZOcGRqK29pamRSVldYT3A4QzVhUEloWHpUUkg5UjloNXR0Q21YQWdjcnoyZ0FqaFhiN2M2SVZRNndkbitzL2NPMkx6ZzdmdHdVVUdudVQ2SldLeEJiL0FJbEhEcVNsUTcwcVBwQlNUdzJDZnFlZU5aODlibXlHNGwxVHJjcEZ0Mm5QbE5WQ1VLZVo3TGY4cU9GcnkydDF6OHJhQVNjclVRQW5KT2lUYmpWdTdaVGxiYVdmY2Fxb3BGUFpicUZ3UTFLRFUxN3QrZG1NZlpoQndqdTRVNFFUbnRJR3R4a1RMdHhYdysxRWp2Y2kzdWJtSTZBYUgwOU42elNlYlp3UGMzcEw0NWtweHlET3BKMTA3NCtsTjVlSFVSc2JZcmp0SWVxNjUwM0J4QXB3NzNNNS93REVWbnRRYzgvTWNnZTJxbHQxdXZQM0FGUnIxZFlaRVA4QWlDUkFwcnFBNGxwb0p6Z2hRK1pSOGs0OCtNYVhDVTVCb3pUejFQaGV1NndsVGpyU1JrRDZJNDl6d2YyKytpVDBxV3RkdGYyOGlPeTRxbHo3bnFUa3h0NHJ4OEswRDJKUVI0N1VwUVQrcDFtOS93Q0FiVHdYWmkrbDRtUXRRd3BSN2FrQWRNNDNxendYeDFmT00rSXd4NFlTd2hKSlNCOGhrOWQ2MGo2Zk90Q21Lb2ZwWERWMHRwaHRJUzYyMjN6NmVBQjJwSHVBTVkrdzByRitiYVgxdWoxUjdnOVRGNVZOdFR0eDFVRzNvVFNWRVFLYzBsTFRTVmQyUDVoYWJSbkdRbnVWNUowUzdCc3lqV1hUVVU2SkhCY1hncmZXa0ZUcS9xZnA5aDlOU0ZaZktuQXlUM3F5QXRJR01EMy9BRS9UU1Z4WjdVZUk1dG5SQkJUeURHVGpKUDdWcHNUZ3V5eDdndDlTU1NvYTY0R0RyL05hRVFybDEybFJxbFQ1TXhxVTlOYUNYcWlXc3ZkZ3lBZ2ovQ01rNEgxMWE3WTNpdCtrVTJEYnoxVmFVNThDQVhpU3BSY0I1SThmS1J4ajdaMTZiaWkwS0pCY2ZxU21XRzB0RlM1RHJ3U2hzZlVxUEdsTzNYNnRObzdLY2tKb1Z5VStjOUY3bElhVkxiU2pQNmtnNDBJc0R0NzRwYThGREpXUnNjYURwdnRVVitQRDFraitJcDBOZ2YyazcrZzNvM1h0dUZIckc0Q3FkQVFaT1hpOGlTdVhoTFB5OXVFY2o1Y0E4ZWVUcjFzbWRGaVhLN1Vud3RTVDhvQ2VRckl5bzRIbk9BT05aajNCdTlSOTB0MzVXNE1LNEdGVEpFaEpaYmFySzBJaUJJQUFiU2xRK21jblBKMFpMWDZtdDFyTVN4SGhWZHhiQlVlNHZOcGNHVDVQY1JuN25UemRQWjFjMFJXd2x6S3VVY3dJSUFQWEIxL1NzeVQ3U3JXNFZ0aEJBem9SV3FHMjI0ZEhoaU0vVnFtMENlOURqempuRGVmNkJuMzlzYXRkZXJrSjJaR2h3cWdIUGloNmdBOExiSDMvQUZ4L2JXZld6dldKRGwxdWwwUyttS2N0aUl2MUVTVzIxRXFVb1lTVkpVZUI3Wnh4d2RGYmJIcUxxTjEzeE9yc2lzeDRrS01zQXV1dXBEU0dVbmtjNENRUWVmcHBZazhGdmpLSkdnQXlEMFBZQ3E2T0tvN2hTV3prS0lIcGpmTk05ZXMxcWcwOWlFNkVJV3NsVGFSOHdUeU9jSDlOVnlodlFyZ3QyNFZ4RkJDR2FnbHYwM3Z5bkFHZnYrYm45OVVXUjFRMk5mY3BiTnNTSlZRVkZXbEQweUhES1dFQXFIYWtLWGd1SEhza2VNbkkxenIzZGpXaHRkY0UxYlBaS24xQjMwMWRwQ0VMSkpIUDJKMG51MlgzRlpZUWtoUjZIenA1YXVNVjFsTGlGQXA3anZYTkxuVmlSZEFwTkNuT09TZzhoYUhRdnRET0ZkM2NTUDZRUUNmMEEwYUxsdWUvTDJyMFpGU3c1RzlBdkJiTG55TnFRUUMyRTRJN2xaejNIbnlPTkw1dEhWR3JsbWt1VjkyR1ZMU2lYS1lDVmVzNWpJanBKeVFPQ1Zram5nQTZMTXZkTzJOckxhRWl0Tk9vN2tPSlpXd0M0a24ySjg5cVFjQWsrUGZUSENGNnRzQk1ObzVDL3dDem9UM1A3VkE4OUVlazg1d09YKzZ1bXFVUmJGd3J1dHVHaVROTENSRmhUSFFodGxZSEpVcElLc25qeG5uOU5STDdLTDRTeVkwaDB0UlZxTTJsb2VMdmM0cFhEbVZZUDErZ0dvT3h0OElsNVFKVlhuMDB0UzBSejIraXI1WFFvQS9MKy9qM3dkYzlpL3gyRE1YY3pFSlNFek83MG9vY3dwWEdTU1BQOTlHNE5ndUh1N2pzOVpRNGpISms2ZWc4c2RlbFhuYmhGUXBDV3RjMTE3cjNFdXliVWVzMmdRSHBVbVcwcGJpUzZFcUNENUNlYzV4N2FIbEZkciswTlBvdTYrMHR4UFUycEtlTHdscHgzdHJXbGFmeXF5Rll5QVFvZTJpTmVGSGRyamthcHZRa0puRWh2RHZCUWprSG4zNDl2dnFvYnVUNGNlM0F5MzJJYml2cENHayt3Q1R6L2ZHZ0RsNGNpVGZEWldmRXpubUcrUjZkYUt4Mkczazh6Z0NrcTBJTlZ5MU5wcWZNanF1T3JUMzU4eW9yTW1WTWtySzNYM1ZrcVd0YXp5cFJWazVPdTJzYlQyOCswb2ZBclNjZVFySS96MUs3V1NKVll0YUthYkZVdHBLUTJYRkh0UUNEd01uZ243RFZsa01TU2xYcHdESVcydnRMYmFTb2srUGZBT2xxVE11enMxYTFMSk9UdWZ2VDBxZGFJYktVcVVCb05CMDA3Q2hCVU5zWlZBSHgxR2txN1IrWnR3WkIrLzIxWXR1OXhJTk5rQ0JXMTlpdkMyMWVFL1FqWCt1dTQ3MnBMcTRGVTI2bXgrOEtVdzhYbTNFT0lCNUlDVDNESHZ3Y2FvbDl2R1ZSRFhLZTJrdm9jQ1Z0eGozclFvL1ZQbEkvVWFNUjRVdTRJQWZBVjF5Q0Q5Y1ZISDRpdE1wWGhJWGc5QVFSbjYweEZQclZ1MVNLREhxVFpIYmdBcXhqNzZxbDZ6d3BDa01BNVBuL0FLNm9PM05EM0VmaElrVk44UkJnRVIzUG1VUHBrZUFmdHExeXJScnNrS2RlcUtsTEk4OW5uN2FGem1ZREw0Q2NBamZIV2piQlMwcks5UlVIYmx0MHFyVnorTnk0cmJ6elJJWVd0T2ZUendTUG9mYk9pdGIxcFJHMmtPNUtpZUNRQUJvWFUxVXF6cFhveWtsYU80OGdlRCtudm9tMlp1SlFKc1pFZEVsT1JnY25uSjE3OTBYUGM1U3I0Y2FWRktmVXBLaW5yWGRjTnJ4U3NGS3hqcytkSlJnZmJHcU5jTnFOTkJaYlk0UDE1em5SR2Zrc3kwS2RpdU5PSjhCZU1rYzgrZnBxczEyZXB2dUxrTlRSYmNMZmMrTUR4N2ZVNnBDMFhLRUM0cjhJb2ZFaytHNTRham5OQTY4N1haWWVVK2xBN1R5UUJxcnNYL1U3SHFDV1hKS2xSVnF3Q3J3Qit2NzZKOTJLaVNpNnZ4andTY2NmOVBycWcwVGFIY2JlNi9QOW5HMU5qdlYycE1sRGsxcGF5eEZnTkw4T1RKSkJFZEI4aEl5NnYrbFBPZGFKd2ZiTGx4QktUR2pvS2oxN0R6SnIzZStJYmRZTFlxVkxYeXBHdzZrOWdPcG9qYktXTmY4QTFMVlpORXNDR294WStQNGpWM2trUm9nUFB6S0h2andnWlVkTEIxRWJ6M1RiMjVWYjJmdEtHSEpGSW11UkoxUWVUMnRnb1VSbEtUNXlCbjdhZmJaZlpLWGJuVVJhbGlUZXFDczNKTnRTRkluM05hMXBNSWhXelN2a0NXSTRhYUJVWGk0U3J1ZmNVNHRLRGxJenJOL3JBcE5kbmRiTzRkRHBEb1EwOWNEcSs1YnZhbElKUGNkYnF2MmFXYXd3a1BQL0FCdTV5U2RCNkFWemxlUGF4ZjdtbDVNWWhwdlFKMkovd2FxRlozUHVWNk9waXZYVk5xZ1NBaEVaUzFCaEpIMFNNQS8yMUdHNHFrKzEyc3dRM254NmFjRC9BRDVPcHhxektQTWhOc0p1VjVwYmJuYStsVFk3U000eUQ1L2ZVaWJjdG0zMjB6WFpUanJLVUVrT0RBL1llK3JVYVM5RVJ5UjJ3ajVZRloyNHE0M01lSzh0U2xkU29rMVhxWlhhOHc2UXl0VFp4emtjQWZmL0FOZFdHazdwWFBEVUVJbktXaEErYnRYZ2YyMUZ0VzllZFJrQ3IwdWxodW5MN3ZRVzRlMWFoN250ODl2NjZoTGttS3BRTVlzcVRsQ2d3cHZqQ3ZxZFRKdmx5YmRDRU9BK1FvVFBaOTJBeWRhYXpwZzY4dDA5bDNsMXUxN2hmV2xsQ2c5VDVEeFcyNmtjOW5hVGdmWWpTMmRaSDQzdlZWMVFWMmRZMXJ6NWxwMDV4NVVhUzNIZVB4cjNQYVVMY0gvREgvS2pIbnpxSzI4cWlhUEJNZVhQV1Z5VmpsZkdNL1U2NHJMaFczMDdkWHRIM2p2RGJKdXRXbFczR2tUSnlJdnEvd0FQazkzYVZwemtKVWVEM0VhMEN6VFk3cVM4Nm5tS1J0blRQcHRWNjB6NTA5dE1OcGZKcmdxQStJSjdaM3hWNzZFL3dpZW9McWR1Q0hjZDlRWmxJcEVuRGphbjQ1Vk1scFBKV2hDdnlKUC9BTlJlUDMxdDcwWWZoeTdIZEpGc3NScmR0S0dpY1VKTDczWUhGcVYvaVc0cmxhdnR3a2V3MWFPbldzV0ZIc0ttVmF5YVo4RkZxTVJENDlZRU9yQkdRVmsvTWYzMFlhY1BqNDRrUDRiYlVNODhGZjZhYUdYWHJqaGJ4MDZKR3c5ZTllSlRyRnZKWmlwd2RsTFA0aWYwcnhrVWtUVWlSRmRMQlIvNGlSK2NmVFh3N1ZxZkVqdXV6M2tSMHNwL21LY1BhQVBycVNkY2JVMmx0c0VOb0dFcE9ocDFPYmJXanVwdG5MdGk2N3htME50U1ZGRlFwOHdzdXRuQjl4N2NuOU5XM2wrQzBTTk1VTGlOaVJKU2hSMFBZWm9YZFRuNG1uVEIwM3huVGMrNXRIYW5KQjlPSzlJN2xrL1pDTXEvdmpYWnRoK0pmMGxibDJCUzc2cDI2dE5iWnFVYjFVdHV1aENrbkpCQlNya2NnK2RabzlVZTFYNFNXMmRObDJTbEZUdXk3WEhGSm1xdHlTOVU2ZzRvZzVKeVZCSnlmYzhhUVdzOUp2VXNxcnlWN2RVT293YUVwOWFxVEZyVnhRNDh0REJKS2ZWYjlUNUZFY2tmZlVNTmJUNlNwYmloNmpBK1ZISjl1WEhTbExMUUk5U1Q4NjlCMUdTZjl2RUNqTVUxTUFVdXFoMXBMaFBoQUJTUUQ0QjFvZllYVlRiOUFvdExxMUZyamJZclNVdFNvN3lNcGp1ZzR3dlBLUms4SDlOWm03OGJYVnFyWEV6dXRhOU9janpvanFTR0huUWtURzBuNWtISDVTb2NaKytqSHQ1dWZaTy90ejJyUUxWaHlLUkFaZ3FOYXBTVWVrdHFVMmxRUHFrLzBwK1VaR2U0cUgwMXpqeFJZSVYyaVI1akFLZVFLNXluKzBnWndmWHAwNlU1Y0I4UlhSVGppSG5VcnlVSlNnOUFPMk9tTjYwK3ZPOTZSQTJxblhkTmp1UzJhVFRsekdWdHh2bWQ3VUVsS2M0em5HTW5qNjUxbjd2UCtJRGVGZGNjaDBEYVppRjhSaFNIWnM5VDVYazhuRGFRUHJ3RHhvNXp0NnA3VkRidC93RGl5bm9yTEFZTEpjeW4wd01kdVQ1R1A3NU9sZTZvSjIxZGR0NTVpazAwME9vc0s5V0hQcEt3MHBoejJQYVBsVUQ0d1I5ZElmQ2NHM1NyaUJQamxhaVFBcm9QVUFqOWEwZmladmlOVFlWYXBJYXdEbEpHNThsZEtFSFVOdkxVSy9RRzZwdVJUNDdLR1hnN0Noc29VMnQxekI3U2s1eVI5L0dCcHBmd3krZ3JkamUyeklYVWIxRDNCUHBOblNnb1VLMm9UdnBxcUF3QjZyeFB6SmEvd3BUZ3F4a25HTkpYc2R0cmRQVkIxRDJ0Wmw5MUVWVlpxanZ4THFWSHNWR1pDRmRxVStFanh4K3V0NllkQ21XL3RuUjZkVElyRWVGQ2pwWmFZakorVnZDZmY2Y2UrbXoybjN0dmhXeUp0ZHVBOFpZS3NnWjVFRTQrSE8yZSsvYWxqZ1cyMzY0VFZ6cnMrbzRPQWtrNHoxSjZlbENXdmJKV1pZOVBGT3NTalI0VUpCSlZIaXBLTXFQOVJJOG5JOG5uUTh1T0xXYVhseWx6WFd3Qjh6VGl1OUN6bjNCODZKMjVGNFBVbEx0TUJVVUtBSlNSam54NStudnFxUktMTHIxSy9pVGpXV1gxbjAxTDRLc0hHQmo3NjU2dDB1Y2x2eFpDeWM5VHFUNjF1clVjSmI1aUtITmFWVGE5RWNNMkUyekpiU2N0b1RnSDZxSC9BSDBFTitkdUlsZHQ5K28wcVVZOVdwekNuYWRPYkg4eEpUODNZY2ZtUWNFWTBSK29ldXlOc0xMcWwxS1NKRDlQakxlUTJGZW1IQ25KN0NmWWV4T3F2MHI3Yjc2ZFQyM3lOeWR6ckpSWnRCcUxQcVFBWlpkbVMyU1NQVURaU1BTUWZaU3VUa0VESE90UXNpWGJkQU4zTGdTeWhRQnlSa2s5QWs2cXlPZ0IwcUV6WUFlRVIwSHhDQ1JwMDdrN0Q4cUZYVEovK1VMdjdMZW85S282UkRndGRzeXN2cklhUm4yQUhLMWZZZjMwYm4vdzk2elVZcjFXdVhjaVkzSWRhd0hJY0pLZTM5TzhuT2k5dDd0VFkrMHR2UjdTczh2UUlqUUNGTEQ1SzNNbmxTbGU1enlkV1c3ckd1S2lRVVYxdTU1aUkrVGdDVVZaKytQWVkrdWhsMzQ1ZmV1WlZidVZsczdmRGtuek9jNHoyRlUzSWNWdG9LZlR6SHZTSTBuOE9YY25aamZhQnZUWkc2ZitzRGNWNVh4bFBxa2YwWGkyb1lJUXRKS1NSN0FnYWRMYmJmbW55NFNXV2FtcHQ1ZytuSWFKN1hXbEFZS1NENFAvQU9Pb2VzVEowVSt0S2ZFaElHTzhJd3JIN2VkSnYxemJqWGpzenVUU053YkNrS1pSVU1NVkZqSHl2K2V4ZVBjZ1pIMTRHakNEY2ZhUkxiaXpWSjhWS1NFS0FDYzQxNVRqSG5nMVBiMTJmaCszdU9OZ2hCUE1yVW5mcU0vWVUwM1hqUWFudWIwMlBYdlVLNlMxUjYvRVV3d3RXVElXNTNOa0FaL3BDcy8zMW4vY3pMa1VMaVEyTXFjYXlrcDlpazQ4YWRMcXMzUHAxUTZhTE5vdEVNbEVTcXVzekhHcFBZSGloRVlyU1ZkdkhjVk9keEE4ZU9kSmhlVTVNVnhoNUQ2djVycmdVUmxKR1U1NS9jYWVQWjlIbFJyUUdsOUZyQStSeCtsY3ErMnlVekw0cEpaMEtVSS9NWkg1WW80N05kUjkyM2x0czF0TmVqaWgvQm13QkxjV1E1TllQQ1VML3dBWHBnZS9rRk9mR3BOKzZLZGI4QXFEeVZ2cWY3WWFCOHFsSy9NQWZva0RKSitnMHRGZzF4ZE1sTzNKVXJnUUZMeTB4QktGZktqT1NzNDkrT0I3NDFjWVYrUDFPcEZVaFFEK0EyeTA0TWhsclA4QVY5RnE0Skh0d05hZERqdzdiRklhYkFPU1RqdWF5bVZkN2xkMXBWTGNLMUpBU002NEEyRkhxaFQxVk9FcDFEQ1M0cnVVdHhhODl5ajduSEI1OWo0L2JUZTdFMWFoV2pBcHRIZ3BTUkNwVGJLRXFBeU00ei9ubjc2VHphV3pMcHExcFAzaXc0bHFIR2tKRGlsbnREeWMvT0VEd1NNYzUvYlZtclcrZDFSSkxuOEZxS282Rk5sQzNFNEM4RTUvK3o5dFpYeHhicHZHMGhFU0VySWF6ekhPZ0o3L0FDNlZ2WHM2dUZzOW4xamR1dDAwVy9vMmdENGxKSFhCNkU5ZktuUDNHNmdiWXR5aXJyTlluSmdTbTNTQUZ2SlNrak9Cd1NEL0FHSHQ5OURDbTliOVJ2dXF1YmY3WlVGRlVyYnZja1Q1eFczRWd0aktSSWVTQjZoQndjTmdCU3lBTXBIT3N4T29YcUlxVnRiaEpwTk5ia1ZHbzVTN0llbVNYQ2tPci80WUF6bGFnRG5uakpBR21zcys4OTBLRFkxR3BsbDArTFJhbW1sdHJyVlRlZURzaDU4b0JjVUU4QThFWTd2SDI0MEFkOWs3Tm5pSWNmU0huVm5JSjBTUFVEVWo3MFdaOXJLcnkrcFovd0NCbEEyL0VvNTdIcFU5MUs3WjFIY09BN1Y5N09vMnJ5ZXgzMDB4NE1ORVdPVkVaS1VJVVZFWVQ1QSt2Sk9sbXZUcFIyb1pvVDFlb2RxWGJQYlNyRFQ5VG1CaHA0K01wU2xzcklKOThjK0JrNkp0VzNJY3NxZjhYY2M5dXVWRmFpNWlhZjVMQ2xlQWordDlmdmxDVkFuN0Fhc2p1NWRJbVVScVBYNm8weXArT0ZlZzdJU3l0YXp6bkJ5NmVUNENVL1RqeHAvc0Z0dWxtWVI0am1FOUFrQkNmb0FLUWJ4eEZFdk1rK0N5bkgvWmZ4SytXVCtsSTlkZTNsQXRTb0lYV0xBbFFXM1hNdHRCYWtPRkE0NGJjSmVBem5rcFNUb2pXRnVLeFk5UGlycHN1Vi9DaTRGbGllQ2xDdVJ3bGJ4eUR4ajNJOWhxKzd2V08wOVJGb2pRbkcyQW9sVGRQaHRSR3U3UGx4eFA4eGYxeW9rNlhLNXFwVzZQVVg2SlNMaXA3VHIyQ1l0R212enBRQThmbkpTZy9RajZlMnRKYkNiczJVT0RiWHZwM3BMa1FUQ1BqSVVUbitiQ2oxVytyZmJXMzdnVTVTTFZsVkpxTWdCTXhtYW1LeTR0UXlwdFhxRGtaNDdoOU5YTFlUcWVvKytvbFd6L0FCeGlpVGhJeUlMbmU0WEdCK1VwZUNBbFpHUEgyenpvQ2JSYllVeXRwWFZMcGd6Skw2a2tsMjRsQlMrRDV3TTQ5dk9yZGRXMzY2WEhSUHRSd1JaRFNRdGxwREpBQitxVG5HUVBiUVM2MlMxQ0w0SVQ4UTJWblk5OFVjZ1JTKzBGbFh5cDViVjMyMmNzU3pvbG9VMjlZZFBxTE0wU0Z1dVRrcktuQ0NPNVN5ZUNSN0sxY3JqM0xwRlFzMWwyVlYyWjBWdEtwcVcwT0JhRjlvendvZVJ4ay9wajMxbHh0cGZOeE9ialNrM2hjOFpiRGJ4UTQ1OFBrcEo4SmM3c25qOStDUDEwY2VtZmZOMmticGY2Z3k1c1dYUTZyL0xobFJ4OEc0VCtVQW5IWXJ4ZytENHhyTEw3N01HNFRSbk5PRmFrL0dRZFNlcHdjVTRXemlKU014MXAwSXhrREFHTktmenBiRnhMMlhoWHhjaUZNeWFqTlhKRFQ1Q0NHKzgra01IbEtVODRCOGs4NnNsMndhTnVEU1hZbTRrOW1sTTAxNUpaVzR2MGlVS0pVUWNITG5jZlk4ZVRnNUdCbFVPb1czcmF0aDlvMU9NNHhEYUxicTNGZ2xSU09NQS9RKy8yMHZGeGRUSjNUcW53TkduMUFVaUhQYmRxTWhwbjFuWkhhYzVLendHd2NaODU0K21sQzFNM0s3dk9QRkhJbEp5RGpVZGdLTTNDOHdyZkZEZVFwWGwxOWFjK3hhN3Q2S2dpZmJheFU2WkhTVXV5NVlMYmZmM1lKUm5rZ0QzK3VScTUwemMrYzVWWEhXb2pjV25BcFJoS1VqMUVnRUFBbnlDZnBqMzBxY0RxQnFGK1ZSTkoyNmlBd0ljVExyb1pQODlTaDJueU1rK1NNL1RQdnE3MnZIdW01SmtPRlg3c2NqUjByUVhwY2xBVjNMeUQySkNRQURqMjFRdktwSlFvUHJ3b2pHcDFIbmdkYTgydThpVytBRWsrZzBvOFZTdHZ1dVBWVjk4K21nRlNja1lJOWdQcHhxSHRiYjA3dDFCVnhYVEYvd0QwRENjeEdoZHhIeDcvQUp3ci93RHhwUGtmMUhqd0RxbVZpL3F6ZW00OFhiUzFIbWZobnBLR2xMUzJFRm1QZ0FySUhsWG5BK3BIMzB3Tk1nTlIxNGhvY1JCaW9hVENobkFRa0lCK1k0OGtra243Nno2RGJGc3FMcngrSlErSHY2K1ZQazYrUjR6QWFiMzYvdFhwUjdWa3dZRGIxYVZFaWtKS1dvTUJBU2xwUDlJVHh4OUNRQm5YMHhUUVphb2tKakpTckFVQ1ZFOERQZDlOZEYyWExXR1lqQ0tUU0hKY3VTNEFocHRBeWp3QWNrNEF6ajMxNzIxWEJGZVRHcThKUnFDbkV0ekV4R2l0Sktza0tLampDUjduMnhvSGNXSGtKNTJnT294bjZtaDBPWWw1d0ZSTlFGeTJuUzVDSERNcHdlZGJHZlZXakpRa2puQis0NHhvUFh6WWpkdVEyYXRUZTRPK29VK3FvWkxpVHdFcjR5ckdBQVQ0R21EcitGRnlNeUVoUlA1UU9melk3VDlENzZFVzlqek1TbE9Sa3FJTGF3V3l0WGhXUi9mVkd5eko4T1lnSlVkVHRSN3cyWEZnMVdkc3JrUlhxV2hWUlEyekpaZExVbERaUGIzRDNHZnRxNnZ4SDU5TVUzVEpSYWVWa051aEdmOEFMUUgyMnVGMmxiZzFHa1RIUDViellrTmduL201eC9mL0FDMGJxYlBDb0liU1I0T0Y0T0J6NzgrUCsrajF6dFVsVTByYkcveGJhYTArSXVDVEJRRkhVYVZFVnkzcFRWTVJEcUVoTXg1S01PUCtsMjk1R2NuQS9iUXpyelUraXlUTnBraFRhZ01nZzQ3dnNkRkN2VnBjeDRyWmtwQlQ5VGpqR0NUajMxUWJrY2lTb2JpMU9nT0JXQzBSODJQMDkvcm5YcTIrOE51WVdQNS9PMVN4NXlDTUUxS2JkZFJjc1Jrd0ttaEpVbFhhcFFQemc0OFk5L0gyOERWbll1YVR1TlVrVzdiZENtVDZsTlBveElzZU9WT0huamdmNW53QjVPaDcwM2RFdS9YVS9majBteklZcGRyb2RDYWhjMDF0WHc2RkE4cGFBNWZjeC9TbmdIeVJyUTJpZFBGbDlHZXpjeXFiVjBuNCtxeG1FTHFkWXFxUXVSSlNGcDlUeHcybnRKSWJUd1BmUG5XOWNNK3p5NjhTdElMcDVJL2NqVStRL2VrRGluajYxOE9sWWIrTjRkQnNQTS90UzVVSHAralVPd2IzcUZScHNtcVh6YkVSS21LSkZTMy9BTHQzZ0tMakpYbEw3eVVGWFprZG5xQWNLODZvRjY5UUROTnRTTnNGWU5zMWl3b1U5UHB4TnZyY3FMYXJwcXNwNEVmRVZTY2p2VERXc251S0UrcEpXZUZGc2NCdHExYk5Ocm0vU25oTmxSWWR5MmVwRTE2QkpVeTY0bERnS1ZKV25sS2lra2R3NUFQQnpvYUsyZHN1eWRrcDFsN2NXRFFZRnhYRmVick5OY0RBWEpVRXk4aVYzS0pXVk5OZ3I3czlvSUJKSlBQUmRoNGVzdkMwTk1lRTNnYVo3azlTVHZYT2wwNGd2UEZMaTNweThrS0lHTmdOeGdiYlZCOUZlM3ZVWHMzZGRPc2JkMjM2VFM2RTVhcTNJRUtudXN0UE55a09KNzNaVExaUGM2NGs1THFsT0xKQ2lTbnhyS1RxRHVWNnNkVk80ZFlWSUppU3J0bWVrdEtza3BEcEdCbjI0MXJadDlNNmRhSHZGdUFtaDI3UGpYalpORWVLcDlka091UzZnMHRvcWNsbFRxeXB6S2gyZzRTQVB5akIxanJYS1JVRGVFeTVydWl5RU96Nms2NnkzMmp1VjNyS3NnZS9rNnE4UThyNlU1SG5pcUxhVXNNL0Z0bjdWYmJZdHAyNm9mcDArbnJhS3gyb2tPZXcvVDMxZTZkdHJGczlLYXZjYnk2akpaU0ZOL0VJSHBvNDhoUDExV2FOV2t4cE1FVzRsMTlnbEt5NDN3QW9mbUJ4NHg3NTFKYmdibHpoSVpvL2FyTDY4bFhmM2NhUUpVR1pMZFFDckNWZmxVaTdtcGtIV282NWJnaHN5Q21JZ3FLMUtLU0ZmazdobkhIL0FIME43dWh0eXkzTlU2WEVCd2dvU0NlMzlkVGx5VkwwMEtlUWxLMUtWMmNEdEgvNC93RHBxczE2NlkxcTBOeWRQYVdWcU9TUHFmWURVeTdLSWhISnZTbk51U24xZkZ2WGpWRkNCTGpKYmFRc0lVTzhKR1BiVEw5Ri9VQnRYWWRUUkIzaHN4RlZwa2wxQkNsSUN2aDFwT1VyS1R3cE9jWjBtOHE3bElrTXkwcC9udjVLV2g4eEFPcHh1L1FpQXl5MDc2YW5FNGNUbng5aHEzR1UvRmpMQjFOSGVGUEhWY20xSXlBVGpUU3RNcXYxa2RZamU0VEZjMjRyMXZQVUNNNW1MU2ZnVkZVbFA5S1FzSHRRTzNIT0QrMnRHdW5qZHk1Tno5c3FaYzExMitxazFCMW9KbHdGckNnMDRCeUFvY0VmUWp6ckVYb1I2bHJlc3k0MnJiM09LMVUxNXdDTFVYVDNCbFdPRzNNOCtubjZlTmFqMC9yQTJHNmQ5c0lsWTNMM1NwM2RKYURzR0RTaWw1NTlKSHlodHBCeUI0R1RqNzZjN1Zmb1RpbTJHRW5RWlVyOUQ1MFZ1a1M3c3lubFR1WEJQd1lBQUErWGZybnJUVFhuYzFhcFZvVGFuYk5JTlFuc3hsTGl3MGtaZFdCd2tmOEF2ck1yY1BaSDhTSDhRL2ZxWFplOUZibGJiN2RRMWY3eFFxTFVRWlUxR2ZEcmlNWUNoeVI0SGdBNm50enZ4emxzcVhHMmkyc1EyM2twUk11Q1NTcFgvTjZiZmo5Q2RBbTdmeGplcm1yUzFycGw5UVlKY0pIbzBlaE5ESDB5dFdUNDBRbFhhSDRnSVZuNVp4NWlvb2N4TU5oU1NuVTdFYitucFQ5N2FmaHU5S3ZTL3RKVktOdDVhOU1wbFhrVXQ1QXIwaG9MZlM4cEJBY1VwWHpMSVBQSjFoWnZGK0h0dWpBM1Jyc2FvMzNhOVFlRlNjTGsxeTc0eUZQWk9lNHBXdktTUWZCOGFNSFVQMXhkUU8vbEhYYis0RzdGZmNpcUdISXRPbW1LbFlQbnZMWkJPbFZsN1BiWFNwTGttWXFwcWRXc2xhbFZESkorNVBKMThpMzJBMm9sUytYUGxrL092TDEyakZQSXJtV2Q5RHlnZklWY2R4YnRwMXFWRk5xM1dNcFdDbG1TaFo3RmdFZ2tEem42anpvZFZLcHdJdFZidXEyS3BQWktTV29TNmM1Mk92RUhrcVdjcENBZnFENFBrblRGZFQyeDFBM09FU21zS1JGZFhON2pJUUNGRE9RVHg5Ui8yMVo5ck9sVGJ5MUxHRVJjTk1oeHRzSUszazV6Z2V4MWlFYmlxendiWWg5WUpjVm9VOVBYNTFyOEQyVFRrOFFLZFljS0dFNnBJL0ZrOUI2ZDZWNnRiL1hIYmNkS2E5dUc4bFlRQXQ5Nm5yd28vWWp6L1lhSWZUYjBHYnU5ZkVTVmYwSGRtVkV0R0JKOUtvVkZ1QjIrcTRCa3N0QmVBb2dZeWM5cWNqUE9wamZicDlvOVFTYWF6RFEycVFVdHRLU25qS2lBQmo5eHJTL3BiMnBvbTBYVGxUOXJiTXBnYWpVdW1Nc2xDRThxVmpMamgrcWxMS2lUOTlEZUllT1lGa3M2SDdhM2lTNlNCb2tnQURKT3FkOWdLZVVjRVRXNVlWSWtxVTBub1RqSjh5T2xLNTAzZEoyMFBUcnZGU3F2YVNYWDEweW55b2hseVpQcUtjY1dVRWs4WUJIYWVCanpwekdOK0tSVHFZSUM1c2RLUHpMU1FEODMxQXdSN0RWRXRQYkMxTGl1U1lacXkzRnBoWDNGb0R1VTV6bnQ5dlBCSjE5Vkt4clliak9KaU1xVGdrTmpQajlTZFlUZkx0TnVFaHFiS2VVVnFUak9tY0FrNmoxTk5rQzNzb0piQ1FBRG5UYk5jVzZGMjJsZk15VFdtS28xNjJmNXJKWGhTeWZLaCs0OGFxRWZkR21LcENJbE9xekxqRUo1U01zT0FrT0lQZ24yT2ZPb1RkWGJGbXYwMTJudnBjUUZKSUsyWFMyNG5QMFVua0g3NkF1OWM2dmJIVU5MOEo5U3FZeUFoeFhhTXRxUEFLaVBPVDduMzg2TVdtMHc3enlvUzVseFIwQjIvd0IwV0lrc0tBSUhoZ2I5Yy90Und0aXhxQnYvQUh1S2JjeURJbzBaeEwxVGFVYyt2ODN5cy84QTNFYy9ZSFRWM2RSNkk1UVlWT3Q2bkdORVF5Z2VtUUFFNEdBTURqMkhISGp4cE9md3pMeS8xOXRPNGJnbnJDMUd1cFIybFdUMkpaQlRuM0hrblR1MHlHM2NGQ01Cc0pRRWhQWTRua2xSNHdSOWZIajY2RmNUcmxSSmp0bnorREdQWFFuNjFVa0JDbkV2ZEJwUU91L2J5cUwvQU40WTdYRWVPd0R3ZWVEcU5jcWRhbFUwMjlXSm5lMncwU3lsMVBrZTRCOXpqalJ5YjI5cXN0eDFwNk9HMm1TZTliaHdsUDBQUE9DY2ZmSnhxajdwV1lhQ3FRWGZUVXRDY05xWDh1Q1VncHg0SlBKL1RHZEFZeXB2aEF2dG5sQjBPT3REcExyWVNVSVZucmlnVGRzbDZDNkVwU2V4MUJLU0RuQThZMEh1cFZoaHpaRzZVbTM0dFNkVlJIL2hXWkxTVkZ0ekdRNGpJeWxTUmxReHprYVB0Y2VhRk5VdzVCNVNEMnJjSU9mSGNjKzJkQlBkK1hDUlRwbE1lVW50a01xYndCNTdoamo2K2RhRnd6SUxjOXBZSDRWQSt1RCt0RDR5SkVoaGFWZFFjZVZMM3ZUdlBibTUyMWRGYXRxNFl5bjZDR1V0TkpjQi9sZWlFS1VCN2NkdjdnNkQwNnF4NmpEWkw3cWZXYWtvSzFleEJPRC9BTmRIcmFicEoydjNGcTgrbVhUTG14bmFhK3B1Ty9TNVNZeVhHazRIY1d5Z3BVRkE4a0hqa0VlTkIvcUQybnQvYXlzU0g5dnIxWnVDM1M4dGhNeHB3TGNpUG9VQ3BsMGdBSC9sV09ENDg2Myt6U0xUN3dZRVlxeUR6YWpUNGpuOFd4ejJPRFdCKzAvaDI0VGVTOWZCZ2dJVWtIWDRkTTRPdmthcXRZZlhRM25aY1YxU1ZOZjBvQndEK3YxL1RUQTlPSFJQdUR2bklZdTVjV1pUcmNaZlQ4UlZYSTZrSWRHTWxET2VYVmUzY09COVNkVVd4ZHM1TjYzQXhYWTl2Vk91VVNqUHRTSzg5VG9QcUlaWkI3KzBra0R1V0JqSHNNbjIwd2QwZmliM1BWWlVha3hhWFVZVktqNFF4R2dQTU1wam9Ua0FCQ1BBQTR4cUsrejdzSTN1OXRSbHdqVldSOEk2YUU2azY0cGI0STRac0JWNzVlbmVSc0g0VW5QeCtweHQ2VmRPcEM2YWJZZEhwbTA5bk1NdzJJalhjcGhrY010cEh5ZzU4a25KSlBKeG9FdDE5dVpPTEtIeVdXeVhwY2x3Wi9scEhjcFJIc0FCd1BmenE5MTlxd3VvUzM1dDY3Wlh5cVpYRS9QUGhWSjBoYW5jY0pjVDV4OUZKeW5TaVhKZlc0akZZcTlDZWdTbDE2b1MxVWloVUpsZ2hNZHpndXVxVjdqR0J6bk9CNEJPcVBBME54TWRjVktpRnBPVmhRd29rblVuUFRHdWRzVVg5bzl0bno1WnVxaWt4VWdCQlNjcENRTnROdTVvY1h0VzY1MUU3NlRhcmJrYjRadDk0TGFXcktVUllqV01PTFVQeTRRTzRuNm5BNXhvbTJ0dlZjbHoxVTdmV3pVUzdBU1NpWFVYc2dTRDNjcUtsS0dFREF3anVIL01lZFVtNXFTM3NiWnRVMnRwMDlNNnZWT1lEVjZuSGJQYWhvSkdHRW42QlJVU0I1SUhzTlh6cFp0Q3hvVk5ialNsTUlxaXozRitTMTZxd1A4QUNrZmxUbmoyMXJjaEVkK09QREFJU01JL2Y5cXpTMUJGNFdYUVQ0STJ4L2Q1K25RZldybFhxZTVibDNVS1BXdHhJOXhSNXgvbnhhUkFudUJ0STdRR3o4T0cyaU1rZm5Vc1lIUHRvNlY2MXFURm9wcDdyRlNqQkxRSGN6OE5DWVYrbmI4NHdQSC9BRjBFdDZLRFhaZFFoV3hiVEUrcHpKNjBOUm85U3JSaVJ1N1BIRFdEOStkR2kzSTl4eExjaFVXcDF5Z3R6R1drSmwxQ0hGVThoTGlSOHdiQ3lTY2VPNVFPU0NjYVU3eXNwanRGdzRVQ1JqVDYwNDI2Qnl5RkpaL0NlcDZEdFExaTA5RXU0NmhiemxWaU94WXFVdE9QK3RLbXVCS2o4b0tGNFFTUm5ubkdvK3ZiUjBtcnNtSlNJRTJXRkpQck5zMHRFVGc4SEswanV4K284KytpUnVPdTFVVS8rSFZyZGVwT1BxR1dua0tQY2hYMDdBbmdlUndmMjQwdU4wYitYSHRGWG5hTE5xcjA1aVVGQ0JVcFVrS1UzL3lrZ0QzeDU0K3VOZmJRcGR4ZDVBU0NQT3I3OXY4QWNHUEZjR1U5OEdvcUREazJWZTdGR3RDMnhDZlhKUWxLSjlUOVVMSk9NSHZQeWhSNUpIdG80N2Y3U1huZk5WdUNtYjRYSTliWm84VmlUQ2lyQ0F1cHBkQ2xKVTBmSHBGS2Mrb0I3Z2ZvcTFaM2xhcTkxTjFlQTJxUlVqS1M5R0RUWTdGTEdEMjg4OXA1eURqakkwYXRxSHQzOXdKOVR2eTZaS3AxVGNZUWhjWUxHRU5nZkkyMmtjQkNSOHFSN0RqUnk1c2VBeUZ2a2VXZDgxWGplRSs1aGtZSFhHY1Z5YnZNRzA2cUk5djBlREJaU1NXWEdVSHVjU2Y2bGRwT2M0emsrK2RRRml5RTFiY2loU1hBb01lcjZsUWtzcDVZN0ZBazRQSkJHRHdmSVAxMUNialhTeTdXM2FmVTJIb2N1TXNoMXFUa2ZxUm54OXZiVnoyZ1RYUDlVMzY2MC9IZVpmZCtHY2NTMENzTmdBcFZ3T0VrOForcVQrdWhyemZ1MEhuVnJrWTE4eCtkVStLNzVHdGNBS3dPYklBL21jMFRybmN1YmRtYWJOdDJ2TERhWEE0ODQ2b05JVWdxNFNlYzVQa2oyMFhkdWR2SWxDb28yMXBEckw3azhyYnFNcEhIcUt4NFJnY0FjYytPUHZwVzR0NTFlclMzSnNhWEdZVlRwSHBscHJ2OVVrRGtwUWtIT0NmSklPaVB0UnZQZGxuM0t3KzNKRXRDZ0U5cnJDa0xTcmpPQVNjOG4rdy9iU0plckhjVXdRaU9vQURVRFlrOTgvYWxXMzN4c3ZKOTUvdTNPYzZVL0czRmxOV3RTb2RGZ1UxRkxEckxUSzVVaGxLMWxLUjV3UGY3K2VkV203YTNScVBiUnB0SkRUQ1VlSFVNREtqL0FJeDdoWG5ueU5CUzF0ODAxQ2dtZkpxTFRNZ3RnT0tXb2pBSDlJSHRvZWI0ZFhsdjBPanZTcGRTZFBibENHWXF2bWRYakFDZmNubjIxaGYvQUtldTEzdVNVNFVWNTE5YzF0RUNkRGpSd1c4SEkwb3dkTWI4SzI3N3FpNEZSRXBUV1hYSFZ1RlJIZW9oQ0JuT0JqUGs1SjUwMFZqM2xJcWNaNHpIUXBIWW9OOTUrVlFBQTgrd3ljWjFtbDBXYisxMnBWTzRhcGNzZEVRVkNxUlVSMlZubGhuSFlNNTk4ckpPblpZditDeGVjR3lxUE5MN3lVSkxIYUFsRWxLazl4S2djL1R4OWRHK0liSElnU0YrSU1rQUFxSGNnZjZwV2szWmFaNWJ6Z0RwNjB3c2lyVXh4MUxLNVp5bUtFeUI2ZUVnRVorVW55UGJJMS9xQmVDa1Y4UW5yWFN3VEdIcHpuRllTcnpoSXo1SUF6L2J6b1NWM2NtNEpUa09uVTloc3lsSkNuMlhTRDJKN3VRVWVTb2ZiZ2NhbmsxTUtaYlRPaE5sSjdYR0pVa3FVdE9CN0RPQW9uMlAwMGtTbzhaTWNMZFQrK2FZNEYwY2RjRGJScTMzRlc0VkFha3lWeTFyVHgycHlRU2NaN2lmYy9mUys5UUYrbytBNzF1SkRpbThnZDNPY2FsOXhkejBPMVY2Tk5sS1FscGdCUDhBTXhuT1JudHp3ZVA3RFZUcFZ0dDNoV2Y0M1dvaGQ5RnBLNGJUeUFVdHBQOEFXb2VDbzQ0SGdlZERva1JzeUV5RkkrRWFnRGMwOHRYYUxBamx4MVhvTzlDS3dxUHVoVzkzMVhlOVJ6RXBJcDVhanlwTHZhcDFSSUdRM2dxVU1BODR4bzdKclZ4MDZNVXBUSWFhU2NGMzBraEI0SEJ6emdjK2YrMnJ0WjFwQng1VHMrZ3ZEQ0IzU1hsQWQ0R2ZsQ1I3ZnI1MFQ3TTZYYmozbGpCeW5VNUVHalkvblZLU2twYVNnY2tKQTVjVi93QW80K3BHbWdtOVh1ZWlORVk2QWZEblQxUGZ2MG9LN3hKSVdEaGZLS1dWQnY4QXIwcHFqV3hFa1Q1YzUxS0lrYU0yWGx1RStBaEtCbFJQMC9YVFBiRy9oNHJhTVM3dXF1UXdwOUtQWGpXdkdrRnBDVWc0ek1kU1RrRWxJOUZza3FKd1Q1MHhleXV6T3p1d3RFUy9ZRkRaZXFUcllSS3Jja0F1SElHRUJTUVFrSEkvbE5nazU1enpxWm5VbVhYN2xYVmFuUDdXNHNUMEZPTmNFT3FjR0drNHlFY1pKQUpYOVZET05iendqN1BiZmJXRU96VXBkZE9EakdRbjU5VCtWQlh1SmJvNXpKRGlrSTF5ZXA5S21MS2x4NmRiTWEzN2JwOFNEVDRhRk5zeDRzYjBFeDJ4NFNsSTRRTSt3K1krK0R6cmt2MldpNGFITXBEcWdXRnhIRzNjK0ZBcEl4cVAzQTNQMjcyeHA0Y3VPNFlOSWpPTFMyMGlTK0VyZVZ3RW9iUjVVZkFDVWcrZGM5ZnFCZG9jcVNsQlNFeDFkb1BCeVVuMjFyTEx3WlQ0VGFnY2RCMHBUZWpyZEJkV01BNTFQWHZRVmwzTFI2WlZtS3RmZGZjcHNDbldZcHRjeEx2WTUydXI5Tklid080dWZMaElTQ1NjWUdxaEJsMlZ0TlFFeVdYNmhZTkttZ05NeUtnK3FvWGRYay8vQUUyZ3Z1TU5DaWM0eDM4NTdVK2RmUFVGdVhCMjNueUhLTTYycTRHWXNlSFRGTVU0U0pFTktFZnpYVUZmOHFPY3E3ZlZYa2duNVVxVnhvQ3o3ZXUyaHhadTVWODFTYlNWUElDNVU2YTZaTlhrdHJPRXBRRjQ5QktpY0FxN083MlFyeHFSeWVwQTVRTW43VlhoV2tPTjgyeVQ5VHNLS2UvZGF0SGJucGh2TGRPQnRkVGJaZmswZHlsVXFVL0orSnJENWZVRXJWS2VDaWU4NXoyRlNsRDNJOGF5ZHFjYXYzZFhXNUM1TW8wNWxYWXA1dy9NUW55Qjc2ZG44UTYvcVhSN1d0bnA4dFp1UWlGRWlOMUdxc3JkN25QVldQNVlXcjNWa3FVZUJwVTVjWnVHd2x5TWh4dnNTU2U0WkgzejdaT3FTMG1VQVZtaE42ZmFZZDhKbnArdGZWTHIxRnNpbElnVUZwU1VyVGxhaitaT2VDTUgvcnFLbVh2U2FvNnQ0Tkg0bEk3QXR3K1RxRnI5ektEUzJVcEFMaWlsRG5wWVVzajZhckNYSFkwZ3h5MjY2KzRmbldSd2tmUWFyT3ROSllPT2xLajZ5RWxST0RWemxLcHE2YXVxeXFpQXpIK1oxQ2grZFg2L2JRaTNGdU9SVzNNU1hHMjQvcVpad3ZKVjkvMDFZYjN1U1RPcGY4QVNnbU0yQVY0L3F4OWRCeThicXFVeWE0bW45aFJIVDJSMEFZQit2LzQ2R1JXSkR5eUZIWDlLb3R0S2xPamtyc3FWNVI2SEpWS0VnbFNFaEtPMFo5L2Y2YXRHMDljaTFxYS9VYW02bFRTQU1CWTQ1ODZEa0tQY0Z6MVZOSGJkYWNYa21RdEF5bHI5VDl0R0hieXpVVVdrcXAxUGNXKzRrWlV0MGZLRmZYLzIxYnVOdmI5M0xRVjhSKzFPZHB2TWV3dkJ3SjVpQnQwelJRa1gxVFlVVnVCU0thd2hMaXNldVZZVWYwSHRyMFRmTHgrUXJkUHlqdVVGalBhUHVmR29LaDBxa1U2bktNaElsMUZhdjVhVkQ1VW43blhWRXRDUlVaUHg5Wmw0YVFEbERZd2tmYjc2RHR3R3JZeG5PQ2ZtVFZlNmNRM0M2dmVLK3IwQTJ4VWxPdjhBSzA1aVVsYU1IQ25YSGk0VmNlY2Y5OVE1cmxVa3VseFVweGxPZjVLU2NBLyt1dStvUll6WmJqUW9hdXpHRW5QSSs1Lzk5U0ZCc0ZtcnpTNVYyMTlvNWFHQndORFhaTC9MekhJSDUwSTUzWER2VlZmOUthRk9ReDN2ZVhDcGVNblVPc3lGcktuSUMrN1BPRWNhTTh6YkMyZmdFaUxUMHN1TEhLMXJ5ci9MeHF1TzdZOWppa05GU2tnOEh2OEFPaDdjeEpVUUttTERxZXRkZDg3NVVoNi9ZbHYwNURzajRWM3VsdU1JSy9TK2ljamp1KzN0b3ZSdCtiTWR0VnFub1RJYWtKSGQyS1pQSndQUEhCLzY2OHFQMDUwYWh5eENvdEhaYk9RMnA0cDRXZmNqN2o2Kyt1U3Q3VFRyWmRKa1V4OTRKVU1MU0NFa1o5enJQcE16aDZXbERMWVB3anFkVDUrVmQ4cTk0anVBalZPZXhvWmJrNy9VUlZjaHNCMy9BSGh5b01oS0Y4WlYzajIvYlQvYmI3MXkwMjAzVnFQS3loNktGZkp5RGtjZjU2U1BleloreUx5b0xjbVRTbTBWRm4rYkdlYUg4eHRhZVFRZjIxWDlscjAzY3Y2UEYyUHRhdDF4TTJuVk5FaU8vU1hEd2tBakxxZkNralBCVndEOXpyN2M3RGIrSUxXMDVIV1d5eVR6RTY0QnhxRDJ5SytYS1JMWWJVcms1d2Njb0c1MjA5YTBkMmFydE5hZFdKOHdKUkxTUTZ2MnllU1QrdjErK3JMVmJibzlRSzM2ZFVrK2tIQUV1SlBkbjNJd1BPTkpvdmRqZFRwNmJqTzcwUldsUVZxOVArTjA0a3NnL1I5R1A1S3Z2K1UvYlJlMi93QjhLRGVFRnFxVUNyaDlENk1OQnB6dTdpUjRHTTgvcHpyTnB0bmtRMk9kVFlkYXllVmFUcG4xL1E2MTVqT05QdkVKVnlxRzZUdVBsKzJsRWJjZWx3NDQ5TXVOa2hJRGlsY2tIR2ZQdVB2cFhPcGQra0dseUk4NXRweGw1Q2dXMWpJSTgrRG8yWE5YYXk2emliSVUyQ2VFS3lwZVAwMVNxL3M3dGZmc1V5THQrUGZBUExSZVdrTFAwK1hHQjljNmpzRHJGdWxCOXdrSkI2YW1tUkxZV3h5WkJOVTNwOXVpMU5sNzFadGVLV1lMZGRRMlZJQUNRWFFuS0NjZTVCS1I5ZU5PRmFGOS9DTklXeTRGSUxmQ2U3SE9OSy9XZGhOcDYvSWNtVHFUTERnd0czVXpWcFVuR01FYy9LUjdZK2cxMmk5cjAybXBoRWVSTHVHbk1Kd1dubEF6RUFlNFZ3SGNEMjRWOXpxYTl3NDEva0pmaUxJZTY4Mm1lMkRrankxcXBJaHJXZzVBeDVVMEZRM1NrTktTbHlRa2NnOWpJd3Y5MTQvOTlVbmRUY3VSY3o3VXFjdkMyQVVCUU9FaEhnQUE1L3VUay9iR2w4ajlZVmczYWo0dWtYVkV5a2xCYWVlN1hHeURncEtWWUtTRDVCMTlUdDk3ZHJycUtYUUtvaXAxSjVKK0hnd25BdHhaOXpnSGdEM0o0R3F6WERkOWEvNDMwcXgxeURnZjRwYlUyeUhkTVpxWHZhOUdXV0ZoYXU0OTN5b0hzTkFTc1hmSHViYzZIUWlVdWhsNE9TUVZZQVNrNUkvZmorMmpGYVBURnUxdUVoMnNYM2NIOElhZUpVbUpUdm1kU2duT0ZPRWNIL3lqWDZlaGJibWdtVlZLVTVVVEtlQlRJZGtUMVBGd0h6a0tIZy9iVFRicmh3N2FDcERqM001akh3aklCOHo1ZVdhc0lqdmMyVXArUm9hYm9ickhjbXFRdW5MWlJneDZ6Sm1KVlBxVVFKOUpsQ0I2aThrWjlUSUk3azVIMEpPb0s5OWlib3NXM3ArMFV6YldGY2JWZU1kTGxXcGppSTdqRWRMb2NXMGxsUTdHMXF3bzl3UDVpRHlCb2kyVHNTdllXLzVkKzBHbU16RXlZS0lpWXlHMHNwam9TZTdEYVFNREp3U2VQR3BlaDdxMnpkbS9WT3QzMG4ybkZsYmlvMDBZV1ZKQklQUGtjZXhJOGMrMm1KcTlHSWdDMURuWWJUenF6bm1LOXlUZzVBSFFiVXN5ZUcyN25JVS9OMGRVY0RHQ2tKMnhnakd2VTR6VUwwWGJIeW9sQXVLMDdjcDgrTFR2NG80U21vTnArSktpbnRLSENnbEpLQjhvSVBqbjNPa3o2NE5pTHY2YjkrWjFBY1MreEFxQ2ZqcWNRQ2xEckRoR1FQc2xXUnJZS3lhcmI5dFU1TGNDa3BRNlZlcTVoS2UxYWo1eng1Ky9uUTc2M3RpN0Y2djlyamJkMDA1RVNyUVcxT1VPdXBTQzVEY0k4Y2NxYlZ3Rkk5L0k1R2RVT0UvYVFsbmlaMStjU2xwM1FnNjQyK0w5L0trN2o3MmZTNS9DN2NXRVFYV3RSalRQL2lQSS9wV1IyMnQ4M1R0aGZFSzlhSkx5V1BtZGJLeUErMmZ6TnFJOGpHakhMcUcwOTBUNW0rajl2ZnhHclRWUG9vc09ZNnBNYUlHMjBvVytVSngzdWQ2Z0FTY0FJSEIwR3R3OXR0eGRvYXhXTE4zQ29Uc1Ira3U0THlSbGxhU29CSzBMOEtTcjJ4K250cVg2WWJqb2Q4VDNMTWFrcGJxY0x2SWJXb3E5ZU80citZdEkvd0FTUWNrZWNKenJveHVJeEp6T2F3VHk0NWs3RkoxM0Zjc291ZCtqMjE2eFRPWU04MlZKT2NnK3ZUUFdwZTY5bVlhdTZmY1V5TjNyK1g0bHhZUzJTZnk4S0l5ZnRrZjl0VWxFdWJaVlNjaWlwT01xWVFsSWJib3EwSzdmT1Fya0hqMzAzdDk3VDBGOW1UYnNGMEtlanBRaDJUMnBYM0w3Y3JUMnF5RG5uS0R3ckh0alFKM2gyaVJiZEFqbWwxNlhTNURycWtNS2lKVTR3aFdNNENWWkxQUEdPUjdjZzYrd0hlWWNpeDhQVHlvbmE3ZXUxTmdOcTA3VlZkcGIyWE0zdm8xWXFydFVtdGVpNjIwL09RVW9RNHRKQUF6eHdDY0R6cGxhTzd1SkNhTE5FdHFFNUNRVmVtZlc3c1pPY0QzU3IzSE9OS2ZBNmZONjZoTFRkVlR1eU0zUzJXVXV1VG1WOTRRclBEUVQ1N3NuZ0svdnEvV1YxUzNEcyswZjlZcmdNajBYQ2hwVW9oTGdRUU1KY0F6OWlGQWtIem5rNm11TnFZbnFTRUtCSUhUVTAzV3E2bEFQakp3UFJXUDBvNW1GZUVlbVRLcEkrRWlNTk1seHhBYlVvZzg4ZHF4a0U4OGpqSTBrWFVwV1VWZW85OEdtUFBmNzI2WFVoQndBb2NLd1BHU1AwT0RvM3dldlBhUzQ2bEpqM2ZWcTZxR3BKQ21hZlR2V0pQSHlqQ2drZy9yOU9Cb0hYN2IwcmViYzJ1M1hZYUp0Tm9Mb1B3S1gybE45amFRRDZiZ0I1VjVKVU9NazQxWXNObE5xbUYxN0lBR21kS3ZYQzVJbXhTd3lNbFdPbTFjM1RWVEtiVXJ6aU16b2pIb250S1huVkh1YlVDY2dZL2JCOXNIVGpRYXkzYWJFV2ZLZWpvaHVxU3c2NGh2QjVIQ2lSNUErdnNEanpwRDZCVjNkcjdoK1BoMUZZVkhTbFhvdWQ2U3BYSklDdVFDRDcrK1JxL1ZMcXpyZHlSVFRaa1IvMHdlNXBURG9UaytUbFJIMTl0Rjd6YVA2bmxRQklJMFBhaEVDVUlYL0FCblFnNjBXK3JDeVlOZXQ5TjUwS2lJK01wam5jNjhrNERqS2p5Q284bkJ3Uno0NDFVTEZ0MjhxcmFId1ZJdWN1cmlSeTdFZ3huei9BQ3UwanV5bEk1OGNEbnpxb1ZQZTZvVnphVitqVlNwdkpkY0phN1hIT0hQbUdCZ25qZ0grdzFOOVBONEtoVmFMVlVCcERSUWtGN0orVUErTVo1UC9BS2FDc1FKMFcxK0U1cnlLT005cUgzZEVHZGRrTGNBS2RQcitkV2lpWHROVTR5aXJVNk5VcExLU2hicTJnMUs0eU1GUi9Nb0Fuemo2YXNxcmtyY3FLSkZsRDFpeVQ2OGR4QTdtVmpuS2tLQXlnajlDQ09GZTJyMVZyVjJwdmVrU3BkU3BpSTgxYmFsSW1wWDZUaVZmNGtsT09RZVFPUWRBV0RjTGUydTdiWDhRclNxakZRbDFzVElhc3ZGMUFQWTJwQXozZHdJQlRqQkh0a2FHc3hoUFVlVlB4QUhRN0g5SyszS0xhVHl1SVRnbnQvTmFKVk8zc3VTclVoMVFROHk5Nnhha05Cd2t0ckE4QUs1SEhnSFBqak92R3dIN0h1U0pOcTF6MUtYVUsydzRQVlhOV2U1cEI1QlpTZ0ZDVWNEdVh5Um42YW90cVNibVhWNWRkcTlxVEkwWk1oYlNYSEdWTTViQ2lVL0k1ZzVTY0pPTThqa0R6cjVoejVsRnVRVnVoT0Erb3JDdlRWOGp5Y2c0STloa0RnK0RqMjhlQmJXWWkzVU5wQUpHL3dDbWFnZ1RtYlp5dXF5RUJXM1RIZWp4dEkvVGtWbDZKU0M0cDF4Q1BpU1VkaEI3aWZIdU8wWkI4KytuUzJ6dkczNnRSNHM2UlRFbVN3ckVlU1VudVlYNTRJNXdTU2VmcnBNK250TlJ2S2x5SzNFU1V6cEUwcExxRUFLN0VwN1NEK21UbjlkRis0NnhlVnFXZkdnV3crcVBQTDRBZUhBVjh2NWVUZ25IZzZ5L2ltR1pUaVdXVllVZEQyK2RSM2VZMHE4T1BJUHdIQkI3MDI1Ym1USzgzWG9zWC9mQW4rWXNJeGdFSDVpdndSOWZmWHpkZTRjdTA2RzdBcThsRGtoVGFsc1EwS3dWSkE1SiszUG5RUm9POHR3VTZ6cVVtVGVqTUNRMDJoTXBjd2hUbVR5ckNTZVQ3YUIvVUoxY1hyVWpVV2FmVmMweHBDaExxSHd3YmQ5SUg1VWtuOHFTZnB5ZkdzcmhjSVhXNzNMa09PVUh6NmZMcjY1cG5nM1NORFo1czZtaVJUOTBKZDk3eU8wYVVzdXhhYkhWTXFLY1lUMitHMmMvVW5KeDlCcHNkdGpUcml0NWx5bHRCaDZTcHRUNlcxWldmcG5qNmNZOGFRdnBHck1tZHR0SzNQanhISFA0dk1mV2x4U1QzTFpRUTEvZlBlZE9UMHR6TGp0UnB5cHo1amJucnBTVzJReVZMS09Ra0orblA5dE05NXRiZHZXcGxDY2NnQ1QvQVBicitkRG5yMjdNbkRLdmhHd3AzT2tiWlRiNnVMcTBpOHJkY3Fqa05oa1FoSmxPZWdrcUsrL3VRQ084OEp3RGtmWTZPRjJVK3NQaVBRTGZRaGlDM0g3WG13UXl5aEpPQWs5bUY5b0dma1JqUHVvYW92U00vSmtiZHpMZ3FIcHBjbVZBSVNFQThCdEFTUno5eWRXbmNEY3kwTEFvY3U2Ynp1R1BUb0RLeWt2U0hPMEtWeGhDUU9Wcko4SlNDVG5BR3R0NFB0OGVMd296NHFRbFNobFJHaE9UblU3blNpVExxMXllWnNaN1VMN3YzbzJiMmt2RjNibTJyY3I5MDNUR2FHYmRvTERxa3RKWHluNWU0Tk1Obmpra0Q2a25WUHZyZkRmeTdKeWJHaVVTSmEwdDhCY0MxN1pVbW9WWkgwVTg2Y1I0YVBPVkh1UHVBVHI2MnNWdUwxRTdoM2h1TnR2VVpOcTJmWFprZUcvVkpjUXR6NVpqSUtIRk1wVncwRG5IZXJLaDI4QUhuWDYvdmJzWHNoRHJWaTdmM05IcHoxTWtsaXJ5YVgvdjFicU0xU1Fzb1FoUVVSaEtrNWVYbjVzZ2ZsMFpnQktHY2c4aURuSFRQcDFOSEhsSHh3a0o1bGpHZHpnK1o2ZlN1ZmFub2tvZE91NXJkdmZHYzVjRnlKV0hZYkU2YTVLYWdFSElQYzV5NDVua3FBU242SjQwVXR6Ym1YQ3BDWUVkUVNGcUNsaEorWmFRZkErNU9CKytoLzA0VjJUV0xDa2JpS3Y2dTFtTGNrMXlkQ1JjRXBienNCa2ZJR081YVVrNEtTU2NBWlZ4d0JxSXZyZVNIVDd1YmEvZ00ycE90c3FsZWt5a054NHJEWndxVElmWGhwaHRKeWU1YWhrL3BvZ3lHMld3cEl4bjg2cXpDOUlXVXJWbjhnTzlVL2NHazF5TGRyNnFOWFlyOGhsS0ZTRXdZUGFxUElWOHhVNitvSzduU1QycFMwa3JBSEJUa25RUzZpdHlyTzZaYWxFbmJ6MWR1WlczRUdYVDdIaUJMMVVtcVBLWEgxRXFSVG1DUU81eFhlK3NjSkpQaUk2bC93QVVOeHlZNWFmVEEzQmZxTGFscGN2WU1kOE9ucVZ3c3dHMXBIeEx4LzhBN3B3Qkk4b1FlRmFUOWNTcFBWZWJjOXp5NUZWcXRRa0tmblZTb1NDL0lsT0s4cmNXcktsbjduL0xWUmNwdEtqZzVWMkd3OWFEWEcvTVFtL0FZMUlHTTlxbmEzdUpWOXpMcXFHNDkwdXRmSFZLV3ArU3l3c2x0b244cUU5eEo3RWpBR1Q3WjFUYjBycVpMTHpjTnowdTNJRGhJUFB1QmpYaGN0eFFhUTZzTk10dDl3d0VkK1Fmdmc2R04wS3F3bUtxVVJUcVdIVlpjUTBvaEtqKzMyMTcvcUNNQkg5eDdWbmowcGJyeEpPU2FrYW9tb1JZL3dBZTFLQys1SjdlY2xJOStQcnFxMVc1SlZSbS93QVBZZWNhWlpUbDU0b0tjcVBKSDF6cnN1bTZ5MVF4RnB2cHRTQ0FoQ2xxUEIvWDY2b2QxVjI1R3FLbTNZczFJZFVydVZKS1BtVWYxMTlaY1U5aFRveHJwVlpDbTFMQ2xhaXZ1K04wV3FiQlZGdCtLb3BjeTJIWkRmbjY4Nm85T2gxR3VqNFpxV2xsQk9YbjFId2srZjFPdkI2bHpKa2htSzlOVS82U2xGYnFTVkpKUG45eHF3eHJkY2dwWldWcDlJbnhuVnBEYmJPaUQ4UjYxYUQ0ampEZTVxWDI0c3dDVUdJRGpMVEI1VzZVbngvaVAxT2kzUzEwU1BGL2gxS2JVVWtZSzBENWxLKzUwT2JRbFRFTkdLMUhBVzRPMFlQa2ZRYUsxdU54SWRKYmlpTWxMdmorV0JuUDMxU2tTQkZWbjhTalZOVG9RY25ldlNIVEVNdGh4dW1sSlVjSlZubjk5ZEtxYlVmZ2pMZGNDV1V1aEtoM2dFcUk4QWVUcS8yRnQ5TG0wbzNqWEk0Tk5aU2Z5Y0ZaOWsvcDk5UkZaZ2Y2eDNRNy9DSUtZN1NDUFRaYlR3Z2ZiT29WeGtPcjUxNmsxRzQyNnkySFhNZ0hZSDcxQVVHaFNwU2l0cEpjU1ZIandmMjFjcWQvdWFBM0poWVQyOEtVZm0xUFc5WmNLSFQwL0hPOXI1U2U0b1RnNXg1KzJ1TjZqUjBPT01SWGlRRWs5eXZKR29uclQ0aUR6YWRxbml5eDByaXJGWlhNaHFwN2JhRkp5RGtKeWVQdnFIZGxsTGhTaUVjZmM2a3BiQWhJUTRsaFFKR0NjNFA2NmhwRjFReThydVBQdmxZMGxTTGU2bHpsYkdsRzBTa0VaVWFORXZldWxVdDVLN21BWVd3MkFYUVQya0ErUjlQMDFJVmZkKzNhOURkalVlZWw5WG81YmpweVhGWjR5bEo1VjdaQTUxUzc1MitxOTlwZW9kc1VGNmRPZDdrb2pwYTdGWUhsUnljSkErcDFVcmQ2T09veHFxUTVTSUNZVWhoWHFzeUhxdWx2MDFKNUJDazg5MzAxbThhMzJRdDVsTENGNTJKR2ZsMXJ1dGk1TlNtUEVRNEFOd1RzZlVWODdnN2xSUkhZanZQQk04cktTMjJDVkJJNDVUakl6NEdkTVYrSDFSN1FoMnpVVVd4YmdST2xTL1VyZFhmamxwYTNjWkRBN2dGZGpZT01lTXFKUG5TL1NlbVBldTI5MzZmZTk0Mjhtb3FjbnBYVXAzOFJEemhHY2xhdTdsV2VOTnB0RGVGbzBxcU9tb3lBZ3lrWWVRZlk0eGtqNjZyY1J6b2NXMnBqd0ZjNFhxU0ZER2gySUdkS0lRUGVwaXVkeHhKQTNBSGwzT3RVWHJtb3RaclZrVkNsVytpTzQ5SllXMGxwNUFLRmo2WUhIOTlTMzRkL1NSRTJic21udlh2SmZkck5TWkRzNUNITXR3OGdrTXRFakNjREJVZkpKSXlPTkVTOTdQdFN2aFVscVl6SVpTVXVKSU9IRkZKQkNjSHpxZXNHU0hwNklwQUxYYWNFcUlVbmcrTUgvcnBNYjRobVJMUW0ybEk1Vkw1bFo2OWhudFFpVmIwcXZKbUVrRUo1UjVEMHIzdVczTFRqVktRSWtGdFJNbkRlSEZFQklIUG5uKy8xMUExTzNLZDhDWWNka2o1aVYrbHh6OXZ2b2xWSzA2RzUzeUpENVpXa0pLMnlNbEFBSDVnT01IUHRuQjQxRHpMTFJBbkpSSW50dEpKeTB0YXoyNDl1MDQvYi9MUUdSYTdtaDdtQTBPb0FQOHhSYVBOWjVNWk9hRWwxVUlVMlA2elRwSlVPQXBQMkhuUTh1Q1c2QzR5NFBQS1NENTBiZHpHcWZCaktoR1doWmJqSlU3NDVVZWNKNStiSUE1NC96R2dOZmM5dUdvT2xRN1NQbFNQR000eittalZyYWVTNTRiZzFGRkdaWE0za1VxZlZUWlZIb2x5cHVKbWtNNHFoS1hsdHBBVUhBUHpmdVA4QXBwcGZ3MWVuNjE3ZDIrVGVjcW1zL3dBWHJpMHFkY1dCM2VpVDhqZWZJSHVSN2svYlNoOWMyOHRDdGFrVTErYXk1SVQ4ZVVvYllVTzQ0U3JCNSsrbTcvRCszemdWL2E2aFNtbmtLU21HMkhHVGp1YlVCeUQ5Q05hbHhpM2UwK3o5cFNjaEsxWVVjN2diRCtkcVZtWmR2YzRpZFpTb2M2VWc0N2MzV25NbFVCMWlHcGlLMG50YVJoUUNNSHR4NXdCOWZmVlZyRkpkVkdVaHRvSUt5TUxVbjN6OU5lZFY2Z2JPdFJoMnNYTGRFV253MVNXbWk5TWtwYWJTcHdoS1d5cFp4a3FPTlRybDQycklaWm5rb1gzb0JRcGhRUGNrK0NEbm5QNzUxaFlzaWVRUElXUUQzR0JrYjYwVFMrcm5LZHorZEQ2NnFERlJEeE5wK1hFL01yS2ZJeDVIMjBFdHpkdFlUN3JGNlVZSWFxZEprZkUwdVFsT0NsUTh0ay80VkRLU1B2bzNiajNFelVuMWZ3bzVTckRmY3J6NXgvMHgvYlM5OVNXOGtPd2FNbUhHVXBienJucHRKU001VWYwOC9wcGc0YVl1Qm5KYWpuSkp4NUVkZmtSVXMyNVE3WkJWSmxuQ0VqSi9uZXJodGoxSVd2ZDFMRTJQT2JaY1FzdFRJcnF4M3huVThLUXI5RC9mVm9xdTlscXc2YXVYTnVLR2h0SXozRjlJNSszUE9rQVl0T3MxV3FUWjhHY0lyczU3MXFrK2w1YVZGUjhjSXdEZ2NlK3F4dVZIcU1HM1YwYUpWcEhyTW95WDVTaTRvcUo4L3dCT1FSeHdlTmFndjJXUUpNd0tTNlVna2FZempPK3RZQmR2Yk9tR3Bha3hqeWRDVDlOS05QVmp1QmJtKzhDcTdlVzlUbXBDbkUra3FlNnhoS1Y1L29VZmNEblBBeU5JOVZMQXJmVFJ1WFI3eHBVMlZOYmh6bVpieS84QWh1TEtGZ3FTZ2o2cHlPZURrZzZPKzEyNVZPb3R0SW84MXBLNUFVb3FsSkNsS3lmT1NTU0I5am5WUnZhQ3p1SFVTMVZFcmNpWlcyMHZCS3MrU2tmUklPUGJJL1RXeWNOUkZjTXRlNW9WbG5HdWV0WkRmdU1XZUlwZ2tBb0N5TUhRREE4LzRhTWt6ZkJFaDFxNzQwaHBpbjFSSlM1V2twVXVuU2tMeXByNGdKeXFHNmM5aWlmbFNlUWVDTlZMZERjeDJlQXA5YzRPUjBoMWFrWWRreG12WnhiYVQyeTQrT2ZVYkpVQjV4alFuZnFFM2F3QlZuRjFvTHlKY0dRcHoweG5CN1FVbklCenlEbkpQalVqYWwvN2NiZ010VVd0cWVvTlFiZEtqQURucHQ5NU9POXB3ZjhBQ1g1R1U5dWNudUNocGpqc05LUnpJeVUwb3pMbktZMVVuS1IvY05RQlRRMGlpMGlQWXRMb0V0RWVvbE1aRGs5Y1FncGNkV0F2eGtkdVNUalBqSDdhcCs3RzJkbU5iY3lxM1RMTGlLbExHWEZTV1dpUWY4Q2dSeGduaFk1R2YyMVFydHJ0YW84dDJ1cEZTWmVFWnNmeGFpSzdsUHBDUW5Mekl5bGF2bC80aVI3Zk1Ca2FHbDU3MFhOVVRJaVNkMTVrOXBhRGxLcWFVdVk5d1IyOEVmOEF6N1FSWVJVcklHdWREclRsWkxuRW54UW9MR08ydFVHVk91dW5WOHhiY3RSbUtodHdoVGJza0tTakt1UXBLUU9NaytmT2pwMDZzTnlhd3dOeEoxUGJwejh0S1gySS9xWlBjZVBtUDVoN2oyeHg3Nkd0akRiV3NXZGNVcTZvVnd6YWhKcHltYVkvSFo3TzU5UXkyT1ZKQXdvQlJWNENjK2M2L3dCWk5PWnBWUFJJcU5rdmtvYjlRR2RXV2dlNEQ2RlJJenh4akpCMGNscFhJWXhqQkduOHlhK3hwTVdOS1hoUUFxcTlYa1N3a2J6VkNEdHcyc1JFS1BjMmh6MU1FY2VmKzJoeEJ0K3V6M1JIcDFJbXkzRHlHbzdTbHEvc2tIVXpOOVdwWEpLZWhVNTF4K1JJUFpGaDVjS1JuN2VmMXg3Nkp1MU81MVZvVVF0V3piOHdUV3dHM0hXbUVwR0VrLzFIblBqajMwUzhWNjN3a0lRT2ZBRzV4Vk5UaXBrbzhvME5DMnEyZGQxTnBrWCtQVWgrTzI0b2lPMHBQOVNqaktoN0U2S0d5TmkzWlM1cHFzZGF1Nk00QTJrTHdrTEJ6d2NlZVBwcnczUDNFdVc0Szh6Q25VNWFJb2twL2xsZ0pQSjl5T2NrODZadlpPMXJPUlkxUHFkWXFDa250N2kwaHNFbFBrS1VmNnMvMzQwR3UxeGxpM2pDUUNydHRWaUdpSDcyVXZqUWREUXpyYmRXYmd5YXhQVE1UTGVXRmR3a0VoWlVmbklIak9EblBuL1BRdnUyUFRLQmZkUHZOK2tybUpnMUZtVkpqTGR3SlNFSHVWM2tlUHFmc0Q5ZE03dVl4VDNZVE1DSldJaUcwaFI3Z3lCM0lLU0FnNTl3RG9CWDlTN2FwNkZ2VEsraDhSd3R4U2NBY0ZKSEJQc1BwOVRvUlpIbnc3ekxHK25ybXJkeGJ0cW1oeURCRlNXNUhVQmNlN0ZlaFhSVjN4SWFrTnZOTGZpZ3A5SHdVbjloNTlzWjFFeHBhMFJFcjljSmRRcnVFaEl5aHhQa0JRL1VIblVOMDBTS2ZYYXpVYUEzUW5wakw4UU85emJRN1k2c2xKZEpQQ0FCajljK05OVnM5MGRTYmJxRXU1N2lmZ3ZNb2pZUTVLWTd3c0tHUTQwMHNEbms0V29BSDJHTldic1lsclBLZnAxK2RERU9pUVBDNWVZNHhqR2c5YXAvVDd1dmN0cDFoYW1hVkptMCtSSEk5UmxwUlEyVmNZSzBqQXo3QlhKOGFQOEFWOXg0VllURFpodXRoMld3Z05zdkRHQWVBVDlUeDRCQi9jNDBIZHlLRkxvU0JCcGRkanltVXZvZGFqeTJ2VFdsUVBIS08xSlAzOXZPclJidTMweXFXcXhVWmluV0ppU1EyMzZ4VWdsV1ZFRWozenhuNmF6VzhRb2N4OFNjY3BPbSs5S2syM1grUk5YQ2lwVHk0em5vUHkvU3E3Y2QwWEh1VHVQSXRhaHlVcStFQmFianR1WVVWQk9WSFBzZmNEMjFYNm5ZZDJXVFUyYUZkVHkxdDFBZDdyRHl1NXRLTWR3Q2dySUlJNXdmR0FkY2NpY3JiM3FZalM1ekwwUitlNjFLYWVRckRjcEdRbHh2SjhsSkdQWTQxZk9wMnEwaWZjSXF0RlljWWp5V3U5aGt1RldGdC9tVHo5VWsvd0J0SGt4VVJXV3cyTkNCL3Y2MDQyd0tZdHlXSFVEbUF3bytlblg3R2lwc052bnR6YWRzVXloMUIrbk1SWUVRcy9BTkgwUTM4MmZjWUl4eitwT2pQYUcvZEFTKzEvQWErbDl0OTd2YVEwdlBZUElTQUR5RDQ4Nnppc1c4SkgrdGIwV01sdnRRNFNrcUJJUGQ0MDVuNFdmVG5VdW9mckVvRk5ibGYveS9ic1ArTDNPd09VbjBsRDBXaVJ3a3VPbFA3SlZvRkw0U1RKbUhCT1RycjUxU2N0QjhQeEduZXB5RFd6T3pMbGYyNTZkS1ZDV2xnMVptaXFsUE16SENodEw2d1hUNnF2NlVwQ3ZtUDBTZGNleWUydGxib3dJMitsNVhOSXV1Wk1VNmFWTGtOS2FoeGtkeFNwVU5sWENFRTU3WGNkeXdNZzR4b2dWYWgyck9vMytxOVNndFM0c3hKRTlwNU9Vdk5qbnNVUGRKUGtlQ01nNjlaTlhiWWlmRHgyMHRvWlFFTnNzcENVb1NCd2xJR0FBUEFBNHhwOFRFYmJiU2hXcVVqQUhTbU9JNldtQTJqSUozTkJIcVl1NlJhOHVMdE5aMjVQOEFxL1NHb2lQU3Rxem9mclZpZGtudWFILzBFRStWbmxXVCt1cUwwKzlPZDAyL0FuVmE5clpwMXRNenBUcXhFaE9xZnFqc2RYNVdYNUtqL0xPTTk1Ujh5c241azZOLzhBc0d3STlXdng1aW5VbEpVdWRYNjNQZVMyRUp4eTQvSWNJN0VKQTl5QVBBK21zNit1RDhlUzNvVTE3YTNvVVRIcTB4YXl6SjNLcWtRbUZIVURnbW54MWdldW9IeElkQVFQS1VLODZyTTI4K0w0N3B3QVQ2QWZ6dFJlUmRXbUluaGpRRGZ1YWJicW02cWRqT2t1MW9NYmNpdWZCUFMyQW1pMmxTRXBYVXA3YVU0QVpaemhwcndQV2M3VURQSGQ0T2J2VlAxeWJ6OVdEZ3Rtb1RvOXQyWkhrRDRPeWFjK2Zoemo4cTVibkNwYjJPY3IrUk9mbFNOQVdkZTlicXR4U2R5dHg3bmxWaXJUbjFLbjEyclMxUHlKanBINWxLVmtoUDBIQ1FQQUdwQ2pWTXR6bFZLY2xzd2xxQ1lwQ2U3dVVlZTVYME9oMTV1YnBUNGNmOEdOKzlJVSs2dk9xSWJWaE5XcWdJVEVRdU5LSUlDd1FGZ2R2OTllZDNYSkFpb2Rqd2tGa0ZyTGo2WGNET2ZiLzBHdVNxVm1OVFk0cURqWktNZHlrRmZCSDZmdjdhR200dDN6YWdzS2hTTzVQaFB6NVNBRDlCb0JBa3J6eWdaKzFMenJuSWdxSnJ3dUY1MkZMVEhwc3d5aXQwS2VrdkRBU242RFhoTXV5WWlFNnhLZFFHdS84QWtwWjVLeGozeDRPcWRXYmtqc3UrckpuSWM3ZVZBWlRyblhkVFFwNXFNcVlodU9yL0FPa25CeCtoODZZbW1YY0JTaytsQlZ2dVpKSFdwaGZydkpWSnFrSUtpSk9VdWh3Y2srZnYvYlZDdU90SnVtYXVnMHVRK1Mwc0I1NEVlbTJqMkgxN3RSMTZibFZDNDNtcmZ0NXh3cmNXR1dRZzRVb2s0SGpSTHBPeS93RHFoUTZkVGgvT2t5RSt2UGNVb1pLdmZKUHNQSDdhSUs1WWVISGZ4cS9DUFRjMWFhOFJMV1FLcU5Eb2pETXhUQVlVVWo1VzArNnZ2blV0SG94RHlhYWpDM1ZLemhIOVAzL1hUMmRKMzRMZSsvVjMwM1RkL3RxWnRLaCtwVUZScWRTYW5JTERrOUxhY3VPTnVGSlNPY0pBT0FlZWRBL2Y3b2czMjZhYTJtMjkyZHFxM2I4Z3I3UkxxTVFwWmY4QXUyOE10ckgwd3JSUmNTVzNHRHZJY3EvTHpyMFk4bms1OFpvWVd6U1dJZ0sxSkljUndVbm5KMFV0bmJIRnlYTkZwejd5ZjV6d0NndmdKSDFPcS9hOW9laS82VHNSWUJHRXFVRDgvdmtIMzB4TzBHMzBhMWJhZnZPZEVZVElTM21JSkRvSGJnZWZ0blFSdUcrdDByVitkZUl3OFdTRXJHMjllZS9GUXA5Q2l3N1ZvY3hMY1NJZ3RwYmpCU1M0Y1k4KzR6enpxcVduVDVRait1K3l0MTlZempQSisrZGZGY2tWKys3d1ZVcW9VS1Eyb29aQTRDVTU5c2VmMTFlS1M3UUxhaHBjcVV0b2VtaktnUGI3ZlhUTkFoQS9HdXZGM21KbHlmOEFqL0NOUHBYTkZjbVRtdmc2aFFlRUQrVXBhaU1ISHVmZlZjdXlIUHA4bE13VEdVSHgybzhkdnZydHZQZktreUlCWml5RU5wWldTQjNaSSt3MEZOeGQ5Z0NydG1ISGFleEt6bmpYbTR5R0I4S1RrMVFUSkNCZ1ZNYm5iaXc2RXc2dHlVVnFLY05wUXJRVHFON1hyUG5PeTQwUklRNHJLY0gyMVhyNHY2cVhUVXNKVXRRQkJRbFBqOWRjVVM1SmNLT21LcXBMeWpnL09OQS9kMXVmRVJYMU16Sk9hMjF0ZnBNc1MwNnJOdktNOC9LcU1rZHFaRXB3cUVZSHlsdFBnQTRBeWNuNzY5THcybnRpOWFXbTBMMW9TcWhUQzRIQTBKSzJscGNUeWxhVk5sS2dSNXpuUm1kcGFrTm9iN1Fqc1NRQVVoSVVTUElHb1NUQlMyc3ZTZ25oT0J4Z1ovWFg4K1hyNWVGU3crNjRTc2JIT294dGl1L21VUmt4eTBoSTVlMUsvdWQwK1huWUxDWit6MjZWU2RhN2UwVy9ka2d6WWpnL3dwZEk5VmsvUTVVQnBldDBONFp0dUxYRnV5ank3V3VHR252RVdXb0tabEFlU3k2UGxjSHZ6enA2NytXbkN5RkJiWXdRQ09NL2ZTN2I0V2pFdnlBL1NHcmNjcUtrTXVIdmFoK3FHUjJuS2h3Y0VENmEwL2hDL2UvUE50M0JBWG4rOFlDaDY5RkQxR2ZPcXhUS3RUS3BjSldDa1o1VGtnNDdkdjVwUUl0YnJlV3pGUTFXcWdmVFpVbFN5cGVjZ0huR21xc0xjU2szUFFvOXgwR290eUkwcHRMclRxQ0ZKS1ZEZzUxbVhWL3cvT3B1cTBmL0FGaHNtZkVreDUzcUtZcHpzeExUcWtGUkF5RG50eCszalJ6NkFxUjFWYkMwbVp0ZnZwdDIvRW9zSWQ5S25HVWg0WlVjcWJCUVNDbjN4bmduV2pjVzhIOE5PMnBVcTJ5V3k0ZzZvNWdDUnNjQTY1Qnh0VjJGZnAxem10SWVqcVNsYWNoZU1wempPNDZINzArMFhjT1N5eW9PU3d0eHdBRlNzRThEOHA5OGFqS3BlRTJRRlBtZjZiZkNmelpJSHY3KytnK3ZkMmd5blBSaDFsT0VySVcxL1duOVI1MTYwT3UzWGZrcFVTenFhNDZoczlpcEM4cGFRRDV5cm5KK3d5ZFpaL1M1cmFlWjFSU0IzMEErZE5EUVFOQ0tuNzR1eGF3dDk5OHZMVzU4cXpnZVBiN0R3TWFYSGY4QTNoaVVHQS9KZW1KSFlDVkZibkFQbkhualREVmZwMnJWYWlsTmJ1ZVVoM3RQZUlxUTJCK25jQ2Y3NlUzcSsvRDB2ZTQ0VDAyMGI4cWtrSmFVczAyWXNFdUlISkNGSkF3Y2V4ODZjdUN4dzQ3Y2tvbFNRblhjZy9lbzd5NU5pd0Z1UjJ5dFFHZ3BidHNwc1BxcjZtYVJRSjkwMGVuc0NhcGlreWE3SzlLSUphZ1NGS0lCT0JnQWNIa2pScDJrM3ppOVB1NjFlMm5ybHdVcVE4eFUxcGNlcFU1RHNkMXdZQ2kwNG5IZWc4RUgzL3ZwWnJkb0cwZTFkOVJZVndTcEVLcTA2WTA1SFJKaU9wZVRJU3NGR1FFNS9OajdhbSt0R3Z0eGFzN1hMQW9rUkVlcnZyVkpxUXB3UysycFdRdHBKS2NwSGYzcDd2b01EalhTMXdza0M5Tm9nOHFneXBPRWtqQTAxeU8rZC9uWE5TT05aOW91eGZjUUN0WklVTlFjOUI4aG9LN2Z4RHV1R3RkUU55TmJYV2RWM0JhOUllU3AwTmNDZk5HUVhEN2xLYzlxUitwOXhwMXVnSGNlNkxmNlliWXRuY1c2RW1vdzR5MHR0RjRyY2FqbGFpMDJzNS9NRUh4N0RqMjFrbGI4K24wcXNzemF2VFRJYmJXbFhwcVdVNXdlTkhHM3VweGRBZE5RcE1weU13VGtzQjVYYUQrL2pWYml6Z09QTDRhWXMwQnNCRFo1czRHU2YzT2NuNVVhNE80b0NMMUl1Yzk3NDE2Y3BPQUI4KzNTdFVMbDNwcEZHcDY1QXFpYytrUWhSSUo4ZVFQYjlkS3ZldDBWYmRIY1ZjOHppaUJFVUE0NHRSeWtZT1V0RC9HZjZsZXc4SE9namIzVmsvZjB4cWgwcVBJZGVXa2w1YXVRaEtSa2txUENRQUR5ZFQxcVZtNUxndW93NlcrekhiZVpTNUxJUXIxQ3lEa0xVUVA1REFKd2tEK1k4U2NjY2hJNGQ0RGQ0ZWRXODhuQ2dOejBGRC9hcngvR25obTJ3MWMyZmlWZzU4Z0Q5Nk9jNnRVbU5TdXlPL0ZEVVZ2RGhROE8xR09jS1Y5YytmMzBENytxVDE2U0ZSYUd5NDRIQ2ZoZlRDMWVwemdsSmNJSkhua0lLZnZxeFhoQ1V6RytGWFdaTGJTVkJ0cHdwU25LanlRaHBJSVNlZkp5cytjQURJNnJOc0s1YlpvS0xrclRLbUkxVTdsTUxrcVBydk5qajFEbko3VkhoSUp5cnp3TVphWXhiU2t1N2tiQ3NEdkM3ak1YN3N5am1WNTdEK2VkVWExbUxCMjhiOWEvcnVhUzkySEZMcHkzSEpCWC9oVXJoS1AyenF5MnZ2SHNOV0ZpMlA4QVVrc1BTM0VOdFZCeVFVcVl5Y2QyVjVLaDVPTUo5OGFyTzV1MFVpc052MWFCRUtKRENDdC9EZ0hZQ2VDZnZqUVN1Q0RXNDFmV3hEYmNXNFZLWjlkQTg5dU00QThEQjkrZEZZOFZpN0FxV29oWDB4UVM2K3oxUlpMejc1SzFZL0NTa0ErZzMrZTlIaThyRTI2Z1Vxb1BYQmNLNGtoVlVVbUxNWmRjN0pLUjRTU0FyQndNNThrSDdhRjFTc3piaWU0ODNHcmNSUzJ6MnBTbDl6dUtpYzVKVVFTZjExd3c5MWI0dm1SL0JyZ2dvTWVSMk5GTGlSa0xiSngyZ2c5eDVQeStlZU1hc2RGTkNvOUpSVVpFbGFZbnhucFBTWkRpbFI0ejNqc1gzQnhjWW5uOHlRRCszQldQQmZpSndWblBZYWloME9CUHR6WEk2OG9xem9BUVJVSlMyTHhzTmgxNjNIM0pWUDdrK3N5cGFuV1ZxSFBzb2xzakhrWU9xL2NtOUxkRHFRcTFIWXJVVjkxdFNWTnBySGUyU1FBY0s3U2Y4WEI4Wkg3SFNtVkt5NmpSMzJHS1ZUM1p5MmxCYlRjT0lweHRKNTlRUHNKU2h4QkhnbE9UN2FFVjdiVDB6NEYrWjhTbDUxbDFSa1JrUWlnaG9EaFJWbnpqaklCMFJqU0drUFllR3RObHJSOElkWG5KMFBRbjZWU1kyOFZlbFBmRjBPM0tYQ0NTVlByRU15RnFUd0NzK3FWQW45dmZSYllyMWlVcmFHVmVGV3J4cXRWZGJLbW4wTnR0cGhrL2xTRU5wSGs4WisrZ3hSYmZyTVdzdUNuVXhSYmJXUzJBb0xIcGtlTStTTVkvUTYrbjM1dEhaY0RNSXBZZGZUOGJGVW4vQUlSQnlELzVTRHpvMmxiQVg4QUZFcGtFcFVuS09VYUgxOHMxYXRqN2FyTlV1dzB4c0xhWFZJeGRrVDJsa3VMYUxnVXBBd1IrWWpINkEvWFRWVXZheTNxTlFGQ2pVNXRrcVVlOHNvQjdsQS9meGpnYzU5L3JuUzdkTWMxTm1YNmwydktDS2RKaHJaaFNWZUNudTc4ajZGT1JqMkl6NTAxRkdydE5jcDY0eWlsMWFraFNVby84VHVIZG43SDc2b1RVZUl2bU94b2pFa0tCSUhsODZnYnBzV3lLalRhblZaZEhhVXRsdEFXajBnT08wZ2tjWkh2bkIwQUtoMUd5YkFyc2l4UkRFaUhIVTJxUEliY0lVRWtBaEtoNDR6amo2ZU04Nkp2VUZ2bTFidEdsME9uUm5aRXQ2SXR5UWxuQUxZSkhLdWYrVS9YalMvN1JiZlI5M1hwRndWcXFCa3BubFQ2MElQcWtxU2V4Q1BidDk4KzNBMElpeDIwcGRma2YvRDA5ZTRyN01sb0xZV280STA5TTFaNnB1VzdmU1hFMG1vcml1bHYxMjBLVXBSY1gzRUJBQ1FUaytBUHZ6Z0RKcmRVdEs5NzNxRFZOdUdGTmFmbVNCL0lhaTlwVjlFcUtzQWNjNC9jNloyMmFEdC9zbmFDUlJiZFJHL20rc3FVNTI5M2Q0N2x1TFBoT2NET2Nra2dIakViUUxnaVhKV1k4dCtsT090dUtWOEcwSkhhWDJ1UTR2a0RzUVRrZHg1VnpqT2g3ZDU1Q1RHWndnYktPOUJGdnZPdEZUQ3lzazRHTlJuMXE3OVB0b2JPN1kydkhvMW94V241c1p3cVZNbXBRQ3AxUUhjcGVRTzVROEQvQ01Zd2NuVjd2SGVTSEJnR0c5VlcxTzhlcTRwWU9CakdBVHlCalFaM01sMGlUQ2JsaE5ScFU1MEZHWWpxZlFmVU1lU0JrSDJ5Y2FnN0VvTmZsM05FcFZXZ05wUUQzS2RuWVdXLytiQS9PVGdmYm5KOGFES2FNb21RNDVrK2RNa2RUOFpLR2VUVS8zZjJrOWRUMStWWEJ5MmJsM0lyd2kwOTJPeFN5K2hjbGRTWVU0MnRJT1FFWUFPVmNZSS9mUmRnL3dXaHR0bFNIMXRSMVljWkNoMko0L09uM0g3NjdyWm96RVdqb0VpckJicjJDRXBiTGhPQmdZQTRIalhsdWRUbUlOS0VtUFZHVzVYb3JLR1gza3gzVkhHY3RMSTdGRWY0RjR6N2FYcGhMd1NrNkRORWxZaFplem5iTy9UNUNoaDFRVTJMY3R1VTJvMGFHeE9tUUtzMDUyS1VFT3JaVm51Q09jRlE0SSt1RHFnYmlWZXQxMjJYRzQwTnh4TExSY2pFL25KQ01mcUR3VXFIMUlPckZkN1VnUlE3VTRxa3A5VktWSmVUMkNRc2pPVW53Mjc1eGdsS3NIdFB0cUZhcUUrcW8rSFFuL2lLQ1FYVWRxbGNjaGFmNlZnZWY4UXdSNE9yOFZ4NWhsQ0FNaEpxbE5kYk1OY3dLMDNQeS9XdjNhL2I2bHU3VXlJVWRLVTFDVXdGdVBwQTlRaHNFcFJ6NEdPRG5XcWY0SjJ4VXJweDZjWk85TjRRRnQxbmM2YkdkcDBkdEh6b2dOaFlqQTU0VDZpaTQ0U2NBSjdjKzJrTi9EVjZRYjE2bE9wQnUxNXI2bWJhaXVtWmM3dUNBbUlsWHpObzlndHc5cUI5TzhuMjFzWHZIWGR0Tm9MZmpYWHVjYVhiOWswQ0NsYk5XcTA1TEZPalBvK1JEQmJCNzMzQWdEc2FiUXRSOEFBa0hUSkFiZlZ6U0U2NU9uODhxc1FNT01vRG1nS2NuMDNvZzB1KzFWYVUyeEZtb2ZSSXFCaXVPVXhhWFV4MUpUbFFXNnJqSTl3a0hCSTUwT2V0RDhRL3B5Nkk0RGRLM0t1RjJxM2hKWTlTbVdEUkZJY3FVbi9DdDNQeXcyVC85UjNrNCtWQ3RacmRaSDQrZGNURW43WjlCTklrMjFDZWVXS3B1aFdJU0VWS1l0WDVsUTJEM0poSlY0Q2xkejJBTUJCR2tKb3U0dHozWlhwTjIzSFhKTXFwejFLVlByVlRmVXR4WlZra2xhejN1S1BPVkVrbk9pS0k2bXh6dkhLajlCVldkZUlqVGdiWk9UVE9kV2Y0cW02dlhqYzAreDl4cEtxTmJjQjh2UWJMbzYxQ0VPMGpDblA2cGJvSGxibVFQSUNSb1RiZDdhUmExTWVxTlNjQ1lTaVN3RUxCVDJuM3orMmx0cmxVbFI2MU1GQ2xQbGZxRW1VaktNRFBrWTl2L0FGMHlIVE5kN2R3V1dnRjRPdU1LTEVvcklJQlBKNDl3Um9IeEkxSml3L0hhVWNIQVBsUUdSS2VKeXBXYzFmWkczVktsd1l6YmJTMHcwSzdGcXpqdVNCNS85RHJ5ZmZnV1JTMDA2andaRWhwYm1FS0h6Sy9YbnhuVStyY2FEUm9hNFZRZFlscHgycEFTbEFUOUFCN2FqSVRLNUpOY2NEWmpLYzRRWkNSZ2ZiUHZyUGpNa1BqRCtlVWZRMVRXb25ZNUZWTzY2aFdhd2ovZUdYMjRhaVIySjRVb1k4RFAzMFBibXVXbFVwMVZPVExDQWhraGJaV0QySDJCMWN0MTkwYWZTdmlGMGRDQ1VwVWxmY29jZmZTejNKVmF2ZHRXZG14MHBqc2xXU1FudFNSbnp6cDA0ZXQ2cERlU25rVFZWNGdveG1ySFVxemI4cVVwNWJhblZvT1FmVUo3ajlNZTJvSzVycnFVcUo4TXR3dG9CK1JzZmxIL0FLNitLZktndzR5WWNPbHVTWkx2NUEyTzVTem5IQUh0cXkwUFkrNHJnY1JVcnZJaXNubEVCdjhBUHo0N2o3ZnBwclg3cEFITStyUWJaM1BvSzkybXh6N205aHRKNVIxTzFXSG92MnppWHZkTTIrcWsydDJMU0d1MWdZK1V2a1p6K3d6L0FIMHlHeWUyZDE5UnUrOUMyZXN5RTY0NVY2bzFEYjlKSjhGUUNsRStjQVpQNmFpYlV0aWg3UTdVd3JXb01KTFQwMGVzOEVjSEt2Nmo3OERqV25uK2p2OEFTQkVxRndWdnEzdVNqQkxGTUNxWmJoZFI1ZlVQNXJvei9oVHhuL20wTGdGRi92ZmpBZkFuYjBxV2MyRzVhWVRKeWM2a1ZwdnNWc3phMndlME5BMmdzMksyelQ2RFRXNHJZUWtBT0tTUG5YK3FsWlA3NkRYWDMxN2RMM1NaU2FYWm0rbEdSYzBpNFpUYlNyV1pqTlNWcGpxVjJtUTQyNENudDVBU244eXljSkhHZFRQNGhYWGZ0NTBLN012M25Ybm1wVmZuSStIdHVpa2tya3lGZktsU2tqbnNDaU0vNGlNRDdZNFVucDY2dmVxTHJVMmUzbTZoNEQ3VGU0OTZMbVUyQk5sZHNpUkZobEtuSmEyeG50YkhjbENQNlVqaFB1VHF6RWNMR1R0WHVYTlcyc1Jvd3lSK0k5RWo5U2UxYWE3cmZnejlHbStWS1p2emF5aDFUYnlkVTR5SmJTYVNQOTNIcUpDd0hJanhVR3p6eUVGT0RwU2VxUDhBQ1g2dzl1YVN1WlpzZG05YVJFR1cyN2RRQkpVQi9qWVdRb24vQU12ZHJXYmNiY214dG5iUGZ2Ry9hNDFUcWJFN1VCeFFLbE9MUENHbTBES25IRmVFb1NDVDlOS1RmdlZYMWIzMzF2YlRiSVdLWUZrVUM0UGlxMVhhRExnSWxWaHlqTUp3bDZVb25zaUIxWjdVdEp5c1lKS3VNYXFLZ3N2NStHcnk0N0ttU1ZhWkd2NjFrRmU3OS83YlREU2JvdENvVWlTUVFHNmhCY1lXQ0RnL0tzRDMwTXJ1M0lxcmpTM3BVd0U4akI0S2pyK203ZGZZblozZkNqcm9lN1czRkpyOFpZUHkxQ0lsYWhuNkx4M0Q5anBFdDNmd1FlalhmK1BWS3gwMDNoUzBQUkpic1daVDNKWmtzTXlFSENtdTl0WGV5cEo0d1FkQzVscVhJUmhsZUtYNUZrVW5WcFcvUTFoTGUrNUZXZGxLYVRKY0E3Y2RvVnhxaFZTcno2cytWcld2dHo4dVYrK3RCT3REOENicVg2ZktIUHYyRGF5NmxSb1h6ZW5SWkJsa0p6d3I4b1VSOWVCaldmdDhtcDJ0S1ZTWnRJZGlsUERucU40SUk5c24zMHRLdEVpTTdoU2NudjBvTTVBa3Nyd3BOUXRWcWJWTGFMYUpCV284clgzZUI5QnFzdjNMSFU2cFFkSUJQZzY2cWhEbTE5NE1RL1VXYy8wcHlQT3JUVCttRzZKMEp1V2FlNFBVVDNmTXZCL3RxK3RVQ0VrQjlZQk5IN2JhSEpEV1FDYS9wS2Vxa0ZVVXQ1Q1NBUnlySSt1ZFU2NlpjUmJhbmtUMWhBQjdnQmdINm56cWhmN1c0L29sVWlTZ0VKd01ySjFCeXQwbzlmcmtlaXNTa0tVODU0enpnRG5YODJoRXVENDVWcEFBOHE3V2pOa3VZSnF3bTNwRnhlbzI1VUYvREZXQUFPZnJsWHVCK21vbThkbzVNaUU0WTFTa01JQTlKQWpQS2JVcnVHTWdqd09QZms2SWRqMDltYzJWSTcwaG9oWHFsR1VrbjJQN2FrcXBSNXpZQ1ZzOTZVSUtpcFdSeURnNUI5d01IN2FuRWlWRmJRNHdOdXRNYkliR1VLb0gyTnNyYnRsMnhLcFRrRmJqd2NMaXBTeVZyUEdQemVjWjUxV0twUkZ0RnhrbjFtUmtkcS9jWjRIT21GZnBrVmx0cHlRcFFLMHJTQUFVNUdQYlBuOVAxMVE3MXNsTUFGejB5Q3B4UjdNNStuUDZjNnZScnBMVytYSHlTVmE1Tkc3Yjd1eUEyME9VRHBTeDF6cEtwKzlXNE5QcHByYzZseG84cEw4NStudmRpeXdDTzl0S3ZLZS84dVI0QkowMzF2N2NXdlp0QmkwYTJvRE1hSkRaN0k2R216OG1CakNzOHEvOHg1UE9kVXphcWx4WVZTbHlVcUEvbTluY2VjSlQ1SDduUlZhaCtxMDI0aDBJUXRlVzBKODRJNC9VKytQT2lGNXYxeHVMQ1laT1VvR25xZDgvejBxZHhtTzNKTGlSZ25lcVhVNGFWc3VyN0Zuc0tpQ24zK3crdkh0cW9YSFRHd3lKS0ZFL3l5UXBRQjdlUEIrbzBVYWhTZ0lyaXpnSlIzZW90Q2dRY0RPUHFEai9BQ3pxZ1hVNjBocGwwTjluY0NYMEh3Q2NnRGtjWkg3YUJ3ZkhRc2N5U0t1cFcyb1lGSWIxbmRMVnY3MnczYTdFYWl3cTVUcFBmSGtMQlQzWTU3U3BQUHNNYVdDNFpxYW9EWkUybnVOektNNkdaTGMxSlA4QUtCSHo1T2VEa3E1T2YxMW94V1JSS2pMblI1NnljbzlabEtFNVVzcElHRmZRZWRKUHZiYnRvVTdkYVJPTlZhak94cERianhVOTJOUFF3bFJVRjhja0JXQU9lZjExMVg3Tzc5S2xJRnZrRWxLUmxQbG5HZmw5cXhiMm0yR1A3cVo3SVNseklPVHBramI1K1hXbEwzbGFwTlN1UmsweWtQSWpzTjRkY1MwRUYwSGtMQS9USjUxK2JkYldVMjc0MVFRS3FvTGpQQkxUekRwd29GSVVNai90K3YwMTFiaC9GTnc2ZldubVVZbVJIRnNyN3Z6Tm9jVWhQSDF3TlNIVDlUN2ttMU9WZFNVQnFsdElLSEVsSHlTbjhmSzMrdzVKK2d4NzYzOVRqclZxK0JYTHlqY25xRCt0Yzd4N3NYNXk1VXh2bUdEa0RUcFZ4MmwyNmhiY1U2UzdWNnVzUzVyd1NoSVBjQWdESVNHL0sxbjh4QndrQWZON0Eydzc4MEhiK21vWXBkcnZRWTRmVXVyUzVzcjFYWnJ3SEpiUUFDVmdFRHVWa0pIK0h4cTliZjdWMUN1MEdVM1RXZlVsTnBTaGN0U2gzcVV2NWxoT2Y2aXIrMk1hRmU5ZTFydEx4SGdVNXdxS3lKVWg1V1VudE9Ta24vRG5rZ1lISDY2Vy9FUmNKSC91UVNrL1NnbjlMYlM4dVVwWC9JVG55QTN3UElENjFmcWZ1UGF0VnRoMjcySkMzWHBEWFpGaFBxQmVLVHdlMU9jako4NDgrVkhBMUN4T3JtNjdybFE2RmVha09QTXVCaW5TWXJlQkhqcEdFaDVRNFVvQk9Bcmo1UitoMEl0bXBGdHViaUtkdTF5WElndXFEVHprY251ZlNuanNCL29TbytTUENlQnljNk1sMXpsVitBbWsydlRvMU1vcGpyYVd4VDR3YkF5QmdoV001UDFQSjUxK2xSb2tCZmdsR1FldTJQNTJvbERaZmtIeEVrQUo2ZDZzRS9lNm55YmZuVTZuUW9NNVVxUWxsOXhUM3B1SkJBQklCR0NmMDRIdHFwUUlkcnlxWklrdExaYWtQdlQyQXVSeGdyd2NnKzVUakl4K252b0IzaTlYclZxY21sQ2NwVFVlU2x4aitibFp4Z1k0NTl2ZlZ3cGxpWGZOc3FOZWR6VjR3YWNaUmsweEJKVzlLQkFVdEtVWkdCOXpxeTlhMjBOcFg0Z0FKSHpyNU1VWGtLYkNUbkdPK0trSUwxUHVhUlU1MVBoc3lxYldqRjllT080T1I1N1RUYWk0MFU4b0tqNmdWZ2VEK212cmVxd2JvdGU4S25ETmRMMVNWUjB1VDByVDZhNW9Ra0ZRVVBDejJnSzUrYktTZkoxQVdUZXRzV0RDZW5VSnFVWXRRbGxmclNwQ2NSMzJsaFNUMnRqSVNwSktEem5WaDNIM2tlM0R2cEZPclM0a0dRcUNGVVN1TXVFcGRXakpaS3lmWlFLbWxmdDlOSFV0a0xCU1NNZE80MCsxQUMwOHlvZ0p5Ty9VWXgvRDlhZ3JKY3ZDZ1dKTHUyalcwN0pwa1FkdFNXeVNGUUhGY2Z6Q1B5b1ZrZHZzZkhrNjc5cmF0Y2U1bHpDaVAwOCtvMmdxYWI1d2VQektINkVjZU5WQnk1cXZVckppVWlxVktYVG1FVlJBbk1veWhtVUVraEtqamhTbTg0N1R5RTZNMWdXbktYdUc1dVJhMVdaOUJUS0ZzS2pyQkJTQjZZQ2svd0JKSlNlRGpnWjhhaWtpTXdDNDhCMTFwb3NFZHA2YUZFRFR2M0gzcnAzRjJEcWNheUg2elMyMXhaMFpZVzg0VS95eU1aQUJIUGRubkdoRFI2K0xsb3RUb2xlU3YrSzA2S3Q1aFliK2Q1dk9ITW42cEhQUGtaR21KdTdkeTQyNDhpRFdVLzdxWTZsS2JRakxoeDcvQUU1OS9jZTJsVXVhNW02WGZwcmRGYld3bGJ4RGlWZjF0cTRXa2o2RUh4cXZiRXNTTWhzNUc0N2ovRk9IRURTWlVNaDBBRWZ6NjEvb0Y3eUlEaVk2ZTVrZGlESFdIQ0NqQU9DRkh4NVBQN2VORldpNzdYb3FMR29kQ2d0U2cya0pYS1ZJQ1RqZ2R1UmxJVjkvcHpvQ1EwVEtsWFJGanBXVXJrRWRqWXh4M2ZUOU5NWFoyMzFVc1MwVlhkY3RJRUNQZ0NtUVcwa3V5c0RKWHg1QjhkNVAyR1I0dlhSVE1aa1p3U2RobXNvdWo3TnZDUU5WcTJUblVuMDNxazAvWjNjbStMaGtUS2ZDZWxTSGU5WlJNYUtrdHRBajVsclBBVHo1OGNmVFJnMmcycG9teWRGZHJlNGx6UlYrazc2c2VrVWg1THpzaFEvTXJ1R1VOb3hrQlN5T0R3RDQxUlpPNDI1VWk1VkpwOEZ1blJuUUVyYWhJN0ZLU1FNSko0empqUHRuVS9UTHBIb3RzVkZzSmt4eUZKa0xaQkR2dUFzZS9nZ0gyUEI4NldwMGljNjM0YThjbU5odjg2VDcycS9FQnA4QkNEZ2tKMytaL1lab2x3NmxYOXgyRGVOU3BVSnBwRGFqR2JrSnhHaE5BWVNVZ2pKSVRnRnhReVNmYnhxcldOY0ZmblhpMWJsU2p2WW15QUZwa05GdDRER01KenlCZ1lIc0JuSG5VOU0zUGV1TGI2Yll0RWFpdFZDWEdRRUlKUTBsYmZjRkVncUk4L2ZYNXMyOVZwRmJkcjFjZ0tsdHd3QXVaSlQzUElkS0JoQ1ZrNVNuSGdIams2RmdEa09SanBqdFdoOE1yam0zZ3NwQUNkTmQvd0RORVMvS1ZEaFVocWwyN0NhZncyRVNTbG9rSXh4d1BmR2dsVjY5UnJOM1FaTXV0VDVVMWhnZkR4VXcwK2tsSGRrOEtJU0R6OWM2TlczbHl3dHc3NGZwOVhjQ0VOdEZVT0tGZm5LVDVYejh3QTR4N24zT3IxV3JPaXV3Rm9YUVlpMlVaUHB1d2tnRGo4NE9EcWcyNEkyZWRKSUlPMUhscGRVQXRHaHozMy9ubFhyYWU5RkZsV3EzTFlNV08wdHRPR1ZLUVZrNEF4M0pQeTgrK2M2Rm03L1UxYlUrdVU2dzJiOVprS2RtdEdWSGRwWHhTZXp2K1lCdzVDU1J3TW5qN2FyZTVtMXRsdFR4V29WdnJZbkJaVWY0ZFVWTkpjd2NweWtZU0NjL214a1o4SFZhaVVTbUlaTGh2R29seHhYODZNdXNCbU93UDhQQ0ZMZFVQc2ZQMEdwWTBXQmp4RnF6NVl4cjU3MEJ1Y21jNlN5aEIxNi96UDZVWTZKVEtOZDhWMkMvVnFlNHg2cENXcEVUMHlSNTVLSEZCU2VjL09rbjNCSGpWaHVUYk94SUs0RkhqMENLek9DRXlHcXF3cDFKV2xLeVFGaFJLVmdqSUdBRkp4d2NaQlh1cDNsVjdTVW9RWmtwMHZnWXdvbzdsSzhCS0JseDlaQTRBN1FPQ1ZBQTZ0OUkzeXVtMkxlanhaMDFtVDhQaDk2bk9yRGphRGp2RGFpTTk1VW5sWGFRbElJd1ZGUU9vVEJmUWtPSlR6SlBUTlpueGk5ZnBNVU1RZ1VxT20rUFhRYjU4NmRycFY2eHRzK2czcFVxTHUyRnFOWDF1aGRGYWtxbVIzM0ZSNEZHak5MS0lxWktrL3pYOGdxYzdHd0FTb2R5MDhEU0xkVzNVVjFSOVRlNDc5OGIrN2dWV3VTa0ZZcDBKdU00MUNwREo1TFVaaENBMjBrRGpLUVZIeXBSUE9wdzNIVnE4K3U4YkhjUlQycGppM1VRa3h3WFBKQ2doVGFrTEpRUWN0Z2xYYU1weVBFUFVLdGVsMlFwUmpYRXhVcENFOTZZY081RzFMZHhudS9seW0wTEhqd1QvZlIyTEtlOEh3d0FBT21jZlUxV2hYWGl0NkdnUEVjcVFFNDJPUU1ISndhSCszbTF2OGR1bUV6VkVMVTFNZVFoUHhFQjFJN1ZIQVVGRWtaLzlPZFNHKysxTGV6MVFhdUMxNVVPb3dIM0hHVnRQSlVIWTdyYXUxUVVrK3h4bEpIQkIxYnRuWlNwTlpVbWRDbVUrUTI0RlBSNTdQb3VvSjQ1N1QybndmbXdNZysrcFBlemJpSFdyZG5GZFRiVXRRSmFCWGtsUThqOTgrZU5XbWlwWlVwZlN0RWdSQzgyZ09KSUpIVFg4OFVzMStyWEphRWhOY1lEanpmY2lPd3oySk9SNE9NYzZsT21IY21aYlZYblVSbHdvUklRQ29kdVNGRC9BUEU2cXQ0cGtXMDI3VDNXbTNrcFBEaWtrbjZZenFWMkIycHVpOHEzL0dZeVhJN0JQYjNwR0NzZStOWFp5SWlyTzU3d2NKUFdwVnhIRkpVei9kbWpuV054S1RiekxkWnFVVXpIRkt3d2twK1VLK3BINmFwdGYzeXJDWnppcUl5cGJDQ1ZKUXRnaEtjam5nY0UvZlJndC9wdXBxWVRCblFFeUZZR1BXSlhqUkdwM1Q3U0lsT0RjaWpNRUZQajB4Z2Y1YXl4Vi80ZmdINGtGWjI3RDZVVHQvQzhpUWZqT0tUQ3M3ajFLNDIzSFpjRmp0Y1VPOVNrNTUrbjMxK1d4dHRkbTVNaG1PeXl1blUzdktqTGQ1Y2MrbmFuai8wMHpzcloyTFlOMGk4Yk9vOU9UT2I3dTFtWlQwdXRLQjQ1U3JnSDdwd2RDMlhYS3JhTTFWSnVLRjhPNTZoN0hFZmtXU2M0QjlpUHBwcmo4UVE1TU1HM0Q0K3g2ZVk3MGZ0M0JiU0pSTXJWT21NSDcxTldwdGZiZGcwME0yb2xweDFRQWtTWmljdkxJSE9GZXcrdzFhOXVyVnFGdzE0ejYzSFNpbVUvK2JJZFNjZzQ1Q1AzT3FOVHJ4aVZPcndxUUhUM3pIMHRqbjNKNS9UUjNyelZPb0ZQaVd0U1FsbGxEWVhMS2Y2MUg2L1hTNUpibnZQQU9hcVgxUFFkYTk4UzNpTllZUml4d0FvOXUxZjYyTFN1RGVyY3FtMm5iZE5jY24xbWUxRGdSVUo4RlJDVS93Q1IxL1F6dFJ0N1FPaGpvOWhXaGJsRytMYXRDM2k3S1JIUmd5WkdPNTF6NmtsZWVCa2tBQVpPTlp4ZmdGOUtDTnc5MjZqMU5YUFN1NmwybWo0ZWkrcWpoMmVzZm41SFBZakovVWpXbWxlNnd1bDJ6NzFtYmVYVHZmUXFkV2FjOTZVeURQZlcwcGx6QU9DcFNlM09DUEJQbld1Y01XdEZ2aEpLUnFmdFdaVy9sU2hVaDlZU1ZhQWs5NnowNlgrbEhkbjhVN3FZazlYblZkR2ZaMjlvZFVXaTM2QTg0UVphMmxjSUtQQVQvaUkvTGpzSHpFblZ2Nmg5MnBsZ2ZqWFV5dlZIYmFyVldoMkJ0SzFEdCtOVElXSTdVMlVGclMzNmgvbHNnL0tNbmtKUndGWUEwLzFqYmxiSVQ2UTFEMjZ2ZTJIWVFLaTB6U2Fnd0cwbFJLbEh0U3JnbFJKUEhKT2RTRlNzS3dxOVhvZDVWQzA2ZExxTUpYZkNxQzRxVnJhVmpBVUZmNGdQQlBJOXNhYWk2UXZVYVVUaU5SVU1GTEt3U2NaT2Mvek5BSGE2ekwydVoyVjFYOVlFeG1JelM0ajB1ajBhVWdwaTBXS2xKVXQ1RGEveUhzQi9tS0hxcnhrOWdJVG9ML2hUdFZ6cXc2aDkwdnhNYm1nT00wcTVaWCtyKzNETDRPVzZSR1BhRkp5T0FyR2NlTzVhdFdMOGQvZDI1N1k2UDQyd2UzNjNqY2U4RnpSYlhoaGdudkVkeFlWSlZuL3lBSXovQU0rcmxmdTVXMi80Vy9ROWI5alVwbVA4ZFFiZWFoMG1uREE5ZVYyZk80b0RrajFGRS9VbkFHdlNlWXRaQTFPZ0ZTUzMyb3pZTGg4ejZkQjh6VlgvQUJVT3Y2cGJDVzJPbjdZVjVFemMyNkkvcFJBMWxZcExDL2xNaFlUbkNqbkNVK2M0UDAwR3Y5RzgyZnJtMzIzVzcxWHYxTWwyNVhkd25ZZFZsekRseFMyOHFXRDh4R2U4a24zejUxRGZoeDFMWm1xVnk3dXMzcVYzRWd1M3hPTDhpQkFyUWRhZVBha3JTdEtIRWhPQndHd0R5ZWZwcG8vd2tMYmtVM3BkZnZhY3Z1azNYZEU2cVBxVXdHeWU1d2daQTkvUFBrNDFJNGhMRWRTQnYrdFVJb2ZrdUNRN3BrNkRzUE9tZWxMWmFaVTVLV2xLTWZ6Q3RRQ2NlK2M4ZlhPZEx0MUMvaHM5QTNXdFIzS3JmV3p0dVZGOS91U2k0YmVMYk1ncjhFaDVuaFpCOWxBODZWSDhlcjhRZTZyZjI0ckhTVDA3VnBiZFhtd1NMeXJFUXF6Q2lrY3gwS1R5SEZnODQ1eHh4enB0K2lWcXpPbTM4Tyt4SnRVZFREcHRHc2hpYlBkU1NjcVUzNml6OVZMVVQ0OGtuVmNSMWVEem5xY0Nyd2tzUFBlR2taeG5KNmFmclNHYnFmNkx2YjlzMUtSZFBUSmZiYzRKS2xOMFc1VUJ0U2ZzbDFIQ2o5Q1VqUU5xdjRTSFc1UWFpOVIzT242ck9tT3NwTHNRdHVOcSs2VkE4alcydlNaZEc1MSs3UkkzUjNTNzRzcTRKajB5blVsYllRYWRDS2lHV2xZOHI3QWxTaWZjNmtLNXV6dFBSYXMvUzY3dVRRNHN0bGVINDc5V1pRdEJ4bkJTVlpHbGk3OEpXMjZ2ODdvT1IySm94QnVUc1pyQ01ZckJ1NWJ5dXFqajRkdVlvaFdleFNteWYrbW9QWWk4cnltNytzbTRhczBJcUlMd2JhWlIrZFpBQXlmc002TTExMjdaMTBSWFpjV0lXVk5Pa0FwU2ZtSFB6ZlQ5ZEIyNXR1TDJwVnpSN2gyK29ianJyVWtLRHJ2OHR2dHpnako4NTU4YTRzdHNxRkpqT01LU0VLVWtqSnhwODY3Qmx3bG9VRkpGUFZzL2ZOSEVaTEQ3U1NYUVFwS2lRQjlNa2VCN0hWcHJ0ZnBreHdvanZwYVdVSlV0ekFBd1BKU0FjWkE4YVdTeHJ1cUZNQ0ZWQjFjZDVTQUhtd3I1Unh5RC9pd2ZmVjdqYmhkakpSR21keWUzS3dWQUFuMlBHczhmVElpcDhCS1FwUDhBT3RmbVVLV3Y0c2cwUTZ4TmxJYWNWQ1pTRUxRWFFGRkszQXpqQld0UXdsR2NnQUgzOGM2cUc1ZDNRcFNTWXp5UTIwakRaN1VwS0VuZ0o3UjlzYy9YVkYzQTNualduVERMbVZSdU8zM1pQekpiVDNlQWMrNVBubm42WTB2MjRuV0ZaY0JxUWh5NVk1VmpHRXZBNEF6OTlGNE5qdWw1NWZCYkpUcDUvWVZlWmtzUTE1Y1VNaW1HMnB1cGljMCtXcEtmVVJVSFVaN3VTUW9FZjVhTGROcnpMakljVWh6dlNydUMrd2RxYyszUE9zK3VqcnF6b2QvM1pjVkFwMVVCYWl2dHlHWEIrVlFWa0xDVDc0d000OFowMjFDM09aa01Edm1udGJ3TStPNCszLzQ2ajRrNGV1Tmp1U20xSklPQWZxQWFLeHAwZWMySEVuSW9pMXVxd25HWElzVjVEWmU3aSs1Z2xKSkhKUGJqSnhvUTdxVmtDTzRwNmFzQmJtR3doUGFCMjhZUDYrZU9Nbno1MVAxZTluSDh2ZkZJVWxDUmhKQTQ1OS92b1hYbGMwaXJ6eWgwcFF5MjZWbEtRQ2VFL0tEL0FKNnFXdGlRODZDNE5xc0tjQ1JoTlVaMTVFTzR4TWZBSGVrc09oUzhCV1Q0T2xjNnRLRGF0S2wxcStvVWhEc2lrdlEvV0xMbVBWQmVQY3pqd2ZsR2ZyNTBZOTU3MFZBaVMxeDV5V25jajAxSnh3UW9rcS95L3dDbWs1bjNnZHpkelhiSmt1S2ZoUnlxWktZNzFLTDdwUGFrdUgrcnRCQndQcnJvajJmMldVNUs5N1NjQklHUjVBZy80cEs0eXVVT1BidkRlRzUwOWFIS05xNzAzSGx5cm5mWmNreHl0d3czSDJ5MmtvVTR0ZmQyaklCS2xFbjJHb1doMDUzYWpjbWtKdUJEaTRabHBhbngyM1R3MjRlMGxQT0FlZk9tVWtWeW5XL0ErQlRJWlJLWlVXa3hFbktoZ1lQQTRUeU5LOTFBM1dLeGRLR1d4MnFhSGN0WHZuUG5qVzhXK1RLblNDMHNmQVFkSzU5dWpkclRibG9TMkFUc2ZPbTB0UGU3YjBXZ3R5ak9ocDFhMjB5R1ZLd3BYejl2Y29FNUhqR2Z0cWk3clh0Uzl3b010dWlOSVF3SDFSMll6U1A1am9TTWxaR2NCSUhQUDE1eWRjdHI3ZDBtMXRoWjE1cWhoZFNteFlyUWRlVGxTVXVZVU1aOEg1bEhQMXgrbXFmUGxpektyRGtPbjBvbFRLbXk1Z0gyQVY0OXp4b0xDaVJ4S0tXbEVnSFRQbHZTN1pvZ3VicUJJUEtudDN4ajcxVUk5bnptS2t4WEtmTExhSTZ3cU1sYmhPRkpPUitYNjR4NytkRXVrYjJ6NDBLUGFFdXpZNlpjbVFHMVRGdlphUUNEemdrWlZqMlB2cjhYdGpjOXUwSnVxVmlrdnhvcjRMa0dRcGs0ZFI1R1BzUVFjL2JWSXFDYWMrdDFNZytvazV3eVNlRmZYUHRvb0pTbjFsQzhFREk5SzB4L2hXMHVSeDd0OEtzZEQ5NkxNcXdkdWExUjErblQ0cjg5emxjaDFJVXBTanduUCtIbjZmWFZNM0hwOThWT2t2MHFxdW9iYnByQ0RCNEtjSUdjcEFBeHhnWkk5c2FybTBsK3MwcStHYUJjTmFEVWN2OEE4eDl4V1FRUENmdCt1bUczaHE5azNCUWFiUTZkT1pMS2tmN3pVMkFBdERhMDlvN2NuQ3ZPTWZ0b2VxTktoUzBrbm1HaEdjNmVsS1R6Y050dmw1UUZESU9QTHY2MG43MEo1TUNXekRqcmFMVElja3gzamoxQUZaRGcrdmJrY2p4KytyTHQxYmxQclYrMCszYXpTL1VaZURyWnA3NnpscGFtKzRMUmpudFVRU01lNDFMYldiUHIzWDNJa1dkVzZ1bEVPZ3lGc1ZXYkFVRmVzbEtpaElhSkdQbng1UEdPZmJUUnQ5UGV5OUlialYrbDI2STAySzBwdGNsK2NYWkJLUmdoS3pqc3lEakdQMzBldVZ3YWlObG81NWlEdDAwMHBmaVdoNldvTFRqbDg2VmV1VnFuMUJGUXN5MktQRGRwdFBSMnVNdXQ0VTZBcFFVNTMremlUbkI4Rk9ORy9wbXRPUDhBN0pHVlV1S2hLcEtuSGlna0lMb0pLRXFKL3dDVURKMXk3aWJCV2FtbnlWV25ia1dJOHRKOVJVV1d0SzFwS2NqeVRuakg5OUQrMjk0SjIzVWFGWlMzVk1NeGdwdE1oUk9RQWNxQkh0emtuOWRDbHZDZEZMVElPZXg5TlNlOUdyZmIyN1dzbGVOY2JkS3YrOWtaNFFGekZzb0xDR3lRMmwwanVVUmpHZmIyNThhV0NuV1BjbTR0NHlhVmIxUEFTSkNpbzkrVU5KejdxK2c1NTBhbktoZGU5OHVYYUZqU21lMWtxa3pLays1bG1PMzQ5VTRHUms0U2tjbFNqZ0RYSFlqTjVkT1U5bDZIYmJWVVd4UEVoeDA5NkM4cEtrcUFVRW5PQmpHUHY5ZFc3Y0hMZEdXRTQ1enNEOTYrWGdTN2dNUmhrOTZ2TzFXeU8ydXgxRVRmRjl5b1V1cGlGM1IwdXNkd0I5MUJvOG5ISEtzWnlNWTVPdWphZmVDMUw5dnVkWDkycGpud0RVUWlFekpjN25TZ0hBQitxMVpHRXBBd0FBTURWZTN0Nmw0VzZFbVJPck8zVUMyNmhONzFPeWFVMnRJZVV2OEF4SVdTQmdZQUk5aG9MMTYzcXpUSXpWY1FtUzh4SWNWNkNtQ0ZsQVZubmp4aytkUk1RWEpxbEtsTCtKV2dQYjBwSVR3dEp0Y3d6WkdWdUswenVCNkRwVERiN2JwN0dVTzdWdjdjVVl2UTF4V3dmWGNUM0pXZURqQXdNZnFTTkMydTM3RHIxUlZPb3pQd0tDcFFTaHhJSmF4ZzU0OGdIT2YrVldmYlhscy9Sck8vZ01pbjFKU0pGZWtPSVEySDBkN2JhRmtrT2o2RUZJU1BjbFdPQm5YN1B0ZTU1MWNYRWVjRHdiV3BabEJYL0JVbkdGWkhudTVIYjQxTVk4V080VUtHbzZuclVVdUU5ZFhRVzBsUit1OWRFMUZmcHJURlR1R0RMRERaQitaa3FBUWVRcEp4azV6d29jRUVaSEdpaC90dXBGUHN0RFUycng1UzFKUVhXbjFxVXRDVWpnS0l4alEydVhxQnJiYkZOdFc1WVRUakZQakppSVY2WktSMmNEUHVVZ2NZOXRkOW5WaUR2RkdsMnU5U2tSSVRNbExyak1kS1NyMWUzdHlGWXoycUh0cXJJaTg3UGlPcHdrZFIycVMxd2JoR2srN0ZIS1NkajA4Nm1Oa3Qrb2xHM0lacmpMZmUwWDBvZGRLbGR6cUFTU2tmNFJwN2FSYzlwN2cyd3pJYmRaTWZzRGdjWVdlN3UraC9UOU5aMTNqdEJJdFo5dCszNDBoQ1VrcldnWnduQnhualZyMngzMXJWb3NDMm9VcDlXVDh3VzduQjl3QnFCd01xUnpNaktTTmowcDM5d1c2MkVsV0ZwKzVwaXQ1cktYUGNsejZhK3B4YWtwV3IwMnlQaWNBOFo4ZVBPZnArbWd0dFphNksxZmRiY2ZwZjhpbHlRbU8yTUhMNUNTc0tVUi9TVmNEeHFYM0M2cElrSGJadTNhVWxNbXRURnBqUTBJQlA4eHhXQVNCOU01N2ZxTlZXMnJxbld4QnFGTlRDa1FqQXBhNWxRY2Njd0pLMWorV2hYMGNXcnVWd1QycHpuSTRIaURid3RLbEtId25RVXBYaWFZaXdrSFVaL3dCL1dwVzk1ZElvMVdWSWVjYVhNN1MyNCs2cjg1VUNwdzUvb2FiUUNWRWNxSlNPTldYWmJwdHVMZDJER3VpNHBqa0dtVGt0dnNNRkg4NTV0VGdjQlVEd2dLN0d5Zko3VWdBRHhvYVVDMjZwVmJtanNYaTRBeEZaaHFyempoeWxoVXBYZWhnbjdqdDdoNUdjZmJUMzJmYjhpbHdtSXMrZTFHY1V3MitFcVdBRU4rbVNCZ2VBQUFCK3cwT3VaZmdOaHRnWVVkejJIbFF1Mk14cmhLVTg3MC9QK0Q1VU5ZWFQvU3FBeTVFaFFsTGp5aXNPdHZ1cVVFSHZKN2llTzA1SndvZU0rMnF2dnBzaXpEcGhhcFVGcWNsVEJhcU5Fcm5jcFNDcEpBV2g1T0Y4K1FzSEJKQVVGZWRNRy9lbG9VOTl0TWF0eEZwVkdVSFdYVnBJQlUzOHhKT01ZVmc4K0RvTmJ1YjAyUWlFS20xV1czMHNrb2x4MExDMU5vSHlwSlAwSkpBOXVCOXRBWXlwemNnTEt5YU5PV1NHNm9yUzNnSGZUcjFOSjY5ZEYzN2J5SExZajFXZXdzTUxNSlVoNzFmbEI4WlA1U0NjRUE0UG5IT3ZlYnZETHJjRnN0MUI3MW5KQ1V1SUsvbDQ4ODZzYnByMVJudlhyYjl1TjFXbnVTVk9OUjFKRGhTUnlydVI1d2ZQSDAxUXJ4cmxNcXRRUkF0UzBWMHVwdVNlOWI3WUxaVGtZN2UwakI4SEI4ODZlMlN4S09vK0xxZlB6cUZ0NSsxSjVWQVlIY2ZyMXIxclZDbVh0WEkxdHhHU1hwRDRVNmhLZVFnSGorK25mNmErbHFwUXJmaXFreHd5MjRrWTdrNEkwS3VpZmFHRk1xN056VmlBcDZXLzJMSHJLS3lrRWNaSjVKeHJSQzByZml4cWN3R1d3VWhJNEF4MjZ4WDJpOFhPc3JGdmpINFU3bnpvcmE0cGxyTXA3cjBxcjAvWVMzNlRTQTdKVGtKQUpJT0FNRDZueHJqcU5zVTZFVk54WStCMkE0U1FRUm90emFLKy9UMW9hN09SZ3BkT1VsSHYvbHF2THRkdVErcHNvQVFsSngyRC9MV08rOXluaUNvNU5OaksyV1NBalNnaGRkaExlYlc2dUNFakdVazhrWjB2dTh1MWtlcU5PczFCa0xTUVE0VkRrZmZUblhOYlRyWWNqT2dsQ2s1YUo1SXgvd0JkQWZkR2lKY1MvamtqT1AxMDNjTzNTVkZrQTVvb2g4Zldra3Bkb3o5dk4wb0NxWklrT3gyd084ekhRb0ljeWNsSkhnWXhqUFBuVE1XTFM2MXVyVzZaYk5IWWNrUzZoTGJqeDJtamxUanF5QWxJKytUb003dk12MDJTdWZCQlE2Mk1xQkhIMzFwUC9vMVBTdEozeDNkazlTRjMwd09VS3gwSitBSzJ2a2ZxU3dmVEF6NUtCbFIrK05kS1dwcFY3UzA2dkduNGovTzlZL3hqYXlpNEpTalpXMWErOUVYVFpSK2xIcHB0blptbnNKVElnd1E3VjNramw2WTVoVHFpZmZCUGFQc25YUjFHUnQ4STBlbVRkajlvN0x1eGFwSzAxMkZkVDRZV1dlejVDeXZ0SUt1N3ozZTJORkpBUGIyWU9mY25YNHRwSkhjUjdlTmFBMm9OblRhcXE0YURGRE8zbU1hZlVHbE5xOEt0RjRTTjFmd3lHZThLeVoxcFNvN3BUL3paYTdWYTVvOXpkTkRjcFNZOVkzTTJ0cUlBeXQxVWhEUVAvTWx3TFFvZnNOTjhoTGZhVkJJOGVSeHpyd214SXM5a3NWQ00yKzJvWUxiN1lXRCt4QjFhRWhPeEg1L3ZRSjNodHduTGJnUHFnZmRQS2FUYTV1bmlvN3pic1dWdlZUdW9XMmR5SkZpdnVTTGVwTmZVSXF2VVVPRkgwLzZnUURuQTVBejQwQXVvZllEcXY2Z2VzaWlYSjFjYktWZWw3WlV4d3lLaEx0K1VLaWlUMks0YjdVY3RwVndrY1pDZTlYazYwT3V2cHMyUXU5d3lxanQ1QVprNFBiTHB5REdkQitvVTJSeisyb3FQc0hjRnJzbHF4TjRyaGpONCtTUFVuUkpDZnNGa0JRL2ZPcDI1RFk2L1doejFudTdLZ2NGV05zS3lQL3l2dDYwRCt1anFNNmRhRjBPM3BMc2V0MEVTVVVCTk9wZFArR2JhZmFXNnBMS0VJUXBQZUNBcmpISXhuWExLM3RvL1EvOEFoMldoR2RtTXNWa1dpeVlxWDEva2RkVDNlb3JQazl5d0FQNmxFZlRWdTZodWxHSHZuYWpscWI3N0swUzk0U0gwdXRUYWYvdWs5QzAvbGNTdEhibFErK2xZMzQ2QUtodlB2bGJCWjMwcWRJcytnUE1Ta1dGZlRUNjIzbm1SaERaZkg1MEhnSkdNSkhjVHlScVJEVGF3QVQxelg2VGVwakxTVU9KNVRzVGpsKyttZm5WS3BIUzNVSXZROXVUMWZibE1QUFZ5NzZjVTIrMVZHY0tiWEljQ0ZTVG5rNUNpbEpQc1NkTmhDbzljM1JvMjFmU0JRWFBUcE5QdDZGT3ZaVFN1NUFTMjJoU0dELzhBOWZyMmpYcjFnVmpjZTZ1bU4vYmF1N0lPTk5CNk4vdmx1T0psUUF5MHNFQWRneWtjREFJNDFaT20yMDRlei9TalhOekUxdEVxNDZ0QVc0Njh0MExkakk3ZTFMWjl3UUJuSDZhdERQaDg1M3pvUHlCb2pIbVJmQlNsbzlEbk9ucjg2cC9XdDFaN25YQmRNRG8zNk9reVdhakxjVENxbHdRbXdWUld3UWxUYkpKd0ZCUGx6MjUxSld0K0RqMFhSYmZpTTdoN2J5TGxydnBkMVdyMVNxanluNXI1T1Z1S1BkOVRnZllEVmgvRHEyTXB6RnR5dW9PNG9ZWFVhMDY0bUE0K01xYmFDc0ZTU2ZCVWVNL1FmZlRHeXZnVVBxUTVJS0NPT3oxQngvbHF2SWVFUlhoTmJqYzl6UkNFMDVOYURycHdEc09nRlk2N2YyUkxYVGY5WTdsZ3BhY2VQZW1FZ2R3WUhza24zVjlmYjIxS1ZadWt5V3pHTVZQY01oS3NjNlZPeFB4WkxOblVwK0RkRm16b3IwUmhTM3ZnRitvZzlvejIvTmdwejlUb3N3ZCtMWHUralFMM29GWmJlaHpRMm9PeDNnb0pDaG5HVSsrZURyK2FkMzRRNGx0OG54SmJKU2s3RWFwOUJpdThiRHhKWU9JV2lxRzhGOWZNZW8zcm92dHYrSEtkN1hDMlV1RHNVcnovQUgxUTJiazNmckZXVlFyT29hWm5hdkM1THpwUTAyRDdranorZzUxZXFuY0ZDdWRKK0xRNGtwZDdXMU9FQXJHUHpEN2F0VnVNMDJsMnlnd1kvcHI5UXFCYlRnNEg2ZVR5UE9wWXJ2dXpCNTJncFE2SGI4cW11RGdqT0RKQXpRRTNQNk9xVHZXekZkM3R1T3ExUDRidlUxVDRUNm84VkMxZjFkb09YQ1BxbzQrZzB1WFVCMFNWV3hTMUx0S001Tm92YjJTR1poNzFNNFAxUEpHUDdhMENYSmpTVS9CcFo3aVNBTTg4ZVFkUjkzV3BUNTFLa09QbEwvYWtqc1YycURoODlveHpqR2ZQT2o5azQ3dmxzZFFrcXkyTmtZd0Juc0JzZk9sMjU4UFc2N05xUDRGcS91Ry96ckw2MWJidm5hQzU0bDQ3VjFYNFdSVG52VU5OZHo4TExSL1Uwc0R5RDlSNFBQdHBzOW91dFN3OXdZNklFeFFwZFZaUVBqcVpOUFk0d3YzUGQvVW5QaFE0T3E1dlgwOTB4YmttcjBLQ3B0S2dUNkNTUVU1NTdrNCtuMDBvbS90bDFtRE9hbjBpUzRxVEZUM3REdktYUHVBc2ZON2VQSFBqV3Z0TVdYajVwQ1pCdzRObGRSbm9lNDlkdTlMTUtGZmVEd29vVjRyZTVTZC9VZWVQbFdqMGplVzM1QURBcTdhVy9LM0N2dUdQOFhIdG9kWGx2blQzSXJ5STAxTFNWSlBhNDd3QW42NDlzNHp6OWRaL1VqYy9xRHFGR1lsMnRUS29XVGdHUlBTUTBFNXdTbFNpTzRaOXg5OVNyeXR4N29oRVhydUFwTENqMnVSb1A5Uno0K3BPcFlYc2xaaXZmRytuVHoxK2xHSVBITFZ6MFlaWHplWXdQcVRWNzZrT3BNM0I2bG5XSktjbXpILzVicnpKeUIrL3NQdG9BczBPOGJDdWRtNmFkVW4zSmhUM0tjYlVWSEovTUZZOGVQSG5qUkNoVTJnMnRUM0hvekRVSmp0dzVKZlZseFovWHpuN0QrK3BuWXVwMGUrZHk0OXUwdUFoRVpocFQwaDkwQlMxWUlBT1BZWlBnZVRqT3RTdGpFU3hRaXpEUmxJSHhFOWFBOFJSRzVxUEh1SzhLSDRVZzdmdjYxV2p0ZDFHYnRSVlhIUzdVZFpRaFkrSWxTbnZTUWtrWkhKOS9mdEdUOXRmbEc2S3ExVXBocW01TzRURWNLVVUraFM0eXBVZ2dEODJEMmhLYzhEUHY3WTBaZXJmZkcyTnRyUVoyOW9OMlBQMWFRRWx0bU54OEloUXdYSFR3Ty9CNEFINm5WUnRLNTZvaDRUV2FpcDVJYlMwVXJWM2ZLa0FET2VTY1k1T2ljYVZLRFBpRUJDVDJHdjUxbGJzRmw1NzRjazUySjBxVWx6YlRwRmpxdEF1M1hWUzJuT0pUVGJmY1Uva3gyRlFTUHI5dEJ5KzZidWxkbHVzeTU5c3BhcFQ2MVM2VElYSVQ2aktVZ2doUUJ6N1lPUjlEb3JYVGNFZVEydFRpMjJTNDFrT05LN1ZmdGoyMTUwZTZMY3VVTG9rMk42ckxiQ1dtbHZMeURnWUo0NHpuUDIxVFlkWmFkTGpLTWtuT3Y4QU56Vm8yVUlhR3ZMalhUdlF0cW5WemMxYnMrSlp0enMvRUNCRFRGYlV0MG50UWsrQjl0RHVwN2l5WnFpNDAwbEI3eXJoUGpSbHZmcGx0K3FOQ3QwMTF1RzJwUkNVdDRLQis0NXlQdU5ER3NiTHVVNm9HSzdWMjhKSGN0UlNFRHNIa2pQbmozOGFNUlJhMGtrSndvOUtxeTdqZDQ2ZVFMR080cGh1aC9wWnRPdXNNYmxibFU5dVpKa3MvRVJHSkxQZTIwazU3UGsvcVVmT2ZBQjFBZGFHMVNiZWxtczI1RGRpdGQzWTQyeW5zYjdnT2NBSDlQMzhhWmZhaTRyZXMrMHhUbTNtVXNpQ2hETFNXZ3BTZ2xHRWtLejRBSG54ZzZYcnJBM05nWEJHYXBjRWZOMkV1K202TzBLSjg2V0kwbVpNdkJkeWVVSGJwanRpak1TS3dJaWdSbkkxL2NtZ1RzWnZQTDJadVNWTGxRbHZ0U2duMWtCZUNTbFdRVDlkTXhZM1U5Ym01RlQ3WUZUL0FKeFFwVGpLOEJ3ZzhGSkg5Ujk5SmZVMWxjNVMwckN5VHgrdXJSUkxPL2pjcDJkUjYwSWNtTzYwUTZnOWlFOXc1VU1ISUlJOXRPRXkzeHBJNTE2S1BXazlNeHlJNzRTZFFOdlNuS3VQYzJqczI0cW5xZkRDeWdwVDZtQ3RHQURubkJ5TS9xZEtWdnBXV0tuY3Y4S3BnU3BTWkNsTGU1U29rOFlPZkgzK3ZHdSs5bXI0czIzNDh1c2JzUXFyOGExbUpHQ2x1UFpBeDcvbHg5U2ZialZUdHl6TGd1MmE1S2RCVXRYekxXc255ZnVmT3FVTzNOUVhDK3BRTlhmRWtYSWVDaEI5YVlycERwc1N6TmpxbFU2bEphaVZDZGRmb3lXWkJ3c29hWkhhQ1BZQlMxSHo3NTFjcE5PcEZhdWdPMUM3RzBSM1ZaYzdTbEhhUG9PZEI2Mjl1OXpJTzNOV3RtTlRuNWlGTWlwR1JFN2xKZ0ZJd1M2UndrTFQ5VGtFRGpRalZmdFlqK294VUpMeW5FTEk3SEhTZisrcEdHa1NYbkhQeFpPbFhVT053VUJvcndSNVVlZDdxV0ZUbTNwUVllYjdnaG9KVUZZQTl3Ui8xMXpOVHR2cWpRbWFKYUVKSXVCeG91TGErSXd6SENEZ3BWL2pVcmdnKzNPZEFpcDdtWEhWR0V3M3A3dm9JVGhEUWNKQUdyNzA0VExmOVNmSnJzaEpla3RsSnhqdVFFOGpKSjRSNzhja2dEWHliQTVXaXZZRFlWSi9WV0hnR2thazduYXBTc1crL0VyY1M2WWlHbUp6TWhEazJLMDdodDBIakEraEE1MFNMclRDc2ZjbUJiRDBoQ1c2cEJRR25pU0VCYXZ6L1VFYy93Q2VxenZWVUVVNmlzaERjWnVOTFpMamNrQWxTanlVZy9ROXVPZENXNGR3Nm5YQlFuM3A2NUQ5T2JTUkllWDJrbi9BRkU0Q1IyNEhISkhPcVVTTTlQYUNsOU1nVlNjZVl0ZHpiZWFHL3dDTHk4Nk9lNmZTN1g2akpjcUZJYWpLaHFiOVYxOHVZVEhWd0ZaLzVmY1kwTTlqSzY1dEp1ZzNBdU5hbVljMXdKRDZ3U25JT0FRZkJIMzFmTGI2bld6YVpma0JFdnVpSlpreHBDZ29KVG5sZlAxUDJ6b1VidGJoVXE4Wno3a0JRYmJXNzZqVEtFbkRhLzhBbCtuNmErUldwYXlxSzZuNERwdHNhTnovQUhlUWozb0tTbFFHbXY0cWRDNHE1U0o5TlhKdDJqTlNuZmh3Q3Y1Vk45bU9TYzhjKzJnVGErenpGM1cvVWJvcUZZUTNMVlVDeENqc2dOcC9LRDNrZ1pPQ2ZiSGpRMnN2ZjNjU3lxSTFTcHJEdm92SlVFUEVFS0lJSXpnNmt0cTk0cGxNcXdvOVljTFVaK1VWS1Nmek5rK1RrLzMxWEZ0dU1acFl5TWpiSGFsQmM5RGt3RkpVRW5zZHowbys3UDhBVGJRNGRXaVZXb0lhblRJcEJZK0o3Z2dMSUl5UjR3UDduMk9lZEZTcjdUME8xS0k2aDVEZFFuMStxdHZTRXZzZ2hMUGNBRXJBOGdsSkI4a3BCSDYwT3lkMllNQmJLRVZGQkFJTFVoNVJVbFhIMTlqcVozTzM1cGI4VnFURVQzU1VwSjdVWktWa0o3VTQvd0FJVCt1aDh3S1Uxa3FQTjVWUmZnS2xPa0lUb2UrK2d6djJ6UXI2ajJLSGFWUm1wcHJqejlPcWRXVkptS1F2dVc1TWJiQ1d6M0QyN2xMY0E1NXdPTVkxV0twMXJiblZldFNaN3RibGowbVBRYVFRTWxLVWdaUEhKS2grL3dCZVRxeFhmUjJkL0hhZGFrT29vcE1PTEpYSXFFdGJYZXRwb0lBVTRBRC9BREZLSkFDUnlWRVo0Qk9yL3Q1MHFXR3hVMnFsVHFISVhIanBTbU9xcUxRcFN5bi9BTVFwQTdVa25uQXlCOVNkV0haTU5xM2hVc2N5dTNXbURnbjJlM2krM0ErNXB3MXNWbmJwbjEyb1VXVmJQVXB2UkRpcXRLMEtpNkZMVXRiMGpMU0ZwUE9mbTVJenFUdkhwUjZqN1Ztcm4xeDJBekhuSUNYNHppbGtLU3JHVThEamtaQjFvanNqdGZZVmgycW05YTNjN2pyampSQnB3U0FWSHh4NzZodXBSK3lycXQySlVLRlVGTnJRZlRkUTU4cWlqMkhiOU5aNHJqS1VxNGVIRmpCTGVvSkl6WFJNRDJWd0gzUkdmV3RZMktob000OUtVR2xVV2syQmFDS2xIazlub3RJVTUzTENWSVVNZDJNOEVmdm9aN2c3Z3c3dXZLa3F0dUMyMUtUTjdoT1RBN2NOS3lEaFI0VnovYk9qZFZiYXpIazB1ZEJYTXA4a2xEb0NUakI5eDlDUGJVaFhyYXQydmJlTTJyU3FKVDM1RlBhUjhDNDR4NkVsdENCNHp5a2tueWVOR2JZKzBGS2VPU3M1NjkvdlNKeHg3SzdwQUNrTkRtWnh2dWRLdmZUZWlKUjFSbTR2WjJJU2hKeHdSeHpwdEtEVlRNUXpKaHVCU0VOZ0Z0WGduMjBqR3lWMXpJTmFkaFRXRkpLUzJod3E0K1lKNTQwM20xMTBSWkZQYlEwcktpQUNmWk9zY3Y4QWJWTHVLK2ZjamVzYmtLY2lvOE1EQkIxb2p6cTVJa2xpTUFVZHc3U0UrQi82NjlxTkVtUHZTRlZCMHBQbHRHY2R3SEdmL2JYR3FKR2tQTTFCMlNqc1FPQ1ZjQS9mVm9GTXA3MFptcURQZTBuemdIUDI1MHZwdGJqV3BUcDByM0RuS1VyV3FMZVRpR3U1cDVrTFMzbjVpZkErbWdKdXpBVEpsS0xJS2U0WitYZ2FZUzlvQ3AwWnp0S0FjSEI3ZkkwdSs3VGpjT1M0NHQzdGJaVDNGT2Y2ZFhZVEo4VVkzcHJZZEsyODBzbTVkbDFpOWJ2WXRLMllDNVUrcFMwUm9rWnNkeW5IRnFDVXBHUGZKMS9TeitHZDBiMFhvWjZPN1IyS2h4bTAxUmlDbVpjYjZVOHYxQjBCYnVmcjJraEEvd0RMckxQOEI3bzBZNmhlcTZWMUdYZFJTL2IyM3lnL0U5WkdXNUZTY3o2S09mUFpnclA2RFc1UWJCR2M1K3AxMWZ3WkRjaTJSS25OMWEvS2s2L3lVeTVnU05lVFQ1MS9sSkFIY1Q1OGs2NTVrdUxUNHJrNmUraGxwdEpVdDF4UVNsSUhra25nYTkxZDM5SnlQdnFQdVMyYUxlTkNsMnZjbFBibHdKN0NtWmNaMG50Y1FyeURnZy91T2ROWnpqU2d6WWJLeDRuNGNqT044ZVZBNjUveEdObm9OOFROdWRzN0h2UGNPcjA5ZlpVR0xHb1JsdHhWL3dDQmJxaWxDVmUvYm5PT2ZHb2R6OFNxM0tOTE1XK3VtZmM2aXE3andhWkZsa3BIazlyRDZsSEh1QUQ5TkViYnJvNTJUMjArSVlvbEVrdlJWMUZjMkxEbHpWcWJqUExHRkxUZ2dyV2VmblgzS3h4bkdwMjRPblhaTzVhWXVuVmZiT2xyWVVncCtSZ29VTTg1Q2trRWYzMTVITUU2NzBjTHRsVEo1UWdsQTJQVS9MTmNXeUhVenNuMUUwMStmdE5mRE5SY2lZRStudU5LWWx4Q2ZBZFpjQVdqOVNNYXZKUVNrakI3UnJOUzVheXhzeitMYnQzWVd5RW1WTGNWTGZvOVpkVGdHVFQxc3BXWXI2Ly9BQi9RV2ZsV2VVNUtjNTFwb21LcnRVNFQzQUp5RHIyQjhJTlZibkZSRWY1VzlpTTYxeHFRbEFCNDhlTmNzNno2RGVFY3dyaHBERXhoSS9KSlFGWVAxR2ZCKzQxdzN6ZGJscHdHYWtpaXZ5bWx5VXRQTFpCN1k2U0QvTlhnRTlvUEhBSjUxNjBXdHc3cnBxWmRHclVPUTB3NzZraHlLK1ZKeWs4SUpISUpQR01hL0JSQjBvZXFDSkRlWEU1VDF5TWo1MXpmN0hWVytzeUxEcnowRUg4MFIzK2EyUjlNSFZKdnpibW0xS0kvRTNDc1p4aER5U2x5cTBIS2U0ZlZhVThIOXhvc1dkVXF2VW1aQ2JoaEdOSlM5M2xvT0JTZXhYNWNIajJIanpxWGREWkI5VEJCNDVHcmJjbDFCeXJXbCtadzNGV2twYVBMNURWUDAvYWxscGw1N2tkTTIzeTZkWmxCcDE2MnRTWXpqc2VTaVVHSmNGb1pVVXVJNTdnUHFPZElmdVIrSWoxSzdoWDFVN3d0U211eEtkTWxINFNOR2RXRU5vUUFqQUJJUDlPdFdMKzJVdEM5b1VodFVQNE41OXRTWEg0NlFBc0VZSVVud1JvZFViWWlyMlhTMmJYbzloMnJJaXcwZGpMNzBKb0xXbnprOXd6bm4zMFJaa1ExNVVzYTBPY2N2ZHVTR2t0OHc2RWFqODlSK2RmeWNWT1ZIWlc4ajFpRVRJeW1ndEE0Q3NjWiszalZoNkl0enJvMlAzS2FzKy8yRmkyNjYrR284bGErNXFISkorVWsrRXBWK1hQc2NIWExmK3p0YnQ2bXByVnNWUlZVcEx5OHR5UWpsbzUvSXNEOHBBK3ZuSG5YRmJWZWRaUUtaVVlxRkUvS3NMQXdvQSsrZmZXUVh5elNXYmE1Q2tOODdhZ2NudDJJUFFpamRwdW5FM3MrdVRVdnd5b0lJempVRlBiUHAwcDB0ME41WVZqVjZpTUNVQzNOTGkzQUh3cFRhUmhQZ2VQMzBZOW45L2FMUHA2S2Vxb3greDBkd0s4QXJQbkdTRDJuNzhmcnJQYXZ6cDE1eTRNMytOcFEvRVlMU0lxK1N0UHR5RG5PZU1hdisyMWR1MjIzV3ZXQ3ZUS2ZyM1lCODZ4V1p3cEdpeEVLUWZqQU9RZXV0ZExNY2FRdU1ZaVprVWtKN0VZSU9OdmxXaWRHYnQ2WEhUVW9sYmpQQXVrT045eWNKSEFLc0g4MmNrQUE1eUFlYzY1Ynl2UzJJc1JkUFMrSlBvd2V5TWhwcEFMUkt1NUtUMmdjZ1p5Y25TeFd6dTdQYWlKalAxQlNDaE9VcVU3Z1lQbkg3WjF6M1p2OUtucEtLVXI0bVVRVW9jVVFFSUgxd09NZmJTb3h3N0ttdWU3dzJNcUoxNmovQUJUVGI1eVVFR1FyUVZiOXpyeHAxS3ByOCtZc0FjNEJPTStlQi9ucGFMd3MyaWJnVjkyK0pDTzJLeWxYb3gzQ1VCNVE4cU9QS1I5UGYzNDE2Ymg3bHZWR1Y2VlJtcm5UVWpoaG9uc2FQMUo5dit1cVE3MUJXdTFicWxHb2hjcGxLbVVSVXVBSTlRcXdSZzRQano5ZGF4dy93VTdZV0F0YTh1bmNEWWY1cURpcSt2S2lKUzBuQ1QxNjZiMURiMzNsWGFNODJLZW95b2lZNkZ5SXlBQ2xDRTU3VWtwQXhnZXc4YUFGVTNpbHdyamRyRUtEMjl3S1F3dmxCQjhIUHVmdm9oMnZ1TEd2ZTlhdlQ2N01MVWFlNmxxSXBHT2Mrd0gwOGE5RmJKMnpKVFVGdHd3cGhMUjlQdUk5UmVUbklKR0VnZlg3RURXb3c0TU8zeGtsOFpVUnJXWVNMaklaY3pIVmhRMlBXcTNzOWNkalgvWEM3ZnRRVTlPS2dJOFNUa000ejVHUEoreDQwU0x4dSsxOW5Gc1Y2bVFtSXJUeXcxM1Jtd0NvQThvSUF5TUVBL2ZRVXVTMGFaYTl6dHg2U1hISG8wbENHZ2hrQVBFK2ZmalBqN2UrbWhzem93dE4vYjlOZjNHZWt6MVZFSmNSVDI1UlF5MWdGUVNvcCtidTU4K05SVEc0alVoRDVVcnd6L2IvQUlxSDM2Wk1qS0RwK01kZTlKM2UxVXErNlc0czJwMHhEa2wyZklLa0JTc245eWZHamIwL1dOZWROTldjdlNBVklpMC90YlF0NGp1ZFZqdFVvL1JLUWVQY2tlZGU5NjdPV05hZFZWVjl0NHNxa1BOeWdVc0Z3eUVwQTlpVmNqUHRxMzdPR3ViaVI2dEFrc3FpdW1YNmJ5Rkt5VmNZR0NQWStkV3BjeE02RHl4ZGhnYWpXdk5taHROeStlU2RUcmpPbENpL0YxVnlhNUNEcFEyY2h0VFNjY2ZUUS9pWHhXN0pxcnNaNlFwYkN6N25uVEdidjdidVdIYnJjdVM4eXd0VDNZVnVweVFBUFA4QVk2V2ErSWJzcDB2TXNsZjh4V0hBbkhlTStjYWt0R1Q4RG9vcHhDR0hJZmlSdHhSWnNQY3VGWFl5M1o5ZGFTaHBQY1cyMWxQR09RclBIUGo2NnFPNlc0ZFBSQ2tVK2xWTlQ4dVlQVGNLRmhRWlpQNWtFNDhuZ0FEVmIyWHMyMjd5dmRtajN4ZEROSHBxVUtYSWZmZTlQdklIeW9CSTR5Y2Mrd3pvMWJqYkI3WFAwT0hPMjJlYWRJWktuU3k0bFlBQThqQkpWODM3NDFhZTl5Z3lRVlpKL0lmT2toaVBLbjU1bGNvK2V0ZU8wL1VuQ25XZXUxS2s5MlZCcU9HbVRKSUJjU0U5b0l5Y0U0NHhvT1ZKMjVkeGIwUmJGdVFuSms2WElMVEVkSENscno0NU9QOEE4TmV0M1cweFJXZlFxVUpMYjVRU0ZEK29haWR0TDFrYmEzM0J2S0V5bDVjRjd2UUZIenhxYUhEaXBjVyt5blUvU3JreHlWQ1FtTXB3Y3F1bzdWYktyMHkzNWExVCtEdVZwQ0htMUF1SWpyQyszOS9IMi9YWEZmVzBVcXo2UW1xelpibUh2bVFncU9jWjkvR1NQdG9zeE9yQzA3dXFEdFd1bWxNeDNYWHk0dFNRU29FbndQcVBiblVCdkpmMU02aDZyVFdLYktFR05HUHd6STlNQUtIR1Zubkk1OERVZzk4L0c0dkFCMnhWbFROclExNGJUWE1vamZOZU0zWnkxS3BNcFg4THZLblE0emxKanVSUGo4aERtVUFyVjNlUHpFNSsrcHR5ejdXc3RoVkpldXN6bkZwRGo2cWNrbHByQXlBdFNVa2dmWURKMVc3YzI4cnJrcUR0bldMZ2Jlb3hxekpMeWdVT01ncStmMHo3cElKR1BiT2ZPblRwOWd3clNvVVNKU3JZaUlpMDl0TEtvRFVjWVdPY0tQdVFjL3FTT2RBTHpjR29LRTUrUEo5TktJV2R5VnFnSUNTT3RKN1V1cmE0N1Z0V3BiWDdaeUpUYkZXUUk4ODloYitJK2JuNWM1T2Z5L056alAxeHFsdmJTUmFISmFqVnhsNlRLS1A5K1F5djVHbmZKYnlQZFBnL2ZJMFdPb3V3S1NxNzAxUzNxSDhQS1pkRHlIa05kb2JXRGtEQjg0eGtmWFF4bys3MWNvdDh5SjlmY2FjVElmUHhDQWs0T1R5b1o4SE9TVDk5RVlFdHVYRkJqRGwwMUhXb0hvNmt6ZzlOd3NIVHNQblhqTTI5cENJeW4yTFFxSmJBK1oxRFM4RDlDUmorK3JwMDZkSzFDM3JGUXIxUnVlVFFLZFM4TkNUNldTOUpWK1ZzSHdBQnlwV09NZ0FjNnM5NDdpMjFkbTMzWmEwU1F0NWxyK1l4SGJPZkdNcVY5L3RvbzlDdFFpeU5rMDJ0SnByS1piOWVsaHhNcHdJUHFLN0FDb3F3RWp0SUdmUEgwMURNa1NZOFJTa0tPUmdiMUpKUkRjY1NrTkJQb0tYL0FIVDIrdmpiU1RJbys0RUpWUmd5a2orRlZaaVVYR2tKQy9tUGI0Q2lCMjg0eHlSNTBPM2FIQWNtcjlaaFFaVU81cnZjQnluOVI5dGFaUDBlRE5peWJMcVZHWVMyV2ZUbTB4K09GQ1FCK2I1amtKeGp6KytsUzZqK2xxUGJMa21vV0ZQUW1IM0Y5eWt5RnA3bVJuUHlLd0FNKzNQT1BHcUVHODh6Z2FkSEtlNDIvd0FHdlNJYktFY3dITVB6L3dCVUE2QnRoRXVhc0loUUozbytxayttcDExS1VwVjdkMmZiL1BVelNyWnNXenFKRXVLWExaZXFjYXFHSlVLY1dsOTdmYU80U0VxVndwQnhqR0FRU1BPb1NsM0VLSTQvS2JjYkNrRWRwS1FWcFBzUWZyOTlYTGJuYjNkeTdJYzY4NkZjTFZNanptdzA0dGFVcmRmU0NUN2c0OCtmSjBkTWxiT1ZQTEFRT3RDN2pCaUxRRlIwNVhuOE9hNmIralJkNEp6Rkh0MWhyTVdFbFRic2Y1ZTlSUGRsUXdNNEJ4enpvYjErazNwWWM1RFZ5d0hlMExIb1NsQW5JU2NZQ3YwNHhvcDJyczllMWlyTnowNnNJZmZTcktZYnpLa2tnZVFGWjR4OS9JMWIydDJOc0xob2txek41YmZETHlrajBrckI3SGYrWkt4NEkvdnFDTk9TdDBodFlXbnQxK1ZXSGJSQmN0emFQRDhOWTY5UG5RMXMzZFNVbjA0VFJSSVpmSGFscDlKUGI3OGZYbi80TlM5QnVPSGNkZllvRXVTNkZPeUFKSFk1aFhhUEFUM1krd0E1T1Q3NnIrNWUxdTF0cDJXaTliQzNQa2Z4TVRmbG9qemZjUzNuL2lJZFRqQkJ4d1J6OWRHamFMcDRvbEFyMXZYdldKcnMrb1BVc1NITzVyQ0FwUUdGQUhuUGtlUGJYbDJIRVhIVkpSc1B2UStCYjdoS3ZqTnJ4cXM2a2EvRDFQMG90N0s3TlV5akJFcVl5ajRwMUlLeWVmU1RuaFAvQUw2YU96ZW5LQlVyZVl1aHlxQ013emdTRUFad0J5TUQrK2gxczNiYk1tUTE4VEh5RUtDaWs1N2Nldy92b3ZPM2JOcEQ3RlBwcFUySStWcUFHUm42bjlQR05adGZDODYxek5INHYwcnNLdzIxTnNob2hSQnlwVHAvUFdxanVndUZHbkNrUWwvRHhJcllTeUZLSUpPUHpLSTl6cW5KYmd5VzNFVmVRbHdBQlk3ZVJ4NzZtZHdLMVViaW5LUTh5VmhLK1BsOXZjblVmSHBNVlM0emEzRGpHVnBBOGpQT2cwQ1BJSThSWXhrVThGOW1NMEd1dFU2NXJka0tXcDFoeFRiTGg3Z2xLZURud2RWOVZPa3RUQVNoeFdSMmxlYzVIdnhvMC93NHYweDFia1Fsay84QUNXNFBKKzJoamNhMVUycXFaQVNwSnorWVlIQjFkaVIzUkx5YSt5WjBhYkNVa2lxbkZpbWpWdEx6cUFsVGg3a09mVUErRDlkSDdhbXZQdzNXVysvSWN3UWZBd2RCZWJFTlhqcUxRUHFJeXRvcDVJUDArK3JQdFhkOHVJVzZjOFFGdGYxbm5BenlNYVgrTDdXcHNoOXZiclhLbnRMNFpqdHI5L1pTQmsvRVBzYWNpM29zeXVVQXN0RktFK21WT2RxczkzK0VaL1VaMWJXcGtaNjJHNWkxaEtWTmhTeWVBQ09DUHRvV2JTWHZLRkxLR0kzcUJ0cnVTa25sZi9Mb2xKbkxUYUxTMVFDd3R4c3VMWWNQZDI5M3QvMDBNYmllUEJDdTFZZ3B2d2xqRlZtNkE4M0hlbHFjSlFSbENnb1k1OFowc1c5TWVxMXF0TVVXM29LNUV5cFRFeG1tV3gzRlRpbFlTQVB1VG8rM0xkekFpeUlNdVQ2YUFmQ2VRVDV4L2ZSUC9DUDZZV045ZXFSL2VhNkthbCszN0FVbVNnT0o3a1AxRmVmUlJqMzdBQ3Mvb05SOE0ycFYwdmpiQUdtZGZRVXhtUXBtM2x3ZEJXaHY0ZFBTZlRPampwVXQzYWhFUkFxN2pQeDl5dkpUeTdPZUFVc0g2aEF3Z2ZUdDBkUGJrYy9iNmE0eFVta3Evd0NKa255U2ZKMTZzMUJzbmxYOXpycXB0dExUWVFuWUFVbGtGWjVpZFRYczg5R2lzcmt5WDIyMjJrbFNuRnJDVXBBSEpKUEFHcVhYZXBUcDh0OFpxbTh0c29VUVFodHFydHVySkhKQVMyVkVuN0RuN2F0VmNwTk51aWl6S0JVMlE3Rm54SEk4bHJQNW0xb0tWRCt4MGp0TS9BbDI1cHZ5VW5xTXVhRVFWRmt4NlZHSlRsWlVQblZsWklCN2NnZ2dhK2tPRlFDYU1XOXF6bGxTcGkxQlF4Z0p4cjg4R21xLy9LbjJnZlVCYjcxY3JUbnFCSzAwYTJwYjNaa1pCVW90cFNsT1BKSjBGT3BQcjRxdEdvOHlqYmRVUitscFUzNmE2MHBiVW1jMFR3VXR3MEtWNmJtT1F0MGdER2NjYWg2dCtGM3ZERXMxcTFLUDFYWExXVzZlNy91RFZTcThwZ09JeWNwZFNsYW0xbkJ4a3BQdDRPcTF0TnNGY2ZSUmVLS3Z1TnM1R3FGUGxTaXA2NVVSRFBqTVk4S1gySDFHUC9NRWtaNUkxNjhOSkdlYlBwcDk2S1FVV3R0YWx0dGdrYXA1bGMyVDZBRGJ6MHF5Zmh3OUlWMHZYV2VyWGVtbElSTmVpcmoyVlQ1VWRRbFJvcTFGUzVUNmxjbDV3a2s1OGtrOERBMDZjaHR0dU9vSjQ0N2NqVlBzSGZmYjIvck5xZDUwZXN0SmhVVXJUVkhrT2hiTFBhanZKU3NZQzA5dk9lUDAwSHJQZ1h6dnREWDFjWEc3Vm1VUTNTN3Q3YlVKOXhDRzRvY0FVKzQyTUIxYnlBZUZaQVNlTlRKQWNPcHdCUy9QVkpVOHB4NGFrMFN0MlY3b3czMktSdDlHYldxY2dpYk5rS0NHNmV5bmxicVZuajFDRGhJSXhuazhEVmR0U25TYStpbTF5eXJEa3hhUlRsZDBTU3VRak1wWVVmVmZkVm5MeVR6MmpIekg1cytORkM5YUZUcjJ0YVRiMVFreVdZODVzSmUrRWU5TndvSkJLUWZZRWNFZlE0MTB3bktQYTFCRG55UTRNR1B5Q01JWmFRUHQ0QUExQmdKVlZsbTRKYmhodEtCemZQOEFQdWZ0UWN1bnJ1dFMzYmdWUkdkcTdta2p0S2tQK2doc09KQnhsSUordWVEenhxMzdhOVVtMXU1c3RGTVlreUtiTVdudWFpMVZyMGl2L3dBcDhIblhaU3FqMDhWRngxeWx6cmZVN0xXWEhTNDRsQzNTcm5QellKejl0QlByWnR2WTJoN2VPM1ZRTHpwOVBxOEZYZkNqd1ppVk9PS3p6MmhKT0Q3NThjYXRCRFRoQ1FrZzFFaGhwWVBNQ0QzeHBUU0VCUjdoNFY0NThhNXlzQWtCQ3VORC9wYnZhNWJ0MkFvVjFYMTNNdnVRd1ZQUGtBdU5qOHF6bnh3TmZGYTZxZW51ajFSK21WUGVpaE1TR1Y5cnJLNXljcFAwMUdXeWxaVDFGRC9ES3Z3RElyK1YrMGJvZnAzZElwanlGb2NIYkppUG83bW4wRWVGSi9UKzJ2OEFYUnMvUTcyaHVWK3dJdVhVQXJxRkJYeTh3bkhLbXo1V2ovOEFlR2dyc0p1Wkp1UzIweFpFc2ZId1ZCdHdIL3hFZVVxLzZqOXRHdXhibmNtTGJtUW56RnFVVldVTGJYaFdjNXlQcm9zcERiN1cyUWFjMm5Ra0JSK0pCN2pPbnBRU3IxZ2JqVU9vR3RiWjFxUlVQZzVLVElwcGRDbjQ1eGtmS2VTTWUza2FObTFXN3QxVk9tTnhycXNTZXkrZ2ZNNjlHS1J6N2o3WjBRVVZxemJnYlZQdVRiK0s5VUhFL3dBMmJCZlZHVzZmcW9EZ3ErK29TN3I5a1cwMjB6YTFtdzRyNWJJVElxUzFTZlRUOWNLK1gvTFNWZjhBaFMzM0Z2bWNBQVQxR2grdE5salV3eWZDakpBNXpzQmdaNyt0ZHQ1MTFpbDB1TzlYNmxIREpRSEVOUnozTGQ0ejJwd01uSHY3Wjk5VU9wN2pLcWRPWEpja09VdW1KSkRuY1FoMVkvNWxmMGcvUWMvZlZPM08zSS8xYnFNYXIzYlVucWhVM2dweHZ0ZngzSkFLUUZnY0JHZkNSZ2FFOXgzYmVHNER6c3BtTktsTnQ1UG93MlZLYlpIdDRHUDc4NkFSSURFZHJ3NGFBMmp2MVB6cDJLb05wUm1Tcm1XT25hakhhRzZlMzl4M0pMdG1hcVZDcERWSGx1eUtuQklEM3FKYlBwOWdVRHdWa0E1ODZXMjczSlZxM0FtVkRtcmt4VXlQVlQ2dy9PUWZKOXRFVFlTM1pGeVZpb2gxdDVaOUQwVnBLUjh1VmNnanlQR3VMcUUyOGtXKzRWekdBMlNjSUNSZ2ZiQSttcmtWNW1MY3ZBN2o4NlhMMzR0M3Q2cEhOZ2dmQ00vcFZMMnRxTXFzWFRHak5RUTZXbi9WUWduaEFCUHY3ZVJvdlhudkhNb2EwUVZVOWN4eHh4TWRsQ0dDRllTRC9MQ1FNcSt4eG9KYlRScmhOMnNyb2J4WVNwZnBQeVZENUVKUG5QMytnOXpwbDZNdG0wMm5aRkFxTHFYeEhDWEphR3dISE1uSndzZ3FUOThZK21ybDNVMHk2Q3RQTUFNNEZJMXVabVhKQTVWWUkweWRxQjF4VlhjQ25YSER1UzZMTmxRV0dIUFVTNC9EVWp1N3VVbFdmZkdtVjJsNng3T3JGdE1XN2RzbE1kNEZMYlRpeVNGanhrSG5HQjlkRC9leXZmRjA5aGNpSXB4SHc0RHFuam41dmZuMzBzMDJldGlwT3FncUtFZW9Ta0pQQTUxVmlzTTMyUHpGUEpqYldpRXBMM0Q3WWJmSVh6SFBuL3FuTjNpTnZHM0Z1d2JsOVdWSWZId3pyQUJJU1FUMkxQbkgzSDAwSnR1ZDJxbnRWZEZTZ015bE9ybW5MQWpxOVJ6dlRqdVBiLzhBdkRHZmZRaG9XNWwyMFY5SmJxcmpyZmFSNkxpc3B3UmovdnBoN1N1V0hZVzIwS1BaTk9nd3EzTmFMaytyTnNoMlMrY1o3ZTlmL0NRTTRBVCtwMStNRlZxYUlJNXdlMm4xTkRtbnpQZUNtRmNwSGZ0NlZDYnIzVmZtNGttRGJEYXBqTDFZbE5KU1pjQmFFS1VUamdxQTRBeVQrbW1LMisyUTI0b05ueDdhL2dzR1lscEJUTGt5bVF0VDZ2OEFFdFI1OCt3UHZnYVU2bmJ5Ym9RZHhhWlZiaHVLWE9ZaVRVTGxSeTRIRWhBUFAySndULzAwWjZqMXUycmFsR0ZTVkZreW5FeUZPUTRTV3V4RHEwanlzK1J6amcrMnE4eUxNZVlRMGpjLzlUMS94VjFDbFJuRkZhemdkOXFFM1VadGJSckZ1cVExVFVNc01QT3JMQ1NEakdmWUh3UDEwTHJMdVc0cmV1UnFQUVpxaUhud2t4L1VJU3ZKL3dBdFhTQk12dnF5M1JVbXNUMFFvdUZ2ekgwakRjVmdISkErcWlUaEk5MUVhdDI1OWpXRGFOTlJSclp0TnFPRzI4SWZjQVc4NHIzV3RaNUpQN0FldzBVYVY3akdFZVFlZFJHMitQV3E3N2d1ejZWUms4b1QxMnpVY2FlemYxU2syZzdIOU9ha3FNZ3lHQ2tOcXh5VGpKVGp4KytkUzBmcFcyanAxdE92VjI3Nmtxb2VuMzl5QWxES1JubkF3VGtlM2NSblB0b2UyUnVLNXQzV25KVHNNeUl6N3FUTFVvZnpWQWNBaFIrZzl0R3VxM3pTcnJzVlB3MEFMalNrdUtiV0hPME9JVUFPMDQ1SnlPUjl2MTFBK3VWREtReWNKTzlWdmRVdjVTOStJYllvQldkdHJQazNZV1UweEU5aUs4Q0VLVjhqd3p4M0ZKL0tRT2NjODZtWDdldUxhS3ZpZmRWcm1QQWt5ZlVqcWJCVTAwbFNpZTBIendQSHZycDJEdmFMYis3YlZCbGxMa1NUVk94c09ISGFzbnRCeVA4QThOTnhXYkhzRzY4VStiU0daTFNENlQwaDhoWmJIZGp1K2J4bm5nY0RVazI1eW9jb0JhY3BJK3ZwVTBhTEM5MFNXaVE1MVBhZ1hFdm14TGxiaXZ2UHhrS1FRNDNsZmFuS2Vjaytmdng5TWFPMngrL2xNdlpLYURWNUxRa05OSldyNTFkOGhvazloNVBBNUdmdVJvYmJwZE8yMlZXaXNPMi9RWEtYNmFGQ1F0aDRxQ2lEZ0xDZjZjK2NhQlZmdEMrdHNLczNkbHAxQnhsMkU5MkNZMnJrSDZIbkJCSHRqVmQ5VVM4b3dmaFBTdnJhSk1SM25DdWJIVHFmU201MytidFdsTFRNY2dtU2wxa21RVmtJY2FQT093KzJQOHhwWjlzZHNxZmVtNU5WcVVxQkhrQ250QVEyWDA1YlZKWG5zS2g0VjJnRTQ4Wng1OGEvS3YxWXRYTEVVL2M5T2twcUhwQkR2WXZMYWxnZm1IMC9UeHFyN2JiMnlLSFVhczlVSkJSOGUrdzgyb2ZtN215UmpQdGxLai9iVVVLMXpZYkxuSU1IR0IvaXBWM0dISWViUTRjak91ZjErZFhOK3lMeHBsU1VpYXoySWJXYzlod2s2bGRsNi9YdHZkeVZVTzRGdXRVeXN5RXFST2p1QS9CU1B5b1h3Y0FLL0tTZkdRZFdxM3Q3ZHY3b2hoVTZZNHc1MmoxRXJXUG1WajJ5UEgyMUZQWExzOU52ZUd6VXA2NFVWNWZiSWZaUW50N0QrWWtlK3FyUzVvVW9PSXlDUG5UYk9qMitYR0hLcmxJMTZZcGc0OTJ6YXlYWFUxZFVsY050YnI2VU5rT0JhVWxKUWNubndDUjlORGZlN2V5MkxmdGFwTzFLTDYwaHlHeW1tc0x4MnFVY25KeDRBUHNlZk9oVGZYVUpSdHZOeFo5c1dGVkhib29yQlNHNm04Nll6L1lQNlVMQkpQR0FDcm5RczNWM2p1VGR5cUpXNUFSSFlRQWxMS0ZaS2p5QXBSd01xeHhuSHRxM0ZzYmlsaHhZd25menBKVmMyMHJMYWRTTkJpcW05VUZWT3FKZGtKUWhDbnNyK1RnWlBQalRrYlhWaTIyYmRqTVQwcmp4VlFXMHhFc045NDRIQ2dmY0tQMTB1VmpkTzE3WGlXRktiVEVqcVNDSEZwd3BmM3dmUDYrTk1sWWV5VnpXcmJiTkVWZGN4MWxyNWdBUUFuUG5HQjQrM3RyOXhCTHR6alNXZ3JKSFFmdlRSd3h3ZHhMUFdYaTF5cFBWV241VkZYYmNVT24xRlpqU3dXVmtKY1M2dm5KL1QyQit2MTBIZHdDeGZsWFJiZE9qUjI1NzhwS1lhMHYvQUNwY1VvQUQ5ODQ0MHhybXhkaHpvaTZuWFhKTWxCeUE3OFJnZzU1L3oxV3AvVG5iZTNkOTIvdVBTUTg0eFJhdEhubUo2NHpJUzI0bFpTRkVIQ2pnRFFhQmNMYkZscDhRa0hwUjY5Y0YzeG1JUWpDczl2MHEwOUtINFN0KzM3WG9sWTNpa2VoQWJXRk53V3NxVzhzSGhKeU9FOGVkRXk5YldwbEc2cEt6dGhiNUNZOUdrb3ByQUt1UFZiYlFGWVAwN3lyKzJtK3NIcm42WFd0b0pWOFdYTG0xSzZtWUFkY3R4Vk5MY3VPdGZlRS9td2hRQ2tuS2dySEE0R1JwQWFCdW96Y0cvVlR1dVc4c3VWS3J2U2xCNUJEaXZVVVNTY25qR2VkRTcvY25IN1dzTWtEcUFQdlFUMmN3Vnd1SkZMbVpMaVU0eWVueXB2b3RvTjdhc3g0ejhuMUhwS080S2JQeTkzMjkvZlg1VmhKQ2ZTcDdnUXRCQ2x2TFRrWlBKSDMxRHhia1ZXaTNLbFNQVkxUYUF6Nlp5RWNEVjJwaW9WWGlxYWtNSUhmakEvd25BL3Z6NDBqV2d1U0d1VjNVOWE2UGl2bGlPRnVISjhxbzB1anVGMVVkUkFrcVA4d3BQeUFlY25YQ3pTME8xQXRoUklBNVdBZTAvcDlkWDY0TFFEVENvMENTUzQ3d285dkJUajYrMnYyME50YWxPU2xiN1hZMGc5b1RuT2NjNUI5aWRIV29vMVFrVlprelVoc09sVlE5eVJZZEh0TjV4TWZ0VVVBSVdWNEpPUDdhWDI0aEltVkp4ME9aVGduS2pqajMvZlREN21RVEFvMHFIMytwaFlTRXE1Q2NjRURTNVY0clROZjdRbElRczQrdzFWOTJMTDVDcXRRbmVhTnpKMk5lVkhudU1yVXBLdTFDUitidThrRHhxTnA5NlE0MTJvVEhjN0NWbjVScUtxRlprSmNYRmFjK1ZhU0NyUFA2NDBKSzVkNzl2M3pDTW1XdkNubEpKSjg2OHpvQm14MU5EcUt6cmp4cHAyeHZxVjBGYUU3RjM0cHBobExMaFdRUWs0VGtrSDI0MWM5MGQvcXpiZFZuN2QwaTNURnFNZDMwWjhtUStIVUpVT2UxQ1Vrak9DT1NlUEdOQnZwbHUrcWJTV3Npc3hJNGN1YXNSY3gzWDA1UlNZeWgvd0FRcDhGMVE1VG5nRG43YXN0RnRTYlVrU0ttN0tVNjlJVVhGdXVudVdzcU9TU2ZxVHBKaytGYUxmNFhOek9iNDdEdDYvYXNJdGxqYVdqM2lVbmZHUDNxRHVTbzNSV1hBbWJVM25WdWZtK1lnSkgwNDhhNzlzcXp1WnRaWG1icXNpK3F2UzNFUEJaWEFxRGpKVitvU1FGZlRuVmhwMWdUNFVRT1NYbE9PY3JKei9scU5yOFp3ZDhiNFoxcnVSbEtteHdScGVnM3R5SytGc0RDdTRwcVlZYVVudzBwSEw2VTgzUzUrS2Jmc1ZNVzN0MmFxcXJNcUtVaVRJSUQ2UjR6M2YxZnZwbTdnNnc2eGNFK2pXTHNGU29OWnIxYWFWSWNsMU4xU1lWR2lwVWtMa1NBajVsSEpDVU5wNVdmY0FFNnhjajNSVUtYSVlTaDFRN1Y5b1BhZmwwZHVuanF6dlRiQzZHNThLcDREclliY0trQlFVbjJDaDdqOStQdHJiZUcrTC9la0J0ODY3VXNjUThJaDF0VHNYNFQrVmJYMjNjTDBxTTBtUkpRNDUySjlSU0U5cVN2QUJJQk9RTStBZmJYdlptN0ZsM2ZjdFFzK21WZ2Z4S215WG1aRU4xQlNzK2twS1hGcEIvTWdLV0U1K3VSN2FSSGQzOFJ6YXExZGhISjBxNnE1VEZYRFNaRVNMWEtQQkpGTm45cVVocGJtRkJod2xmY251R0NsSk9lTkZYOEhpeExmZ2JKemR5NmJYbUttOVc1cW1Wem1YSDNVeVZNa2hjaEszMUZXSFZrcktSZ1oxcExIaHZNRjBIUWJWa1V5Y3VOZFc0Q1Jra0VxeWRnUEtuTVFSanVPTTQ4ajMxOFBSMkpMS21KRGFWb2NTVXFiV01wVUQ3RUh6b0lkUUc4dS9GSjNUdDdhSFpTaDBaTW1xU0V1eVo5U2NNaGFZcWVYWEMwbkhwdGo4dmNvNVVlRWpqUmhxMXhVbTJLR3FzWGJXNGtGaGhzR1JNbFBKYWFSOVNTbzhEOS90cjZwcFNVcFBlcmpVNWx4MWFFYm8zT05QclNkZmlBN2J5SVZUc1BwMjZjNUZJdCtYZGRhay94S0UwMDRwWHBPbElXK1VkM2FVWjdzZ2drajh1T2RkMjNQVS9TK2k2cHY3R2IrMzB4VnFEUm1HbzZiMW90R2xJaDB0N3R5bUhMSktrSWNLUUNuc1B1QWNFNkpPMisybGdiajlVVlo2azZOdW5TN25aaTA1bU5RNDBLYWlRYWU0VWtPS1ZqaFBINUI5enpwY2VvZnBFNnJ0OGJodHpvenU5TktwKzFNdXR5NjljOXoyOUpjVE5xQ0V2bHhDWGlzWVE4U3NjY2c0ejdZMWRhQ0MzNGEvVS9QOXFubFRFUGptUTRWSkFIWGM5Y2ZQU25vcFZiaFhEU0l0ZnBUcGVpVkNPaVJFZjdDQTQydFBja2pJOXdScjByVk9ackZDbFVLYktLRzVzUnhsYTJ5RGdLU1U1eDcrZEJmcCs2TmJINmJMeGtYTFkyNnU0YytQSnA2SWpsRXVhOEhhaENSMmdCTGpiYmcvbHJBQUh5bkgyMGI0ampUbjhvblBkNUJIK1dkVW5FcEN2aE9haFF0ZVFyR0RRTnV2b01vbHlSRU8wamNtWEZrTnNwU250cHJDRUtVQmdLVjZZQ3U3NzUwdEY0N0p6ZGxONUlGdWI1VTUrcjA1eWFseE5RUkpWNmJrYnVBVVJubk9jY2Z0clExYkVpQ0N0cFBlMTdJU3I1ay9vZmZTQWZpVmIrTVh2MUFXcHMxdC9NaTFXVlRaU1dxbEVaYzdKRERxMWc0eC9VQU1jZlU2dHNTbkFybFZSR0d5N05Xb2ZQeTNGTTMxZjFGNno5bGFVOVFZODVpMldaTENLeC9COEI1cURqeWdlL0dQN25TL1A3ai9nNHhYVk1WYU5RRnlrbi9lRnlxVSs2NFYrL2NzNTdsWjhuVGxVdUJEbGJmUkxjdWFJaDlCcHJiTXBpVW51RGc3QUNrajNHb1dOczV0RFQyRVE2ZHRaYmJiRFl3MmhGRWo0QS93RDJOZm1wQlFucjYxU1czRFdPUnduNGM0eHRYOFNkWG9GejdUMXhOVm9yNnkwQUNWZ0hHTStEOXRGN2JMZXVrM1l0aDVENGkxRnNBT3RLVmdMKzQrbzEzWFpaRGpEaTZaWFlTOGtZVUZqMit1Z3pmbTIxVXRDb0txMXVMV1drcTdrK25uTGV2YUhWTW5UYnQyb2Z3M3hhM0pRR1h6cWV2UStsT1RiMWVhcXlERGtxU2gwSjlWdHhheGdnRG5HZk92OEFWU2tVT2JIVk5uUzI0cW4wcGJSTmNKN1VLL29Tcyt5YzhaOXM2WGJZN3FFYmZhWnRxNzVBRHpTaDhOSVh4M2UyQ2ZZNk85RnFkUHIwWjYzYXNFdU1TbXNwd2ZZaklPdmNodHVaSFVnYkVWcDlvays1VEc1VGVvQnFnN3liSzFpOFluYk5aYmcxbUFGQ0wydUZUYnpYbElKSUhuMkk0L1hSSTJHM05zdWc3Y3d0cm9kR0ZMcWxOWVFaeUgyMGd2UEVmTTRva2ZQN242WXhxQUYxSXNHcEpzTy9Ybko5TEdEQm50OHZ3d2VSai9Fa2U2RCsydXE2dHRJOVhpczFTTFVFT3RPbzdxYlZZU3ZsY1Q5RDlmdWsrTlozY1kwcU9ud1ZhQWJHdE1tMnFEeEF4NzNHUC9KamJvZjJOVGUzeHMyaWJ6WEhXcWFJeUVTbW0xT0ZTUUVxV1FTby9RWSt1aEIxbDE2Tlhxbi9BQStqbExuWTBDMGhCTGlscVBsWEE0QXpnYTU3c3Y4QXVYYlJwaXoyYWEraVpOZVdseWFHdTlFa0g4cFFzOGhJSGxKNTFjOW5hOUNnVWg3K0kwMkRVSlVwbFRTWEhHdTVjY3E0TGlENENnQ2NaNDFUU2g5aDV0MXpVZFBPa3p3blBCZFpHVWxHaEIzcFg3R3JGUXR5YzNTNnFYWWpTcGFIeWw1c3B5b2NaT1I0eHB0ckl0ZTJxeFRHcXc1VzJuR0htZ0ZGTG9JU2ZJeG9MOVdsazBnVnRxb1UxOTVBYmE5Tmt1UEZmZWtEUEkvcFVTZVNPTlZYWSs5cmduMWRtd1g1enFJYTIxcmNVblA4dEtBVmxYSDBBSSsyZE1qNER6QmVLY25Hb29KQWZYRFdJNU9CblE5eWF1blZUYzlDUkxUYmxxTnJkV2tuMVhFOGhQMEhHZ211MHlHVk9Peng2b0dmU0xTdVQ5TTR4cGd0eDlyZjlaNmEzY1Z2UkdnOGhmZWxLSFNFOW50ajZuNjUrK3FkSTJ6dkJOSVhVM3FRcFRUYXVTU01uN2FpaXVtT3dPUk9BZGFLU0lEZHdkUGp1YmFETkN1MGJKdWk5cnFnV1phRkNrMUtxMUNVbGlGQmlNbHh4MXdud0VnRW42bjZBRW5UUXIybnFGTW9wdCtaUzIzNWtWbjBuVDM0YlE0QmhXUHJvZjdWN2pYMzBzM3hBM2t0dTF4SjdXSFdKQ1pVZFFiY1pjUXBLMnl0QkNra3BQbEpCeC9iWGVlcktuMUI1MWFxTWxzTGNVNEdtajhpU2VlMFo1d1BiT3JpbkV6Q0NzZkQ1ZDZFeFkvOU9mV2x0WTV0TjY3THMyanJGSzIzazNjbEVXT21POFczUFNCem5HU05CZHljMVVvczJtVFA1eS9UQ21sbitsUVBrZlhqL3JvbjN4MUxQVjIwRFo5TWFMYkVsMEtkQ3lNSDdmcG9YVHFUVVZUSlA4Q2lQelF0c0pFaU5IVUd3VGtxd1Q1QThaOThhOE1zTk5xUEprRHVhdDNXVzhwa0pjVUZIcUIyeDVVYXRnV3FCYnV6emprSlRhYW5WSjZWVEhpcktrc05uNUVENkFuSlA3YXRjMndUZkxyVGpyM3Fva0hJTFovS1ArMmw3cEZkdTZ6NlNwcVF3dGwxQkRucHVkdi9BQThaejUrbzFLT2I5MXNSMFBVNlFxTVFrSmRDRm5Ddjg5UUpock1oUzE2aFhYdFZWaWJIUzJBZzRPTmpYVnZIWmhvMG1SRWh4U1N3c29jVU9RVkQ2WTFVN1IzUHIxdFVHVGIwZVoyTnFTcjB5VUFxUm55RWsvbHo3NDBTNE81KzNjcXlKa200YXU2N01USElRd2lQbFMzRkhBR1Q3RHlUK3cwREpEcUhaSzNFSkFDbEVnRDIxYWpNaHhLbWxwK0VFWXpWUzRTdkRkUThoV1ZZSU5kRkxxajlOcThlcnNFcGVqeVV2SVVrODVTb0hqKzJuR1R1TTNEalJLamJjOFNXYW93MUpRNHZIZ3BDdm1IamduQjlzalN3V2h0dE1xTk4vak1oVFFRWE94TGFpY2svVEhzZFh1ejdLM0xaYlRDbzl3eG1JV1N0Q0owWHY5QW44M3BqMjUvYlVFOTZFNGNLVUFVNTNxT05icm1HdkVDRHlxN2IwMGR4VjJteUxWWmNmZnB6cTVrRlBxQ0s2TzlsUU9UbkpBS3M4ZjhBVFM4OVFsMlV1bVdjeFNHNnd3aDJWMnV2eEVsS25Dc1pHU2tmbHg0NS9YMzF6MURiNm8xSnlVbXAzbE1lWlVvS2RlN2cybDFROGRxVStQNzZwTjI3VzI5RFE2ODFLZWNkS2VIQy93QnhLdnFjK2RCSUh1S0g5WE0rZzBvKy9hcno3dnpoc0RUcWRhSFVjSWx5dTE1eFFDbGNFSnp6OWRYWnFsYmEyN1MwUzJLOUhxYjdzWDFGSkNGZHphODQ3Y0gyOXorbXEwN2FjMXJ2V3lsYnFVckNRcENkTTkwcDlEZEpyRWFQZk81RlBicUNsRHVqVWlVdFNZNEdNOXpwUnl2SCtFWUdmT2NhYVg3aEZpdGN5alN3aTFUM2lSeWVaTksxTGZlRlFVelIweUcydTRCdHRTaVNmdmdlNSttdStOYTk1M0E2bEFqdmtEQUMxNUFIOTlPUHZqMDk3ZEdtcVJiVm5VdWwxZUhoVWVvd0dGTnBsZ0hQYTZrSEJIZ1pBQkFIdm9MV0R1M1FMYXZGZEgzSm9ZWVZFWDJoS1U1U0NQcVB2OWRVR3JtSm4vd0pHUjMzbzNIc2lZelFNeHc0T3dCMCt0Vk9tYkNUNlBSMzZ6Y3NweEJURFc0eEhaVmd1S3hnRE9Ebms2YWo4STc4S081T3NuY2cxVzZhbTNTYlVwTGJjdXRWaVN6M053bUZyQ0VIQklEankxRUliUm5rOCtCb2ZzM2xRdDNyOGJvbEtncFRUL2hoakJCN1BuVDlQOFhqam5XcHY0YVhVNjEwaVdwS3R0ZGdNMWlrMVdTeExtTXR5VXN1K3EwQ0VES2tLU3RBQlB5S0dNZ0VFRWFHZjFPVWVacDFRejU2RHk5QlRkYitGQXR0VTJHMWxTUjhBUFZYVTY2WkF6anpwc05zL3dBRXI4UENqME5zMW14YmpxUUtNcnFrNm92dDRRa0VxWGxzSlMwTzFQa2p0Qk9NblNFZmlHOUlkdWRNbS9MdG1iUFY2WEpvTXVuTTFDQkZtOHJZYmtOSldsdHdBY0tDU00rUGJnYWRqZnY4YjdjV1hSVlcvdEZ0bkZwRGltMWQwNnF6ZmlTbFAxRFRZU2tuMytZa2NlRDQwaDErN25YNXV2ZU11K2I3clQ5VHFWU2ZVNU1rU2ZtVXRSOG43WTlnT0FCcGI0b3ZscVJCOTJaQUx1UnFrWUErZGF6N09MSHhsSGtybDNWWjhFakFRVkJSemtZT21nMCs5QTlWdnVNdk90dnZ0cDcxNDdPejVSK3grK29PL3dCRTF0MVRCYlYvS0lKN2ZCNDgvcG80TVdTeGNTdmhsTkZLVTVVU25BR1RxaTdtMnF1bGoxSHh5Z0VJU29BLzN4NTl0SkVCNUR5K1paeWEwYWNocHhYS1U2ZHFGRm0zakx0Q3NPVDZmTE1kU0d5cExwVDNwSnpuc1Vud3BPZWNmMnhxZzF4K3NNN2dwdmg1Y1Z5QkxXRWxVWkNrQktnU1QzQStNNVAyOXRXaDFjVlU4cUs4dGVwaGFrbndvZWRSdHhOQkVDYkVVQjZiNnc0TXA4SFBrZnJ4cHdqUGg1c2hRMXhqTlpwZHVHb1VhNWUrTkRsV2Y1aWkxdFZ1bzR6SkRDbjhOZHdLTSsrZE1wdFpYbzlUSlMrc2ZJcithMHNjblBJSU9rUHNpdXlZclh4YmpoZFBjQjh2OU9EZzUvdC9iblRQN0FYL0FBYXZJQlpxYUVQT3NwVVF2NmpqR3FiWUVOMEo3MFNndmw5R093MXBqbVZvbUlWbFFXa0FudUFHdnVWZGNXa1JGeGxMU2xaR1FscFFHQjlOVStIZE1pUzY1SVM3NmFBbFFTb3FBNThZMUUxbTRHMis1VXpDZ1d3VXFSakE1Lzc2Wm1TbEtBcnJYMTQ1SlR1S2lOMHJ0Ym50SzdwaFFGSlVWaFBrNlh5Nks1SGp5MU5OaHhhbGs4RStmMTBTZHdibVlVNTZxWXFXMkVxUGVDZmx4OUJvS1hIVVBpYXBJbVJTVk5rNUlCNEE5Z05DWkt3NitNYTB4d2l0dUljNkNvbXFUMm1wYnEzVmZJaE9BVmZYUW5JbTNMdnJRSVZQVWxmd2MxRWhZY1IzcElTYzRVUGNINmZmVnN2S3VTY3JRWlBhbFJKT0Q0KytvL3BZZ3NYVnVoT3J6NTdoR2RTMGhTdlk4azZsRDY0a2Q1Ly9BS0RUMU9nKzlJUEdVaGx5RWlPby9qUDFBMXA3OW5hTTdYbE9WNnRyY2VrU3lYcERwU0JrbjJBOEpBOWg3RFJxaDJwU1dZN0xRYlUybHp0QjQ4REh2alEzMmRiYmgwMXZ1a0E5NEFPUjRQOEErR2p0YnpNTlRBZWZaNzBBQUpBVCttc2RtU0MrMHNEVlJySnBNckwvQUNuYnRWY21VZ21BNnlscnU3VllTY2NuOVB0cXB2V3E4NUhlYmVSM0lEaEl5UHk1L1hST3J0UDlMK2N5a3BTNHIyR0RnNmk3cHBraUxUVXNNcDczSHdFNVh3QU1mYnpwZmFqUEJYT0JpcnR2bUpXOEFLQWxmcHJUYmppME9EQVZqSlNEaytOUWhxeGdWQnVNa2hJVHp4eGs2dE4yTXlhYXR5TklTa0tMaXVDbmorK2hOZU5XZWpUVVNvL3pLU2ZsU2xXTTgvZlRCWjVMa2VRTmQ2YWxKQzRwSjNOTXQwN2RURVhiT2RVRzZ2U1JWYVhVNEMyS25SM0hnMjNNUjJuQXlySVM0T2NLOXM2ZFhaLzhWWGJ5b2JKdHlPald5STkxM0hTMU1OdjdaeVo3ZE5tc3hrL0s0dEtUL3dBVHNTT1BUejNIR3NvN2ZyekNtbEY5ekh5RTVVT1NOUk96Vm0wMjB0eHFodVRSNHFYcWc3SkxsUGRmVXJFSWY0MGdIbFdjblAzMXRGdTRvYmlSMGwxWHdqY2QvU3N1dXZDVDEybEtNVklTNGRPYkEwcmJQcHE2N2RucUpZRmM2bU4rSlVtUGR0Y25PSWNwVEVWVHNtTEViL0l5RUhIb29TY2c5eEdWRE9rNDZqL3hVT3AzZnpjNFhWWlYzeEtIWk5KcmFuS05hRXFpUlpUY3h0SENYSlpjU292S1BKQ1JoS1NlT1JuUUovMWl2eTVFaE5RcjBpU2xTc3JTNDRlMG42OXY5Ui9YVXF6dDQ4dUszTWNCQzFjOXlUai9BS2FGWHIybUlDeUdVbE9Oc0hXcDdiN1BJOXBnKzd2cURpam5tS2h1VHVhYi9iUDhRMjBhdlNsMUc5TFRyOXV5S2hHQ0tuT3NaY2VucWtsUC9EU0IyQW9RTWtueVR4emp5emZUTjF6N0czcGFrQ3gzdDFaajFhWnlqRnhwQ0huc3FKU2t1ajVYRkFFRFBHY2F6Q3A5cVZCNm5nTGtPSkNVK1BPb21vUkt0YnNyNHRnS1F2T1FVS3h6cnhiL0FHc0lsclNIRTVCK29xcWoyZDJaa0ZjY2xLdGRpY2ErVzFhZWZpRGJwOVd0bTdjd0xqNlYybVMzR2xoNjVKTWRoRDB0cUlNWkxMYS9sVVBKVWVUZ2Nha2VsZjhBRVYyeDNGc1dNZDI3bmhVT3VNdGhNbjRqdVMzSklIS2s0SHlxK3FlTUhPT05LTjBmL2lCMWV4SmtleWQyYXM1S294V2xEY3A5WGM1R3p4blB1a2U0K21tSDNONkMrbTdmU2Y4QTdSNkdrMDZUVVVpUTlJcCtDeEw3aGtMS1FSZ243Y2ZiV3AyMmRGdVRQaXRLMFA1VUlseDJvVWNRWmpRR05VckdtZlU0UDJxeDlUbjRzbXlXMjlwektmdGxYazFhc0tIb3R2OEFhVU54MUhqdUNUOHl6enhnWTBEL0FNTVhwNHJlOE84RlY2dU40N2JTOUpXNG8wcVpKVW91S1VWSENzRWVjYzgrT05lMjdIU1QweDlIMWpmN2NiOHRXcVhXaWt5VXFWVEtjT1ZKUEpLbEw3bGRvd0RnYy9RNlovb3A2bWRtT3B2WlNIZmV4OEFRYU95OHFOOEFVaEpqclR5VTRIMSsvUDEwVVN0dE9VbzFQYzFXa0pjWXRmaU1KQWJKeGtIT3ZjazRQcHBnVVpYNVVsQUNaQ3ZVU0J3b2prYTh3NjBSbEtqZy93RE5yNFZKUUU4cnlDZkd2bnVqbmtxQSt3T3ZtTktWU00xLy85az1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcHVibGljL2ltYWdlcy9vdGhlcnMvYWJvdXQuanBnXG4vLyBtb2R1bGUgaWQgPSAyMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRRUFTQUJJQUFELy9nQTdRMUpGUVZSUFVqb2daMlF0YW5CbFp5QjJNUzR3SUNoMWMybHVaeUJKU2tjZ1NsQkZSeUIyTmpJcExDQnhkV0ZzYVhSNUlEMGdOakFLLzlzQVF3QUlCUVlIQmdVSUJ3WUhDUWdJQ1F3VERBd0xDd3dZRVJJT0V4d1lIUjBiR0JzYUh5TXNKUjhoS2lFYUd5WTBKeW91THpFeU1SNGxOam8yTURvc01ERXcvOXNBUXdFSUNRa01DZ3dYREF3WE1DQWJJREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBdy84SUFFUWdFc0FlQUF3RWlBQUlSQVFNUkFmL0VBQnNBQUFJREFRRUJBQUFBQUFBQUFBQUFBQUlEQUFFRUJRWUgvOFFBR2dFQUF3RUJBUUVBQUFBQUFBQUFBQUFBQUFFQ0F3UUZCdi9hQUF3REFRQUNFQU1RQUFBQnlLcE9IcnZtWVZlbFlBbkRHM2R4a0V4STZDZGZSNCsyc2V2a2FyVERoOC9yOHFLMjQrWlpsMVY1ZlJScG1jWThtamJWWER6dXRFRFFTYmswMnE4eHBJTkRJTm9hYUNoTnRWcGtTNlk0RjJEVmhZV3UxV2pKRFhvNWlXNStneTZQT2F1aWtCaURZeVNLV2FNZXZzeDM2VXM5N3p5Z29xVHkwbnp1bTBXdnlPa3JHWTFBTUNuOURNM280OUFoTjhiTlpRTXNKMVN2RDBzUEhZdnozeVhvRzcybFduTXhJd2ltQnI1NVd1cGFpNkIwek82a3VwWG1zNlhHSGFRekhJbDZMQ05uQUsraXZZNVFkREpDWTdDTE9xdm5MRy9uY0UrOWFZZ3RWcDBaRzVIVGI1N2xCNzVuaDlPUjdLZVB5cCt1ODF4UTc1ZnEwYkcwYUdueUpkNkR6ZVVkeFM4bThRazJueE9hMzZwWEsyUTdJZCtpekRveTVsTlJZZFNVem5kRXU0SGtwblRKM25WelZyckVNcmF2bkkyWFF6WlMxYWViMnczNy9PcDM4MzBQUnAyY05jZm9tdmk5encvSUtWWEhKRFZRN05aV3RCS0wwWlpTNW9Hc1UyL211UjJiMXVnN0FpbmVxWjZUblVvY3ZKRy9SaTZPMmZNOFg5SXpWZnlhZWk4M3YxMlFIVEkxc2xNWXZYbStsNmhML0NMTVdja3ROWnZCeWJ1cEt3S2xWZ2VaYTJVeWpVWUVkWDZPY2txeVNUTjBRWEpja3RoeU8wT04rZExaaXk2bUdvNVRUVVdhWlkybDRsWlQ2N29qQ2lFMDZpMHRLZ0M5d2dwTE03TDZmTjBxZXhXTnQ4cU1uUkdOdUhqN1M1aGZaNWpsbTVOcnoyTWx6aDV5ZzBMWGVka0p4S1ptVzFKeVBnSEJEQ0laUzdSVmhMQ2cwQkVOSWlZclJHM0kycjZERU41ZlJNcElWTVVRcnF3WmNVTlhwMllXOU9QVm5QWDM4M1V6WXc1YjFLQWVEVjFMcUd3a1dtVHM3aWQxQVVlZUd6TnQ2VkNaUFN6VXR1YkJrbEsrS3JKTE1MWXhadFFZdUFoUnlka1dubkQ2blQ3Um1EVnk4MTFZNWd3SnhoRXNxQkdCbVhtYmczbDJ6THY2a1V1dStFNU5DZUc4b1BYejBxWExQSUNlVDNWdU83d1ZjN3FScmpkRFhWQ3paZUppNWZvVjdIbHVxdmIwTFhvUTN6MW9ZalJpeVlCNU03aklZaTBwTTZkNmFPVDBFSDBHL1pqSFpGa3NPYXFsbkswN09WcGcxVlV4WnR6TjBVenZ6d0lXMWVxeWhwbXRvSmtDTVZKRytiNzZPam84ejJPejZBMDV2UTF6ZzQ4MWJEaGM5ZlRLemkzMU9Za2Q1Ymg2N3h6VjY4WitZNlgwdkIrNDh2NlduTTZQTTlGMFI2UE05UEZUdXBnNnlXaHVOdFpPQ0FDL24zMEhrNTYvUG94Zm83R3hMRlQvQUYzTjlSNCtrSWo4cFVZbkVXWW5PY3VqVTFZazFKWmFvTHFTSExydG1GZGFxRGQ2RkF5c25ZRXVRelZhRGt2ZEw1dlRIbDA0SmFzazlUQ1dVakRXVVQ0NWxuOWJzTjNzR2pUbzBWejU1MkFxT0hXL21MWEhsM3BuYk5HSm5YWDBlVHZNMzR5eWt2bUZ1ZWp4b1ZCQ3VwYjRzT2JsZlFXczJHbzVIbWdzeHg1R1NhYnpGSzBVcUlmYUxRWm9ZTmcxU2tob0dFRlZhaDF2Q1A2Qlo2WVIzMG93RDBsNTZZNjFUSzhFM0xlMlVySFM2eDdPYnJXNTJRb2VtOHhROUV6UWVtWnlHN1JoMFRsMGlXZUhtUGZtZDNUcHZQWGZCWW1wOHUxcll2bFlVUzdGTHJuZEpzbVBUc081Mjg5Mm5QMEV4cW4xZmg4V3VQMFFlVDF2T0Z4eStVb2J6SWNqaUQxVHVQTG90OUhYbWIxUzBSSFJLVTFYQlNWdVZteHFaTlRsWnowK2xTTE5tZWFZKzVFbVZndlRuMElVblVsaXMyclBxcnRiV252ejY4RFd6ZnQwT0Flckp4MGNqTTNFTlF6UG1QbmRaNkMrZnFTRVdoaTZncW90YU1QUnA2ZlJ3ZWp5UnJMSTdPV3NsNUZVK0lSYkJRcGVpcU1pdDY5SHl1d2pzYVVPcEduQ1NPbTk4eTVPcFNYVkZMYldKeGNmZDQzbTJ1THlPajhSNk4vcmE1TkZhMnZCZXBTN1NPNFZ0NWc5M08wWXB4WlN5VzVZRHFtcldQUFhsZk9mUVBBK250V3JONmZlL1I2TG56TjJWSG1wZFhFa2F5VUhLdVp1U0FSQmZSSkZCNm9LUXR3THVna2lvYkxHQU5rRU9WVTVLTTFYMVN3S1phVHpPcXJrMTQ1MkY5TERYY25uSmMrcnQrbkJyckxYMzhIVDA1clJ1cXN1Tnl2UTh0YjhYTnQ1dVBXbExGVDFzUEthbHl3aXpseWszMnFTelF4Q2VpSlpsd3NZazR6ZFNpa2NTQ2x1cE5nK0lOTFJhQ2diYWpRVDBISXkxak1zVU8xem43ZWw2eWtORlF3S2t5eUxTRDFoZUl5QkU3QTVMVlRoejBCV2dZdkJoN21mZnE1ZHpIMDlXdG1PM2Vnc3BxdEpaQ2wra1BqZHJsOHEyaFN5Y3F3dFd0Z1pBTHRNa1EwT2xZVkk3SFhXSnF5NndrNGM0YXh4ekZkSG43T25kY0wwTzRlQ0ZnY3dFUjVDNWZDOXp5UFFFN3ZJK2l6WFhkejdrNlZaQW8xcXlURnRXSzhuZmwvUWNIdU9YM01tN3J1TlU3bHlNb3pJV0wxb1JEUnFIZFdBWXVoeXRTYU1HdlkxNnNlamxONytlekpiaFRNYWN4QnlSWjUyK2Q1UHQ4RDNIMCsxNU1yUGJJOHRPZXZRNGVYcjAxMCtoTFg1K1NEMEJoa3JZQjROekRidEs0NHRUSVRqeE9ldmRrNTJvVFdLOStUVkZPZG4yNkRaWStwRjJOb3VWZEVxTFFQUDJUejc4SnpmWTh2ME9qazdPVVBZZFYzRjZjVDJHNjgwSitwK3ZUTEpldTVubloreldMNHF1MXpPT2ttc3VXcitmZlFQRCtsZVA2SDVYMmVlMWtKK1ZVTUdUTnk2aVNzYlNLVmFWeVc1cVdMR0drdWlXeFpkY0hRVU13a3paQ0ZaMHl3dEs2R1pzclZZMzB0blhCQWNwWWViMnVmeDlXWWxscHI1YlVyWDlUUmRPK2pmTlRuanJ6eFZtMnZsYk1TdmlaTk9ibjlMTXFSYkt1cUlPVlN5SitWMHNpemtyTk5yS1l4Sng1ekRUYzV2aWltak5RbzBSUnl5SlFpMFdnazJua0pMYVNQUVlSeTc5Qk1NdVgyd0hLTmRaVzFGc1VvSHFDc2tRSGNnM0xrS0xaWllzSFF1NnJVc2JpWWd3Y05GNHR3enY1eEhwdUgzZHFieUYwYjZabnRYcDI4eXBYcjJlTzZITngrZ25HZno4M1NEbjZxekxRWStobU9KaWM2NVhVSElYbUlHOXJYbTBjMTArMjlIbHlWM2s2OEVBdkxtU3IwVG9TMkhOMGpQc1RKODdEMXg2YTRXZGxuUG53cDNNcU9hUlpaclRhOVV0UE03bUxWY0pxRzliZS9PL0ZQSlpZb2x3R1hqMDQ5bSsxMEU0UFk4NTJ5L3BjRGIwVDNOR0RWNTlhblpuODVxUE96RnV0WVFONWRlWDcyQ2FMMkp1NnVkTHVyV2hlejhuN3psa3hqUE13UzJOZ2JJeFUxa3ZXWkdVelBacDVIU1dLNXhhMkswVGR2SzZFdlU5Ulc5RVRXeWRhWWgxcExSTm9Kb3JnVXpQNW4wL2pYcDFjSlpGWE96NmVsMlg2VHA1SDNob0ViVVdTemtPQmJMcVJ2TnoreXZrdmkrUTl4NHVkdS8yRnM4N3BPNnZCUml6bWJ1b1REQWhGZEZjVlowME5YTVhKVmdVR3Rrd2d2ZWJXYTg2c2d1SGNDZ0lreVdWVVdiTTBsdkxpVXp1ekJHdFBMWEdIWmhPemtkckIxZnJNbWF1VE5jdS9udzdUT3Mrbmtta3hURGwxb3dIbmpyR3BFR0t5TW93UkZDRzA3RmIxb0F5aWlNQ2p5N2xVc2pKZHFtVUJLaGFxRGFNNksxd2FPNzBqVHkrcjB0ajg5dHpuNTNsYVdwSG1qcEZsMU1pckhGQlVBZzRFYVlTV3BzRTRWVFZhTlFhYmZTZ09NMFlBMk1TdlJuekFVeFhMb1FBdU5lZnlmUzh6dDdPZFM1MTlySUlsbmE4OU9uNVBTM24wTnVnK1R4Nng2VktMUnF6NXRJTXpZVXVtSGQ1c1hSYjBVcm9yTjgrclNodkk3ZEhieXFyRFJYUzVtUUtWelZrRzVGZERiaTI5MlpReTZweTRlc3JGK2RQcGMzaTBOUmhvdk55MTltajJJYm1ualF3dEJLS0JlQTgzVTlVUWx6ZkZlWGRPT3JtOEgwdVhveXJ1UDh5T0Q5Y1BsYml2UmM3bERzTVZjNklseXlwY3VkTGt0YWF2YmVHOWI1K2V2b2N2ZHg0OUhHSWRFdWZoZHlWMFFwVGVtQ2RLczlqeFVJTlRrQW9sYXlEOHdhSG9ydzdJZHhjNDZZU3JCanM1ZENjS3czVnFXbkJ1OG4zY3ZvdkgwdlI2dW1mSHY5T0VISFBYeitaNjI4eDl6dVdJNkRHS2dQdEJhSmdoUTVoMDUrTFl5cS9QN0NzYm1iSVNTdXdJbXlHeVdzQmZUbXlya2xoSm1TU3Nhc2wzUmRRcVVsVlJLcXM2bFNGV01wdTdHMEZkUlN4dVp2VkRDRXVuUE55TzFnNU9yalJ4L1lTcGZRTVE5VEZ2ZVJjTHJlYXJiSmhQSnoraUNTcE1YcHRaa1FFUUlYQmlBMkJzQmkzRVRBTGczUGpTNkpLcnFES0M1YURzMGJwOUorN215dHVwZlBaV2U4Y1p1Y0xXRDVmazZHNTNjZkswbGptaWdVNHNSS3BqWWNVdW0wRndXdHNibGZzMzJ3ZTBLRW5RTVpVdWxHWVpNKzNtOHBNcDFqUVEwM3BoNWZjNWZiNkdjVlYwOWpVQ09obzkvNVgxbko1N2lXMDVMS2l0TFJveTRpOG1yUHcybG9zVnVvbDlVMHpKcWhiZGVGM01iSFlTNlVTQ1J6TWpWTUJpYlVDSDI1dDdxTDBNbkhuYjBJd0lhTTJIcForV3VTdUp5dmdyeVA5UHBlYWp5bDFxS1pmbnk4N2JOeFpkTzQxM1EyY2M4elpzUEU1SEw5VldpOENIcy9MK2daYktibFhkcHBwcTI2a2pVdWlITG9sY3VyVmw2VHpXckE5VHA1bW55dWZvM3oyVk9tSkhKOUkrWnE1M3RiaFlscFhVbGl1QWt0VEViS0lKZXJYM09Yb1oxQ3hIeEc2WldadDlMaUdBQ2FHWnFYMG9mVnBiNnNzZzNxcW9xellyYU9iNVdMdjhyaW9kUE1mSzJ4VTNHbG5wR29GWHNXazFjZTdTRytMcXNxa3F5cTFOM1ZwWGRHNHV4ZjA1eG1OL1JOZ0JZdGNsOG1sVmRTN2xSRXVxQzVLYnFpZzZseGdsVkFVcUl1VkdhTFFmVGs3TG9CSG1kZ08rdjAyN3NicXdhdGZGZWw4bThtUGZueDZWUnVrb0JNdVFod1ZFcUExRWtzb00yQWE2S0Vqbk5WYUZUNUF5VUZ5YkRkWFFib1hzNTJWb3JlNDJua3hxb1pYSkVvR2N2SytmMXdiNThHTVNjcHlhb2tqQ0F3bEZLSzFrT0hWSjdKSzZhZXpKbzJIakQ3QkpUR3g4S0FHSFNybU1LVHpjaGFWSzN0NHBxOXVYbTdQRTd2U2cxTmoxbll4YmZHNHRyYzk5T1dvRlFMVWFNQ0k2YkpmRjBxSERSdVRVT3M1TkdhUXVpL2w2Y3pkYVp6VTRSdElxckxROE11MjFyMUkwZWhERnVYdklTazg3Y2VGc042YWpPWHhmUWVhWFY1NmJjL3JlcGVsTHM4OW1Eb013bnlGNjh2cWVVNzAyUHJlYWlhTTRScEwyT1ZWcVRxcy9ONmFzMzRnZXh5UGFjdVhSU2RDWFM1ZFdwY3RWTHRxcFVlVTFuSjdKb2V4em44MDlVc2plUEI1WlFTMmpnUmVuWWQ1dGRkWHJMOGxjMTY0ZktkelBuMUMxK2ZPdHJiYVN4Z29FU1JrTVBLY21paGxnY3pmemRHM3QrWDlidXVnd0djb1JMblFuUUw2RWF6VW5TTERocmoxb3haTFdXVmt0a1hTYkJDbTJIbGM5TlRGczUrcTdvcFZ5cmxXVldwc3didG1hN0hXSFZVM1RGVldKS1l2bm9MaFJZeVZMa2hzR1NJcVN3cXJGdXhsTjJRRWlTUUNKWlZMWmMzejRyRnQrdm9tcjV3OW5CZmtqcUhNelBucXFxVTZLaXVUUGR0SkZaQUs0cGhNZ2tXZDFTM3JiazFSQnFaRGx4eC9abm56N2RlUTljWURyNmFNdFJpaTlGR1NxMHRVNHdmbnl5UVNaNS9nYVhacWpQU1dkMHFpb3BSRUZTYUxVY3NwVVRrb21Rd2d5MzhyZDFHMHNqdlFaaU5NYWk4MGxwV3ZBemcwT1ZZMDZFYnRWRldteGN2b1hmWjUyRlhvYWV5MmNycCtIbHFabExPZE41YlMxYmxhKy9POGpPZGxSTDE1T1RUYlFsMjU4N0R1VncxbE5RYkxjL25WRDZrNHdqMzhIVnpPelgwZlo4bDZuampvYWVmcjF4MUxDdWlSek96ZWRVWWkrZG1hTFpPSjFzZS9kekVkY2Qremp6cERwV1I3TG1lUHhQVmNYdTR1MXBVN2c1SlVreXpaazAxT3haVjJSbFE1SERXWHlQcy9LZDd6M0w3WEFZSTgxN095bngrdDJkZm1ybXYzbHhMRE50eVlhNkZvNTA2QU01NitrRnJtcDZxOUh4Y25vTS9ScndBN09McTdNZEVuYm8xZWg4NzZEajgvcE54YXVia0lqTzVXTHBJdGZTVGc4bDZ0VUhQMGJMNjV4Wk9wa1o1ejBtTFVQcVdxOHc3WHFUVFJwaDJJTDVHUXhlVFJ6dC9NNjVZYWJ0YUltNXBrRVZRNk1laXIzc1VmSjFuZFNVY3EwcnVyVTI5TmFScUZKYlowMUV4b2l0MjhwcTd4YTdsWlZWMUpkeVVGeW9GMUtaUWtKVWxFM0pWQVVHd0t4aVREV1Z4eXR1V3Z0UnZBNkhNbmVzMUl6M2lhQWNzS1JhWGlBRmEwaHV5SlRLdGxsUkxXU1NkRzY4KzNIalhLb3c2bXpFelQxZExrc1RpTmNhVHFvM215cmVZWjlKV3M4ZlA2L0t6bm4zQjRmSU8wbVk2RFN6SWFhemlqTzJwcFkwUmpXcEtGQkpLa2tEYW5PM1Z0YmwyN0J5NjZtdkx1aVdKT2dzaEhQM1lzeENYckZtQnE5dFJKY3JzNTU2cHQyZEhieW44TmRNME01dU16VDBxV3hsWDYrRjgzb3pDK2Fuc1RPczhjTzhjWU5DZkl0R0xwODNaMVFEdFJRS2JEbDZjdlgwbDdUeGZWeWZxWFluK054YXp5SHJKSWc1QlFibDJOQXdsc1hmZFM2NSsrM1FEejJMcWZxTTNtejNuczRNOWF4MnRIQXZQSDBWK2MxWlk5M1R5dGVPVytzekhtc0pNR256WHFQTWRwaHVhUFFZOVBUME9BVHVKdm5sbmJNQURLUXFoRWhjWllMcG9nQzlORHpEcEdsbERhcXpIbTZvYUhBNW5xOG5acDVYMENGOUZkamJ5dHZKaHRMT3plWDZEa2lhaCtYVmFUUDBZQ01WMExMejlXTHphWHF4THRla3RKbEZveDFpOUtWaGpUUUdvRFdXZWxpeGNOSHRMMDVZMmMxYXBudVJ3QURiSFlHdXU0WUZ3ZGpMQXBDTUxtVGxFcHVTNVIxWTY1c0VYMmxYYTVkMkpNdFZUSzdzYmxsQm9SMVZvbFZHNnVvM0pWanFWRzVLakRKWktTSVNVNStUdTVQMjd4R0FZOW1STVNhV3RvS1dGV2NXaElFS2pYRW90Z2lsR0lFUUV0b1FtUFQwY0haNGZPdzVkZUhYcjJiTVczZjFlanF4N0Y1MXc2ZVYzVDNDbkZGbVlaNWhCOHJxY3ZPdVBLRFB5VGNrbGk4MEZDMHZUcHl2UjJPWDNPL1NjcnJqMEhLVjFlTHdyVmhxdVdhR1ROTFlCTTFuaWFxNkE0QTZsMWMyYzdDQzBJaVg0SUlxTFlLV3ExcXdrcnNJQmo3amJsTTZOMjdrZFBtTjNYNW5SdnoyeGErakRTYVdCZENBalhLa1ZuMDV1U2xjM2ZqeDF3UllkdXJFcXphNjFaRnIwbHBEVGpYUTZ2QzI4SFAwclNYSnhsQmprb3RMR2h6Y1hWdDJ1VmtWMmJGaUVleldYWjFyR2pwSmhhbVBESE54TmMxWFdGSEtMZXVIZTdraGhuNkdjUGJ5YzJ6eW5vdlBiNUIzUzZlYkhUWmVlck1MelRyV2NCVVZJdXpPaEZ5UVhDaUJ1N0d1RkJRR0NOUXVxa2hHc0xYUHc5alAwbkgxaGs2bjFPeDV6MWpobWZRdmthM3JibU9JTDlLSWcwNXZKbTE1ZUY1OCtuUHFuOXZ3V2pyMDllT2Rua280RkprUWJOcHlZZlREM0h6M1Q3ZWRsL1AxZTM4M2wwODE2aldEQ0VzMUNFQjkzWHh1bndkZWdTbUZFU3prTWd1Wks2dFNURlNwS1FVcGRVTWhrVGx3YUxsU1hjRWd1cWdXTjBPNUlLVmNib2JGdTVJT0VOQ01sa0xsODF5dnNyNTZtNEo2SWsxeXFhcUZ5cnNWaElTUW1wU1M3RVIyTmxGZFd0WVZHR25zOGJkeGNHU2xhT3ozdE9peURScng2VnlhYldaenNhRFhpTVhTRTVkWEpqbjZvK2I5TnlIbkxkbE9CbDFGenh5eW1YdVRNbjJlcDViMFBUcjAzWWRQbzFlSGFjSEFUMWVmd1JpSGZuNUVxTENWdXgwcTAwMEphMUJXdHNpeG5WRmkyODRBa1pZaE9qTmRCQnZUc1dWVmU5TXptKzNaMCtQMStQYnFkSG5hVHp0Q2t1Zk0yMWpRMjZscFFsbTUyekpCNTdyRnF3WHJ4YU9lbjZJWGJCaXczNU9hSS9uY2ZHYzRXaEdqSEd3bkIwNTlQT1N2MGFNQVgwN05CUlhjQW1XeWZleDU1dDd0RllVYnJ2QkxDSnBkTWdzeXQxUytYbTdLNTA0K0hzYy9MUk96Sy9teDdiVnM4am1NcU9GS2hTRWNraklEQXVWYlZXdzdNN0NrbHhsYkFyMERBa21VbWtHaGlBdHF4S1RvSFF3Y2J2WU93NTN1ZkVldjZWZW5OcTRsVjZGZFNHREVsMEtlZG5qWm1nWG1aajFXUG5kTWUvVEIyc0tYcDZRL0orazV6MHVwQTlITlpwWm15TmQyQ2xtWGtyamNIM2ZqZDlNejhqN3A0aU1TL3MrZjM1YmR0MlIzbmRERFVjRExFb1JXQnFaSkVpc0xwRUVKZ3dwSU5TRlNpZ1NwQWtrQ3Jxd0lJUVZLb0xxbzZxNVRkd0lCeGNhODNsdk45ZDBUSzVDc0FaYVFYSU9GUkpCVWhNR2pKVkpCWGNNdXJxVHJia1dScFppMFJMV0FlbnRNMUsyS0QxSzBUeGFISko4Ym5wMVBET25ZbFBOenVrakE4ZjJYOFNGM09YdHpaOGk3U1ZlZTFxcmlXc1VjTW5JT2E2SGI4dnEwcjFkOExyZDlWemVxak5ZZVgwZVZ4d0phOEVUUzJVcERWS21rc29XanRJdDFWbzBDY2doamtZclhhU2l2clhVbGE1eVNXdlR2N1hFN3ZCMTdyak9UaUp3SDI4TEFpV096c1ZtNkFBNWJ0Y0ZPdWIwZU4wZGFJeXV2cm9qYkxIVVQrZGpwRnZPb3luWjV4VitQM3pOZU0vWGJZcTZzbGtORnZ6bmJacHo5QnczYXZZK2NyS1ZrVGM2d2NPQzJ0bFlpRGMzQTRXcGRpTEhsM1k4OU9hdnBjM0xiZDNQTDlQeitmdEdvL001bVFaSXkxbWc1VW9aVWpUbkxMclRocHU2VVZUTm5WTTBCc3FCYU5JODd6SzBEeG1XTUhNeVl0K0xwV0h2Y0xwNm01K0IzTStzcklYYkIwS2NuRnhYT1ZsUE5zbDRXWSsxTW9KclRJR2dlWDJQQTlGa2JBV0RqV3VMWTRzbFlQU2dSNXJaZzFMSDQxNXE5U21DTkprU2FwK2sxOFhyZVoxUFlrK2Vua3NzMGRpVXlVcTVWMk1hWXVVRndZTzZzUjNZd0NxcVlWVkIzSlFGVlFWeWhBcXFPcEtwa2tGbDJNRHlPSGZoK3M2QW9UR29wYVExQ0dKRFpMUnFrbFFoRUZ5Q1pMRTB1U1RWVkVWaTNmazNMdUp5Mm5mMGhVK2VaemxPT2R4QzQ1MzZjMmg4bDUyWjVTc3hKeHUrZDBjOFk4WFlSU2MrTlcvUGNhcmpGNUtabVhaVXJ0cWJsOVBkd3REZXpxYy9IdWl5NjhHRTNaWE1nRk5aRUdocGtGYlQxeFRacU9VWG4wSmRaNkthN0xNQ3JwaXpXOXNMTTcramZwOXJpOTd6T3phMWJQT3dXWm85TGhMSzlFRFJXbkp0b1pEcTVIcm01Mm9lcnVRV3hxck0vVGVJR2lpemlqRTgxY3Z6OXpoNXRGN3NXVk1xNVQ5bExsVmNkR05NcHQyNTl4bnA2R050Y3VtZ0VTOFFjNmVuUWpGU3ZaZUd4OVBYd3RBdlF2NHZScm5majBaMHFRUlJyanJYanpuc2RQelhjOGprMHdiNU1tMnVTYUJFbUV5VFlhQXUzRGRuZnVxSVdNcTZxaGhqZHBkeVpNRXVYem1jTk9YaFlZdG1acmxDZk85QmQ5L0M2SE90NTRtWkd0YVJRNVM4MW9zUzhmYXJxNzNkYUoxYVFuZFVtOUhtN2VOMDNKT1I5N0x6YjZCZ2hPT21RSkxOY1ZUNEdjayt3em9KVlhRMHpSNkh5M1g1OWUwM0szemVqUTNNN0lmYXl6a3JHSkhRd0xsUURxcUM0TWJLcWdTVkJsUTJ5NnFobFZRTGxDd29OQll5VVhLcHE2c0d2R0JFZlU5TkVERk1DNkJrbEpWVXNCR2dFWWpTa3JFeWpxb2FYS3FTWjJCcHpkRFF0MmZ0bTlHMDJmcXprdVI3VTZUQW1JYVpPMDVOSzU2eTdrWlo4MU83SmlKemFWTExJOUdIV09wbXc5bUZ6MlVLNG5NWGVjdWlvcWRRVW13UklyUmVka3AwU1NXbERCVWlGVlV3Q1ZTV1ZqWmRoUWlHTHFpVGE3cVFGYWFhWXQ4N3BCbWJUZkM5RCtqbzYzYzgvNkx5ZTdjNVRQTjVUVThyeTUrWHRyNnMrRmZYQlZ6ejZXdEhKSHFaRGJuMzBiblhBZTRwbkZUTmFNQnNET3FGZ3N5K002M0g5Z09YZlZObFRLdm9QNDJxWXJIQnV5ZWw5VnEyWTl4ejYyTFpwekJrM2NhZGNtSWxaOWRWVW1MTUcwNkxmamRzM2NzeDkyc2p6TlROZFphTFFUSGx5K3BqbU9Ib1hZZFBqY0x4QTgweXdGUFU3SS9xVU1xMUNabGRiZWFUMlVrRk5wS3VreWdYSllpWE14UzhPVXpxYW5CYy9rOXZtOTg4aXVndnZINmMrbkJFdlMyRGxaKzRkejUyL1JCUzRKOXVrOHpUbXFSSkZSN09lN21iaFJYT2FEeUdscGk1QXlMRVo1V2Nmb3JuMHFlbzJ4Y0dkRFl5TlZHdnA5Zm4rMTVuVHBkbnZsZXh1VnVLWVM3a1pCaVJWVVpMcUlrc0dGUXdvcXFCY2xNa3FEdWhqQ3FxYXVRV0ZLdlNiQzVxb0ZyUjRTb1gwUFNTaUZTVWtDcnRZaUdDSnlhb2k1SW5kMVpWeVJWS2dpV3l0cnhlWUd2ZWR1eWJabDY1Umk5Mlo1bTFxM25QZWhMSnhhbWxUQ00ra2xwaVk2cHlvZGk4Y01JNzFvNWVIcmM1NHJJSStab0NhQ1lxU05KTVQwQ2kwUFBJeEdrRjBqWWhRdVlGM2N5U2toRXd0Q2hpOUhRR0YySXZKMHBrVU1zemN0OXFIcWZyMWRUdmNYcytUMmRCMlovbjgwMEpNeUp0bDE0R3VLdGRCWXM2OHM1c3VYaEUxOFBSYkVOUmxJMTgyMXJlbWlaTjNudE5QT2dRKzlvUkRwcWFzeG9TQjA3bFZib25wTVc3bzgvb25Mc01HYWMyZmg5L2lUcnkwYU0rWFdMUmNSWmRmSnBXeFE5cDUrVHJvS2pyMDlMVHZ5akNIVldZOEM5K0tubndiOE14MHVoeE92NTNKb1l1K0RCc1UyUW41VzZtaHVZdXdoTHBQWEVWbzl3S2xKMXFHalJmSnl4UGFSeFc1VDBSeERqR3VzeFRMd0N3cGJha1UyTlFnZEVsNXhjUXNwNm4ydWNPdVNZNjJnR2E5Rmp5MXJFTW83RjBaQTJLdG90aTZabGtHcmI1bm84L3YxQmtEZUlTR1BSaEpaT3phRTUzYnY1eFpQMHJlUjBQTldwMlIyQnBOSjVETEdTWGE3QTZxQkpJT1ZJeVZJT3JxbXlxaEM2b2JEdGRDTzFScHBaMmJ4ZEJHTXlCRXZIRUU5N29rR0UzSlFYVWlJTW9pNmtjeXhzR1FiV3QxSWlMSUt4NlRPaHp1VXRnYWVqM2oyNTlVNUhORU1FNlVhQ1RKd3ZuV2RIS3EyWE1xVnBWS1MrUHp6VURSenpTclFvb09mMUYxWEFSMmMwNGN5YlUxZ29XWnJsbDRydGJxeFJHMXVKc1BVT2NVdGQ1YlJvUEVST21KaExWUkxRd1Y3TTNaMm9PQ0tsaVlWZGlNdWpMdnNXbEdxZXZyZGZsOWZ5T3JXU244Zk5vdE4xZzR4VnJucXBrNmNnZG4xMGpVQmJRV0xSazVOak1FWTJRTlJ6NmlVdWJWNVgwWG1mUjM1MVMvVWJOQ0R0a2xpcVRCRzI2S0c2Rmd0SmQwZVpxTU91N0ZxdmpUeitobmkrSmo3WEx6NzNjL2J6SzV2UVlLajZYYnVVWlczZHl1OWx0MUhJczRHcHZQcGxueHZ4RlhoMjVZQjYzSTZITmx2TlIrWHoyeFVsTzBZOWJDMElic2lpS3RObUxDbDFzL09jQkwwdHp6enZPOHBsRlVBbGR5TXFyWU1LNEFGbHBnUlVBVWNZdXlqS3VRQnNvZ1lVUkRzZEJkWElBVzRhU3dlTE1sYVIwTUk3UTBmUHlkZE83ODNtNzNGOURvVVkxdDBOWWwwVlp5UTdOYkZUT2p5U3pYb204amR3VjBYOC9SeXZWYWp6RHFya2hEWTVKQXNZSVhLR21RMExaZ01wM1EweXhsTlNwS0dyV3VwYUs0NUk3cDUrS2xWN3VzdW9LNE1RVlNoU1ZITWxScTdsSmxZMnFLcFJWYU0zZWptNkhGN25ENTlIYWMybm85dHV2SG9VNmxMb3pidHc3WG4wcXJwYStielhiUm5QSlRSeXBTM3J5c0dXV0tYV3E4NHlWc25NOFphcXdlTzlWWlBQRzNJa1gwUER6KzlXcDVMbGZRQjZwK2JGN2pnZCtYSHNGOWVXaTgxbzFYbnVSeEpaTXRXS3hYUVB0Vm9KY1FwVFJyV3l0QzdzOUNmUW1hOG03RHU2blM1M1E4dlhXYUQ1TWRMVjNYTTZ3Rnh0QkdycHhXblZKZFp6WWhCSmJob2xvSE5KYU1UVkxHTk1QbGZSZVk5amRVRSs1TWdYV2wzWU1hMVBSc3dzME9JeEo2T2NGYWNPZ09ydjVHcDhlN015R1dIbTlaY2RmQTUzWXNtdHV2Yzc4MUNyTDB0dlJ3YTFqdDFjL1Z0NXBwbUdzcnpYam5YUm1wVUY3T2ZweW5ydXg2Zkw1RHRXak5Cb3pEY3ZYRnZPM0NXYzBaTmhXVWlka0JadU5YQWxGY0EyY1FGbGFZdzZUb2l1Z0tPSVhUQlFFWUxRUzdhRzZzTGt0T2hLZ0dFTFZVVlVCVjAxUW5WTUZ0cGlrNkZhR2JuOVZIUlhsQTZ2Szlick42R2x0b0xobkJGTWpVYkdiY1RUSHE2dk05WGgzN0wrWnE0dHRoNW1ZdDFwa2pSR3d1cXBzcUVXN29hcWlvTGFrb1dGUTFRU3hWY21DcjBSNlZNaVdLR3F5OGRVbnRWTGxqR1NDcVhUbVNRVlM3RlVxZ0t4dFZkU0E3MGZJMThuRnE1ek01MWFOV1BidjdibWpKUlVhQTBhTXIzbjEranlkYjh2cFpzcXVQSjBxK1BTemx6TlhWcE1pckpaQWlEZ1VncGRRRFpETHNiSUZpMlMwMDJvcEl1cWJ4OEwwcStpdm51UDZWNTMxc3ZNR0MvUTV0UlpUZ2ZTWUxTV2FrdEFaNlk1dVVIcTVTVzNSR0p6MHMyNDl1SGIwdDJEWDUybXMwTjVvZS9LeU1XUFZTeDFDaHRRNWtSdmkxMlJVMHdWSHo3UTRMUUNhNDBsU2l1TjVyMFBuUGIyRml6Nm9LU0dsM1I2RTZHRGRTMU96N0hnR1ByWkJjNVduT3R0RHNScU90cTVlbDRHdUtSaVIwdVpQYXgzUEpzeXpicDJkcVV4ODIyMUhweFZrZnoxTmMvUmpWakZYTXVibGJFZFhaeitqNS9QZEhveXpDNWVXY0tNaEF5MlprT2loMkpHbXNueWhORk15aWhTNUlZd09xQ1hUV3lVYTdWMUt6ZGhjUTFCRFpVc1ZNdTdaVldJV0owQTBjYUFTcGdpWlVsVTY2TTF1dW5sWHBTTE9yUW5SNGZNK3I4cjZuUlRGWDFidU5SUUhBRUd3QkV5bHJ2bnRxSVIzZC9sT2p5OVhwZEhFMWVmMmRRc0xjTDExbmt0OUJhWkNFcDNLRmhRQW9hQ0YwYVZaVTZtb0VPdUdtc29uVGxRcXM5VGN6cXk4b1EzNm1rdW9Fb2lCZE1va0l5eVJFZ0pDcFZ5VmhZRTllbk9Ia291ZkFxcTMwTjZQTjJhZTVzSmJKVXFhRXc2RFcrZnlnd204WE9ESkRPV1ZDT2d0VGRWSmQzUW9PQVNMSUxaY0d4RlV1a1ZTOUZMcTJWTHBBQ2RaVW9XQmxvb1dpYWM3eUh2VmQ1OHl2MW5sZmI1UnFyMnlsblNvYXFtcWwwNXBxalRjWUhuM04yWXRXSFowZFhQMWNlbTV1Ti9NOVJxdkhQUXpPNmNXTnpXWnYwODlqblhNZFZMSUpSVUN3em8xa3AxTGxPK0o1ejBubS9ac1RBK3FUcVJiRVEzcUZxemFLejJkSG45eXVacWQ1VnplVndlazVVZFhNcWduczA2T1dSbjJzZVVDZHFWVXRHNTl1Tm90QzRMcHpDMVo3QTV0VXRtUkNoTVNOVG5ZdEJjOUZtOUJPZXJyRGZrODVLbFlaMHkycDBWbGtxT2psM2NrdU1WWUVTNEJXT3l4SWJSMWVTOWVLV2M1ZHA5TjNGVHFkOE9FbWp2STVWSTNqejJVYkpsaVcyWWFtZWxPZmJXeENSWTdLVTJzYXVEUVdxMU9VTnNKeVRhSThsYVZNSTFBbnFMQWwxMFBPOUVPaStGTldYdjNJZ2cyRElrYWlCeFZDTjg1MVVFelRrc2UyWXBGZHZmNVlzT2oyRFBLYXVYcTlET0szTG82d2MwU3VuWEZUb2R0UEVEWFBzTDV1dWxvRmVkUnIxOExvWG5xekZtbFBibmJCcGZsZm12TlNyOUt6S0NvSzVTUTNVRmRXdHlJV0Z6SlJWTWJaNXpaaWVlWkZSd0RaQ25vYURiOXJVYU5jYlRzRHE4bm1CNEh6YzkzWWtNcXFFVlZJZDBKSXVWRVM1U0xrcEZtQjZvU0FtV1EzY25kWDBSUlNOVVEyd1FaV2JSREhtMFhSQmxvSXNCMnJtOVVkNytjNS9mK005N253UVoyY2hWZEozSlFRaGpUbUpibjJOZm1abDJiZE9IUno3YjlQTzA4dGJtNUg4NDVpaXp6ZWFybkp3aVNsMWhIbFlqYzFZMnBVYXlvdVZVcDh2eS9yZkordFEzZGRpS3h0V3l3TFJzMVluM0hZNmZBNlY4bmNySUx3WHpOV0dlam1JMVpJN0t1VE4xQUVoZ0RLeTZqY1hkdlBCbDYvSGFUZWVsbzhGMUxNUW96WU5DWXNWQWVUUGVlUjlmeDg4cUo4ckdNQjlzaUcrZEhjdVFtZzV0TUNwWlVRVU1abFhxZEtjc3FXaklkaXkxc3NlSXRkd1o2MlZDeTNvZ3MwMDAxbnJRSUpIVFRNMDFMYUFtbExUYnFUU1RZTmNqQVhUUlFFS05EUjBOWU9Da3VtU21rWERWWmxhaDAwNWZIOVB4TzNYbDFWOTlHVlNTS05OWkNWTXJLclpKWVE0TUx0aXBSYWRFOVdVdWlXWGJnTHB0am81UTlSSnJ6cjZVWnpLNjFFY2crbVJITFQwenJIamwwTWxjd21vNXllN016T3RUY2pjVGhXTmVpM1VFU2N0Y0pjdWhhT0xqbUJDck8zbnJ5bkplc1lsUk1MTUMyWExXWmxJTHdlZGwraERWNTNaWmd6aXdoMUZCUWFTT3FzS2hETHVWR1FodEVsV0Yyc21vVlNrMWNMU2JJYjFreUUrbUNvVDFRUmxJRzdWSlZOVmhXZUdIRnVBdEFzS0tpMTQ5NGFWOC81MzBieFB2OHZQbDEyOHBEZElrbE5HN08yZDNFczh1MXVqSXlOOXVuQm81OWQrakUvbXJVN0szQmFEVmVjT0pSeERhQWpOd0JTQ3BpUmtCQVVRUVhRZVE5aDV6dmZMc0M5UEE3QXAxc3FGdHJjN05XL2R5OURqczFpUzhkZlBQSXJZbVV0cUdCa29Gc3JBSnNSV1llcjhuM0xrK1h0eE5aVmt1TE1iR1ZZMVZRYTZ0NGpVcDQ5MzBIRjdua1pWTHo4MGxzRnVZWk9Ua1M2dVJxcVRveW9EYXozcWpRV1lSTm5DbGhjcEZuY1RsR0tjbFdGQWRNRzRMSlYyS3F1bVFTcGtLVWk1VUdWVkF1VUFIVlUxSlZORlFpM2RDTm80TkRJWUxzQlZOZGI0SGU0dlUrVkx2MG5ZMElvdVhlUnRCdWF1RWNXbzlPdGQyVm0yNDdzN05MYytoVGRFaEtNelJtRGRZOHRiQWF5anJUTFVPaUJsbXF4SVZxRzFndytrVFhQNXN1cHk2NUROQnpseTVVN1ZMR0N1eHNMcVU0Z3hwQTdMZGhKT3ArQ0NPdk1SSEZKbnRoQ0NNa3NPdmo3M1AyMnlqNE9peXE0enV4dHlWVkU1S2tzcWthbFFnbFZBSVpFN2tKeklOMEVWWHRGd1c2cGlSMGJRUzdMYVpkQXdycUlDTXpaVmRNVGpZRG96ODJnUzZqU3BLS0RuOVJldGZOODN0L0YvUjhJVmRkR0VrZ29ZUWVrMHN5N2pNTGpvME55dHozMmFzTHNMNkdqbnU1bnRaa2RpM2tvODRhYVNuTm9qYVVzYUhja0FRbFhkWk5kYVY0cXQyRDJ1TTdXYm9wVVZreEozVEhwcXpUU29JbFFCeVNwZEJCbkU5T1NQUGRncW5COUhuUHFkZVFVbFVOMUpLc1NZTUdzVHFyZVF5bW1mZDdYRTd2alp2NWVsR2RkRnkzY2t5OHJtTHJaZXp2TWFzNEt4cUUyUzVjcTdUaGlTY2tpTHFRZDFLQzVWTXVocGwxQlpDQ05GUTBLNVVaY0dBVXFobEFqUmdWQlVLaENEcW9WUld4WW0xdlBOOTZ2bjFvbWRZMWJjbDZWbDJoYjh4bDlGNXIxaXhnYndURnVVbXdXNWIzdFBYbjZnNnBveTN6c2E2YlRvakZBQzZFcHA4YlV5eWFDbkEwQ05FVlpEMExpMWkwWWFveUZXVVBYSk9Mb0ExNXBYcE9QWEY1K0JPN2hLRFFpZ1J3VmlhR09TL0lmb1JxNWczcmZnV1Z6SlZUSWtvN3NLcG1sYTZkd000UFNJcUxHYmtpbTVkSWtsaEt1aFhVc0trc2RTVUV1ckZDbFdwS0lERWw2UzJXSFJMYkV0cEs0blNXc0dxVWx5Z1NDMDBuSmpTTEtjOTV4Y25uMnFTcHVWVUtWNWIxZVhzZnpxYk1YMFhsU1NPSlYwMGI4elo2SDJCWmRwbW81MmU3SS9MWFkvQzdEVG9OeGFPYzFNek14TkZxS0pNMXlVZGpTUkRWTndhbDFMZ2hqOHQ3VHp2b1k4eVZmZnlNZ0ZPMElZTmhLS3FaQmpvb0Vhc1pUZ1JsUm5KS0lrcW5MbUt1bktJUmpVR1ZZd1hsWVNxd3VVYmk5UWFzVTcwUGtOL0xPdm8rVTdFMzIrWG43WE5MOUdlY2Vid0c1VXVFS0thSlRaSkR1cEJuY3BPNnFnbHdXWFZRTGpKWW9TTkNxT3hLamhCTTBEU1NUTitoZ1p0WnMrV0hXd1pDV3JkbUVqUkxNYzZHUkNZd015cElGRkdhaWlabGJzMU5ibVBabWRyV3hET2Q1dm84MzJsVW85OHljR3ZMcW05ajhmWHZVVHNyRmhOa1c1UWtQWnp3UjFnNVZ0ZFNjbzJkR3VjVGU2WWdEb0Z6YVoxYTV1aXAxVXBvZ3ZSVW1jMld6S0dsTVdLSEd6NXJKWG8vTzNLZ1hKQmtheVRjNURzbm8wNU5QT2F0R1ovS05JYnpUQmxTVVlXeHZYeGRIazlFN2hjMjFsSk1YSmFtVVZCWTNhS3VpQVpMQ1N4cFZkMmdDcURsd1dqRWdZMFRIYVN0Yk5KTUtMUk5HVnZKWGRhSWdpeGxMdEdkNm01MHRjbUZndHlNTktqRXhwS2xLb3BnWGZFODE3bnlmczh5TXhxOUhpV0RSQmRuQkd6TzJlbGhCY2RUQ1dVYTZIWkhaNjZ0T0Z1RmIzWW00UFc3S2VKb0pCd2lzQ0ZkVUl5bFVFcXBSYVRsUHlhUFJlZTlmZ3MxWHJtZFZGWjJFR2NDeWpvWUVxcWVkMUJKdXBUaVNVNGJhNFdWVlFFTmdSWXdYbmNHUE1uSjF6TGxsbXliSElmU1YyZU52azlJNUQvQ2lRN2lSS1hKWjFFNm83UmRRa1ZkM05YTGJiemtkUTNpV3p0V1JPdExZNmN1bWxrMEhLV0RhQVFNeWRQUGF6V0w4UUhZdWhzUVhadHg5UTdPZUhVdzhqMVRCME4wbE9wYU1LZHl1UjVSY25GRTdEZXh0emhiZFhueWw3OHZPVHZxOWFadlhFUzFmcDhsc0hYT3A5QlcvRDJDMGt6SFo0Y3BWRzI5dWx4elQzTEhudHRVNWJKVXJZYktrVmJLY1lxMVJhWmgzcUZtajRxVFJFaFdnclVzUEdha2xhYW1zcHNHYitZU1QwZm5McTRPU1duTHFBNXVadWRhdEdIVGdiWDQyODV0TEZlYTJWa3RHbThuUld2WmNKK1Y2aE5CbWVkU1JLRU55cmtzVlVSMGdsMUxrdW1wZDBLcGRCZFdJeUc2SGRYVFRLQXRGV2pQV2lOK2M5a3lwZTBYSk5FdGkyVFVXTDJDSXF6ZG5RNVVJMVdHdEFReGRWZEZqVmhWQnh1MGpvcndZN3NYditjTnlWRlM0S3BJSmhwTmJ0dFpaOUxEVVU3YVc1RzU2YTM0bjQxc2JrZGdhU1FXWStKS1VkcmcyUlpJSVJqSlZTblhLNmMwbnlWZGZqK3A1cEV1WG15MVFwa0N4bEFnaXFxRVF5bk1sVTg3SUNIZDFGZDFCRll5bm5KVXFLc1RJYnBUZU4xVWpaUFMyQit6UDJzSjVmb00rTG1YYW1YWnc1MlFsbWpndGxsVjJtTElLR0VIUjFhMkVIZXNOdDA4VksxQUhlbktaZXFWSUdZMnFsa3g3cytZVjVkZ1puREF6VGR6OGxvREpNRy9SelgyYjVoTG9acm1iSTNweDg2dE9xcmc1WGZxYzNtSnBQYXpZVG9ZTUp1cmdsWFZRWVV6TmE0dDAzME9kblNSME1QVUxZYWNleC9NMGxTSHRjL3RYbVNIWjZsQXRCZEIyV3B6bHZhTHp6R1MxV3U4ZXVzb2wwQlViRUp0cXg1em8xb3Bod1RFRXhSazAybUc1UkVMNVZMblo0bFdWREc1QXVwUUZjY25ibGhMZk1ocDZHTjI0dkM3c080bHh2UTF1NWV4bDBYQjFOcVJaM2N1Q1NRVjFMRmRNR3BJWkdydTZwV0Jzb1VKU1Nxa3pxcFVUc29Gb3JHN0xHRXdTcGRHcWtWc3RNVk5Kc3JwaHJrWkFraW9tWHo2QVFGRjFWV21BV0pwQklIUWdjdStENXoyL2p2WTVNOWxPM2xDRlJJaVZOUVpUbHJjcHJiUVNqejYyRW9wMjB1eHV5MDF0ek94dlFhV1lweEtLQTdBazRReEJWVkJkU2dFaGwwUE4zRHRQbmxkekQzY1hQc2xiZWV5THNEbFVVZEJZcnFxY1hValYyTnBrUVdyc1pSTWxTcGxTaUkxYmt5c3F6MnE1WUU0TkdVNk8xeWVueHJvS2NlZVBNVHN5dDdOWEEyNFYxTkdPK2ZQVkZzaHk2YUdqU3Vla05NQzNCRTF3UEdwWlRGR0VzQkJxNERDR3JremFGbG1FQkwwVXZQbnpIcVVqbk5ZOGZEVjluSm1aYldsaU5HRHM5Mk1HcVNseU55U2hsQnRVVlNpb0pSc3VMMGVKMDUzcno3OXRkSFZ6Nk9mMG9tMlExdHAxNmFkM0dPMzBVNTJOdGZtWUpqRk5jYUxRYnhZaGk0SmRSRHd1M0pFbTBIbEpaWTZWd3B0Wm5VYVN2TmVMUlFNNmExMCtZK1NYVjlYamxLZzVKUXJzWGc4TkMzV2RuYTdQQlhtdXoxajUyaFFjYnVmcFptM2VEQU5sNWQ3Ym84dHlxWE1TNWFWMkZpSWhKd0pNclNRa1pMQW5vMWtHQmVkWEdMMGdiTk9kVlpyaXJHN1RxcEtiQWdVbmdOV20yQWFEQmtCb0RkcWd0azBzVzJubnVEbHBURldFR0ROMkpDNm9DcXJFU0dxVDV2MDNJN00vT1FoOWZ5NnE2WUV0bEFoMythNTUxRUxSdHoycjFGbmJuMXRZa282ZFRzV2pIWFkzSS9DdEZxTE1hUzVJeUFTWlZxMGE1WUdhbDc1S29pMnp4anBPbGl6ZEZiZkl6ZHhGUndrZW1sWStVSHNMclBsM3FSV0lWSTRsakJGWTJWY3FKM0tnU1hZRGJYemFUSUl1NUluWlVTRzZzK3ZCYU5XZlp4eS9VazR6ekswSW5PcFZVRnR3c1ZkVU1tbkpFV2VJM2F1U1JYYUhqczZEclRueWwwQzUwcGRFK1JZZEN1ZEE2YWVWbHAraXJ6U3c5S256NFF1eGw1Nnh2SEtOUFdXTzB0MDUxRDE1aHEyTVpWT1hJaVZLYnF4akxxb01yQ0ZYWUVNcUhrYVNDeFozWXU3UE82M1A2clNBOE5xbFo3NlR2UDFOTjgybVdScHRObWVwbU5wT2cwNlhuYkY4bU9mc0JtenJQY1l1eW94czNtaU1WRmlHaU5yQjRWYXFzYjNzZ08yVnFqV2s4Mm1zdms5MU9qeGJxUUpKQXZYbjcyTFYzZFcveDZ6dFlYQ2xFY1ppOC93Q3R6ZWcvTjl6ZzFwMCtydlBwOHJySnF5eWRrSlNvUXdteXEwaXNKVUV4YjZrS3B0b1F0d2tza3NvRGdrMjY0cGRYVFM1Y3gwa0V0QWFzYzd1VlE2YU0ya0RNUUN6QWRVY0FBWU9kaENGVVExVExxeEtKZHhzSmRWWUNhNnFZdFN0ang2OW1QM1BOcXJHNHJSbmpOZU9RQm9vNUNGUkFtTk5hR1pHeDA2WDVXWmQydHVWMkcyaCtZOGg1SzZ5U09pVmRQS1NZV2toZXVoWVM2RVZZYTBMTFFEb0dQRDBjNXFrTnJXdU9YWUVualYybGsrY3o5NEx4ODhudE5XZm5wNktTZWR2dEtwY3c5bE41MlNsZERLcUxvYWVKRXNoR3hUWUhhY3g0blRmbTFjVTd0R1RSeVJpRGZ5dDBkaktnckcwbVd1NWQyRnNiWTFGWEJ0dTRBMDJubUNoeWxCWXlsVlNPZ0Zvd2wwaEJnTjJVdEZTUWNrZ1M2dE9xZ1UyU3JTcUJLY2xVM0JDVUZZV0YyQ21hRjgvUHNtb3V1akc5S09qUFRwMEEzbTlQVVdhVHVnWHAxN0tlall4aUtCcllZTlVhWW5Xc2pZODNoaDBNR2NjdVBzMnA1TGRtRlpkaFhKNnl6aUZEaTlKNTkyczNsMjQzc3VsQSt4NDFWVVpJZFNKeUxlZnpHYWEyOGRFWXR6VFdlcjV6TjZDMmVGUlM3NTFSU1dyYUR1cENMdzYxenZKKzU1RmF1MHFiNC9zbVFIbEYzSXBLeHVaSWdhNFdjTnpUVlA2TTB1emttMnJyU0d5cTZJSmR1QlF4R042YzJxcVdPaXZnNktvaG9HNnFMcGdqUTBJTnFtQklvb3E2TGxCTkdOc29YS3FXUXltNVZSMWNsQlFHTHNBTUxvRXVUclhuc1BVNS90WXFvNXJDYWJESk5Nb2dLT25BMFZPUm82Y0JSVTh6Zmt0YWIzYzV1UGQwV2M3MWVXMmpVKzc1OHl0TkZxMkRvVXB0YldFblFzbGF6cGFXeFRBVW5abkhqY3dYYWgwV0N4YkNjU2VqbVpndzlkTlJ5UzBvVUpGK2JMUlN5RFNLQzZ2T0FRMW5WU1BJQ3FxaGpNekpOcG8wNFgwZE9MVnd4czBZdEhNdFM0Nko4M3E2ZkY3WHBpcmpObHF0RFNWRU50UkttUUtUS3FGaEJWVTZHcXNsVktWREJwRklJRlZSdXpBMFZVQW80SkNsVUxMcXhZVUd3b1RXeXJFYmRpQ0xIRGtSdG5vUU0xbVNScTVWamIwOFc3SDAzTlFlUG9PVVp2ZE5TNzFOckJKVlRYdXdpTlNHOURtbXNleWVQYmZITXg1MHFSbGZHcDdVbm56eTA1emwwQUtIbDArbnp0K3NseTRtUFJoeHAwVkJLa0w2S3BXY1FMeDk2YXZteksyclFqdmNVY1k5bS93L1c4ekQwVjVkUEhnT2dHZEVHYXI3Zzg5WjZISkJhTlJwYjVIdEhMckZzbFdvdTZ0VEdxYVF4ZGpVV3hldmFWVkk1ZFE2ZWpNRENkRXBZeXBGMWNpbGFCVERWQTJjK3VPR3JuMXVWY3NhS1V4WUZOM1VwTTEzVEpCc29ndWdsRUk3V3hiS0tXNmdFSVVKcnF4QWh1eFJveWFQa1lPaG05blBLUkRyQUN5MmtpNEZDNFZHWTBWT0JvcWNDSmpXWVM2ZVZTZGdXejE4bUhiZENVYlNqR1hZMXBabjBFQ21oWlNCUSt4aXk2SldyVFpXTW4yTkx3dTVtYll0bWJIMHhxdVRlNUk4V1BwcWVmTnJTVGpoWi9RY3hIT29ocFVOMVdkVmRHZFZkVkZTK2dwWDZQMG03d2Vqems5T1BHL01yOVRucGNSanN1bU9qbjZxdU9BeCtEMEZxdk9jSjhYRTIycUpzdE5nMmxpTm9BTkJVdTZDb0kxSUZVT0FSQTRFWTQxSEpWVkIzWUVGWEdDV3RtYXh4Y3hPcTZ1Zm16U2R5RVhhRUdCb3FrakxraUt1ckNHREZlbmRsMmMvdFdaTG5zYmRXN1cyZ3JYVFp4WkNON1M4YkVDOWExSWE1NkxjYjF5YUVQY1pOU1MzR1RkWktoc1NpYnFoYXVwQ3BJb3BpMjZyakhPa1RqS2RRUTVuTG0vUFdSM3pMWHNTTElPMUtyS3ZablcxZGZpRGl2YnM4eDMrTHpHMGxMemVnQ29HTUxvVFdxWjQzc3Rrbk9GZFdwc3FrekNrRTVaRHJsYjFVMUxoQzBSYk83RWxEcHREVGN6UzJ3TU5IalZieG1zWDhHNDV6Q0xha3Fsd0xtZWxTUmcyWWpBaXBoS0lXNVZNR0ZYUTVVdGxTVU9xa3FxV2E2c0tHOUttTFpoMFNFOUZuczh2TzVYYTQ5MGt3SjFhR2pVS2wxQU5GUkF5NmNEUlZXYTZPbmkvNkR6OStlelljeTNrSitkS0Z0dExlUnJKYTNLZ0ZSdzFzZ055WU5Kd2s3cWhjWlNZRVYwQ3RxcWFJYXExV3B5cWhDenB5dFQxZ2hMRm1lSGxlandpNUFzQ2dhdVBJYUluQi9UczNaK2QyaDBYbG9idUNxeEptZkIwMTFweGk3RjZ4ekU5cVMrTWZYb09aZlJzZkd6ZWhxMTVQbis4WDBUNElmVzhQdG5tamErcUNvYWFLZ2pUS0VSR0lEU2FTb0R6elNYb3RJamZXQkdrOURObmJwbWtkaHZQRzNVY1RsWnFabXNkYnJsNEp1aFhLejl3Tkw0TmRmRDBWbWwxb1cxT21kZWdZbHovQUVEUnVHOU1EUVVvNWJyZWlDcFc3T1ZhMkp3bzNMTlpNZG1jbzZJM2hPZnBrclZXV29FRFdOcklwMHlYcFlxeE8wTnJORjYxdk9GVWNTd0ZNY212bHp2cnpiK1pPbk5jbDJ2Q05rNFdZZEZoanc5UEl0Y0ZFRTlFNmZKbVUrc0hpZFhpOHl5b0l6M2hWZWpMblk5bmsrbzZ3TGgwTWdPSmx5S1lRMkc3RVpkT0FQUXpOaHJ5bnBJYUVPdFRSbmQwNUxhcUJhU1hsVFZ0aWFMR3ViUUdDYnBKd2NhR29SWXlDTXBJRlNSc2FrYnVWUVNTbTdrb1kzWXQxVUYxRkVuU3FsRGRGa2RrNklZL096MStiSmczOHMwRlQwdHltcXFhWGRTcWwxS3FpcHlORkhBZDdrKzlJZUxoejBGeVdaV2JJRTVsVElGMm1KRW9rRmtRMldibEVzbnhkdk14cTJ5aTR5NkVicTAwbXRxRWJxeUVLY3BVL09NV0FMeVNWR1FpU0tPWHkvU2Nwcm4wVzZsenZRZHIwSGxWZWpMbzhKbktrWnNDb0ZnUWpxNUJ3cUpLU1dsVXVOVlpVd2FZSUFMS0dzV2k2ejhMMGxkRCtjNS9vL21mWHk4N0NUM1luU3hxV0Npcldpc28wdElaeXBIVnZKVy9RN0NNekczbkNpY1V5azJIQ29pWm5TbU51SG1MUUkwVnBvZVVOWTFmSzVQcTgzVHI1bmV2ZjFkWU1xWisyeUNacmVyTzRkbUlqMUswNGhoUjZMdkk4ZFNScE9wZ2d1MVRpQWxubzBaOWRjK0xUbHRYdGR6OTlZRzhBT2Q1V3U4eW9MR1N5aWN2UFNzc2VuRk81SkVwMXhhTXU3ZnpLajdxTXRzQk1jZTVLcmpZOTJUUHNDU290dTNtdG5tOUJXVjNCNW1odUt0WjJidU4xTWU3U3hSK2QyTUlEaUx1b3B1NmlSTVdWUktza3FkbVpyTVlWYlFwalVoWnBHQndpMWdtZ3dTWWpocktldGxxWXVhdXBhZFhCSEFzblZDUUR1REdWS3QxSktITEFtV0JVRkFRVlNrbGo2RzZzNTZ6ZVJ1SHFvNEdmc25vOCs3cFpvMEtjenZTcEdycVpxcmhNa2dETDBPUFI5a3JtV3lWRlc4SFpLcnFLSXB0SnFLb1ZXY3FyU1NrcTlEVUxjN2p3c0pmYXdKYmVjcnBxb2kzU29OYUM1UXVTa2cxMDFZa0oxaUpJVmFsTmd3eFdEWFJQTzl2SCtEUXVwM0ZubXJVaHVRYmltV0J6RlZkaFJRa3F1RTVHNVlWTGxLWFV0VlpTd0t1Wk1LYkxhS2N1S0FXQ3I1L2lmb3F2UVBrNnZiK0wraDVWeTV2bFVKcUVzTTVtZFhNM25OS2g2T0NOak5HV3ZLcnFZRmdsbW9waE52WkRSYlNnUUx4RFBXM05UWFRxS1NMMXZiSnpPcHkrMzFJWU0zOU9FVnUzcElYcGJrRzYyNFdnS052V0thdFRqajVZOU8wY2VkQUZybXArbVROSm1HNStZeGJOS3VoUEZpMzFwejVjd05WdFFrblM2Vld1MU9KZlNxVGxaT3NzNk9SZWdYMGMzcFlOZlI1cnFNYWdicTBKdzd1ZXRjU05HYlBxV293bTVVRlRxN1BudXh6K2JxQjRjdk1qWWxqMDZwcVo1L3JNWXU4OHp1cm1ibEVsQ3F5U3NJNUtTVWlnazFSMERUV0tWcW5neElpRVpuY0dqeXMxMEZCQ1F4WmlKTXFYUTVZaTNZa0k1QnR1RGR0alJDM1IxQWcydHVMSlYycEJUcnhCSnAwc09jNVBkcFFtdlFlaDJjbXdsVVZWMHBxaUZUVXVPYWx4QStvODE5QWVVYWxzTW1vWm0zMkpSbVZWSlVDSmRXQ1JlejFXTlZBRnJza1JWR2tiTVVORHFsb0pBVHhRcDB4aVNvS0JDUkloR1ZFQ1NMTkNhMWFrQm1FMVBFZlMrUTlwNTg3bUpmNFV1SVlZVXRpODdXVUtyc3FLTTdraVZrSkpTU1VwTHBvcFUxVjFJeWloTWtrM2xkRVdWQUpHQ0FlR1dpcUtvc09MMngzZnlwSDB6d0gwbkpqWlJkT05YWnpGNkZhTXN5YlhXNTN6dXM3Wk80Y3JyT211RDB0TGpKSnAwS2tCc1JuSzdNVXNvYk0wQ2x1VW1LeVZwcG01L1E1L2I3Vk9WZTNlMkFkYTIraFZVSmFhYVNwelROMlBzbkx2MVRUdjQyUlcwWkVaM05MNHJPbGd3NnNHYm81cDdGVnZOeXZxOHpabnk5TlNhejVLV012YzNZNVJ2Wno5S3kwWGtMT0hnTWdETHJSZTNtZGVGdmN0c1d0eTY4dHFyeWFNaXZJcDJhZW1sbU1zYXVwUWJjWlBrOVVPWm5CNXpMemxSdDI4UHNjWHE2Q1dmTGJMcVJCd1RVa1Ewb3NoSVFtTVJaRFZJb1M3VUlxQWdzR1VReks2TVJZVUlFRGRXVlFYYnF4c1dXczRPcW9Lb3FrYnNhb3BsRFFGQmpLWFlYcEVrclJoYk1HK1RzV3psYldpQk8rbUxjTFNoSzIxaVZLYWxpNXFycFJKSUtTUU9uNnZsN2xrZW5Kb205QmhlY3ZnTW5JUmxTNWlhbXRwQ0Y2THp2QzdZcFZVemVxa09wTlVteE1vZGFYSkxXUU5NdFZqZFNXT1NKWklkQUloSUdwRkphdFd2SnBRTG1lbzhycXl5OTYxVi9OWjZEU3pQSWx5RGwwU1YzVnBYSkJYWW1LU1FVa2pER3gxa3FJdFVKQmRsU1hBVVdXcWlYMU5TaEpDaGV2S2swME1kRll1Z0cxL09jZjByeEh2OFhLMFRwZEdXRGRvbUNMU2tjamF0YTRnbld0UjJUeHRyVXpzQkZDT25Fc0FCek9UaXM2eVJBS1FIb3VjN29ZZXY2RXhGdW5XSmlTMUt4YTZrWkttdCtMVVJPN3hPNVhMMXpTM2J4dFRGbFdDNnJMT21WYUhZK2lyTDJzcFhJYmFjK3ZTeFcxWVZTVnluRG10YU5CS25wdFpqQW5wRnp5SjZjeHNuRTFCbWV2SWRqWjFjMnlsbUlyVEF2SWVaYWhVVE80MHhja0d4bWFFbDNoMTlYRzZQTjUyaTh5NW5UMU9BMk9qMVRjZW55dlJZeGQ1Wm5LdFN5d3VZSzZzZ3FsaUVtS3NwZ0FobFZTY3E3bGpDcHVqQ21FQlFkVkltTjFkTWFJQnlWVGRnWVZSTE1IVjFCYnVWUXlBS3FvRVhwVkRjdERqMXIyelJnUFAyYVdFbTRTNExMb2xoVU1TUnE2VTFWd21TUmswWisrcDdLeldzdGpGdnpzbUxaT2NaVnFRR3htZ3p1WGVxMWlOYk5CY3Bzem5UcGNYVkJSYm1KSWFhMEVDVU9abllUcnp5Q082SnlCVWNoQ0ZJTEMybWdQTkVpeGFNNVdETHN6MW43L0FLUGhQZC9QNHRLVHpzZ3VyYktVVXFpcXhTQ1lYVXR6TGtDakdKWEpUR0VOZDBGVkdGVVVwREJPWEtPYnBNYXZDcWtIRndibWRBdHdSYXMrc05MOEhrOTU1RDNlRkRZV25MV2hiYzVjMUdySnJhaHpPcmVYVnJvTVZyUURVdjFhUVVyQkF0U01wTEpXZmRXV1YyK3Q1WG8wK210Z0UrazllTmxWTkNkaWE2YlRrTldjMnRQVDR1NTgvVTZYQjA2Y2ZvVHdiOXZNSGs5VHplWFF6VHk5MGRtbHZQMVZqaXpkREpsMXBhczFvQWlpTkdqQUhBZ3U5bVlSYWFDd1QzbmllWkVHWXg4b3JWMGNlbTh3ajBsbUVIaWdGVlFKR2tsU0FhSVNhV3hkNFRwY3ZkUEE4VlZsREFnMCs1Mi9GK3E4NzBkNUtaNStobFZ4bkxva2lJTFVGWWtrUnBtc1Fsbm5WRExLbFZZU1NreUM2WVVvUWtsT2lHNkNwQmRTZ0tuUVhWWFFzVzZ1aHFuS3FxdXdJRzZBaHRTcmpGNDlITzNNaVREMEZMRzI3cVV5VVZFeWlXVGRFSXF1b1RKSTBYci9BQ1B1NW5JUU9Sck5Mc1FtcmFaTUVhVUpKUnZaV2QyYXRoRTVXdWU2bFUvSTJWbXRMbzI0S0FWNTlPVnRpM1VncnBpUjJFRVZOcHd1WFNka3BLWldMUXdFYWpJVjJrckxtMlkydGYwcjU3OUI4YmxPcnJ5SWtrSGNsQ3NodEVzU0ZaQVZLV01TS3BZVkpKQ0lKb25WVTdzNFZYb1hVcG8xSFRZaTVXRE5iS29BTExrc0tJWllneW90V0xlR3RlSkQxSG12Wjg2bW9kZU9xWk5FRGthODlHKzhPL05rU2p0c2lNYkdEa1hNdXkwblNiVGFOcUZ5RDAzYXU2UHAyMEp2ZTdqSHJUODcybm5jV0NSdlRWbzJadEt6ZUxsR1QvUWVWMTZZZC9oYU1NNTF0NStzMjFDL0ZlRzNuYU0wYUF4WVR1SXV6eG9wYkdPOHN0THZUVldSYVhyRTRVVUs5T053dWNLMDc4Wk16eGFXeFZxam9ZbkpKQ3FyRkt4SVJVQnJyRmV2SSt2UE9ndVlaRnhOdlE1Y25UM0QrRDJ2RjlQVVdkdk5teXdLWlpRbE1YZFdsTHFCZFZCRU5pM2NxaGxBc0xxZ2RNb2dTTUtGMGF6cHVEQXBrTkJWbXMxdXJFeHBpTXFyZ3lxcXBVY3lyZ1VKU3B5Y1BvOGowRlpMTG9iVmtJN3FRS3E2RlZYVGlWZENra0ZWMWJYUTliNS91Ukl3SHhUM1p0T2NzdWlXTnFhcGlySmIxV3AyT3RyV3c3dm5scUMydWhxb2FodEtoVzJBc1dVRFVIb0k1enphVXAyY2tuWG1hSzRFVGdpd0dKMFp4SlM5SmxlVGJnS3lxY3RuVTkxNFgzUGljekpWK1ZuZFhCRGNqY2wwbFowV2sxWW0wSlFaSkthZ0lRaEpVZ3NndWh3VTN0enVCTjBWV0lFaGt3cXhPYUlCWUdWQ05qejFjWUtFaWRSb0hNNmc3SGlnNzNEOW56eFlvZE1lZ1dBWk54NUNTNk5qbnpweTh1VFZhczFKMGtrVU96SmNHM2RyTjlEVEMxOU95d0kyY3hHZ3BHcFdsdlNFQllLZFdodTR4YWpUbmFrVk5Td3F4QjRtdnphYXgyVTdOcnhvd3VUajJtRE02dlFLd2x4RUo2TFd3M1lXRENZb3hhQWxrRGxDSlBNR0ZweGhZM04zVjBuZGhZRlYwblZTaUpVaE1VeFZZZzFSM3hIWUhFM0xpSUpBQityOGc3TG85MnptYnZFNzlOcFBITXpXVXl5MVJJN29rcnFoRVlXSTdoclpkV0RaV01HUzVReUdycG1xQ080RXFyR3BWWFVBWkFRMVEyQlV3cXhva3VDa3NpYXk2dks3NUlFYjlRdTZzdTROaktwU2QxVWN5eGhKQkkxY0dDdVZHdlM5Ym05SEpMMFl0bVdyWEJNNDBXdTd5ZUZMY2lxblBaZVhmbkt6d3MrbXBMdFZoSmV0czRGb1lRRUpNV3dheWVvYTlTZGFuSEcyQklmWUpKWXFyYWhncXBSRTBwMmN6UEJxUUdWYmt0ZGIybmpQWWVKaTBnUHpNcnVpY0RKU2R5V2k3RzNNc2l0UXduVEVDN3paTEpsaWFLY3RWSlNMSVlOOUtiMjUzY0RhU0c1RGxoV2JJREZNYllxV0poZVJWRldkTEF4ZWdlVzlVanFueEFkUG0rMTV6SXRoRjJxQzFJV0ROQUpHa1NyQzNReXJkU1Jna0JQZDVxWlAwekhJSTNqVk5MZVl0SklWdEUxNGFURTg5dEl6d0dHaU5pcUZaaXNXa3NkTTZ1Zk5SQkpxMXF4WlVLQTlhYW1LTW9RdFRkbElBck5iY2VBT0tjb2llTkt1dVNTaWx5REIzSmFLbFFVcVVLU1J5S3pYZlBWamRjaGtFa2RRU1M2bE4zQmpOWHIvQUJHbm02ZmNGemR2amQrZzBIbERZdTVsMXF1Wk1sMklvTUFoZ0F5aHNkWFZNdXBUZFdFZFhWU3FxeGd5c1lLaHNLcXhJSFFpUTI1UlJxcnNsRnljS3NzL0o2UFI5UExnUDlWcTUxNVUvWEhpdklEN1c1WGhVZTlWYjhBUHVPZDBYNWl1dHorcTAxWTZFa29rcXFtdlZkbmhkL0E1V3ZIcHozNlNXNXNaMld0dDUybzVheTZRTlZXZHVlcm1iUmkxMW9oMDJzWWFoTEJSaUJndzBaTmVlRDBJWHBscjNxMHZLWjlDek5kYXdUeEoxNGxxUnlodFdseEtWbXRRaFRNMUs4enN6anUrczhWN0x4c3RKMVBMeXU2dEtWZEJMa0VVbFZMQnNtblJWZCtabm1PRzFSS2x5NGZOUzVjaDFJTU5saldzNkJHK3FEb2FDV1F3VmNPZ0NnQkZzSG5xaEU1cWx0V3FYQ1hXbGVOOXBtN00vQ3NBZmE4L1NDQUowS0dxVXFSZ2lZVTVSQXlEQlpVRWJ2YTVEY3ZwaTJacU9oOFU0dGpzN1JOc0hFTmNuU1lyaFBGbVhyc01sTmlhd09GV3RsTkFKd3BSaXdjdWhKSkdySW1hM0MySzNyQllzVTI1WUxEWm1nT1N0Y2E1a3NUa3VyaUtraWNsMEYxSUVxNkZVdW5LMXNWcHgwVlI4NXlvbVVxQkpMR01PREVvS1duMGZsTHgyOTZmbCsvNVBvYXpTWE5UQ1JhVDdTU2hrWGFSd0xRVW9oQlJnNnFwVlZjbEJKVkRsWEhVbFJxVllqa2x0TGgweFozWk5CWEsxekttOVBURk8xMm5oeFV6U2VNNXllUkdZOUUwbkd2WUtNU2VncUs1MlhySjJyelhIOXRtNzlmRGo2VGgrbGVlb095OUQ2anh2c01MNDliK1JIUjZYUGVqbWpOdTVXN1Y2YlVjNGlKWFRVcHFyMFhtMEwxMWdXcDBJcUl1V0cxem1xVXJUb0Z3bFdGS242K2ZwV2JiSlptWU81OVJVWFU3NkFUUU9BVml0UnBBTWV6QzhhVlEzazM2RDgwK2hlZkhWTkxmQm15QzFOM1VTS1ZZcnFpRmQxZWttZHE3WVpkSmFhTk1UVlRRNTZDV3ZPcll0clFTcnljSUlobDBXOGdWeWxCR1pPemcwcFZWblMzSmRUQUxHYVhaeDJzR0M2OHB3L2JmUHZvT053TUxyNWh1emtXWTJpQ1F0aU5yb2dXdXlxcVc5ZWpIc3k5NWtGODl3c0VucnZTQktHTVJxSkpxOUN6bzFrUlltc0RBd0V1VUN0cjBnNElWa1dOc29kVlZzMVpOT1lpRU1LQWJvcUtZb1lTcFRsTVNTL01VYzgyaWhnQlhVbFVVQ3FLa3BKR1ZWMEtEYTZ5QVpvMDRjNWRYcGMrM25kZnBHOHUzQzA5UThOdWRPak05T2ZYUWhYTXJwMVY4bFhZQ3poQjZCZWs1dXR5czBhZWl2aWRQbm5VU3l3ek8xV2t5MTJrUnJnbktHQmRRVzdneDFja0NYVml1ckZGMWNBU0czTUc4OUoyUE83ZlBIME4rekxueTY5RE9QTlRpZEdZc3N1cUFJNzZwQ0ZOa0FOa3ZPclVQTzhhOXlNTHdJM295dm40OTQ5MStZNC90T2YzVncvZCtFOXAwMjNEdUhMbzUvb2VPeFE2ZERMS2hEV2RPbVptaUFLUmV0cWFHbGttWm5iR1ZiWU5VUWpKUnBLS3pZa1dqTkllak1YMFJISXA2S2tBNGJBWlVpRFZJdEFwQjVwQjUxbVpsSlNNWHJ5ejNIaGZWOHE5VTdNLzV2UmwxTTh6bFJLN3FOVVlXaGxoTklaWWwweXhkemFYb2sxUWk5SEpjQmk4S3VWV2RhYzdGYXpjS3Nxc2wzS2JGRnFqb1lJb0VsMnBrSGNYQW9xaFZyT01TTmc5UThCNzd4UHF4eldKTDF2T2RCWkR1ckNXSTJPaUVZRkVDRG9WVWxKbS9tN3MvVWMxWjVldVRWSFd6aVZxU1Z0eDZsSmtNV1pXUUMyVWdpRFU5UXMwcDYwVXR5RVJpM0FaSWFLMHNHa3N6SmlqY2tsQXVXV0syMEdjSHJxZ2hzSnpzRTNQSXU2V2NxNmtrbGpHRkJEUlU1SUdJY1VXdnY0enpPcnVQeTlVRzRzQlZ0a3BWYUlMUEh3ZWNkTWJ6RG9qck1PbXFyT3ZUVlhrVnJHOU9mbDZ5OXJ3ZExKZzBqMHBlVzZPV1hYTEc3bkd4Y1E0UXBESUZBZEx1bWRyZ25Xb3BsbHJreXlCanVONnNEYWdKMDlrNDR0dWgvTGloN1RXWUVkNlppUkYyVFZ5ZFUzVlV5eGxadTZHc21VQ0JKQVRWeW44ckhYTTVtdm92bWh2eVp2QjFPZjBPemE5R1hYcjBJSGN1RXJxY2RDWGJ5WnRkcEpFdTZTc2wxWjJoaHBCVzVsTlhUR3dUY1pCM1JWbUtsRlhMRlBLQ0NObUV1bk9oL04xUEU2WUJrcTFMQllOQnphalc4a2kxUWxJWXZUR3UxeGRNNWZSbjVOSHkzWnBzUzU4YnVvbGNrYXVVVFRBRTlKdVNORzdNN3R6TkRKc2hwaThLRUNkaTBoZGNsM1ZHbUVJQm1NZ0ZLaVJRTFlRU01LVU1oMkYwUVRCdUxzaWtxYW05aDg3NkhoOXE4a1lsNzNsc3RaU01HclFLeUNrSVdHaEF1cVVsUmw2Y3hyYm9tbG5QOUUxbzAraGxqb0dlbkhzbks1UktOR1k2YzI5RUNXb3lsa0dnTThoU3dJV3BFVWptemlhaG9nNWl3Y3BDbHRXN3VTaEthQXNHbVJvS2VCSEZoRXFYRHBNWmNDcElSSlRETlBaMWRiZ2F0UjM1cUVydUpHenRJSVZvcXJvTEc0RlVjWUF0QWE0ZFZTeGNOVm5IVXVyeksxcTAweW8ySzIwNXZPN3VYcVhFYm93ZG5CMDkva1l1ZjJ4ZUtianQ2OHZJbE4rcUx5WWk5WVBrMTFIclUrVXJUTDBlVGp6WERaMVVlMTQ2VnZQUjRlaTNXN1BNU010Y2h1NXJNS0YwekpZZGFrQWVXaml3emJhVVNHVlJhb1pkQVBLTGw1N1hybXZORGxZbklWbTBKMjB4YVUzMTZ2Y3VkWFZybHZ5V0hEM0VxK0h0MFphdnA1bXpYbndvdFY5QkdzVFRWYWwxT3VLSVZubmVCTFBLSlZxMEdsRGVNTk5YaUI3QmE0elB0VHpscUZ6cHlNekVGVE1yem9EQVFLaTNJVmRYakpLSjl0MmZGK3g4SHAyTXp2OEFNUkVCUkYyTUZkMUFzaEtwRWpYYVl4TGVtR0pOdlZDNkpHYkthTXNPcXF1RFVxbHNxb1VsaEtIZFNKc0doYUd4c3VIR09iaXBVMkRMbHFTNWJzUWZtdlFPUjFzSFRmZ1RUZjB2a1BKREpUTFVVdUJRV3JDRFNrcXFDcW9CWFJLdEdyRHJ4OVhRYVd4NjdpWHBMcGkycVdtYUp6MVhpYzRPd29Jd0NicGJGdzVUczdkdlJvYzNSMlFORXVscFd1RXRUYTAyb3BiYkFFeDNMcHd4Y3R4VjFibmkxS2pwc1pTVWxSeEJMdXhHSDBPaC9rb0dRK1NSc3BNMUpZcExpVWtnU1NCVUtncVhHVlJVTWJsRHFYVGE2YlZOSU9DcnpyMEwxMXlJM28xMDV1UHJaK3M0ZUQwSE43dk01OHV1bnk1ZFFKSkFrdUJKSU9iTW5zdWUreDBsYXZtZW9tVTNHYmFGNjVGS3VsZGlXNk1obm81d0xUaGRaMkw1cnU4TDl4cmNiVW52enQybG5PMGNmQ2cwNTc1TGVGdWljNjlxbFdST3RHbDQ4MnpOMWFkR2gxZEhTYmdHVTlhSDBCRzVRNmlSMnZtOHlyclpOdXpCajZtVTZqSkVvMDFMcUZhWkdsb2FBMVdtM1NwbkVlaENqYklrRldXcFFORW1xcDVQSkJyTVZDbW9ZdXhJRkpDd0pkVkZBYTNrejMvejMwSEhmc2RHSFY4NzFhWURNY3BZeElycUUzS3RoakxjeVNNYXpQZlZEV1p4YWFvd2h5bXB5bzFzcEFtRlM2dWltaE1MWU5YSm9vSk9Ub1k1RmdXNmtHb2NXUTNZSWF2VFZXYlFyb3I1MExVL1QrTmRqQ1NKVUM0Tk1NYWpKSlFRcU1MZEN5TGFrNDEwdFEzUDZOanM3VHAwbm5vTlVGcXl1WjJoclRlY1RuNW5FMkRVcFdGalZGdndiSGt4R25Nb3VFb29hWFE1Q1d3bG1rWmE4TEJNbHh4Y2h1S2h4NStlRzZ6NnFnVzhDZnU3ZkpXWHFSdmxrdWl4enU2dFRLdUJMa1NrdTBxdW9GWGRoQnVVckE3UXUzTDBRVTJocnB0RFdEWXFUR0tkS0Z3MW9oV2dOTk11YmN2V3VYazYyWHJYQncrZzVQb2Vaa2tuUjU4a2dYS3NKZFdxNkh2K0Q2ZndlbHIxdDhxbU1FNnl1NU5abGpiTGd5aGtFZW1ZQXF5cUpyTGJzTStmdXJwbnpIVlBXYnptNHBPU3g0Tkg2NDVSS0dzeUE0R1pzK2xDMHladG1UcHRmYjg3MGVuYnBZY3VIYm83V3ZoYkt2dU41T3pIbTZGNTN4elRuZE1yWG4xOURKWGRoYSsxdG1yZW5SWnEwa3pDRzROSHpnMm9LejVkaTZyS0VLdEV1R1BOZDBEZ3FvSGkyU0VyRXhNMUF3WEFyWXNCbDFVZ04zV0ZOQzFmdStoNHoxbmc5WFFiamY1MHVzQ3ppR3NrcmxRUjFWaWNtNjBralhRTldKQWRHR2trc2hobUYwblZTODZzYmpLa2lkRUl0bktvVU5jYnVwRTVRc29XTUNyQURWcHFwRDhYUXZDaFkvUytOWXlxVWtnU29iQXRpd3E3YktGNUZraHV5a0UyVk5SeW5SMzJjSmUrdzBSMjEyWm9xY2toTWxHb040VW9peXB0dFFDYjBablZKaEVwSEFneE1BWVZFTER6TUFMTURKMFFicklxa2NEWjVpZlBLTmp6djB0ZFR5K2dkTVB6bkNxODRsbEVwTHRTTjNBa3VrcGNvTGt0SVNrWmRYTG1GTHRDTndaVVkzSTB4TTBRVzltWW1KVkxvaFdpd1pUMHpyMEJwcGxSdVRxK2RpNjZPbWZKcjdYRjlieHh1VFRua2tITmVYMEdPbnFPbGwyZkxidWVEY3BPU2F4ZFhkS3J1OUV1R01PaEtCbVZweko1RTZjUGU4bVhSenUxNmRQSFBSZDNTcm4rZU42MlRwWklZUThaUjFjRmlhZWhyUTlXZDVzMnZKdldQSHR3OTFFM0ZyN3FQUmh0ZEc3ZHh0ZU8zZjI4WGJoejlSMmJSUEZmTTZaTmVlSFhuZmVvcUtOQkl3WlFNak0yWHBvZW1ITjFndXVWbDdBWFhPVjBWMmN4elEwV0tiRnVBdG9HYWxtRHpGTEFJQVdBMEt6QzhLS0dNV00wclVQUjhJOE5QWVA1MnZ3WHNQSzduellRRkVuUTJwS3hzVndiQXhvcW1QUU9rbkJZRld0ekxTVlNWVlhqZFNvT3hNUXFqcW5ZMFFCVlc2c0RFZFVBMVRrV3FtYUJYclZjZm80ZTJQSDFkKzk1UXhzRXNtUnFoaVFsMjFLYVkvQ0ZrY3phbUV4QTNvWmxTYTFLbGlRc1BXRUgxWHJCQU85QmNCdFczTHJVa3pFNG5RbTFPZEFFa1RDcWhVMWNhc0xBYjgxeHFMTVdYVk1KcCtkN3paVm9jTUdMY25tdERmSjlOeWZWY0tKOFB5ZHJLRmxsQ2x6TlhMRkt1MHBLZ1hWd0tLUklibGhMcTZWMUNwRUpWdE1JV1Vnc1dNV3lodEV1Uk5VYkl0YW5GTHlDY3oyUUxsMWE2Y3VxeXAzSjJmTjg3NjdtOTJIbFlZK3I0OVhMQXZiZVc5eDVmUnYxSzArQlJzQTNtUkRmU3JseTFMbE1zU2pGMHdZRXEwcnllWFB1Um8rQnlmWGNYMUR6cllmUWRRRWVpNG5ySlo4Q0t4YmdxcHM2QUZOUkxTbCtiUFJlWnlPaDVzVzNIMXZDMnNuYXV1aFczZWt1WG1ucjdHN2hhY2R2VmJ2TjlibDVPaXpPeU9TK1gxQmI0OU9UUFpKY3p1aUc2QUJ3alRURnUwcmVyV3MyWG9ZZGJUYlpva0pka3VKR0xxQUUwa0FOMDVXSm91S3UydUIwSHF6MlZvakZvcGJSdE85SDVuWnh6NkZ1Vi9pdlFTV1k1c2czTWxZeEk0TVNPaHRvN0JkcHdMZUZWWW91NkZNcW9rVlpxdFNTNHFxbE4zVnJwbFFXVllRRzZBVjZ0cW9Oa1VlZXdjV3ZsZGVmbTdxdmM4NDRCa2xVUTFSelJNeDlQd2lNSm1MV1JYQW5SYjVLdDE0MmtkQm93azJyYTZZdCtsZGpwcjBsSTZDcjB3SHB6WHNiRXNhY2lRbGdrREdqVmtneERnS2lFZ1l4REl1UmhFYVhEbXBjOHJrUTRKU2hkV2F4SjcrNk0rZDJzcVBITzd1NWlYVnpORktBcXVKRGNqY2tnWFVzVkVKQ3FTVUZVdG9ySkdzc1lwbG9HVmVpdFRGRDBpWTlPYVR5YWVmUlJYVXZPRGc1OWdCbEswaTRYU3haS2VWTzVlajhkeXZiK045dnpWU002dWJ2K3I0WG9QbnV2Wm9TM3pjMk1HYlFkZ1dxT0RORVV1cUpkVzFWRkFFV1V4T2ZZT0x4MXFySjRtc3RtVWRkWm1kcnB1TEpoYlN1MkRvWjgrclB5M25VMU9WSXphOG5RODJiVG02cXhaOWVmcldQUXBIVG4zOC9KNjk2S2FzSjYraDIvTjY4T2oxK3Z6SGM0K1RiYXBoZ2ZLNlNkS3drTlBvS3BNYkVxSWNVMExTMHRUcFNVYVU2MW5wczBXVk9wZExPdGk3bVoySnFGMWVTODdLYVhJNm03TU5zK2hzZG9PRlZJcXJzdGk3Y2IrcDUzb2VjK3l6SS93QWhQTkxNNFpZWEVuVWlrb0Zzc2FJZWRzejdHMkJlTTNMRkVzWTNkVlRaMVFvS1VMZGhLcXJxTFlhU0MzRlJlZ1F3TENVMGFYUDgxMVBQZXp5VkpPemtoaEdxdW56TnZIUmhBdmw1REcwekZEYm41dk05cDVPU3l6c0laSXhoc3o2Q1ZzSFZoWjI5WnF4YUR0MTVnZnAyYzhlam5ycVNMRTNabUVhdFl5bXl4RW5VU0tXYlVYVEJPeGFvcktzcmhKY0FDcWJ1Nm9nd0NxNGZjWFIvTGVsWjNjUlYwU201VnBVVlFWWElPNVZDS3BTTGtqSmNwRjNCcEdRUzVrdWh1V3hlOE1ibWJvcVlJNkpvUUtWMFVsckcyWlhuV2ErZmFWWnBwRmxLMGtWVVVMYVR4K2M5VGc3WThMcVZzOXZ6dlNkemg5djU3bzNQenY0OFRLcjBpR0Y2QmxWN1Rja3RTU0JWeUJLbEN1cFRMRTZHdUhVZzNaMGwyeXRoZEdJRFZTUldkNmVXOHltcXdwR2JUbjNlYkxyemROWmN1dk4xdktuVG42Yzg0T1h0TzdWeFdOOWM4ZWlPdC9XNERNdWozalBNZHp6Y05aSkhETWMrelAxMkVFRm8ybHlXNWFRcHNUS3BVTURSV3FJb21hMDI0b1U2UVNVbzF3SnQ3a0J0WnM1TncwTkxPMHExOC9mVFBEVjBJaWdpMFZMbWdwMUJyNkhEMmVjdXE3RzN5NTFFaG1VTkpWekxLcUpYVkUzUkNTVmpRMG1RV1NVSkN5VktkVkpFNmxoVEdWVkZMWXVuRkdtMVVnNkZEZFVOU1VEeWZLOUI1LzMvQURxcTYyeWxReEc0VzVac2N0dUNJckxNTFduVmdpYUo0TXlzOHJHT0NhVzJxYUZUQXBLVzllbEp0dDAwMDVZWjdLdEtJUnQra1VsVjJ5cUhTd296dWtza3FhcTdhZzFiUTJZT0x0U0toeVFJaVRWbVhPRkNPdkpkVkhQdmpsL0ordWQwVVJWeWtya3NKS2dYVWdGVlcxS1lETEt3YzFjR2F1N3BxN3FDa2gwcU5KVUdKRnROWFNHYWFvOVZXZG81dTZZaVdsdFhucGFUQ2Fna00xZFhFNmwwMnRHbE5ua1U5bmkrM3k5L3Q4RHVlV3VrN1BvNHNtRUJhUWRpV3l1eHUwVXU5Skc1QWtxSWxYQUM3alZ3YkNWS0NNVVFNb1IySlZyUkJzTTJvR0x3ck9qUWpDa1o5Q05xelp0V2JwTXVmVG02cXpwMEk2WVFweXRwV1lOdVFNYUhzZnlvVjJOL245TWJleTZQaHQvRnA2b3VUcjVVWUdIU2tyMGdhSUZtZHNxV3pXYmlzOVN6T3JKVDBaTTJlcGRucVhsVlFLeTZuVDVuYXc2SDZoMGNtMTB4YTB6NHRHTHJzQnU5WUt5b21NSXAxQXJrdGNaU2JkL0kwY005YzhiL0FEWTFYbGJpbjJzcGxsVVV6S0lRdXBCcWRLYU9xcVNXTlVXSmkyQUVGT3lHbUNzZ3NFQ0N5U05ZSzIwZ0dOSlBQNEg2QjViMHVmenRYWHMrZmJhYm5OdlczS0xZdlJrejFaOWZPbVBYbzV5anM4aHNJc2JpMnhOYWRhcVNHd3FGSTBEVnJyUVNNYXQ2YU1WdHJVUUwwMkFEVjNTNml0T3hsclhmVnF0RU5YQ010bEYxVU5CbXg0YzQrM3RXSEExdlR3NUR6ZWtoWmNPRUhya3FDMzlFdUY4bDY5eVNadTZnaWxXbFJWYlVwaTdWa0ZTV1ZWUVl5Z3VSRko4QTRjdVVpUXFwUXhLa3MxeWFheEU2SWRTb0ZnUnl3RUJ6MGJWZzBGRmMyTlNsUlZJT1NVRVV3R2N2eXZydkcrenorZzd2bS9RY2s5ZlJrMCtibXd4anpZU2oxa3JoOUt1NlBvbTRVNklXSkhtMHhvWXNKSkJVbFNTVkljcWhrWU5WWkJzRTdYYTVJb2w0VUNtS1RRcHF0Nno1dGVYb00yWFhtNm5uUm9UMFRuUzlHOHFjbCtrMEppcUFUcGcweHdrYlg5TEc4QmRTc05jbWtNODMwMmNKV2sraFg1NnJYb2s4WUEzWk1RNlM1UVN3eHV5S2hSeUN0T1p4cDlGNVB2NTYraDBZZGZGMXN6VmlyYWsySFF4dUZwaVpLTlBSWVNOVGk2R2QwRTBzN2NrV25GZk5QVVBCcDgyZExNeDRyWGVWdWN1dEpTbXhkcEZBc0xxcmJLaElWcnNRZ0V1bmREZGdyTUtGaWF0RFZLcUM1VDBydUREVDVqMEhsdlN5NHRFWHQrYXc2YmpCTUFzMVRRTkduWG4wOHExc0IzSVZwQitOSERyS3hsd1JLWmJyT09pbktSWUZNTHVOV0Z3cFFhVjI4dWJvTDFYT1ZxVDBRcGVoVnRTZE5XSkRTcXJvb2FiT2hoMW82ZXZsNk5wNkZEUVpjQnA4KzJLYU1yazR1dnlmVVlpVjduMEk2djVIMTRWV3BxeW9tUWp1UnFhZFlSSXQwd1pvSnpsY1ZDRFJnT3FMU1lJMUZYVUxHaGtpWTJWVUdBbFN1cXRnMk5wbEZ4akc1cGFOY2tYUTJDc3dNQXU2ZzROeHVCYTJaZkdleTh0NjNQbzlCNW4wTTVkM1RoMmVPbjJzek03cTlKWWF5NnBhYXo2b1lNblhFS1N5aE9zaEltSEZZMUx5ZENRWnVWQWtLcXFTd29VNEJCREViR0FGTlZUVm4wNTkybkxxejlEelp0R2ZwZWRUazlDem9mbjZNd2ZuMDZLaFBkTllOdlRQbDJ4TTBWRmxyeHR5SGlNd3BlZlNHdDVNK3RQUTB5NXZtc0hDeE5tQ3BDdGE3TXpDRzhORGNEYXgxYy9vWkhuajBabzQ5aG84NTFlTDArZ3BLbjBTb095SWd1c2lZb3daYTRtWVdNNnRabjFaMVZwYWkyQmNyTTZpVDFQNXM0NDYxNGRISE9wbU5tUzFsbFptbXdDbFhCcGhRTEFxR21XRkJTZXVsTXRZRHFyUFB0b2oxTXhjcUxReWxnMXp2TDlyZ2U1eklPaTdlSTNKYmttbW84NU5pblFhOU9iVnlMUzllamxxbnR1VzkxZHowSDVvKzliZkVEczhuQTFjL3dCQVhZdkxEM2ViNXJ3V3l1WkJDcGl3WlZDbHRWYXpwMUszU3M3cTFhYWFOSlViYnBCRXdjZUpRMlJpOVJnQ09RTEJMSm10Z3BvNVBZNXZhc1ZtUGJYMElxdjVMMXBjb216QnRTeGEyN1FRd3RZVWRCbmU0VUYyWTNKVVhhSERrN2duU2lHcXh1Nmw1VXM0TVZkU0p3VHRpNk94aERsS0xPbVZHUmkxbU1XUWtMQmcwN2tsTXVWUVFZRkNmTytrNEhkbHpmUSthN3ZWemVnMzh6b2VLYVdKUE9HMnFWRHlRemRPTkI5Q2RhaTZKZGFUM2doaTVjWEI1S3VockZrTUdDcWd3N0NUTWtHQkFsU3dFbHk0bzE2QzB1VHEwNXRHYm9NK2ZUbjZhem8wWitsWnM3MGRPWWFzdlJvbmN5YmZPMks3SG50WXlhME5pT3JjZWQyZEZWQ3JVdDZ0MmdXcTFReTZhdFRCZExCdE8wMW9CcEF2R3NFbmNlYWN2VVZXT1RaamhQWlhodU96bzZ1Wm9adHRjS1pLakNsQURZdVRaTlRKMExRbzRaRllKWFZXTTdHcFdka29OV3ZrTDVwOUN6aTZlT09xZUVzSjJ6TlVHbTg4RVFaeDBUeXpoUTdNdkR2TzgrUlcwZGZSNWxoUG9jL0NGcjAxOFM4MzNNdkl3NlNuTm96K3J5MGRFb3RpbXlqWXR1YzIxVGN6WnB4Nk9aYnQzSTdPWjZiQjF1WDNhOHowbmtOUERQclo1MXZmWGN3OHVjeDE5WGxkelhkUTB2UmZtaytteStPY05XN0p3Z0F3QkRtY25XYVhzUXpNdlJOVmtMWEhXS3RFb3pzWkU2c2hHUWdkT1N5ekFaRFZVc3FCT0hmajZWaFZwemVpL29kMWZ5ZnJTNmdTNVlxWU1xV21NN2NJZGpvbXRTcmFITHBpb1ViTTJWcFpGODJsMnhFbE1KVU1oa21odVZOU3dKQmdOaEt1bTdzTEFTR09xa0trSWtKUVN4cXJHb3lRWUZoS29yZzl6Z2RlWEk3SEc2UG9jbnBlbHgrbjRsYlRRZk5EaVFaTENVV2t1dFJiSXlXV28wa1M1ZUtyb0lhckVzYUdHVUM1ZHFJWUxnek1nUVlKVUIxQm9MSXV4c0JMRTZpODdVYmlVT1IwdEdkK2JvV1pEVTljTjcrTGR5M2JWSHk2dVhvVG5TU0lPaWhXUTcwYmxhTTZsc3ZNeUxldmJSQzlJV3M4WlZKZE5vWVdMRmExYUFhemc1VlpqZDBSQ29tMTV0VlZPT3pUZkhvMWM1cXZwTXdhRjBhb3FGYVlxRElnTkJpTVdtaUliTGZhbXd5SmRwZ3RxQXF3WU5tY3djMEFYU3QyTXB6Nk96Z1ZqSG9SNEFyUHZMNU83T05PYldXTWM0K3JEUEJxZXpLTXozTnlXU2JiaFppMEhMeWp1cWprcjYxVXZOYzcyR2ZybnhkK3R3ZFM0N0c1dFVic3JsT2pSaFpsTzdSekc1SGVIbERuVytZUVU5Rm1DcFhUYnpuWnZXZVc4MzEyYzNTYWRQcGViMjk1Mk9McERSOHJMdXkrVEtJd3FsUW5iYUtiVktSbEsxQzFkaXFJS1FVY3BKZENiWllHV0FsVU9wWU1YazFZOXpMbXNQUVBwTlZQbHZXbHdnRnF5dVRFcTB6YXhWZE9adEd0cGhralFNaFZMZmtlR2RDc21jOWpZZ2dhRnVHdEFRQVF5b3U2cXdvaHNjcUEyVW9HRVEyQWlRdW9CQlZRWktkZ05VanFDSzR1cUI4LzErRDNZWmRXUi9meCtoNm5ENjNqNjlGbWR2RkxUVGVjdEpKTk9KTTBsOXBLMDJJSUhSY3NPQ0NHRFE1aFZGeUdBeklLaG9DR0FWYTdYbzVWS3NNS1hhcGNYcWdRYU4yR2QyZm9hc21qTDFRbllYY0JhZGVYaTJqcXF3TkdmVzZvR2pHbVdhYjNvTlFORWhlbFdpSlprYjVrN0FUd3pVdXBRMk5UVnJKeXl5Yy9veWppajBjbGFaNmFLa1lST1FUcEdqS3ZRdW95VzVHbkUxK1E1MDJPdzZGcnFQSTBwcGhSVEJHME1QT1pXZ3NyWTNmUzZsNmM1QWdvTUNxVFZJazJxcGZRMlpCSjBZeHliZDd1SEZEbk40ODFYcW1VSWZDbVlEalFwbWdyRWpwT3pNZW5SdWMrYTdaalh1VER3SzJLNVZuVHBXekpsNkliTHp1TDEyZnJuemw3TVBWQjJxbXRRNTZScVp6V00zMXpMVTliVnhIWnozUzViK2UrczNtTjVuMFc0RzVQcGIrR1d0NjgralBtMFdVaVZVY3BCY3R1bEVxaUxPV2xtVUdCdzZwSUVEUlFTS0tYYVlMTVcxNGRlSGM1Y0dlbWZUTHEvbFBXbFhZcUlUYW94R3BPRUZyU1M1MllzTkR0cG1jTk9kcnEwWjBWdFdHWmltOG13RUpBRlZXZWhWVkRsaVFWSUk1QUtxS2dqQ0VhS0lSbFZWQ051VkJwVWRBNUtvTExVU2FTT0QyT0Y2UEtMRUgxOGZhNjNBN0htYjlaMkxSNTYwUmQ1UzBsa2hrV1RUWXEwakpjZ2RhWnNtaUZRT0ZkU05YUWpPZ2dGUWl3Z3BkREZnTnNnQWRBbGlHaXRWSzFJbUsyZElKTzZYbGRuNlk2blFTZkhxd0xET21PenZiakt0YXlTWFlISzNUWEtaVXdhSXVpS0xSVnV6Z0tORk9jalRlNVM1VDZqT1RhTFJsNmlpdVFycDUwK1dPcFJDMXZxaGFtMHhLM0RVWlkwTDQ0eGNCN001clRTV2R3UEpKREtWRXpORVdyNkZpMXRpbHE5Tlo2U29odHExRkhrT25UMWVQSFB0TS9ONTFrWjVaZ3dpaERiTGtFaWRTVTF4ZGFsbk4xUlVXamtrb3NseGhxdXdWV2tJTW1QcTUrVTU2ZGFlT3M4MTU3UWN6cDNvZU1IMmZrL1Z5eVVOZEVtbVNtTnFxM3FaaVpLMXU1eHhIYjJjTG9jY2RlOEd6a3ZYb3g2T2ZUWDErVDMrK3VSazYvSjRxV0JLeWlBZFVrZzVlaWwySVFvSlZxY0ExMmNzcTZzWXlXVlNtSWJWZzJZT3BjeXdMMHo2akRyNVgxQXVUTnd4alZtTTBtRUFKdXNCMW5UTTk2UzlKS0M0cThOV3FXMHFnczBVUzAwemdWbG9WaEhSRFZOM0tCdGdnTHB3ckZ0cXdKdGlTWFNOUkJSS2xOU1MycEZ3VnF0V2s0dUgxT1Q2ZkRWeXVqbjJkZmdkYmsyN2VubTdQTWVzczdNRSswbEtiYXJrYmFTU2JhYkIxQkJNZ1hRVlhXOVZHVGFrRHB0dklPMk01d2ROWXVhSFZWUnpRM0pERURzMnFGUjVTVFNLdFZhb25hUXBiTnA3TGVmcTRkbnJHbm81dU56TmJNN2NOV2hMdWhZdlgwSmFvcWxvZ1dyZXpPMmEyWmhwbFhCSkJ0SnFXVXMyRmRXNktqdG1RZFZTY3ZOMWM2Zk5tbkxVZ09yY2x3ZzE1YkZBd0x4V0xWVnpSaXJjT05KSzNzUVNwN00xaG9QUEJ2WmtjcjE1NHNvaHFsb1JBMVFmVFp2ODNNTlFsNTNQZG1lY2k0Q1NXUjBrWnpUMUpiYVBwUUhBb2hKcEpsNDZnMlhpMWFGM2phRGl6RUc5V1lxSDJ0bE5mUDZxOFh6RjlMSngxa0RXaUM4N3BSNC9tKzQ4cDdHWFBnRDNPMWxWVmRWYlJWVVEvWnozNTVkVi9KMmNtWGRieTlIRmZYNkhEMFlYMmVldXM3cVJpaGRhczdwTU1hbWhZRFpoUkRvU0ZrQWdwMlVCbDFXaXF6Wisxb3F2TDRQZU8yWHlobjAzbGRqN0pRUEE5TXFzSUxNTGtxNUVGQnJSUjZTYU9aU3BzVFlaYUhKYlEwUXVxR1ZOaFpSMHU3cHRkR0xxcFFPaXBaVXpwWU1ZRkczYXp6c2FLQ3NNYWptN3FDbERUbTdxbXJ6c3pYUE01K2pONm5uWFVtbWQ3Y0xJZmYzY2pmNXUrOW1abktuRXE0VHlSY3AxQmFHWEhkQUxLdnRxMk1kVklyV01HTWRZbHFvNE5icXNBVzVWTUZsbTBzVml1MlRhSVM4MjZUUG4rWDdSQmo0MVBXNDNSemk3Tys0MDZjVHVmYlNlY28wTmlicDYzNHRPT3J5V2NhSHB5VnBGV00xR0VzcUdHTW1tbURJY0VxYzNtY3VrTmpkcXpBMjJHRFdnemJoREpUVVMwNXRzYzh5YjFoakhTc3JrTDZYT3BCUlZXQ0xZbStVN0N4TnRaRnRKVVQwaW8wTUpZdHV0SkFhekJKbmZ5ZDd6YU5vczh2R21VZWNFOUJ5U0dBRVpYMXlaSE90V0pMWTNNQ3N4K2R5RVo2SXVaQS9PR3FZYUJ5SDJtUTlKbmx0NmRYUDA2bTBFbHE2emFxd3JLTEs1YXlVOVRRWTlqTmw4L3crNzhiN2F6Q1E5UlJnVElNb0RZaTB0R25DY1IxdDNCNkhMbjJIOHJwOEswdnphZWJSa3NjN29sd1VVeGRxeHVBTXFxVW9sdGxVSWNZeDhhVm9yU3FRNHkwVkdkZEJuNVBmUTNWM1hKNk5nVXpBaFRKeXBZWFVwcTRJREtrMGFOcGNWWEpFNUpZU1hhUXk2SFV1bTZ1UUpWeGlVNjd1dWJYU3o2VmlwdVRXMkxVV2pldXFTb291a2NYQk5vS0phdVVTT1RWejk0NXFycjBmTmtrWkpJTFoxZlA5VG0wNnpzYmVDOVI1enpIRW5XMVdvRmQ2MDFUZHRhZXM4Tk5taEdqbjU0SjFNS3k3VXZUa3dVZEhUcWJ6bjBiRUFLczhtbkp0TmhVZGFicGtPaXBrU3UyWEFua2RxT2ZuWSsrOGQxOFdWaUdpZVM3ejFaYVRiMDZjYk05dGJGRXFZWVZwSkRWMHJsR015QTB6YUZvaFVMVmlkSldNRzBVcTJPWWxqTkZyWTVpTlFoaFZ2U2pNdldEZUpleFdldUhuOWZHYWNpUHo2YzFMWlZZb3VwZklWall5c1lxWmE3RzJoTkZrRkE3WGo5VnpMVzFiUEVscGd6R1RZbzREa2NDR09teXJXTmQ2dXBOa29iVmlWRnZFV1pvOWl2VmhjUExRTXlTYW91WXVpVmlOcE40dlEvSzVVNnhibzVkWG9MWG9IS2tnOWNQTXRpNFE4VHZJM1h6OVBmNFAwQmNJTkVKd0dVUWtCc1VVcG1uSzNQTHM5UGc5THo1NmJjcmVLK2dvWmxkWFZFa3VXeXFzV2dsQll4ZDdhcEp0SE8yYVVQNTZoTmxoMUQ2RXlLZHNHdDRhdk9OM3kraU11c1dNbHc2cWdoc1NzWFp5U2JHRmFLc29JWWNRTjNFcXVRSlZ3Qm80MkV1Z3FRNkYxY0tHN0VMQzZxc3VIclRlK0xXM0IwTzZHVXBKSE55QUlxRWFrZWJyNWZUenJrblh4eWlvSlZ3S2F1STdXcmg5VGkxMW1udFpPMkFqdkdoR096Zm1QTFRVU0R4cmRxd2FNY05VRW93b1RFZVBtOXpMZlJ3V3ZEcjJHaVhGMFJqdmpsWHBXdFdua2ZEdG1kMFJvWXBzS0RkWk9aOUV0ZUR6Kzg4VjI4Z2tGSmtRVzZmb3hzbTlwSmFxWVFzb3FIR2dJYkdiYzJtYWFNVWgwVzI0bFNPYmxScWlHbFRHSlkxbzFaR1ZEUnF3QmRnTWhCb0t6YlZUcmh4N1V4dnpNdlJ5c3hEb1RmR3BiMGFjMHVyZVVsd0pKQjJZUk5zWHBrN1BkUS93cEpvbnpxM0N6Slc0SElsV1FVYzJkU2wxZm9DbVVwb0Z5SytOMHZNTW5yOUtISzFuTGNsTEduSTA2QjV3YlFOR0dSbnR5ZlBac1d6RnNjTE5HVEY2T2t5WHFSblFJMEt3YXhKY09MWUZyQjQzM25COUJlWkZvZXVWR1czbXVYVWt3TGsxQXArV2ZVMjhqVnh6MDllTFJ4UFhhbVkzWXlsTEtFUW9ZRnFwZXUyTFFQUFNpWmVMcG9GTGVXY3FISG52UmFHWldiR3dzaDd0WXRETDBaSk15RE1lVmtvU3o2TFpSeEZGZHVSc3JhcUZkeUlIVXRka1VNRHF4QkRwTUJPRkJUS3NnM0tCbzVEWFRCR3VHRHFwZEZEVmxUNTNNOUptN0o0a1lyY3VoSnlDeVRjb3d1VjJjSTNjdk9xS0FORkFHWEFyVm05U3EyNmJHZFlTM21pN01wdE1lTTBxakZKejhqOFRwdTUrdm53ZVM3V1JMTVF4WnVsazI2Y1diZmlXelk3SjI1aFFndG5DVkxNRHEwalpsMHlNdEVoN1ptZmlqNW5SdlNQbmRkL3ozWGpaTEp0Mm5HS2UzVHp0VGVoNjZuUjlSakFzR2lqdzZVbWJQb1hXWXh3WFF5VzBJT1c1RVNXbVJxWk5heVFiaHRabGoyclFUR3NYYlRoand3WSt2ampmbDV1bGtuYkhuMnJlUFBUdkhUbDUwTU5PUzVJRWtnUzZnWDZQei90ZUkxWEM4Wk5LM1pBdlZxbEtZYXdNQ29HYUZ6cldtTFB0TEdzNFZsMXBhNGVUMEszcDVodm84YzdjL284dlRtZEFtNWVqbG5SNTIvVkRuZm41QlZyUHpTMnJiTk9ZdG00d2hMWVptZFNwUzJGZ1pGNmMrREVUdW12bjlEUGE4Zmw3L0M5eEtaUWIwbXpseWQzVUs3SnNSZTNNM0NlbHA1K3pqTkI1anhlbTB5QndMalRTTGFXQzJycXcwcmR5akJxaGcxVEFqQW9OQTNmUXM3SXJuYnl6WFIwazZrZTEyTG9zUG03eGRueWRNT2ltSVZHcEVxb1QxMWUwM1VHQ3hrem9vSlNWY2lWeVNnUmJWaTdsRlZMZzVDR3BFSHFLR2pCWFZGUTZFb09wZE1WeU80R3g1eXRPUDBNZ3lQd2RPQVFyMzVnaHdTNFVHTXVncVgwR2JQU2lxZGxta1oyZVNWajBqbEZYMEhjMXVkYkJXeUUrR0RpYWMxNVBxTXc3T2JtT1ZSSW9haXRNMlZ6STJmaTZPVDBGemxiczczenRsTm5GUndiMWtrY1dFRHBuT0RVM0l5SlB4WHRzTytmaVpCNnNUYWc1ZXh1ZGs2NjVuZk9yM1pYQ1pkMDgyR2x0U2FkVk1JcXR0SXZXeXFNQ0ZMSVJreTNTaW1TNVdySDFhME9VNjhzYTdqd3VxTmQ1Mk5OUmRGSXg3VXh0ekZiYzZhQjFMZVhOeDkzajY4YTVWM2hLdUJLdUIydlNZdDNpR2dnYndrMEpibXREczc5Rldkd1FXNEtTYTdOcDZBNElkSXhRb2swQ2k5bDBzaEgzbFpYWkpFOFR1Y3ZMWFdLaXRkSHFaMWJaa3RDdk9FblRmTkkrblhWa0x1aEViQzZXdXJpTWk5S3VWNWhhSE13ZTBla3hpUythdWQ1ZjJYbS9SbmxMNkhQOUtoTUx1YktYTVhvemFJV2k4cmNwMzYrYy9tVzY4ck1UVkIyNTBuVlY1WGVuT3pOaGJDaDFDQUtNSURBSzZKWmxxZ1lCYkVGRDhuQ3NyTm9uaTk3ZkltaithOWF5c3NvbzZLWmtvNVZTUVVrRmhWTFJVa0hkMUVpcUUwTWxzRWlIZFFXaFlOblRBalJZREFwbEJkWmFDSlNhVmNwYVhWUkJWVk1yZzk5WFJQaTFiTS90K2NCRmVrQlRLUXFtVU1LS2gzN0hqZGRYY3oxTzdhQVRTMVJaYkxWUk9pWmlXZTdWZzZVUFE3SnJ5bUFkWXV0bU5tUzJ4RWpNa01WbFdMcDgzc1c2VHFUMXh6OG03TDA5T080cXJYUkc4NDFSQ2RRQk5GUUJLMWFjaFoxcGRqMUVlYTg5OUM4RjE4cW1MbWkwUHhPejEwdnhhSjIyR2h5dDVxdDVOZmwwWEQ0Sk1NcnNZTFpZWjZlbHlzV3FjbXdHSlkraXh6bXloanljM3Q0NHZsc2FtZE5CcU9zeWk2R3hKUTB4NXQyZWJBR1J4bnliMUUrZXQyZm84dzRGaUp5T3BEOVByVHErZG9XRVdVNkYxY0RHNVhDSXBUVXRaWnEzSnV6V213MlladEtvTFZZNkJXcDNTZ2p4NkRKdy9TcmI0UFdhbURXT052TklHWTh4SFU0YlpOSFlKMHhtNFZ5YXVoSmNnNTNKNTJOWE0yY3V0VENqVm40YVJ6ZW5rMG55K1BvODcyMk1rMWxwaVdjTGpBWWJVdG1XdXo3OFUzcE5kNTJpblZyd3BOYVZ5NFJyekpLc0lRc1JuYll0TXBiaGhwUVc2ZWx4Ym1hN1hnTWdDenFjWmc5UHIwVUx6dFlVS0psMFV6SlJDbFNJcVNtNUpZWFVnUzdvUlZDRllYZXFzcVBxa0xCbGtFcXBTcXBNMTNZMXEwcWk3WEx6YVFLc3RvTnhNYm85RUZYSmVQelBzdU4zNGNXTnYxZUZRdkVhQWVLRWxmU1Y5QWM3bG8rQ1pyUzNVcXlFU2pTd2ZCSno3STh0RDhPeUsxdXp2d2x3RE9aQzNPM25la2xNbk9sc3o0RTYvTzZmYm1JR3ZaWjhIVXhkRy9LUnNScnNraVZlY1prTWVpSWROUWFkSmIwc3lxMloyU3RQbXZSWjllZndsMU96bUkxMmFQYm1ibnR0ZGpmTzJ0bWMzTDNaM1htOWlORGxqRmtGZzBBV3R3Z3NydHlwZXUycTBycEdreHNMQzZSbnlkSlVuT045Qm56N2NzV2grU2pUWWtXMFoyU3dSbjFvVDVmTzdYRzI0Qmx6VG1yMG5uUGFjajZMS1o0VjJZek9TdG9TaVlGeW5XczdRbEZ3R3hPcGtFMTZOdVl4dEZtMUhvWXE2Q1JyRjFNelRRdk5aWThvTTQ2N3NBcmJxa3NlN2NRNmkyR1hWM1VsQ2l3bWZObm1jckJpVlNBeVdXd2pLN054Vk03MUtmTzhqMGZtdmFRVmRkU2NhR1JKalZwVzAvUTRtWHIxZmwyUms3Q2gwMkNFMkRwQ1V4Y2txeGFVOEhNTlpKVGVhb2d5UzNaTUpOMldGMHdnb3BNOEs4ZmVqS3ZPS09XcGxqYVZ5b2xkU055U0JKSUVrZ1dZeHpDbzdRallOc09wMXhZblZxVXdiQktDbU1JVXhFcEZTVUxhQjBJNXRxQ1NicHFtYXd1cEl1aEttK0Nycll2WTg3TU9vT25IS3ZXQ2VicFptenFXbkdiMTBPenZMSFJudWRXeW1LbEEySkp0a2FXKzdTUFpuYmpCMkRPYUtCdGNoVEVEak9uSFdmVTd1M0hxMnhFYkhwcXN4Wk5OY3lOYWROOHFITDFrR0tKMVJqRTJPUXlWcGdqbU1HS2g2aVZjejQvQjZMem5wK2FWMVl5WWtscHEwNG54dnNmazFqYWRPdk1uS055MDFFRFNrQ1IwSnlrNVFUUm1kU2V0a2FDU291NkNKMnpPYVJvMEtjNW83UG1zK0YyNmE0elhaVGRocE8yU21xbDUrTjNPZFdIT281MGNFOTU0cjJYblZ0YW92SVpGUlJEQ0Zrb1kxU1J0V2RJSXlvQXVIQkRzZFNTdEdnbGpFN2pNdW0yeGpxMFdlV0dhcW5yWUM5Q1pHUHphK2dLNWU3RmczUkxvRTdFYWdtWnFNQWhYV1RldFlKNlpra0JJTWNuRXVXem4rUjlqNVQxcHl5aTlDS0tvaG5SWDZIakwyRXp5YXo2Q21iWTlKU3lFeFFscHJrdGNqTG9vRUJvZ05SbHEySHU3Uk42cDFuT1hwejhEeXlqNWt4VFYwQ3lqeDl1cmxTanFXcHE1VEpKYUpKQXFTTnlTSXV4dHFqRXFWRUppR0VPaU1oTHFrU0EyU0V2UkhuMHJUbFVZeHFHaGRBMmJ6Q2RZYUlFd2pXNEV0R05pT1ZZbEt6NlU3Um5GOSsxNU9RTllNeExDOCt2UWEwUFRjN0k5YXg2VG5UUUF5R1kyZ1RHNVdPZEo0Mms2MjVtWlJxSmJNTTJrSmMwNCtiMWZFNkxZbms2UFRYMFRvY0x1ZWZBNVR4OWV1ZkplWFhvM2xoMFE1bWZucEtEVlRhbVp6S2RJeUpiVVJEMUtQTERjN0ZxbVVlTDk1NGZ1ODhiRXRzcmxXclpweVBuWG9PeTZTdE9qTnBlY2NtRGNhU1pwMGMxb2RFc1pPV2dRQXVVc2VqUnpuQnJYYWtHREZxNnRReldoWTA0dHFYa0U0WFBOSG52VDhyTFhqWFlyb0tEVkM4VzNOSzUxYUEzNEgrcjgxNmJ6bHFoajVhalJLWVpCS1V5VVNWTlNRdENXcVlSQ1VFQTZaYkYxUWRVVEMwSUxwR0tFQk9DUmt1cFFScFpxSTFaekUrSnJWdnZOYkhMRVpkeGE4aGlLWHp0b1dZMHlWRHFoSE1LRmJZQVFpeCthOVI1NzBWeGJrOVdMMTUvVDREZDZ0UGpVeW5qenUycGRBTExPS0Fpak05YWMxcFRGRTA0MVJ1V3BtcUpvYXUxUGt2c0RDbFpzTTdGY0R6MlljcEVzbEp0eVkrMWQxYVVJYkZkaEdTU1E1TG9VcTQzSmRCSlZoSmNFVlZUVERYVzhuS21vUklmYXVWZTB5cVdxT1VRS293enVyTmFGck9ZNktCaVowRXJHbVF5azdXeGJZcWVxMmpSazNlcDV5c203azlYUGdablBQcjJvUTZxMDZlYnJuWnI4MmlkWGl0MElSTWtzODBNSndPMFV5SFI1em9OVGNZYXdTNTgwK0Y5NzVuYWZOYUo2ejBaNnJXWXVhMTVtWU9pbFpkNDNZdjV1blBib0p0dVN4azFGR2VuUnQxcktHMGtPaEdrd2habnFFTm5sZlRjTG81T01RbDJjbHk2Vm01R3BVM2JpNkpXa3JlNXprd1J3WXNaRWxxYmlVVGt5Q2dZSTJFTmRqYVNvQmtpbGJXSXFhMHFWQmFyUTJvMTNtYXAxNU5WS2ZPWk8xeDh1a1JZdWhlZCtjZVVDSFRrMytsOHY2ZnpzdGRVM3paa2x6QkVKeUdOV2s1YTJDT2ppVXFya1pURTBFMVlzbXJPREdHRldNb2gzVUJkWUR5ejFvT1hRMEhhb2hzeG1HdFFKczFUS0VQVXNhUlZpT1RKbWU3Ymx3UmtGa2dHcElMR3dCUEU3dkc2MTU2bU45ZlBmMjh1cnlxMTdVTTRLalJHR2RzQ1ZERnlZUzhvYWtYZEEwMWRGMlJicGNzTmxwWWwyNHgyY3VndFFYaXd5Nk12S1V0Z2N3VEFOc3lHOFBadXhKS1FiQ3h1Z3U1QWtrQ1NVRjFLR1JybEs1Q2xWVjNRTWtCaEpuUkxMcWFwb2llMHdGTWlydFJBVkt0VUp4U2RWYXNOQktBclhManFwWXNzWlJWTE9xTXVoZGQzTjBQTGV0OEw2Zm4zRXN6NmRSck1xOXFtR2pqelhHenl6YTAzTVNXUTVnR29kYWhpR1ZqdTYyTXlhb1dncWJobG41M1RUazhYYVdIWktWVE50cXBCSjJXV0FGVzV5R3k5dWpsNk1LY3Q0NWlJd1c0WkFGeUhtbDNGQ0pMMHltYzdVbmZIekpWZmZ3WGRFcm5VNXZRbXAwTU8xcmRTWEZGUmkyQzI1azdmbTF5ck5HbXNvTHlkWnEwQ05RdEFkSGNBSTJEVFRWS3hFclZDMmhCeEl1VG92NWp6S3VmMEVaM3l6WThNbk45QmdlWG5hMjgvVmF2VytOOWp3NGFuS25sSW1wSlRia1hNdGtra1lCZ3lBWW1EdnpkU0ZPaHlGRHB6MkJZdnpFUmk1SkJTaGl4SE1ZTjBCR29OVVFtcVM3b0FzU0VIcHV0SFVHUVhWUUpLamQxQkc0YW9aREtDNkpUSngrdHgrbGNUb1llcjZHZTNxYzdwZVhiRFUzbmIyTGRneUdWTFpkcFFhcU95eHVOVXBwNkZ4SmJERm1HaWJyejZlNVJKTEdwVEU4d09kNGNvTXU4Mmg0MExUTEhMMnBjb0NrcEZ5UUpKR3BKRVZaQlJkWEpja2pWd2JDeUdOUTFuUURGTnNDNmxoZ1EyaXNDc3NKVGQyTmdLekhLcWxGTkxBd2lseXdkMUlkTmQwVEFxNDNueDdPZDFSNlg1NzdQeEhyK1NaS2JPdXpUejlFN2FsR20wOXlaTzJxME9tM2dBQzFVaFUxdE5XK0RPOTJqS00rbGw1eUpnZk9Xd2gzeW1QUm4ydFdCMmZiVmFXS3Q1bTNSU3pXYXUycGZtM1BYTVphTU9ZcTEyS1ZRelJ5amhEVUdaVXJRanJ5OHRKZmY1OTNMV2x0VXliMzZjbTRyU2RPVjNkeWt0R3BDRnNFMUdMb3EydUkyNlJLTmRNRk5vWVFoRXhtWnF6MHFza3NTOVNuc3FpcDZCY0NiZWFHeU5vNkZsSTFTM3Z6NnI1c3ZrUGUrZm1mTSszOEw2N0xQdHFsK05NSVNVd2xrcGRkTWdwZ2pJVDBhZEU4UmIycG0vTHM5SjBwOTdtQTlRNEhOeWRMbWVhazAyY1FtR2xCMEZvdWhGcHl4bGdqREN4b1c3aTZhWU5RTGdzYmxERTdsVTI0QXNaQllDTUJqQjR2VjRYWXMvVDV2UzZZM2RERnQ4Mm5QVG81YVlTNnplcFVxQmk3Y0NqWEc1VUJyUWhrMEdxMFk5UmdMMFFVekxwM0NFRmJLbHNyTVFUbDVDWUZTbTFVVDF5Nnk5dTVJZ3FxQ3V4Z1haSHBLN3NVR0lRQ3FwRHNTRnV6QzJybGlsQnVsUnJ1OUVhanV4b29taVlOQ25iRkUyUUhMVkRReFVzYW1oc2x5eFdWTzVVcGxYS2RWVjB4T1BkajNNdm5lenhQWThwcExPa3pUajB6czhrdGJNMHVWR3pOQ3RzVEJPV2FDbWREbDZjNzYybm1hY2wwalc3bHpHelNGQWpQMVhzeGhIU0FFYm9sQVRLT0FxV3d4VlUxY2h0cGQ1cll6TTJNMkt1SkZLcEJDcCtTRlRWazFrMmM3c3g4L2RUdTREc1RWMllOV3g5REM2ZCt0cDV1MVBVYVNhaVh4bVdOQkpyOHhxTlpaelFkaWRTRk1GZ3JjdDVwenQ1a1QxdG5QNkpGNXRraXVhRzNKV3loWXV0WllSYU4wNDJ5R0ZBQjZjVEhHekthNHk4bDFReW5QN0J1Vi9pSUNrSWxpU2w1cVptTUFxaE9jRjlBVFVUVmRIUnptOTVyYnk5T3BzcktOdStkcnk4U1RMSGlRTE1NR011aENOVlJjR01JS0NoNllEQ3FDMVpRVzdOSkpsQmpaVlVSY3FoM1ZXMVFpdTJyZzlmaDk4dDZ2TDZ6am9hYytuektjekl6SjY2UnF6Ykc1MzR1TXlzSGE5RWF5Q2NvT0F3RlVac1U1aTlUSTIzYUxPbmRrUXhWc1lvN2xtVVNYa0VTbkkweXBqN2hWVnBTNkpvZ2pybFZOdGk5S3d1WXdWeTdHNUZBUkNPUVRndXBiUTJOVVFoc3FoWVZBVlFnUkNUS05GME5GVGFGbFMxUWtKelF5UkN4dXFxRFkwNWQwT3FzR0JtMUkxT0J5dTN4UFg4d2pBdHNOUnFkbjJNMFoyRE1XQzNUbHZHVDF0SlhvV0NZMVlMWFYwTUhUeU5wWjJjMEhubWJTaHpDamE5UTR5SzFaelFHZUdpM3RtZlRMV0xhbHlMWkRCZ0hNc2FvbEw0cTRseVdYbk5HSjR3SUVMUjhYcmNYMGNPTkxuWHgyUUdNbXBZdE5EVVBXMm5WajB6dHFibU1IbWd4R3F4QWdVYUd0elNYckxHWU9QTkJhVnJGdzBGV282RGVlOVRxTkl0T3hhRnA1VmFFbWlxTWIxcUNTMU9CU0xKVm9hN013eHk4TDBQQ1hQNmwvTjNlVmhxVVE0eTRKU2w1SWRDTTFsQThndTNGRU1yU2VhK3BhcVROalRFM3FtcUZjTTdWZUlwY0hsQkdoY2xRalF3YUZsMUtvRWhGb3FxMnhLaGJJMU1SS3FKM0FKdGxDS0JzYnNGRE0yaXpjWG84MzBwM2RQbTlubm5vTVNmblZvb1daTXpwdVpIcFBLaUFMWWJWZ2hpUjBVVm5mbnRXeGI1WTZVbnFFV1ozUWpVd0tlZXprckVWamtWU2pncURWRzBxbVB1UXhzVWtJVk1VVlROQkk2SXVWSWVsUzJieGFsNjg2eVF6eXBVa2gyTnhFbHBwa01LTG9TcGxFSk1rSVdvUURUYXVoYkV4cWFxTUZoSktnRVNGMVl5TndicGtFbDA1bjBack9WeE8veC9WNGtYSzZlSjJyTWNkVDIyeWRHcHF5OUsyUUpzek1KSmNZeGFIQXRYOUhIZVZiaXpqTXdzcnJNTVdxdFdhc0QwMlJab3ZPd1dEc3lhRWdKVnAxRHFHSkF4SmxRODVPMDJrOWlXYytkMkZ6RnFZRm91RjJ2UCtqellhS3VqbW93cGpqV3dwejBQV3pYb2F0dERFa0o5cGliWXVKM0xxcG9aVTFjRmMwKzgwbTlCNHlEV3RBSmEzOHNzbjFuOFo1bjBLeEZhMHhKMUFEcFUwZ0hBOVJDNk5JYWlIWlJhZ3VYdHhyTm5iOHgzK1hpM2xuYnd3WnFaTTIxQnlhd0NzMjJCYVRoQ2cwUlk2cGtUWWFKbmxPQ0s4MXBpV0ZXTkF3YUVha2l6MVFVVlZKdEJHaUdBdzROaGNxRHVVTEdWSW1Rd0FaVkF3Z2dzWG5QRDBMSm1lcjBKMzkzajl6ejAxeVc4TnRNRjVHOGtua3cwTFlpcVdZT3pzdENZRDZRTlU1dEQ0Z0RaRXMwaUxPaENPaGU1bmVGd0FobWZJa3NKQVkxdWhVazVQYmtsb2xYS1ZNc05KdDVONjhtQmtqblF6TlZwK1ptcG1DN0RrMnNDVmxSVmRZME5qS3FTcUhKSTNCdTI2dXhFUWpHMnB1Z0lZVkEzVklnU1V4b3FicXBHNVVvSUYxVG1aK2ZSWU0rbC9vODNuQTZPRHM4KzJxZE8ra3hHZGpZdlFyRndNQWtOV3hqMUtUdWpJcllvN2hzbVpvUUlsaWtzUzlSdEpONjM0ZE1NeHFKRVZTU3FpMk9vRGtJQ0Vrclc2U3BkUkxuNTNjMmR3SW9zQ1h1cDV6dDhIdjVhcTVwZ0ZIQUJnUU51bm1ieTliQ05iakN0YUJkV0YwYnNXbTlqc3A1Z2RaWXVTUFpVUGtEMWhkY2crb0NybGhzdzZXUXFxcTBNeFhOZEErZWNIUTA4cHhIVlp6ejB4MTVtTGMwQjBVRlhUcXlHRXJ4YWNDUTlMaGJUaDlFN0RvOHVYdHpNeWw4V3lSbGhJWkVFU2VGRXFHbGpVdXRGTjZLenlub3pxQ2pUZU1nMUxTcHZRQ0IwV2tWQTA2SXBwMW9zbHcxUU5nWElScUlaM0NvRzRDQkdxQXFHTXRVVllQUDFaK3ViejlURjFUcjZ2UDJlVTlMVkZ5MDV5eXlDY0xjMnRrT1dyVmxkcWwxQmxGWnNHbGdGRG1UUXRveFlobXJNYXhOaUhhRnpNd2NXQnBRWUxOUm9YWi8vOFFBTGhBQUFnSUJBd01GQUFJREFRQURBUUVBQUFFQ0VRTVFFaUVFSURFVElqQXlRUVZBRkNOQ014VWtORU5RLzlvQUNBRUJBQUVGQXJKTXVsRWJKVEhLeEhrYUY0L2NSamtJem1VZVRaSmRUeFBOYlUvYXJ5U1VOcHNpSkpGbGxsbTd2VEwwdlJTRzlIcFkySVFpaXUxTXNSVkVFUVdualNUSmNEOEowV0o2cFdZK0ZZOVU5TXE5b2l5OUdMNm9za1lQL05pRU1ldDZXTm1Vb1EwT05qaWNvV2Rpem85V0pQcUlRVSt2eEl5ZGZPUTV1ZWlJWkdoWmhaWXNVaXl6Y1plcGhqWFZkZTVpdVJIQlpIRWtLSnROaHNQVE1lN0dRNmdXYUI2c1QxWWtzbzVPUW9sVU42WS9LMXNpV1JZM3BZMk9SS1k1MlpZeVpPME5qMHc1NTRaZFBrYzhhWmZhaGFQU3pJcmoxaTI5VHJCT1Q2TCtPTVdPS0p6MnVNamFtZFIwZVBMSHJPaGxnZmFoQ09qNlp5STZJVVhwL3dBajhMeGZQa1dpWnVLN0s3cFJVbGx4YmRVTHNRNWNzU1l5UEErWk5hWHhLVnBOaWh4RjBZNUNtWkhabFJtaFo0TElYTTZmRHNqa0UrTDFXcTFXcTc3TDBZOUk2THRZdGJNUkVZMk9aS1JLUTNvdEhvdmFrSjZyVms0MDlJamVrWHd4azVVdjQvTDZ1Rkg1aGpzVmo3TFBHbVhpTVdJakVjU2NCcnN5eDM0LzJ4Q1ltSXo1MUZiMlI2akloZFprSDF1UXlkVmtrU20yUVcrV0tGSklvUzFvMm0wY1VaTVNZb1N4emd4RUZiakVtaDZSZnVpeDZyUm05bnFqeWtzekhsa3l4YVNncExQZ2NCNi94T1RkZzcwV1dXTXl6Mnd6eTM1dGY0enBGR1A0cDdDWCsxNFlVTFRKampOZnlYUSttK3hDTUdQMU1rSTFGZUZwSHorcDhmaVBHbms4SDZJWE9yNEV4dnVhTTJHdEZvdXgrTDAvQ2hpNVZDallsUTVDWmpmQ29rMFQ1SEF5NDk1NlBPQ0d3VStKY2tleEM3VUlmWTlMN1dObGtHTHVvOERZNWUzRjUvWXpIUGw1RDFDVXJMRTZMTEhwajhvY3FGUDNJb3JSbGtwTHN2V3l6cXMrOS94dVZSelhwZGFNVDFZeEdlZkVDS0VNa1RSUldpT3Qvd0JmVVFrcGRuVWRSTzhXQ1dRV0dLRkNKNmNUSmdSa3h5anAwc2VJaUVKYUxSTFNqYVRnbVZ0Y09TRVZFbFZUWTljY3VOMXJSUFJrdEdTN1VOYmwxV0wwNWVUcHY0NmVRNmJwSTRFa1ViVGFPRFdsaWtXV1hwbHlxTHpkUGluaWt0c2pvb2I4dVhMNmVMSDFRNStxWVk4TFI2WkVweC9rZWw5REpvaEVlWDBYVGVra0w0SDJmbGFmVWNxTHNZaG8vTzFtYkYyTFZpZ0pFdVRhYlNTRkVTVmVITmwwUlJDZEVKMlM1RkdpUktBb2lGSWJGNWtYcW1XTHNSWlpaZndNZW1QeVI3TEhwTVRJeTJrWmN1WThvcGpZcERlajRFTmlNZWpJUUk2c2JHeDZMVHdPUlpQSkdKbHpQSWVpbTg4Lzl2VHlVOGEwbDNOa25TYnR3OHJXUklZOUVmeXNmOXZTUksxY0U5RXVhS0doeHM2akJ0ZUhpS0ZJVEZvaEMxb2FNaU1UUHp3bTdiMFJ1cHFSZDZXUll5UnlPRWowbWVrZW16WXltV2J6cUllckRvdWlXSlk0aWliRFliVFlLSlBGR1JPRW9GbGxsbTdqUDFHN04wK1Uva2NUeDlRZnhjU1hNVmlSaXhwVFdpZWowNjdENnVPY1hDUWhIOFowKzVpNzFxdk10ZnpsYU5XSmNmQ3lyTTJLdXhhUWp3aGlSR0FzQXVtUDhmYU9GT1VVWkljeVJFWG1ENWlTSlNOd2phUFJERVhxaGFXSXZTeXl5eXhhdGxqSHBIeWxaSEhJMk1jV2JXYldKc1pMejROMWlHeU0vZHVzVDFzdXk5TE1RaENGckprdkwxWTV5aVBxWkkveW1lck9SazV3ckh0SXczUnl3bzZiUExCUEhPT1dGamoyYmhqa2tUeWIzRXhvV3NoajdPb2dzNUdHeEZGZGlGSGhvWTBwS3RyRUlSampZOGJSdEYyU0orSVBtTXVIem94RDA5YllZOGlhdlM2RmJLN0tLR3RKUnNlTTZYRlVTQzBTN21yTStMWjJkVGsyNDZ5UmwwMlQyOWJpL3dBakI0UDR6L3lKUTQ2ZlJzaXhsbGt1VCtVd1V4R0tHK2VESHN4djVINFJSWEluZWk0TFIrc1hJOUgyeThaWVZxdFBBa2JUSGpzVzFHTldSZ1Q0TW51VCswdUhQa1YxK3c4N3g1ZUZ5TjhxWEc0ZWxqTDdFSmxsaVpZcGEyV0lYZW95Wmg2YVRhZ29qV2lWalJXdEd4RHdJOU5vY0hXMlNhRXpjT1JaWlp1MHd5OTJrV0lzM0RZeDZNWkptUjh3am8vcGpTTG9lUGNkUW5HT0hxTXZUWk1IOGppekVIWTlHU25HSm4vazRwK284aEV4UnFTRVhveGowWjFHWDA4VWNpUkJTbnJSUlF0SXlvbEt4bEdYeUlSQTZiYVpIR3A2SjZ6SnZoWlZ1eHpJc2Vqa1daTXRIdXlQRGlsQTNHNGd0MnFqeFhZeWlRbzNKZUVKaStESXVNa2RyY2pMbTJyL0FDTnhITmpNdVRDWUpJNi9vMG4vQUIvdHg0dVRLWTNSdUxJc1VoczNhZFhEZmhhcG44VGd0cDhhUitGQ0VqOS9UZ2RqTm85SDQ4cjhSWWp4ckpHU08xNng0R1Fxa3pEanVlUEdrdGxtVEdUd21hQk9BeHlHK2Q5aW5SS2RtN2dRaDZmdXE3cjBSWmVxMXNzWkNFcHZEMHNVbENLSHhvMVl2REdYcldqMWFzeVloOEZpbVdNdlJDbFR4UGZIUlNIMnNiR3pKSVdPUkgyaVkzekxKVHlaeUdlUkwzazhiUmk2ZDVKWWNQb3IxY2c4dVFia3hJNm5vNFoxaWxQcDhtT1JIa1RvVDFZeHNZeitUeU9SaWMzTjRHNHJnV3RGRXV5ak9KaUlrU00yaFpXYnI3WkdlVzJPNTdzWFV0R0xxSXlIbEhrSlpZb24xSmdoTFBLRUZCS0J0RkcyUmpZb0NpYlJ4RmpHaXRHWTE3bzhhUUswdnVabWp1am1qTnQ1NTQzRHFJU0U4Ykg2QmdaczlTTU9taEVXMUgrUHZGMDBFUHA0RDZZZUdTSHdYcms1ajFTMjU4VWQ4K254K25qWHpSWXV5OUc2TEh5NUM4SVo0TFB4Y2FNeVIzTFYwSjdrakg1d0pFWlVYWTZhbnc4OHVHNldTVnNteEZXM3BkNko2dmhvc1dxMHNzc1QwUlplaU54WTJXWXNPNHh4akVlNHNjMkpOanRFaXhNNDA4RjlqMXlZbEl5NHBSTEZJM0c0M2xpa2RObjJTUkVmbDZmZ3hzY1dTeG02c3F0UExOYjRzbkp4bktaV21GN2lPTGVZMUdNV2lpaWhRczJIOGowL3E0c09mMG5oeXFRbjdWa285VWVVY3pjTmpaUG1NNDFMSGpVWHZFSVFoak1uanM2aVJGa1dSRXhNVEZMdGt6cnNuR2laNmtqZklzNmJFODA0WXZUakNJeXlLS0lyaGFzVEpvWTlNZmtSRDRKYU9CMTJHakwwOGM4SmZ4Mlcvd0RCeWtPbjlNNkxLazFGYlpZOHQ0Y1cxZHNvS1JQRFdyOGRldjhBZi9GWXQyVmVGb2hmSnVHV2NHMGJMUEpSVmFNcmpTK3htYVBaRmNRVm1LQ0k0MEpVZVIzRXlNeStKZVpJa3hyUzYwYkV6eVB5aCtac2pwZlpaZmRZMko2SVVKc2VLWjArQWpEY2tsQTM3aFNGWThsRzVqZGlGcHVMc2ZIZTlNdUJTSndjU3hQUk1zc3c5UTRHTE5GcmN6Y05tNGN4ZTlxTkRaa2RtYkhUeFZ0NnB2MXNMazQ1ZUpPTVNoUnM2YkI3bHA1ZXpuWWhRTm95YXM2dkJKWjhFTW1LVU45Y200M0c0UllrTkhVUUV4YVIxZWt2cnBaSm5WeTkyTElSWkZpRUlXaTBiT295cUN5emVTWGFqK094ZW5pbDRXaUV1S0VJb2ZqUjZNWmlkU1FoZHQ5ajA2dU40SVNIUGlUT29tZE8zNnZUZlZhUFJkdVRGWktManAxLy90L0c0dG1ENFdVMTMyeTdGWFpSWXhlSzQxVFBPclEwU1ZTTnBDTWpGQkdPRmtZSWxRaVR0WkdadUk1UE5XU0ZKVTlFeDZSZEYzSmpHUjdMMXNUMXNzVEhJVWpFbk9XSEhHSndmWVhzRk54TGt6eWJveFc2ejJqRnhxdEZSNUVVUFI2TWVtVEdwTE5nY0M2TExMTnh1Rk5vaDFraGRkaVA4ckd6L0pnM1FsUTJTVmlLVFZTaTN2bktlemJrU3lrZnVvbUxFWVljMXpSRmRqR1NSMUdIZGx4NG9vVUVla2g0SWt1a1JrNmVjRGtpTFROSGo5VFBJdExHOUplTmNqNHl2ZE14WnFJU1RFeENZbUpsa21aK29qQlo4enlTN3NDM1pZVW83eEczU0FseVIwYXNvWTJNWTlNYnZXemNiaHNRNUNkNldXWi8vSEUvZEl5UzRqajlTZVBFbkxGSFpHOVYzdEptWEZSbWc1OVhCYlk5aTdFTGs1YjVpTjMyMlhSWjUwZWlZMk5sbDZMU3p6cTBabzhHR05tS0tIdE1ZM3RKU0pTSEt5VTZlU1psa2pjeVFpYVJ1NFE2MTRGcXZnUW1ObGlzV0tiSTlMSmk2TWpIMGhTRklVakc5eHN0eU9UblM5TjJpNUwwMjhKMmtLT20wYTBZeTZMSFRYVWRPUGdiRTlHV09YRW5ieHRzNmJENlVZSjdwU0cyeGZWOE55T0taaml0M1V4VXB3aDZ1WEhEbjZxR3E4YXRtOGJNL3dCNEdNV2xEaVpjQ2tiZHJXaytZNVB1aENHOUZwbGRRTE54MUUvYTFyR1RpWWVvWi9rUkZtZ2Y1RUI5VEJFdXVpWk90bElsSnkrRHBlTXlueEh6alBiVEVZMklUNWJFU3ZWakdNeFNwcmxkdDZzYk41MUUvd0RTNWJUQkp6UDhISk0vK1B5d09ud3l4dmVLWXBGNk9SWW4yTWtiSWJ2Z1F2S0ljTGM2b2txRVBYZ29zM0NrUGtlcjdsb3Iwa2pJdHJ3SkNjVkY1Qlo1RVp5WmpoeEtqS09abW1pVEY1ZXRHMFpFbTlGNEdMNGxGeU1YU3RtTHBVaU9CR3hJMm82ampOajVHdVpKbUI3WHZSdTVsT3krMUNkQ29SUW9pb2s3RU1RMFRQQS9NamNianFNVmpGMk9XbjhYZ0l4U0dUWEZXUzhiU1VSNll2dGx0WThjTm1IRXVKY21JWG1pdUhvNUNHSW56T0pBaTdTMFl6TERjcUVaUEdmL0FOQkNIMlo1OHBsa3BFcGJuS0wyNjQ1VTVPMzh1R1czSkNWcUpDUTVETE1VaEY4b2ZpeGFOakd4bG5UWmR3MlgycGxqa01iT29uN2VuNlNXYVdEcHNlRkRHaWVKU0pZNVFGSWpNVDBXbDlrdEYzM3hvMHRyOGJYVkg1ZGQxbkErZmtpN0xGeU5HZU5yWkpFOXhHUHQyU3ZEdE1jekxIY3N2c0p5SkcrbTNiRU1iNDNESWo4b3ZSL0RWbUxEWml3UlFtb204Y3hTdGJqcWYvVEZ4cFhGREwwWmVpUnQwWGhHT3R6bHp6SlJXbHEzNWxSemVUN1RpeHhKRFE5T294NmJpeXhtR1BxWk1NTmtQS1ZqS0dQZ25yRmNaYTN5K3Q4UUllU0w1a3hzYkxOdzJQZ1FrTHhCOWpHWjRGa2pPLzhBYXRFV0xUTmwycXhNWEl1bTNFZWx4d0ZqaVM2VEhJeTlDNGtvT1A4QVI2WEp1Z21Sa0tSWTJLVkNrSmltS1krZEd4akhvMmI1UmxnNmhaRlp1TEwxc2JQSk9TZ3VpaExxY2tVb3J0YXN6WXEwak1UN0ZxejlYeFh3a0wzQ3BDdmRXdjYvaHJ2L0FGSGpTU0paVUtlOUtMUFNteUhUSHBLS3laTnNjK1QzVG5SS1l5S3NhTDFYbWN0VjhjSTJZNEpFV2tlb2JtY3ZTeEU0aUUrYkU2SExSbGlpSlYyeHExdzE1ZmpIZEpEaVVmcTVlMnlVU1VyZXJadU9vZ1gyZnhVUGZqblp1SWkxbEMzSlBSa0JybklJeG42cEZsamZiSVVSUkV1RUlXakpEOFAyeWJvbGsvMktWaTF1akoxQ1E1MldZbzczaXhiU01kS1JSUm42ZU9SWnNUeFM3SDhlSEpzbENlNUptNFV4eTBqa29VeXhNVWhzWXhqWTJiV3hZaU9PaXhTTndpeXl4c2N4UjlXV0tFY1VMNzJkUmpvc2pJVEd5emNLWll6OStGRFZPMXRUUFRkeXROSnNaNEwrUysveWhpZ1lrcmhpZHFCNGVUSVpzdTZlWGd5TlU5RXVMMFF4eDRVU1drUjZJZmRDRmtZMElSdEVSMFltU2tKNmJlZHdpWEdtM3NaL3l0TVVkdytKUkl2U3FNbWpmdWxaTDNEaDZlalk1RXBVSjJQa3l3MnlldjhBSFJycDhZdkVkRytMSnNUMXhmVnpNakVSWXBDWlpmWlkySWhFakVyczNGakpHYzZ1VzNIV2taTVVpS3M2cU10Y1VYT1dERW9LaGFLSnNHaWFPb3hlcENVZHIrZkZrY1RIbFVoTXNzM2FiNlA4aWhkUkU5VkhxRzhjME9SNUl3TnBGYVBUY0tSeVd4elpseVRVc2N6b3ZDa0lXaTFla3VTYTJ5SXlMMXNzM0VmaXIycng5WEJVM043cDFVV1B6NVorYXI1a2VTUW5FUzU5U280cGJqTHdaczltNHlTM0ZESmFLajhqd09YTFpaNUtGcmpRMFBWR1BFUWdPS3BFU1RGMnlmTVdXT1FqY05pTDdQMDQwd3pKdjNYL0FMTXZ0VWZESFEzTGZFWXVNbjNNa3VXUzRMRzlNc2QwWDUwNlRqcFlQYUx5cnU3RVNIN2lHRWtsQ0xpYkNHSnlKNGFIN1N4U0lUTEYyWnMwY1VWTGNRSWkwZWxsaUxFZFI5ZW85NUxHT0lvaVJqSngzTHFNZTFvNlBGVVk2TFRFTmFNWjErS24yUHRTWXNjajBabm81RDBKaTZlWi9qU0k5TklqQ1NPUzJiaDVSNVJ6TE44ajFKQ25OdkZIMnhnS0F0WG85Rm94cG5Va0l5T2loL28ybjVvbnF5VEV6cWw3aE12dHN4L0N5SEs0R3FTYlBWRkhjY2JwMGZoK2FyeDhLN1Vmc0ZGcVZvaFpHZTB5NXVKUDNTMHVodlN0RU9SK3RpNVBIYkh3U1dpVm1EcGh4MjZwRmFMc3lPb0xSUFZTMFdpRnpvK1grRHNxaGU1cjdXaFBobEZ4UCtWNWhkNzFBc2ZKTFI2STZxRlBUb3BYMHFGTTNtODNrclpqZ29JeXlHemNZZnJrSkt5U29zVWhUYUZsUjZzRDE0R1hxanFKdHJvcDc4RUJFZEdQV3hpWm01aTBQR1BFYkRZUlduVTQ3akdQdnhLb3JzeEQ1SEVscDFVTjJQOEFkV3RjZlRTbVl1alJIcDRvV0pIcG8ySHBucG13Mkd3Y1J4SEFsaUhqR211ekQ5NE1pMW9yS0hvb213U28ya1lFWURnWmNDa2RRcFlsL0h5M2ROM1dOajA2anhvbVgyTXcvRmpmTXlNMVJzOXZLRkZ5SjhQOFEvUGZmYXZnZnRibXBLK0hsNXl5c2ZLaXpJaHJTeHNZdUJzdlNFdHVpSG92SzFjTE9tNmJhdkJQa1VYYUVSalpzb29paVdNb3pyZ3NSWXVUaGEyYzJoZHRqSFBhS2U1UmtKa3ZlbHduSkkzU3Q1cVNod21veWZ1Ykpka2x1aE5iWlJWdnBmYkNPdDZZUENNcnFKalJtVlR3OEdYeFpJa3FaWTJONlNNNzUvamNtMmFGSWpyTHRzZmhvYUhGT0xpYlRicGxYQ2ovQUxsMndFTmt0SjhyTXF5ZG1QcDVTTVBTeGlReENnSkZGRkZGRzBjVGFPSnNIQWVNZU1sako0aVVYSFRwL3ZBaUlXakl4c1VVVDhwQ0VVTWxOR1ZLYTZCYk1JdElJbVBzWm4rbDl6R1lQajNGY1U5SWU0LzgxTHkyMmw1ZjlYSE5OS0NKUnBaVTd0YlJzZDFZaWRhVncvQ0dQdWdWcmd4Y2J0STBTaWJSUkZ4cFFrZmpSMVd2a3NRanlJb1dpV3FRenl2RGpzcFFvak9NWktjZEg0L01tNm9RNGQ1SmVtb21UN01mWWpxNDg5SEFnUmZaSGx4VklsSGRGNDNFOWFSREZLVW9ROU5UK3IweUxqU3g2VEpjdUxjWllzcXk0MEtSdk54S1YvQTBVVnhSS2NFUHFNUlBxSU1UU2xIUEFVNFBWRVdKakc5R2RYLzY2UWc1R0xBUXhrWTYwVnJYYTRtMGFOcHNIakpZaWVJeVlESDdaNHBDWWhhUlc0YXBJWW9rVm96SytHTm5UVDl5R0kzamZhMmRYbGpCS1Y2WHEyWHBnZnVYeFdxU3N1VVhLemNMbHNVV1M4OWwvTmVzb3hVc3VScVArUnhPV2prU2ZDbnd6a2ZoTFJpSlYzd0V1R2lIMmVZaUlvU0tFdEVKRzNSblY2WHBIUkNaRjg0bHZsa2dsTjQ5c2NkU1dURnRoSEZLWmZKUWx5blJHNXZaR0RTalc0bEMxSDJveVNjekhCWXpMTVN0RDVHaWg4Q00wZDBNU3BMeXBiWEdWNkptR09xTjQxRVhBeGsxelF5ZkV1ek5MUkhTWlBUY1dKbGpIMnQ2TW5sZ2xrNnlpZldaUjVaU04yalROckZCbGNicFJJZFRORU9xaXhUVWhNZXN6cS8vQUVNZVBjWXNSR0FvaUY4U1JSV20wWlJ0SlFKWXpOMDltUGdpeUxOeEgzTkxiRi9VWGxhc3lQbVF4UzJ5aFBjbVdXV0tkOWtwSDhqbTlUTDB1YWQ3aXl5eXpjYmpDNm5INGx3eXlNa2llMFNiUERsa2IwWFA5UkZMWmtuUTN5L3JOOHVTS3ZSUk4xall4RG9lbGk3RjVSR1B0a3RNRkM4NG9sSVNLRkUyQ1Fsck02djZzVDBSWkVTNWo1eCszSjArQlkyOGNabVdHMlUzSVVuamwxTUlpVjlrVzFMekdIQmNDT1ZibktKbm54ampVWnlqRW05OFhMMk1ZOVB6eHFtSWlRNUVpUGdzUWtNUXo5bkVjUm1kZG1TZGFKQ1JHSjArU2hGbDlyWnVwUzZtbGt5U2tUeVVTbTNwUW9rU0k0aWliUnhIQW9VbkZ4NmljU0hVUmtYWWliT3BkNU1jTE1PSWhBUzBTMHZzclMrNnRHdEdVU2lPSmx4Q1pHWXBuU3g0bG9oQzBZMlRHTVowL1VMSEp2NE9vamxrcGZ4bWFaaDZIMFZsODdwUkZra2IyYzZveHk0aVVMdVFoVm9sZWliaU4zcXBOTCtvM0ptZmtpdUplSElZbloreThhSWtSR1gzSVJGZXpQd2tZbzJKVVkzMklXbGpsYlVoblZyL0FGc1JZbUlqTGxIVDE2M1VWL2tSeWY2Y1Mya3NhYzgwNFJqT2NtMUoxeXUxTWl0dzRTUlQzUnFKR01YSnlTRkhmS2Z0SHcyTm40endNVEpFZElzd21Qeisvd0RYNmpjU21JY2l5UXhuVWZTemNTeUg2SkVVUlRJb3hUYUU3N0xKVG95Wng1WGJrT1JKM3F1Q0tGRVVPRkEyR3cyRGdQR1BHU3htMWluS0JqNmlNbmxkUlVkOCtudzBLSWwySVl0SUQ1MTQwb1hiUTlKSWNTU011TVRJTzNpNGl5dFVNYkdUUXhraitRZnQ2TCtSY1NNMUx0aGdGQ01SeUwzRzFHWHBzY3pxdWlsQW9RdFdkUE1URXhpK2F1UDZpSEtubVR2d1RtYmlRaDhEWWgrZjF0VXRWMng4cnl1STVaYnBJeFNvNVpBUllub3RIOWNWcC95R1gwekZrM3c2aFhpWXhGQzg2UWRHTEtqRGNZeGJsRnhzamlqZVRFcDVPb2h0bE9NaVVlWHpwK3YvQUZLMmI1SE1qZHRONUdPMkx6SHFJYlAxME1lckhvaUppTVAyYkg0WGRaT1d2VnYvQUZXOUswU0VKQ1FoRVJNcXh4TXVjbGtiR3hsaXVRMDFwRmNLQW9jd2dLQnNGRTJtdzJEZ09Ca2diZWNrT0pJYzViZWx4Q0ZwNTdFOVZZbHJSUldqV3FpTmFNZWpSSkhVUWFPaXk3ODYwWGE5SkRHU1oxRVZrSDA1anlaY0JpL2tSZFhpWXVvaEo0WVVObS9SZVNUSEk2enB5eGNDZXNKYlpRbGFSZndxeS82VCtDeVVpVDNHUmtqaXZPcUVNUTRmREJFUHZubnRoRVJqMnBiaEMxV2toTTJ5M2Z5V0xqb3VvY0pLVzVaVlV0Rm9oK0VRZFBwczY5UEZJZTZNY1V0eHQ5LzhoOWVqeStwbDZqak04ZnB5a1dibWVSelp1ZHBXMHNJN1p0Z1RqR01YZDBReDJTSHF6ODBnWVRHTjd0RnBZdEd5WTllcitoUWtVSkNpSkVVS0pSRkZHU1VjU3o5UTVqWTJXTjZmZ2lDRkFoQ3hSMmk3NktIRWtpYTB3NVBUY2FhMFJYYWk3T2FnVWJkRjJVT3hsYVNFVVNSbGlkTmkyZGEySWdVTmFOa2hzYkpNYkpzYjBmSktHbjhYaG9YaHNYWkk4UGhycnVuOUhNbVI3T21tSmkwWHhVcUhTK04vSk9YRG1PUTNZOWZ3L3dDYXM1RStYOEM4WW43OGt0MGxyRVJFaTFvdEpMWHFzYnlxY0hqbDBuVUhVTG45ZlltV2JpTW1qSDFEM1ljcnVHYUxJemNzblU0ZDhlamgvdDZ2ZEhKa3kyTzYyKzJ4bkpCN0V6Z3QzNnREeVhvMmZraCtkSG94TXhlY1JFOE5rUEErQ3pmeTVGMlBYcVh6cWtSaVJRa1ZwUWpOa1dHR2JxWGxudjQzRFBEZml4cy9ZUklvaXFJY2FMUnlOeHVOd21KNk15ampha25GMmRQbDJ1SE9sbDZvWnlJM2NwaTdVTFZraGVIbzBNeUM0eUlSQ1Fwa25lajhOakd5VEpNbSszWnVuZ1ZRc3ZSMldKa3BERWRkRDFNSzdZUzJ5eHpzWHhYUlkrKy9uZXJKVHBmWk5GbjIxaXJOdWw2Y1YzL2taVVJGcEdKRkNJbTNTSWhqSHBud3FZNHVFb1pOOE1pMFQwUWx6b2ovQUtVMktObUNkUm5rYk9pVzFkZGszenhLUHE5YmtVNUQ5cEZDcW1qZ2Z1UEM4bnRTWWtiaVV4NlB3TWZsR0l3K0ZvdEc2Rk5ESG85R015ZTZlaWlLSW9paUxTaUtUV1NheHg2cnFKWnBINVdqNTdJbUl4b1IrQ2RFcGp5SWMwZW9lb0tZcENaKzVCRTFZNENaZ3k3U0x2UmFyUnNYaEppRUo5aUZyUnQwbEVyU1M1bWlSamxjVlBteFROeFpLVmpHU1pKbVNSZWxpdGl4U01XSnJKakc2TWNyR05qWnVMMFkvRTF0bjI5TFBoUFJDL3MzOEx5Y01zM2FSWTlQQnU1OGtxZWpXcTdYNHgrVnBqODdsU0VJUWlDRU1raVNHeG1iSFlyaktYdVQ4Nm9Ybm5WZU1PV2lPY2ZWVVR6SmRQQ0VweGllWmJlZEpGaVlqYksyUHh6ZTNpU0hxdkRHTjhvd21Jam83UnVKdjJrWmprUHN6UzRLRkV4eEZIbUM5OG9wU1hsK1VXa3V0Nmg1Sm5nL2U2SkV4bkVoREpTb2xrSE5TbExJYjdGbEk1ZVk1Q014dTAvRDhrNGtrUmRQQk90TDFReWp3SVEvS1FoOXoxNXVYbGpKR1V4Wk5yVExMRkljdEhJWk5rNWpkNjRzVzhoQlIweCtZOEUzemhkUGRGbVdVUysxblVmK3ZiaW50bENWcE1RaEM3TC9BTGlhTW4yRTBJM2FYeFJRbTBJOERkOTdKR0phSVhCRkNFSVFpSWhzbEluUFdST0pIeE5DRncvMFJlajBneE96RjZVWTVMTTNxWThibHlvYlZ4dE1NUFV5NUtqTnZYY1hxMlNyVjZ5OGZxTUJpRUluRWN1SDRaYTdYd21tM3NJUXNVQjRuRVNLN2Y1RHFPUmVGcGlWejZ1TzBTUHhIa2pBZ2hJVEZJa3pMT3pKTXZWQ1pHWmpuWXBtNG1iaE1sRW1xTVVqRE8xM0ltdUlhWHlmdWlZdEdlTlpvbDVaa1JsUkl4WnhUTndtV1dOa3BtVElOM29rWTRibWxTMHhlUmxtNHZ1Yk16dkozZEpsRUppRS9tditqK3N1bmtraHV5TVJzUWtiU1FpeS9oWis0OUVSOXpRb2NJUXRFSVpJbEU4RGtPWTVtTjJOcVVweG9zV2w2SmpYQlp2YU4vQ2t4emNtdUhsbjZrc2gvd0EzV2t2SGJZMk1zdnNuOVVSTUpoRUluTGMzR3gyaHZSQ0VoWW1lbXBMWWJTTVdiVGtydDZuSjZXS1QzU29kRVMyWW10bVdIc3o0L1JFdEVSYXFBdUR5T3pKSXlTNGI3a1JaQ1JHUk5yUldlVk9KNGxpbVIxc3NURTlGb2hhdlJhc1JMeTJXTWtaVVRNaGp6eWc0ZFRGaXlvOVU5WWVVYzcwclJFRnRSdUxNY3ZjTi9BMlpaMUZ2dmhMYkxGTzBKaVluMzMvU3ZSYVVNWk4yZmdwOGJYcHZISThsYlIvRkloNWhvaUNFV3lKV2lFUjBrU0pEUkxHVHhFdlVnWTh0UyswWlJyUzlGcFo1N0ZJc2JJeW9uUGMzTGNJZXIwL0xMR3g2eDVZelA0UWpDWS9FUkVxT0hHRzFtWHA0b1hTN2g5TnRTNmNoQkpTczlQbWVKeEZCTVVKSWNIWDdtaXFRMXIxK2JmTVdrVGFibkJ2cVp5VGxiRWtmc0NBaERPcGR1WGJGV1J3ZTJVV2l4Tm1QZ1VkejlNa2xHTVdlVExFeFNNTWk2RTlXUkxFU0l5RTlFK3hhTWlTMGRESkdRbmpreDlQSm4rRElqMEl1aVF1a2dQcDhSNk9ORzNFT0dFOUxFZW5qUFllMGFpT1BMZ0tLdXpjemNlb0tTTDFzYk9yeWNGOStDZEdPZWlFeGZEWS9sUTlVemR3dkVucnU0TFloajhJYkxIOE1qRXVVdElrTllpZWlFSXNteHV4bENOZzhVUjlQQWxEYXBxMW9tV1dMVGF5RG80UHl0R2VYamZwdWJHeGxjTWVqSlBSNlVSOGtqUDRRakFZdEl1a1I0S2U2ZTVsVXBlVVNrazNkcU82TTVtMUR5RnIwa05pVnJUcUo3TWN1WkZhTHdTV2kxZ1FNWWphWlltVmN5SHBDRG0xQWo3Wlk1S1pteFNrU2p0YU1VV1k0TVdNbkFjTk12aGNTeFNMRm9ob1RFSmwyTkNrYmpjSmpZbm9wREh3ZXBFZVNJNW01RzZCdmdia1hJdVdpM1Z5VnJSUnlVYlRhVVVVVVVORzBhT1QxR0xJbVdacDdJNUo3NUxTNjdVdWJNR1VqTFJDRi9VL2JFOUw0UjVOeEpqZWpvUXhDVnRxdm1ndDgzRGJJUkFqb3RFSVdsMGJobEZFa1FXajBhTWtPTW5IZnZHeStiTnh1TDBzYjBXcjBreDY3Um9UMlNiR3pONVJFd0dNaUlpdWZFNU0zY0p1bS9jWW9rb05wZlRQalVTTEhGMm10a29iUjhpbFdNbWZ5RXg2ZnFpSlU3MGV2SWpHUThyVExJeWVjbmxqUmdsdHlLSHFQcW94VXVtU0liVHFxM1lNZTU0c0tRb0cwbEZFaGt5UmlmTVBDWXlPc0RjZUJ5RTlFTGdZaVRvZldZb2t1cnpTTnVTWXNjVWloUksxb29VVFliVGJ5VUphTVNLS05wUnRLS0dPSTFvME5DazBkVHV5R3dxaSs1Q1BCaHlFV0ppRS82VEhwZXJsYXU0b2N1R0xTdEcvNlBSUXQ1ZjhBMVFpSXROb2tSMFl0YUtHVllsb3hqMHl3R3FlbTQzamtiaXpjYmhNVEd6Y1dXYmhQc2srQ3l5STN6cDRQMlR0b2dZVVl5RHJUajA4RWJjYTlSb2E1MnFMaXlLa211VzBKTWg5czMya3FoZTZUMWs2WFZPeDZSSFZYcHVWYmFXc1NMTVRJaUdxTXZuTkhUUERianN4NXF4NUpicFk1N1JaQ1RUZlNRRWhTSElsT3pLeGt4a1BNUk1ZbUtRbUlvUnRSV25nOVF5ZFZqZ1BxYzBqMG5NakJSRmVqMFF0cHdVVjJQNDFFY2E3bWhvWTBPSTRtU0ZHVFZDN0ZwdW93NWR4R1JZcENGODFsNnZXemNoc2JMN0wvQUtMMDZXTzNGay85VVJpSWlRalpQZ1JFVUJ4MTJsREtJNlBSalFrU2h1TW1DVEgwdVZqNkxNUG9zNS9pNXllUEpFczNHODNDRkljaFRMTnhaWlpaWTJNWkV2UnNzcmg4SVJqODRDQWlIdUljdHZsUnMzV2VTZGJjU0dMN1hjczJTaUltdDdkdCszUmxVWnZybmZJaU5DWithb1dqRVFrUWtMa2tTaVpJWEJuV1Q0VHN3K1ovWW9qd2ROVzFNdlNSTVl6eUx6QjhMc1JDUTN6ZkNuVGZWUUpaNXlIbGxJOUxKTWhnVVJScldtVi9XUSsrVWJLTm8wT0k0bWJBcEU0dUwwaUx1Ump5aWtSa0psLzFtME44dlNQOVJuVFEzNUtxTS84QTB4cXhlVUkzYlRkWWpFUkhGc1VCUkdpdEdMWGJadE5uTzAyMFVWcFJSdEpkUGlrVC9qc0xNbjhXWmVrellpNkZJM2FXV1hwdUwwWTNvdVNVZGd5eEQ4U2RpRVl6RVFZaVBrWkNSampjbzBwT3lVaFNsYmtLRWtTWE1uSFRIS0tUZGlsN0N6cVh4bGZJaGFvb2VOa1Z5MGJCdmxja0RINWd6aW51dDNlZUZQTXQyS0tPbmh1YndVbXRNRU9kMG9rTkp5MngzN2xObGpaTVhtTEllQlMwUW5STEtqMU1qUDFVay9jSkNReGFMeVA0NnNhL3JNWTBaOFc1U2k0c1F1NUM1a3A3SENaR1FwQ2tXV1hyZmMrMnhqWlpZMklTUHo1YTcraGhTeVBpZjN4dWhDRVBSRURHUVE0RGpYYlFscFJSUTRvVWVkcFJXdGFVVU9KbTZYRmxNLzhBR1NSa3h6eFBjWHBaWXZPalpSR0FwUmdPZGtwQzVQQk9XcU1SaUlpMGh6Q0VxV05XdkFwdTFrVnBSM2NDOHlaLzFLTnVSQmJVK1MvWVdkWkluNUZyenRSd1FOdHlTUGNiZVg1aTJ5UEJDWXVSb2t1Y2tOMGVZU1hUcThVVkVra3NiMHhlRVFzc240Z3pJeHlISXMzRUdZWmNFZEhNUmRhVVZvaXV4ZkVrTVhZa1Ara3hqR1NSMVdQZ1dpN3NIL3AxWG5IbW9oT3lNeFBSRi8wSEljaTlJNk9RdjZlS082V1AycWNoL2RlVUlZaGlNYk1aalkyU2tidEs0UzByU3k5T096anVyV2pKaWpOWi93Q054eU0vVFpjT2xsbGw2cG04M0ZsaTlwT2ZZakdZeGFwaTJsMGNTamlTT0l5bEQzWXZEeWM3bzdVMG0zWW56TjJmbDY5WXlYYXRZUGhDSFkrUndRaENrUmVqRWpxWUdQeGpudGwxR2JlSmpnWXhDOERaL3dCNXZ0SmpaeWY4eE1CWll0MlFVSzBWRDUwU0V1MnZnV3Y0SWV2Q2ovVVl4bVpjUzhyUmRyTWJwNVo3bVk4amlZOHlaR1pHWXBGbDkxOTdZNURlaWlKQ29sTXNYOVBEd2J4eUdSSW40UHd0SW1NaEllU1VoY2lFVmVuNFdjYVY4MWFVU2paMWY4ZEdSa2hMSElzc3ZTeXl5emNTbm90VVFJQ0U5RXhEanJKOFIrdnFzOXRTRmVpaWtuSWZoRGQ2ZGI1bDNWcEN0MGJJSXE0eVJLUExvVDB4ek40MlNrTGxRNGxJM2FZcEcweHNXa3liTWs3R01zc2hJNmI3RVlIaldLNzFFVUVPT3ExWGpWRXZrclhhemF4eDBlbXhtMFVCcEk5cEtoakdaUHJrKytrZXhEN1U2TU9TUXNoR1FwRjZYcGVsbTRzc2NoeUhNY3h6RnlJc3Nua0VJV2lIOEZEN29JWFpFaDlZYVB3a0lqakZ3UlJWbjdvaHY0TCtaNjlSMDhNMGVxNktlRFN5L2hXcUlrV1JZbjJKME9WRUdqMjdVeFkxSWVPaHFDanU0ZzFiYmsvMlZhUFRyZkw3YTBRaUJqaTJLSEdYR1R0YVNZbUtaSEliaWN4U0pHMjhRaEdLWEUvYUtZNUVzaEtSSmxqRVNaajVNT0p4U2hHRVhMU1JGY0x2dlM5RXJHcTc5ZzBjRXN1SkgrUmlIMW1KSCtYQWZXSkM2amNMTEkzc1UyajFwRHo1R2VwSWwxZVZML0t5bnJ5UFdzYzVWSGZUbE0zNXEzWlM4cHZ5SHJaVC9KWi9rd1BWaEl0TWxFNm5FNHkwWGErMUVKMFBLUnpORU9xSVpreFROeHVOeHVOeHVONDVqeW5xbS9SOEdPYWtXaDVCeVloQ0YzSmRyN2toZGlFUlpIUm1PRzR4d1VkS0tQMnp4MmVUanZ2WGo0R2VSK05HU2paMW5RUmtweGNHSW90RjlxMVJGa0dJUkZpMWpQaGNsVm9wdEc1NlFnNXljYWIxZXZYRDc0c2lZbHppaVE1Sm1lSms0VS9MMGk2UFVaWnVONWk5MklxaXlFcUpTdU5qeW04azlVUFRvY05SaXRvOVZ6OHVKY09ObXhEakV5NWNHTWZYWWovS2tTNnFVUjVza2g1WmliTnpQY2JHYlNxTGtqY2IrZHhaeWNqZzJMR1N4RWNUUFNOaHNOcHNOZzRDZ1BHUEdiS0pRWXBaWWtzamFuRHRReC9FbTBSNmlhSTlXTHFrZXVqMTBQcUI1eDU1RHlzOVZrWmlramVaSjJsd3NFaHlqdUVJUXV4ZkEreExWYW9SRVQwaERlOGNlRWlNZWE1K2FJL0orNm9vVmFzOE45clIxWFN4enh6WXBZWldYOENGcEZpWW1SWWlMTDFqS3RKU3NTczJvV3dVbnBRMzI5ZjRsMnJSOG1OaVZFSkdOazJaZkUrQ2ZsOWxqZW5UUGlNTEpRb2x3MnhUb2NpeStDK1dYUkl4cThtS01Zd1kxd2JhZmJEeSt4UmJOa2hRU0gxR09JK3BreDVjckhGTTJ3S0ZBMkd6bmFiRGFiRGFVYlJ4TnBYTzBVVGFiZEtFVjNVYlNpaWloeEhFY0RKaE1zTnI3WDhTalo2VFBURkFXTTlNY0tOcHRQVFBUTmh0SEZqV2kxUWhDK0pqMVFsOEVORVlvNzNHRzFRanhwZkduUHlQd2ZpZXRzVm5PbER0RjJPSSsvcU1FY3NPcTZhV0NYd0lRaENZbVJZbVJsb3EwMjJlQmlPVVNGSXVodm1oNnM2cFhqbDU3ckZLakRrOStPZktrVHltV2Jaa2xhbjhHR1ZQREE2bGNUNEhvKzFqMDZDRjVFTmpaSHoyeFZ0dFZvazJlcENFcGRTMmI4MHRLTm9vbEZHMFMxclN0S0dVVU5GQ0YyeGp6ODhqcTMzUFJkeWdLQkdJb0NnYlJRSlFLSEEyQ2dPSW9tdzJIcDJTd0VzVFdpRUppWW5xdEwwWlplajBRbHFoZHNSR05PVXNVRWtJUitmaCsvRXRHZU5QSkRrbSs2OWE5bysxbVhFc2k2dnBYZ2wzcnNRbVJaR1FwQ1luMjJibWt1UjdSc3Z1a3JobVZURjJMVHlvbU9aSElTeUdTZHFjeTEzVWZxKzBKYlZtWlB3NjdHK2Uzb1UzQ1BnOExBaENYWXBVbU9TUnVKUmxNamlqRVVmNmIvcjNwSXo4eTdIb2hkaWdMR2JCUktJd0ZBMmxEaUtGR3cyamdOYU5DUlFvV09CTEFtVHhPT2w2TFZNZXQ2M29rUmdLSTRHMG9yV2l0SThtSEdvUkVMK2l2RjZQZ1dsQ2EwL094eDRqYWN2UDVGWDJzeTQxT1BWOU84R1R2V3FFSWl4RVdJWFp4cHpIWDIxM2RkRGJQc1RyVmN0Q04zdGMyT1kzZlk5TnZFWTFHZTBqOTk1SWtTOGtsVDdQT3Y4QUdmVDhpWjNjb3JoRGw3ZGJzKzBsampFb1d2NzN2LzhBd0hySXpSNWw1UTlHSVF0RWlNQ09NMjBiVFlLQW85bEcwb29aV2pSc0VrTkNRb2p4bVhBU2k0dnR2dlViSXhFaElRMFVVVVVWcjAyTGFscCtDOHV2bldxODJmOEFUUDBiMWZuaGk5cDVHaEhqVjZ0SFVZVmxobnhTeFQ3bG90VXhNVEV4TVhoYVhvamMyV1BXOVB3czZySHZ4eThpNzFkYVNsYms3ZmJqVUpLYzBNaDl0dzVrNURmZStCNmZ4LzFJY0dKK3BuajJTelJSSGx4bjdYM3JXdmlmOUM5TCtHVVJESnhzencyeTBlaUZwRkVJRUlDaWJSUkV0ZHBSUlJGY2FORWt5aEx0V2pSbHhiakpqY0g4U2lSUWhhSkZGYVVVVnBoaHVsQkMwL1A2RVZlc0ZZMmNzUmRhUHNTMGZLNWpLWEkzVG5XcjdKbzY3cHZXeHRiWDNJV3FFUkV4U0V4TVdpMFdpV3FYYXpxOGV5ZmZ3Sm5CWSsreDZSR05qK0J1OUVqb3ZDT29udHc5TXFTRytQVjNrWVdSVUQySk9YOVYvTHROcHROb29Hd28yNktLUFRpUEhFMm0wa2l0S09zZ25qMVFoQ2lZOFlvaVZhSkNpTkNSdDBvclNJK3h4S1pSV3NTdFp3M0dYQzQ5MTZJUWlJaEMrSEJIYW8rQmYwV0owZnJGOW41LzUvVDkvTzFEMHlMaTdKcWg4REYyTS9sT241N2tMdFRFeENFeEMrSjZzNnJIdnh0Yy9BM3o4Y1I5OTlzSW5UejJaY2ZLNnJMdXpZZnJQTEhIRlpKOVZQSEZSTEhxbG9vKzcrdWtiRDB4eHJTakZRMk5jNjNvaGtZV3ZCdkdRTW1yNE9ybi9ySG9oRVlrWUVVUkZIU0pFWkVmRE9EZEVsS0Fwd044RGZBdUwwb3JTU05wUldqV2xjT1B3b1FpSWhmQmdodWRINW92NkhsdlZVMkw2L3Y3L3dBL2p2dCtwSVkvcnRKK1g0UXZMMWtaSTdvOVZoOUxKM1JmYWhDWW1KaVltSmkrRjluV1l0a3ZnZm40MW92aFJGRDRWbVBxSlF3eGYrei9BQ2ZiREhQTkxISGFoZlB5VTlmVHM5Tm9vMmFiVGFORVlXTkZFWThGY1NpVGhRdUNqWXpZMGJMVW9pMWVrTGdaUExFUjRsSjAzbzJkWk81YUlTSVFNZU9ra1JnS09sRG5GQ3lxcFpKTTNTRzlWQnMyTVVEMHpZemJKbTBUeUlVOGlGbFFwUmwyVnBMalQ4K0JDRVJFTHVRdVRISGF1eGZHNnZYem8rU1BuOThvL3dDdjM4aTllU3RPU1hoOGtyYzJxVW1xaHlQVjlqUDVEQjZtTmRQSmk2VW5pMmppVnF1NU1URUtSWW1JV3RsNlgzWklLZVBMQndsOGQvQWkvaVJIZ2t4RDVKSFM0ZUlkaTdveDRLRWJSd1lrSTNqbFlxa3BZbVE0SkVhdG5HNWZWeDlzekUrWm9TVElERXhtMjQ1STBROWdxWTFvME9JOUdLUWgrQkNhdVpMSW9rc3JibGs0eS9iUkloRXh4RUpFVVpNa01aL2t1UjVFaWltYlNreWtjRWF1UXZMNGZZOXBVUjR4T2NTT1VYSS9ESDhTRUlRaEM3K25qejNMNUVySzVGMmY4dDNHTHFUVHZkYVJ1cGFzbHdKTy93QmN2ZkkvY2ZtYTl6OHpYYXlYanFuTEZsOWFZNU1iN1Yyb1FoQ1loUFJNdlcrNXZUcThPK01sWGF1UDdDSUlrOVlPaHgvMmRQbHJKRjhJb2E3VjNxNGtuZW1KVzlxSGpHcFFFcHNoam9sQVVDV01qeHBJY2VXcmpGMDREUS9hTGxESlEya0o3V3BXTWZLUmtnT0hEUEFwRzgza3BwRXM1TExLWFpsKzRqSEVnaENpT1VjYXk5VzVHUER1ZVBwMGxzeG9kZGtkcFVUWWhJMmpnUEdLSTRxbmpGQklsQWt4Q0hqVWpaS0xVOUtOcFh3b1FoQ1lpeXl5eXlQTGpIYkVYOUg5MGV0VWY4K1JsbFVjRFF1RW1obTYyZUR5a2g4bjVEZ1orc1hZOU92dzc4ZndMdVRFeE1RaXk3K1hxc0I0L3FYOEVGbzlFSWNkeDZDZVBGbGxpbENhYXN0OXZGYUlZakhBbFdsR0xqV1VTemRvOUh3MUxqeU1oNHpZNk1XU2g1a1BLcEVaMEtSZW1TQ0lOeGU2eFRKUzJqek05ZUtKWnNSTHFzWStxUStxYlBWbEkyc3BJY3RadW90MjBRaVkwUWdRaU9idWNKVHlReHFKMCtJWTJpVDBSUnRaV2xsclI2dldqWndoTVZWS0JlMGhKU0hFM2ZDaENZaE1VamNiemNiemNkRXQwL3o0VVNTV3Y1M3ZUOTBRK1JlZVVJZTRYS0doUldpdHkvSEpJM1VjMGpnaXR6Zm45N2NoMVdQMDhud0x0UW1JVEV4TXNUK0g5ZWpPbzZjZkd0bC8xa0llcUVZL09PTzRsaGhNMlpPbk1PVlpPMktHaHFpdUJlWXBESkswb0NReENlalJ0SzF5b2l4RWtSTE11TVE5RXh5YUZtTXJaNjBVVDY3RkZTL2tVUHJac2M4OGh4eTM2WjZjRGJBNEw3VWRVNmdSUmppWTRrWWs1bi9FVUpjNGxLc25sb2EwZ0lvY1N0VjRZa1VWcGs5cVBPbGFXYmJKWW1pRTJPSHhJaWk2UFVQVU40cGl0aWpJV0tUT2t4K25pMGlMdWVpOHZiV2xOeTV2eTZwN216eVBndlR3UnErYmlTOXlaWWhPeHhSK2VCekZiRndueUtORzFKNUJuQW5SUDdQUjZQUm82L0h1eDlyN0UrMUNZbUppWWl4Ri9FeG1iQ3BEZzEvWlhhaEVEREtvdU80dWpxZWwyRWVxcDQ4dTRXaXFyMHZUSEVnTDdTOEx3blVrTVhhOUg0aDVIbzBiaWFGRWUwMzQ0ayt0eG9uMXN6MTgwaVNrei9XajJHNURrMzNyc1hCMU05MDBRUmpSamdTbVZ5Uk1VYmUramRFYjBUV2lFeG5GUFJjRjMyV1pKYmhlVlEySm0wMkRnWFJTa2ZUNFVKRmowUkRwY2tqSDBoSENrS0JHT241M3ZScEpQeFloc3RraFk3MDRmYTdTL0JsY3crMHl5MktSN1VjQ1J3aVhpeHUxeHZrN2I4THlNazc3NXE0NVk3Wi9DbjJvUkZpRUw1R1dJeVJVbkxHVGhYOWRMdFJGR014OEVDY1BidXBTaEdSdGxCNE0xNkxrcGlSNE1ZNWNKOWtselk5V2J0R0xTWG5SeVE4bER6RHlrK29TSjlSSms0dVpERW9sRFpLWHpJNmpKc2lSTVVlWVFHOU4zdEZLejFHaFNzVDBXaUYyTWpvdXhzWXZEOExraDUzeFM5WWMyV1JzOHJ2UkdIRDBVWlNNWFJ5a1kra1VEZnh1anVvb2loYUx6Mi84aTQwL09PendYd3VYV2xPV3Y1cnlXT081Sk9rUGs0WnNzWHRYTEd1V21QY2lNcTBlaXBRZndNNjZGVDdsQmpqV3FZbjJKaVloQ0Y4RzFzOUdSNmRHMkk2dmFlbVRnUEh1SDB3K21raDQ1STUvb3BDalhhaEVDQmpmS3MzS2NKYXVoT1NJUzNsU2kyMmhURk1pMlJrWHhadkhORzgzaVpZNTh1U053L05tODlSRStwakVmVm9sMUVtT2M1SHUwMm9XMDN4UkxNT2NucCsvQyt5VXRrY3M5OGtSUmloeGIxc2NpTW5iTWR0eXhVSVJ3TFJGeFNuSkpQU1BsMVk5SDVYbGx0ajQ3TExFTDRJSDRvT1R3ZEVZK25qRVVCb3BYa2svVjZiTXB4MGlmbEMxODZvNWszVVJWdGl1YTVpbWxYSTFRclJKeWVqR21sbytIKzZmdjVZMm1yMCtwK3FtZTFOU1ZON2gxdFkzWkcyejlmd2RkRzRkc1BPT01kdWV1MVBzUWhDTEVYcWlPQ1I2Y1lEazZzdTJzYU5udTJjYlpIcHMyVVB5c1JsaFNsR0k4TVNXQ2h3YStWUkVQdFJFaVErMFNLc1MyUEkrMUN5elIva3laNnFGT05iejFHaU9XUXBtOUhxSHFNM3MzRyt4TWVWSWwxVUVQclQvQUNzakhseXNia3oyRHl3UTh3NXNzczNGL3dCSnlVVE5sMzZSTVViRTZXUFJzazI5T25VWXFmdWFsUXBsbTRURXpjaWJVWVpPb204blV6V3lPYWlNNHpOb2krRndQazRwV200MmJlN2tWaWErQ0ppeE9aaHdLSkdKUXRNdURlcHcyU2k5c3NHWGYySjhhcTBMU0tWcWJ0L1pVTHp4ZkNLYkVXN2E0OEZIZzVxMHgzWDVWamxxbVVSUHRvM3dwRGxwVHZzVDAvZmc2aU5xWEQ3SU5SSlpSOXlZbnFtTFJDMHN4NHBUSVJqQWNtT3lLSlF0YkRsRWsyVTlxYWlOalpHQjZld2NiYng4eWlLQTRSWThLSllCNEpEaEpGRkZGRzAyTVVFVVBTK3hDRVJaQVh1SUQ1VS9hMlZYeDJiNUhxelBXa2Y1TWg5UkllYVE4aHZSdVI2aDZodVp6L1NaZmRQSW9ySmtjOVlJeFJvanpKRDhTZXNIUTVjSmwrMU1qRlVoRkdESHRXUnltUHB2YTQ1Tnp5YkRwcDdJeDJUaVB3YnRwSGN5WDFmd0x2aXJmVGRLMllzU2liVjIwWmNTbXMrT1dONGNqVGpMZEdQY2hEMWZEaGJSdGNUeVZMYlNaVkc0bW1MR1JqSnIzSmVPeFJ1STN5ZUJ5czNHKzlIR0p0T0ltN2kreEQrQjZaRHFGV1Q1azlFSVRFOUVZZW5MTnd0ekl4SXJhTmJpTUJvazlwdWNoanhjU2hUVUd4VlhweE5tbXcyU1k0UlVwd05zNFMzMmJZRHg0elpFb1k5WDNvUkY4b2dSOG1TSHFSbEtVWkoydm1ZeXRLL3J2c3NsT2lXVWIxaVlscEJjK0NjbkpTakdNZEZscUc3Z3h4bEtJbVlsdUZGYTJXV1RVWm1YRExFOERtbmxmRG1pNUNYTWZENUpVaVVoYTJLTFo2Y2hTbEh1aEJ6ZlI5SHRJeDdVTFJtYkVza2NrSGluaC84QU5mRXZNcVFwN1lZbGJ5VElVeEszd2lNRlc4OXduVGk2aTkwNE5VZUJ2bXVGYVdxakZrem5TeXg4RnN2dGpYWWg5ckpuVkwvWjg2a0psaVlwQ1owM1Q3Rk1pVnl5Q0g5a01jZHdsN1Y1WGhjazQ3aWNPSEJGV1JHNUNzbEoxdDRjQ1VGVTRjMDRsMk1ZOVg4Q0VZL01SRUhvakxoam5qVXNXVHVYYTlYL0FGMzJ0bGprUEtOMzJ3UkR4RVdubDZLSlNSTGtWQ2ZDRnlZMlhaeWVDVEhPai9KRm1aank3MWxyZGltT2ZPNHg4a0NjbEJTa05rT3hUVktaSnBucEN4TWNHaWpGaWVTWFM5S3NhUzFROUlpMGVuVzRWT01mcXZIWitpS1d3akc1enJjNzJWYnJtNlN1VGFhTjIyVVBGOFpWVGp3OGRPZTFQRG9uUTliMWw0MFdyMHFscDU3WDJzWjFYMmY5Q3hURk1VeitQNmJiSGJaNVBzSWpBNFJ4YUd6Y09Sd2ZwS3grVWgwYlhlMzNORkZzeVNIeVRYRFVvcHE5SjhOaitKTVRJRVNKRVRFUk9wd1J6eDVnNzB2dFhlL2lXaitGREhwWnVIa0paUnUrNUVTSXZDR1RsZWlWaVZJWlVJd3U1SWN0b3BXOFVpME5tUnBSMnZJUXh5SXdOaVpsaEtjSU9abjRtbXpGWnVqRlpNaVpjcEVZMXJzbzJIcEkyVU1vL0JxM2ltOFVzWFd4TWM0UzdZTFZqbUpreGVOZnpYOXNYbi9wMWM3Y2NhZC9pcTM3WEtWcVNMYUZHNFhZMXNqQzR1RDVmMi9PNUNiV3IwdlMrejhmYTlHTVpJNm5tV241L1EvaStpOVFSWStSRks1UGpranlVZmpRNHF0b3RHYlJ4RkJYKzdlR2htMG5DaVNhUHgrNVRnUmlaSW95UWNSaitMcHNXVE5QRi9GNUJmeHRKOURKSCtOTTJ0RVJGblY0dlVqR2RyY1gzWHJaWTMyc1hhaEQ3M29tU21oNUI1VVBLT1QrRkVTQStDT2o0MFRvODZVTWlianpKRVU5c1ptU2UxUnhTeVBIaVNNcjJsenVOMGNsV01kczJvMkk4SHRvU1pUSStOSitXaHdHaXVXbHVjZVlTY1hoNnVVVEhuak1XaTBjaHlHeHNiSStPNTZOMmJ1RjUvZnRERnlUdUxTOXFpa2NEbFJ6cGZITHcrblRsR3BFdHF3OHgwanB0MDV2NUgzdlJtUXkrV2hvZWlSSlY4djhiMG4rUmtWUmkrVytkSTNyRmMxdGIrMUZubHJSdEhrb1hueHBiMFkzeHNSTlVQUnhXMW9vY1ROaCtMbytrbjFXVHB1bWgwK1BiWnQwMmtzZG1URFdsNmRSaUUrNjlMMHNzYjB2NFVMdW9sSkVwcER6RHl0bHM1S05wdEsrQ0pqOHIyalh0TWI5MHBiNVY3U01XMTRHeHhVY1c0M05pMDNNZ1FoN25QbjFwbXpkTFpac2FPUkZsbGlZM3BIRzJSeHJTaVhBaVhEeVMzTGFVYlI0eVVSSWNSa2NqUmg2a3h6M0t4eUcrR3hqRVIrcTdQelJGVTRSM0g3K1Jka1RhZlV4K1AyVXBTUGVLcEdRaS9hMnBQRDkvcTcyT3J4L2tWZUx2NXVpN1duN3ErNTltVWxBOU95V0JiWkRJR1R6OGZUWVpkUm13WTQ0Y2JIcitVMktITk5EU0tHZVhSWFA1MlBSYU1la2liUTNRenkvR2pSbXc3aDkrTEc4bVRwc0VjT00vZXljYko0ajBaTnJwWkgrSWgveCtHMTBHRS93Y0ovaDRqL0R3a3VoeE1mOGNaT2l5eEpSbEI5cjdIMm92c3NlVlJKOVEyT1VtVTJLQXNac05oc05odE5oTENTeHVQZEV4cjJqWTlQeTJJeFpOcW5MY1hRK1UwSjBKTmpoc0Y0ZytWSTNLNHg0U3NnbFRKRzdhU2R0UmJGRjJvSG8rMk9Qc1JrRlBtUS9QNVE5R09CT05ESmZaTnhPbnowNFRVa3l5eTdLRjRqOWRmMWFMV05vZjJpK1N6OFVsVk9KTzA5eVJhUDNxREh0YWEyUnlOSThrWTdvK1JINCt6alZPdXhuajRXTWVzL3NobVNSSmNzUkoyTHg4TkhRZE4vajRtNzBpck51N1ZDWEhnZmdsZDFyK0xoYVViVGJxME42eit2NUt5U2NDVk5QeGQ2WnNWajdZUmM1ZEIwZVBwNEx2WlJSV3RkbEZGRW9Kck4wR0dabDZETkFrbkhzdlM5YjBzczNDa1BLa1BNT1VwRzBVRFliUklTRWlpaWphYlRhT0JQQW1UeFNqMll5UGdqRnVUMDJlMUlwa1VNUjVPU1JDZnBrc2twdUF1Q01Mai8zamtiamRSdUdKRkcwV09udEl5OXVqOEZtUjNGZmJKSGhqU0VoRkM0R1NSUFZlMTRjeENhbW1NaDUweHZUODczN3VuV2tkdEx4N2E4UzI3bEI4N3R4anJidWpYbUZmNjVyakg3NVQ4dmtza3FHVjdmaVEvaFk5V2ZzU3pLTTJqTnZDSmZEL0ZkTnZrSkZiaml2QlorRjBXTmxsbGk1UEhhdkQxWklzZmo3R1FkbDFMZHlmOVNTRU5XZFJpN2Y0enBaK3RqRnEvbG9vODl1VEhESXVvL2pVekxpbmlsMjJXV2JqY09adlp5eFJGRVVEYldtMG9TT0tSUnROb29sRzBjVGFaZW5VaWNIQm1PTlJRdkxkeVdrcDd6NmtlZEpEMVpIQzFBU1BMY21JVE4zdDNOdFNFeGVCeStCZUdTOHVUMWlucGQ2YmZkSkV1Q1IraWRFTW0wakxldEl1MHpHL2YydnpxcE9wUjJybHBQMmVEbERseXBjWTVKTnl1TGU0bFVpMXRpekxLTnRxSjluRlBmTDJ5eVpON3JqUjZjbGRxMThmQXlXc3ZGOEtmRzR6RWlMcE5qZEovRGh4UE5seDQxampIeFhINnZQZ1hsZGpzb29RbVJZaTlGNXNUNEhJY2h2UkRrTjJlWlB6azVJdmpuZDlqOW1UT294MHpwZWt5OVZMcHY0cUdJU0Z3eC9OUlJYYTlINHlZNDVJOVQvQUJqUkpPTGJMR3h6TjV1TDFSRkhwVFJEREt0cldrYUs1U0ZFMmlpYlRhVVZwUlJSdE1tSlRVOERqUGhTVlZwR3R5TWYzenl1VVRGdEovZWg0NGVsQ0p0RzVVbHFxcXhjdDBzWkhrVDVoNGtZK05IMmZqWlkvRWhuNEtKUTRqUEthTXNlSjlrR1ljbXlXa1diaG9Yd2ZoTlV0SnFwUUpSMnZocHBudHFOTWN2YTVXb1JaeGNVNU9tTisyTDl6UDhBbnVmYmZQd3NiTDBtK01uZ1V4KzlUR2hlWmZGL0U0Tm1FVlZhb1JJWHRHTXNvWisrUzNTZE96Y1hwS1IrbEltT1E5TEh5SVl4K09TeXFic2RiVjRrdmJnL2pwNXBZTVVjT1A4QVZFbEZyc1hiWGM5S3JUYnBYZjFQUzRzNjYzb3NuVE45NkVqRENvYjlrZlZuZU5iNFR3eGE5REloTnhPU01HeFk1RzBhUTZQYXhtM2pzb3lMaVhuc2NOa1hwRGttNHFJamJ6Q0I2ZENoektGYUpYSXJSeWRzd3VtMWJqSGpGazNQWU5EMG9aeWJiTmxFaVJXa0NFU1AxclNLOXhJeXhHUFZNNmJKYWt5emNiekRMZEVYY3hEMDhpWWh4dU1WVWVHYmR5cWs3aTQ4TjVKRzY1T1hBMlJlMDhrbnJIenA1N0VQdGZheVJrZkhwdHhnL2ErWE9YdWNoc1VodXlXa244UFQ0bm16YlZHS1hOOFZaRzlYby9CZk11VWVFdVc2U2I1c3ZuY2hHN2pjYmlYSmRqdlJJZWpYTjdHbnVHK0Y1OEp4NGFPRWROajlXY0ZXaTBmSS9QOEFRUnVMMTRPQnJza3JPdC9pa3ljWEdXaUZHeWtKMFlzamN0N04zT0xZVHhySWxIMloydHZwb2pnczlHVVNPMkpMYmJqT1QyMGVSOEMyclJqMFpsOFB5aEVhSThPVXR6MGp3NVNLRkVoQTZmSFk4WW8wVHhXdlFaNlp0NTlQaCtmK3ZCZk9NZ2lHSmJ0SkNJbTAyQ1JLSTRjNU1ZNEcyaUJCT2w0MGttWmVCdm1ZNmlPaGFJaExhMTd4eEtvWjB6NVh3dmwwUWx0UExFTVNzcm5hWEdEY2tpVTNJV05LVWtjSEJscTdzZmN0V2ZueE1rSmJsSzZYdGk1VkY2MXdQNC80akQ3V1JHTGpUOVdzblJmTGFZM3hSTHg1UEttUjE0S0dLWExZMmVWU09OUCtvOEdSQzRHaml2RVd6d09SME1hNmVJaUo0SHF2anJnODZJclJISlJ6bzEyTTYvb1lkU3MyR2VDZlloQ0VJVG82U1dSbVhFcEp5b2Q3ZW1uVWZSVWljSkd5TFBjZTFqMnlpNHlVaXV6S1M4a0dTKzJtS0c5NnhRakhEY1kwb3FFREpHbUtOazF1bEtOU2t6OWE1MnNyM1k3SThINHh2V0E1Q2ZZeVVFVGdRSXNiOXRqWkZtWWRrM0d2dEg4MVRPa25ZMFZwRmJTTDdWM2ZqRnlMeXBWcHljN1hiYW1TNUxKU2JkOC92ay9YcCsvMFdNbHk3RzloTm1VUTlOM0QrT0szUzZmSDZlSDhYMTh2aS96VGpTVDRiRmJId1B4NWlrU2R2OVRiTDl1a3BGalpaeVIwODZjQ0hMU2VrMEplNmZ0YmxhNkxucFVSRTZHNytXdFB6UmlIbzJLUlordEhJMTI5WjAwT3B4OVIwODhHVFZDRVJJWW9vV09LbCt5enhpUjJaai9GZ1Y2Y0U1bUhneWlvK3oyY1AvWkZvWTljdmw5dTFla25XbVhiRWpwQTZkR09IRVZSTEZ3c1NNbU9kNE1OR2FLdWNCcmo5bEtOdkZRdk80VWlURzlHeFRGTGx0RzRzVWh5TnhLWEdOaWtKb3RXNThYN1g1eURLRzI0OW1DVzJkNnRtS1haK2kxaFYvdlpTSFpZeTJtcHNvb3ZSaUh3ZWRXVnc5TnZPbGwzOExHeGN5NHVWRTJQbDZQVi9GL0hRM2RRNWNOMmY4L2tUODVIWlZFdUNjamE2YlJWa3R3bFMzTnVyWStYTVVpZkJHVjZTNDFYaml4c2dlVk1mMi9mR2tuYW55VFovRVpMNmY4QUY4YTd2d3ZUenBmRVI2UHhvMFNYWXpxdW5oMUVPcTZXZlRUUzBoQnNTSVlKU0YwOWtZYkQxRVBOT1QyYzQzNlU1emtTeWk4Yjl5WEluS0EwSWdpWEpJWkpsODVkRXJYWWhhUk9talovL1RGOU1Cbmx0SStDUk4rMlRLSEFraVJHVEdSTG8zY05tOGNqY2J4VHRieFROeFpZM3pBUnVWY0Y2UHpObjZQaHZzZytjYzkyT3l4eUlUcVVHTFJhZnY1K0xWZG01N1RadEdvMVM3ZjN3bUxqU3o4N1c5V0xTKzFqSVZzY2h4cUdWNnhSTmM2UFIvQjBXUDArblpqVE9Ib2l6OS9iR3lOT1YwZmw4NVdON3oycDhHNDNQYndlUnlSRmpmTGZINnJscEVzdEh1YlF4c1hKWS9FL2E4ejR5SDhkMUhvWm9DN2w4YWV0Y1BqV0kyN2ZKelQ4cy81UzQxZW1iRkhORHFlbm4wdVRtUkRiRVhwUkgxTDNRejgrNllwYllRaXlGSVhPU2YwVVRtS3BDWWtQeDVWN1l5ZEorWk1iSWZmS3l2YVI0bHJFU0pDSXZpQzkyTDZZcGN6VzZVQ3FKZWMwcVcrM0ZpU2F5UTRhSDVjS1dOUmpHVEd5OUorRklhOXFsd3BDbHp1UHpjT1hNU0wxVEhNbElreVhKN052YjRmVHpHeFNHeXpCTzBoZHErSGpSK1Q5MWk2YitKNi9wZXZqVjZ1ekFyZVdlNS9hVWxXbGowWS9od1kvVnpUZnVUTFF2SnlSNTBYbDhra1JYTXBKTnUzZERwbEpqOXc2UmRER0tRdk1mY0s2Ym9YdUh3djJQbExocXhGanRtU1MydGlmREpNeWNxWXpvOG5xZE12NkNIcFZpT0JHMFYyMmZuNWU0cDN5Ymp3MzVXajB6WTQ1WWRSaGwwODZLS0VSWkh4SWFFdUlQMmt1WXBjdUtRdUI4eGxMMjVESmR1WktRMll2dm44clJlVzdrc2V3bDluR2wrQ1ZrRDl4eXFQcU13ejNLUGo5bkN6cTNTd1NUVzNtTG9maG9hNWsySWJQT3IwMy93Q3FMMHRpbng2aHY1YkZNVEV4c3RhU2ZERlhlekJMM1dXTmxtTEp0bENRdTZKK3RlMFJ4cTlIcXRYcXRPYjBZankzclpaK2w5LzdNeVBhb1NKTzJ4NkxUOCtEK0loL3MvN0lsQ3M4a1VONnlseEwyUlQzRTVJZkI2bkZ1UTJrdDFSRjlvcmFTbHl1QjhhUkY5dVQ4L2Q5akhWL3JHaUl4eXRNelI5c2pKNS9qZXI5R2VQeC9TWGw4RVNXalp0UENXakd5TDVrN2E3R3RPcHd4ejQ4Mk9VSmlFVmNjZGlsR1JraktNY1RsY2NpVFZYOWMwZVVyOVNYMWswWk1nL01wV09SSXN4ZmJKelBzc2o1bTkwdkFqSDlweUlTc3h5TFppeWJURE5TMG5LbE52STRxcEw2UVZtT1JKWEthclJFdkJDYVRsNVVxZDJma1NUMGo5WDlXeUkvYkpQbE0zRzRjeHlMaWZ2NzJzaDlyTEhyME9XMUY2bzhvL2UyZTBaRjdXOUdMblQ4SHF4UGtmZFl1ZFBIeE15U01zcmZmZnc5RERaME44WS90RGpTTEVlTkcrU1R1V1dYTWZNVFA3aU5KelFwU2FhcFI1TnlwVU8xSDgvSEhqR3VLNVJ4UXJiODZXVCtubVRLdE9rTmt4a2orT3grcDFpMC9maDQwcnQvV0xSM2VuR2lpSkg2U1BEOGlHdVdOYWRWZ1dlRTR1TDBYbU0vZnUvMlNrdlR4NUhGNzdjLzlSSEpieFNZOTBuNGp0VGxsY1VTeU1iUXlUMHgrWmVSTDI5a1JuNCtCcXlBaERNR1JxV0xOdU0zaCswVXVjVXVjcmFJVFBCbGR1SXkrU1Foc1QxVWR3NDdaU3Jidi8xa1d0cnFVRGN6ZWIrTnd5K3g5akVKOXVPYmhMRlBmQlA0L3dBV242WFl1TzFhcmpSNk01MVNvL0IvRmsrdVIwbzl5OHNmanZTdHlXekcvRU9CZUVqeXgrSkMwbHhPZjFYSkxnbEwyUUorZksvRVBhamM2bXhlWXFpYmtJYUZ5VVFpcWFPQkxoMFNjbXYyY3VlWW1TWnY0bElmaVNQNGovOEFjdjZ0aVFob2liZWYzY2xwdEdQa1l1WlB6cTlPczZiMVUxVE1hM3VCa2xKWkZta2xraEZFTWxLSE1YN251aktUV2FMbEtadlRiSlRzYkdONlE4dnZ4a0hzbU4rNzFMS0VKY01zeFpXaVdiaHk0cVJqSks4U0c3VEVTWTQxRWtZVW1aUHNMblNFcWVhVzVwMmxwamZ1aStGTFkvTFgwSXNUMHExM1BTeTlMTDA2VE5zbEZpN24zZnU2dmxaWFk5VjVmd3VKbGx4bGxiRVNqWHpkQkhmMVdieXVWUDY0L0hCSFI4a3JaVkhnNUplNGdpWDJvcWp3Um43VW5LWGg1WDdZTGllM0lRanRIdDIrNDl5RS9kR1NKU0l1aGpHUnBhSldaVWJXZmt1Vmw0a3hvL2h2L3dCYTAvTzlMaEhuU3ErQzNadTVRaFdjYU83Unpja2Zrdkg1Vm41cjFmVDd4cDJmdktsR2Z0azRTV1J0bUxQWmwzV21xaDVlU081MUVrM2U0dDI5R1Iwdmh1MGlTMnl5eFMwaDR4eDN1Y2RyU0lvUWpkN1JFV042YjdqQXh0U2k4YUpjSnk1UXh5dFI1T29xSkZqMFdqOFVlTks5cU4xSy9nZmMvaDZMcU55UkZpK0dobEQxODZXYzJYcForTXZYOUg1OGZFeCtPcHkxcW5SS1Y2SWZ4L3c2dnFjNWpQSkh3V2hNZWpRMmZqc2dpVWJiSmVaS1c0VXBhSS9KT3lBMGszOVhSdDNOcXBINjU4ZmNhRlZ4Sk9pRVNTZXhJZkJQZ2tpdWY0bi9BUFhIVkhsNmZnaHUwYnFVZGFLZmRla3ZFZkRFbXphUlQwdlIrV2NzL1B6czYvQnh1cERrY0g1am5KU2sxT1Vjc3BZbTdNbVdRNXMvWlMwYjdFZU8zQkhmTng5NkVTOG9pVm94bTRzYU1jZmJDUHVsNDZXUCttYnBUbHhnUzNUOHRsbDBUZThXa01lNDhOakV5YVIrSjhEK2Q5aTdZdmErbHorcEJNWHgvaklvWmQ5amV0YXNYR3I3bjJMUkl6NU5rWlMzUytOOTM4TXVlb0V5bm90Rm94bGN2eHRhU2lTOFA3UHorUDdjRWpiei93QXF0MGw2YmZ1aWlYS25hZG84eWNtUWpaWnVKVkZwMlNaS3FuNW41M1Biem96K0kvOEFhUGhhL25ZK3phVUtMUDNlejk3OXduZWlhSldmaUpJOEZObEMwWithOWRnOVBKeVdSMVVxSGxISWUzYkNld2NyN21RSWlHOTBzVWQ3SU9tbVI4STh5UWliVklZeVNaaTVVaUxONXVGbXFHK3lURXg2eVl0SHlidGdtTWZpTEpFRXRpSkxaSDljZHN0RjJMdVkreGQyTEpMSExwODhjc2ZndlRtOUZxeGVOV0x3TVhZejllbjYreXRFakpMYXVwemVwTCtsL0RmVE55bHdSMFQwdmtsSTh0SThqNGw0VnljZDFSa3lkS1ZDVXRFcUc5RzJWN3VGR0hMVHVIcGpqVVNYQmtXMTcyWHRQRVJzakszazVISjdHMVV2cWZ3My9ySHd0V1B2L1kyeVlycTYwNGFRKzNrajRPRUtrT1EyTGd2Um43eW5FWSt6TGpqbGgxUFR6NmZzWndOMmhTRzlIMnNqNTdZakduR05zUmpKTmFLdG43WkpjUTRKVUpqWTJJYkdSR0kvTmxpR3hqNTdGNTIzcmQ2Zm55UHRYZmh5UEhMQmxqa2lub2hQdXZUanVXbGo3TDBYbnVmYWhzNjNxTjdFbXlPSEl4ZEhsUDhBQ3lIK0RsUDhIS1BwTXlIaHlMNC80YjZadnJidkR5bDQvd0NzWWtPUStZdzhqT0NjaTZncGJtb09STkpTaGQvWk55RzNFVTJvdXpFWkhVM2JINWlTZzBUNElyMnl1UzhOKzVybVdRU2lORGUyVTQ4dDgvbVFiOXY4TkwvWWhmQkxTOUlvMm1RNFNkU1cxb1hsOGw5bmd1eEcxVzBodWgrNFVUYlo0UHRvOVA4QW12ZEx6K2FTaXBRNnpwNWRQTmFONk9MbExhTXY0RjVXdFE5U0cxU2loRThqbW80L2F5SXZHbXppdXh4SVJUbGxqNy96UkRFTWNtTHgrK1VORDRJMWVWb3h6cURINGkrZm1meUl4WlpZMzArWlpZcGkxdnRYZXRXZm42ejlFWHJmQTBVVnFrTm5WNTVTTWZTdG1QcElJaGdTRmpGQVVEYWJUYU9DSjlQQ1JrNkNETW5RelJQSEtIZi9BQXBsWHNSZzBuUkQ2L3JRMFJSNEh5UDdaQ05NcGkrdms0SmZaSmljbTVlNGxJYmlqSHVsa2xTSWU0MnBFWHVVNUpSaEZTaE44eThWeW83WE5KaWp1Sis1eit1NWJINDNNYkdmeERycVkvWmZDaGlKeU56cjltdVY0dDZVZnVyWWhNc29wYVZRck9EaER2ZEkvRjVsNWZibXhySmpuRndudUxMMGNtTzlIbzlIbzlJaUhGcldVM0lYT2liRnkwUWx0MGFXM2Q3WVJza2hLeVhEUjRFTkM4TVhoNk5jTVhnaEhjUGpSOGxqMFp6UzFYeU1meTQ4a3NjdW02cU9RdXhhV1g4eStIaDZ0YXJSdWpObGNqSGpJWXlNQlJGRVVTaFJObzRqUTRqaU9CUEhabDZPTE12VHp4OXY4Ty85c2pOY0pZWisrS3N5OEdONkkvRXFUS050TitYd3h6alNkU2swMFdsR1AyZVQzUmlwUGFrUDJ1N1RsS29yZ1VVeFMyd2JUV1ZVSmphdjdSWHRqTisxeVRIeVAzRFkyTTZmSjZPZUw1USszOS9kR2ZrWWszdFVJOE9QSEVZcGNYbytSeWRIRnMvQkc0WGh5MDNIay9iNFArVjU0SHkvMThQWCtVeDdNemtQUk12VDg3SDJZL0F0VVlJcVdpTVlucFluWXhPdFdJWnQ5bzlFaGlKVDNKalkzeGJXalE5WHB2OEE5Y1Q4L3JVemJJMlNHbnFuUjAvVzdUSGxqTmZEV2xGZDEvRTMyVG1vckprZVI0c1JqZ1JpUmlKQ2lWcFEwVU9JME5EaU9JNGtvR2ZwSXlNdUdXUFgrS2xYVm1XRytPMXhsMG1UZEhQajRpUmtYcHlNYkoyejZqanp0SjdVOXlMdHBKdlo3VnlROHhodGxQM0NpOTBveVJCa1hSSWk5c25rVldOMjBybHRZdkxuN1pYdWtyRVNNbmxqR1lmZGloOGNUODNXK1hKV0tETjlEVVJxaVBJOUphUFh3WG9wNjhGajVKTVhsOEo4RjZUNEswNnpHOG1BaEhjT0ZGRjhhc2VqSHJoWW5Xa05vMm5wRjZ3SktwWXFiZFhDZTBTc1lpUXhFNWJpemQyVnovMWtjVkZlV2ZtakVmdjdPZDZ4K1pqRnJISE9SSHBac2owYUYwMFVMREVXSkk5TWVNOU1lR0xQOGVKTHBvajZRaml5WTNpNnRvamtVbFpmZFpaZWovcFpjeWliWjVYandrTVlvaVFrTFd1eG9hR2lob2FHaVVTY0xNL1NFazR2cEpiT3AvYU0yTXhYQ1dMS3BycU1UZ1luN1NKd1B4NU9JbkxiNWw0VmpoRzBxSEhtRWxKeGhhMkpIL05ibzdmZktFMUg3RzVFV3pkWXBtWWM2SkNxbS9kZnVrM2FmdVZFNVdTR3hzWjBFdDNTWTJMdVNFZnZob3grYTVmMHhEa3FjTGNvcy9FdGI1Y2UzZ3MrdzF4U1M0T0JJdmxlVyt5WEorRXZIV1JycVVidGFIb3g2dldIMlQwZmsvYWNaUHpFajdXNWJwQzB4VG9rOXpncmVYMjZJcDB4YUxTUTBVSkRONzJMblI2clJqRjgwbnBIRktSajZReDlQRkN4R3cyRzByU3ROcHROcHRLSlJKUU5zb0dQcVpSSVpZeUw3N0xPQy9pV3EweVpZd0hsbmtNZUFoaUl3RkEyaVFsclhjOUtHaG9hTXM0eE0wZGtwSXpZVk1uamxpbXBYRk1sd0tCanZHNFNVNCtuc212TTU3VGNtT1NTbEtoVDNJdWlVUy9mR01CcGlieWpVWWk5bytJS0xJSDF5N3JYaFAydTZpcmk5MUc2NFI4c25HMGIxYy9FYXFVN0xvZWowL2hwM2pqOGE1SXZtWEN4dXlVdWNjTEhXN2NuRnFpSEMxVW5vcTJzV3QxcCtzb3BpUDAvSUsyU3FpeG44b3E2c1FoYVBSNlB1ajRGcktUazRiUFJocEVaR1B0RUptUDNQTXVSUlcxdWtJbFF1eGFSaU1qUFlYWTlIcktLMi9JaGpJWTNONHVsSVlhRkEyRmFVYlRiclJSdEswb2FLSEVjQjQzRng2bkpGNHVvaEkzWHBlbG00dlM5TEwrS1UxRWxrbElqZ3R3d2tZQ2dLSlJSWHlQU1JteWN6cUR4VGVUQ291NUluR3pIL3dDVVpIa3BvY2pIbHA0OGluSE5BOGkrejkwcFM1OXRyM09lalZ5cTN1b2lyYzR5dWFGY1NNVzFHMFNSYk0yMU4xSVUyUWtjTVdORGFxTWliOXMrVWlGYmxkemRsMC96WCtJZGRVdkVPOTZUcmFoRDVJL1pSVnhrMjNGMG8xR1R0ZWNhNFBNbjIvbWxXYlhyZk5tNGl5UXVleDZNL21ZZXpSYVg4ZU42TFNEcVQrd3VWaWh1UERmbFMyeFpFZGJJdWg4NnNRdEZwUmpVWDJNYTBUR00yKzJpaDZWOFhpSml3T1Jod0tJb0ZGQ1JXdEcwMmxGSWVsRkZEUlExbzBUZ1NnUnpUeGtPdFRJNW9zM0kzRzRzc3Nzc1JaWlpldG1UcThXTVdlV1FoaGNpR0lqQWpBVVN1eGQ3NytvekRudFVNRHlqVkpraVIwL09GdXBSa2grR2tTaU9XeHg2aWRScWFTb2Jvb2t0cHU5MDViaUV6eU96ekhITnBTYm1sVGw3VWVwRkR5S1F5Y3lkM2pXNDJTa1dxaE9wWmQwakZ4amRJOXpHN2pMdzdRM1NReGoxNmZKNldkU0k5ejhuNE5jTG1QNTVVWm9uSnFVa3J5Y3hpdlpHUnM0cldRdU5QeGEzb3hlTldLMG1NMzhNOGFmeTMvaHVMMVdyK0JPbWhFcGJwRVhSbGpCTEY0K29tWGNuNEVQUjZSU2xwR1czUmFJbElXa0ZlajdVTnNRaExsK2ZoZmhKeWZUOUtReFVLSlh5MXJSUTFvME5hT0praFpQR1hLQXVya2lQV2tPclRQVnM5Vkc4OVJtODNHNDlROWVKTHJNYUgvSXBFdjVES3llZkprT2k2VnlNV0VqQVNGRW9yK2xuejIvQml3REpER1NPalpPU0k4cURQMmZCUGM1YnBveFo5aiswV1pSME43SDVsR0VSUk4rbmhRWEZXWlp4M1M1S2llNFVVU3g3cG1UM1NUT0NQc0p6Y0RGSmJwbHljbzhqbTY1R1hTYlAzWCtObjZ2VG9YZitGaVltS2lsdlVtNVpFN2h4Q0gxOU5uMVBPaVZwbjRmOG40VlJ4MnFrY0xUeVBoc1E5UDVSWDBpRjJ0aitIR3hDMGx0dEl4ZU9hV2kyN2NsSng1ZVJiUkxSalB4QzVhSG8wSkVrbG94dmlNZmEvTEhvaWNkb3RHdHVpNzdNZUtXUjlQMHFpUmhYWlhkWFpUN0sxb2EwYUdORWtTaVRnVHhqTEZPU0ZubWY1RXovQUNzaC9sVFA4aVk4K1JqeVNaZlowSFRlcExGaXBKQ1FrTDRXV05sall2SFoxT2JtWHRYVDRtbTVEWXhqSkhUOFpza1RGd2VWUTREd1JZK25XNlhUenZwNHpNMXhNc3JFNlM5eGN0cSt2M2ZNcFBnWDFyakpLbzN1bFo5aE1mdWxGb2x1UHoycUQyc3k4ay9ERnlTaTVTYjRsRWRxS1NTL2I3R2Z4V2Jaa1FuOENKZWVIR0kxeTJpR1FqSkVtSnZkdDV5TDNQNmp0RXRGNDdiMWpGalZhZVh0RTZiTDVjaGwrN3JlY0dxa1hveS9oaWhDMGpXNlZSYTRpS0toSitVV0l5UzNOYVBUYTVKOE5DMC9XNzB0Nk1adUdKbGFwTnRxaGZGMC9TdVR4WWxGTHZyNDNxem5TdEdob1kwVFJPSmtnUGo1T213dk5rNmZFb1JTRUlYY3RHTVkrRGRyZkY2OVJsb1hFWVJVU1U3MG9vWXlRK0cxdVNRa0xTeDJSbHpDalBqM0tVRTI0cTZSSmtmcnRrby9WUjl5anBrKzFXSlJhY3FnNWN3VkxJK1BiY1hKdWNpTDlzcmdPcEhDYXNmaHVpOUh5U0gyTWk5cjZYTXMyS1BsZU94YXJ6KytHZm1KSTJiWEdMM1NsUkNiSlN0eEY1VDNER1A2NnkxOEZjSjhmWVlxVWIxL1g1YkpHWG1EODZXWDhLRUxTTEZxaVAxbjdHcnR2bkdyZjdGMFBSUmRERktVQnNpS3R1MFl0SG8ySVk5Rk9LZ3RFM0ZzWHdKT1Q2WHBhRkJMKzQxbzBPSktKS0pOR1hIOG44Wmcyd2dJUXZpWTJTOFNkQ1l2Q1pIeVpjbXlNL2FvRjJLSW9qUXhqSkVqcHBYRHhvM1JkdmdjUjR1Y0F6UGlwdUNIaWlMRW9EdUJia1kvWXZJcEZHMlNqWXJ4eWZJNG9uSnlIYmFsc1B1MFI0SEgxRlZTM0lUTjN0L0cyOUg4SDhWbHFTYnRDN1AwVDUvUnV6bWx5VTR0dGlreHV4K0hHbktXa1NRaGxEZWo1MFhaWit2c2FvZWpaa1JsL3dEVDVFSmRpOEMwYmRJaHR0di9BRi85RXEyaUl5a294bnRUMHBpSWVOenBqMjdYSWIwaldqVHB2VmFyUjkyTEJMSWRQZ1VTS29YZDQrQks5T05LMG9hMWVyOERHTkVrTkU0a29tWEg4WFJZdlZ6WW8wb29RaGZDMk5qR3laR1pmdFVpREhMaVQzTnZtS2NoUkYyTVl5Umluc3lJY3FNbVZFWmtXSVF0S00yTGJvNGpxNDFLTzNpVWVkakp4bGUrNXFsa243NVNpb2l4MFpNVzF3Ymk1TDJ3amNrbkEvWU1sOXVkSitVbU04SWZZOVlTY0pkUG05V0NrSVhiKzZlSHV0RmtaYlJ6WjVjbHRQSkNscEZEOGlIMjJMeG9xMVp5TVk5R1pKY1MrM3hwRmRsQ0Y0RWZrdGlGSnM4SVRIWWhFUGM1S3BSMGMyUkY0Y2hsakkrWjBQUnplM1JFSFEvSzUwYjdIa1NJN3NoZzZVaGpLL29wYTNGRm00dE1ja04yV1ViZXl0R05EaU9KT0JtaFQrRCtNdzdZUVFoQzc3MHNiR1NKeUpURlBuZUtaam5ZNWM1cG1PTzRqeG85V1NHU0pFanA4MXd6NVhhOXhGcUlzeERJUW1KaTF6WU5qbEcxK2NublNWSVNzVVNVZVdxWE5YVHl6U0hKNmJsVDlRY3JmMkZ3T1c1cndiaVNIWlh3L3dBZmw5UEltSmlmdzFlbkhaeFJ0WXlQT25uUm41cS9nazdMRzlHTXlTU2kvUGNvbkVkVkVyVkxTdEkrRXVPTkpSY1hFZXpaQ2RTL1ZPY0JDU2VqRXhSZTFpODJPUzI3aWg2cGJ0R0laRmFvWXFVSnlHMk13WVhrZUxGdElSRi9TOGkwYXM0Ulk0bTBTYk5vMVJ5bnQzQzh5Vk1lbERKSWxFeXdNc2RyN3VtaHZ5NEkwa1JGOFRHTWxLbXlmQTVHOGhNNmVXNmMzdE1kNWNrWTl0all4a2lSTWIyc2p3T1VVS1c0VWpGbHN4eTRqSVFob3k0dGc2UDN5YmJGd2p5TkpwUjRjR2VsUzlHVnJIeFBleU1OcXl4TmpFdHFZb240K1V4KzRzYjdIMkpDaWRGbTNKTVF2aVhLRlROaXFTb2pHVE56SXhzbFNHWDNmaGZ3c3NzaytPdXQ5THJSdEZFb2xMVklTMFpRaEt4SVdNYUlqZ05XU2JiVHQvaVZrS2ttMkl4cGtlRytSdE9YZ2ZpSStCa1ZGeDAzOGZ0N2RGb2hhdGxqZkRscGl4K3BMRGoycUVSZjBxdlNteVRPYVNLRjUyajA1cmh2d1NXcjVHTWFIRWNTVURxY2RydS9qTWZPTkVSZkl4a2xaTk5HVWt6Y0tWbUwyWStweW5UUTJ4WFlrVVBSa3lSSW1SbFRReUxJeXFVT1JUTVVoQzBxekxpMk5sV0t6eXo5MmxVYlRiUlNTeWNxYW9xMDQreUpLRm0yam0zZTIyWG8reVd0RUlDUTdJdHhsZ3lMSmpRbUo2cnNldFVQWDFIWGtWYlpVVndMWHpveGVTVDdHUFQ4a3l4bVI4ZFd2L3E5MG5vaElpaGRpUkZDV2pSV3MrWHRPUmY2NUlVL2RDRGxKYms5MWpQMlVyaTdGNGx5UWh1MGVqSW1Uekd0TnNta1JWNnZiUzVsa2VsMmRQaDJ3aEhSZjBFUHlJaytCK0VTMFhMb2JXamp6eWg2dnRsRW9uQTZuSHRsMlJWdm9zZTJFVVJFTDQzbzRrNEdhRkdVYk9uNW5QTnRqMFdQMVpyaElSV2lXakdNWklrVEpHTEpZNDgvVjdTRDJrV1lwOFk1aWVyVnJKajlOOEQxYTBra1Z1anRSVkQ0alEvWVRFaHhvWmtGeVB3UFI2UFZJakEya0lvZW1DZnB5aEswaEMxWGZ1NFZNaytUanZyc1loK2RXeDZ2VDlsNTZ2bnArMXV0RWhSSVF0MEpHMGFXaWllT3hsRFIrY0hJeko1YUlzUit5OW9tbEtjb3N1VE9SNldXTXBqSE5qWWkyTFY2YnFMNVowR0hjOGNkRnF2bVd2Z2llUm4vQUNyS1BxYnlVRmRVU0tzVnhsT0k5SDJNYUdqcWNPNkxWUFhvNGJzdUdKRVh5dlJqTWtOeXpkTE15OVBsUmk2Zk1mNG1hYnhROU9LZWlGcXhqR2hqSkVpUXpCMUZFNGkrcWtKMmxsb3dUNHhURUxTU1VsT094cy9IcXo4OEgvVFNMNVpOVzdlbVRrL2EyRDgrVjRIb3g4aUZFakVoRVpGRTBWcDAyVFk0U0V4ZkZYTTNRcEVYUStkRzlXS3RyMVdrbVdQUjZlU1ROMnN6Zy9rSjFoN2ZJa1JRaEVleGtVSkZGSGdlajBRcG9XUEhNZUp4TXNHeCtFNUN5T2phNHR4VkkzSGxXSWUwNHZlME1Zb2t0cTBqcFpLWTJjYTRNU2hCZjFyc1FuejVjeUoreVFvSEExWnVVVC9tWE11VXE0WitVUFZqaU9KMTJIYkxYK1BoU3hFUkMrV2lob29hRWhJY1RhYlJGRkZhTWtNWklrTWtTSkVqRDFEZ2UyYWtKN1NEdHh5N1REbFJDWW5ySktSUDJ0ZDdHOUpSczhES0dsVFRLNFkrQ1dqZERkaVFvaWdSZ2ZpV2owV21DZEVXUjF2dGIxa2lLOUpLZTUvMGI1YkpjaUpDZkVpVXFmVjVmVXlkajVFSkNRdEtJOEZHMFVSSWpSV2pHdFd0WStWTmoyU01tS2paSWlUajdWcDdhczNhV0lqUSs1RmttU2x4cTJSUXY2UzBmT2lYSGxJNVAxSWZCTWkrZEpjeVM5dE84Z3ZxaHFuMjBOR2ZFc2tja0hDWkJYTHBWU3hrUmFyNWFLR2hSSEUybEZGZGpHTVl4akpFaVJJa014NVpZbjZrY3laNEVSbWRQbk1jN1JlbVZXVUlZK3hraTYwZWpKZUhxOUc2RzdGRWpFaEFqQW9vZFd4OXVMSUtSWmZ4WkZ2VVl0QzdQMGZ3dDhzWTlYNFJJNjdKc2oyTVJFV2lGb2lLNG9TS0YyTkRReXRHS0kwNGlZcGtrTVZ4MFd2dEZ0cE10cGFLcmx0RWVScW1uUkthRzlMMGIvcHZ6MlVRSDVGNWZFb2NEUXVFcTBrclVmQlprVmtQYU1ZeGowV3NrZnlXTGc2ZGUvcHpHUjBYOUY5bEZGZGpHU0dNa01rU0dTR01lbVBxT09CTVRFK2VtNmt4NU55TDBuSFc5UE9samxvOVh5U0d5eVVoazUwZVhHSkdCQ0JHSWtLQk9WTHpxdEdoSWZCaHljUm1LUmVsbGlQUGRMYUo2ODEyZnVqR1BSajFYbDZTZHY4QWt2OEEyN1VJaG90SWlFdEVKSDY5S0dpUW9rbzlqR1dKamVuQTBXTGtmQkhsN1MySys1UzJrcDlqN3YzNGwzb2ZsSGd2WG0wV3RPWW5rcWhvOEhtVDRpL0kwWGNPMWtqUERkSEpEWlBwa1lER0lYOVI2SXJWakdNa01aSVpJWXhqR01ZaU1uRWptVWloK1lUNTZiT3pIbDNhb3lSclMreHNZOUhZeVRHTVkyVG1JakVoQWpBakVVUjhhWk9YUXRFVU95Skt0TWVRVWhTRXhhWDhDNDA0MWZhOVd4alk5SG96eUpIOHRqYWwySWlJaHFpS0V0VXRLMHJSc1k5SzBvbHBXdTQ0SHJ4US9KenJ5TmtuUlp5S01tUXdHVGlYZXZtWGFpV3FlbFczYUZJY2pjZVJQaWRrWHhMeS9MZ1RkL0F5U1A1TEhVOEhqQ1l5SXZoZmV1NWRyR01ZeGpKREdNWXhqSDJSbktBczZZdVNGb3c1NVJNUFZKaWFZeXlReGprT1E5VU1sNWJKVEpUSlpCdlJlY1NNY1NFU0tFT0pNZkEySW9hNTFvVkRpWXNnbUkzQ2ZjK3lNZHJ2NEdMUnNmYXloUk52RW9SeTQrcHd2QmwwUWhGQ0VSSUlTRnFrcXJWajBqQ3hvbzJqV2pHSWVqMFk5RXl5eHZWZWIwb1NJNGlFVVNPb2ovVGFwQ1NxdFVQenJ0MHMvTHRTVHBKbTAvRmQyaS9hM3B5ejkvWDNNWi9JUXZGaU1KaklpRi9iWXhqR01aSWtTR01ZeDk2elRRdW9SRExDUmo2aHdlUHFVeU9STXZWakdNUTJTa3h5SjVDV1ViN2VuZGtER0xSbVJrM29pejlvYUh3YmV6SE9pTFBLSXN2NXEwZlkrMWNhMXdQZy9tRnpvaENQeGVQeUpFU0lEK3d0YTBjZWRHVUlvY0JvYUVob1k5R2NqOGJ6ZG8reUdPY2lQU1pHUTZHSjZNSUthMnNaUHhMaC93QkJ4b3FqZ29ZbTBYR2xxL1BKZWppTFN5ejhwb215S2IwOHR1MHVFeEQ3bWZuVmYrV044NFdZaVBjaGYwVnE5TEdNWXhqSkVpUXhqR01md1JqdWZwbnZnTExtUXVzeVJJL3lLUDhBT3hNL3lzUi9rWTJlcmlQVXhrOCtPSlBySUQ2bHNsa2svZ3dUMnp4R01YSStCeUp5dlI2V0x5aTlPTkdpaEt5SEJHVmlaZWwvSit0Nk0vTDBlajBvV2lGcFB4L0xmVFJDRU1aRVJFUXRJb1MwZWpyYnFvNnJSb3JSalF4Nk1aUlhCeWNpTVVWVUdJUkl5KzZPalJuajhDN1Z5VG9yVjEyVlJteExMaWpqY0lhby9UY1BUYXkyamNiclBhYmtQUk9oalFuN2U5bWRleVAyd014RUJkaUYzTFN0SDhDSG94NlBSakdNa1NKRWhqR01ZdkhZazJMRXlHSXg0dUZqU050RG9sRkRpT0p0TmdycVhKc0hHdEwwclNqWVM4blNaTnl4dmlFaWN5YjdGb2hhTXN2Z1loQ1ZOVEV5emNLUXBGbDZYcSt4NlBSRXV4ZmJkckZjSDVsZkg4aE8weUlpaGFNZ1JJaUVJUXZEMC9SUmVqUSsrUlJPSkpGSGpSb284ZGlSQjBLWkhJSWsrSnk1UXRNcXRQUmZDNHRLTW5GTHprbEVqQ3hrYUd0ZDlra1JtMG5UN2tKakZJY3JQSTFRaDBPTVJSaVRxL2labDhUOXVYQXpDeUFoQ0ZvdEZyNUVxN0g4YmxxOUdNWXlSSVpJWXhqMFhqUlFreVBTaXhVS0JFVDBaSVpJZWowZW0wYUswVWlPMW0wb3pjU01NOWs4Y3lNaG1Ua1l1MjlHejhqNHJTUWtTK3JSR1RSR1luZWx0Q2tKbDlpN21JWXo4WTJRMWVsa21kVlBqcUwzQ0ZyRWtSSWtDSWhjRVRIR3pMaGFWR3ozUEdObVBGY0o0M0UyalhaTFI2U0d0R2x0YTdGQ3hMUkVUd014NUhFeVpITFJhTVprWHVGMnhQMmkxc01lMkpKcmRwRmJvT0p5U3RDcWlNNkhxOWVOVTlMMC9OYjdYeDNzeUhXcXMrRm1CbU5pRjJMUmFydGZ3dlI2UFY2TVl5UXhqR01la2ZCMCtLeFFLR0x3SjZzY1JvYUhxeGowb3JXT1Jvak5NNmp6cGd5ZjY0Wk9KeUhNWWhpN09Sakl2bXpjZVJEMFE3cmUwUnlDa1dJc3Z2dlJ1eFNHeHlONkhQVEhDVEg3WlhveEVueDFVbGVTVzZXaUZvaGtTSkVRakhpa3padE9uOXhROGNSUWlaY2U0bkJxV05WR1VWSXlZbEVuMlBSakdNZmM5SXhzU0YyVjJzemVlK0tKUzJrSVdlR3ZkRkxsSk1wWFZGY3RqYm5Id1pJMFJTMnlyYis2dnVmWjQwV2pObyt4TXZWalA1RmM0akF6R0w0RjNONlBWNlB1Zll4akdNWXhqR1NIb3ZHS0c2VVZwUTlVV0lZMk5FdEhxOUs3WEhSV1Nqd1FaREliN1c0M2NLV2kxOG5nc1lqZG9tSzllZFpFVzBvWitVN0VJVFJiTDFzWXk3MGNpYjAvTG9qbVNKNW9pNm1KNmxqa2IwWnNxakhxTXZxUzFRdXhHTVJFNmZtZVBIVWVzaW9yQlBaT0dSVFdzbkgxRm1paE85TW1OU1dURzR2eG85R1NReWhvWXhJMmppVVVMVmlmYXRNbmpJUFg5MVh0R1FrWlpScUxqU281SHVySDRrcEVlRTZST3BIaU1sUk5rbzA3dCtOZk92QXhhYlZva20ya2J0Ykg4RDAva2Zyak9uWmpaRVdxMVhaZlkrMTl6MVl4Nk1aSVl4akdTMXg0OXhCVVIwdlZsbTdsYU1aNUdQVnNZeEhsdnRSTEdtT0xpMHpjV0tSQ1FtTHlYbzlVTWo0V2twQ2x3bVMwYUVTUW15T2FVU1BVUmtLU056SE1VemVoNVJ5TDBjaVdTaDU0anpTTitaaldWbTNNZWhKaTZXekhnelJUajFJLzhvbml5emJ3elExUis2SVIrRVdJUkZuUlNTeUthWjEwbHNzamw5ditYTGJIcTVNZWVXNmVXeHl0NE9vMmtaS1NKUVVqSjB5WkxGS0xhNVl4NlY3WHB0czlOaTlyYTd2MnRLMGVqSmVKZU1uZ3Z1UmorMElibmtxTXVOMG5IMDl6Y2VObGNFNDJSNEpjUzNYQWxvM3hIaC9CZW5QWXJvZndNZmorUStzVHAyWWlJdEZxaGFvc1RMSDhiSHE5R01ZeGpHTVpJa014UjNUU3BJV2owUXo5UWlpaGpLN0dJU1NLSkQxWFkrU1VhMVRGTTNsbGk3RVhwRVV0emJLMXlHNGJJdmxqVkRrUHdwcy95SlJJZGFmNU9ObnE0MmVxaDlRai9KZ1BPT2VSbnB1UXNRc1lvUk5pSTRiSGpvMkNpT0FzWlBBUEVQRVpPamd5ZlNUUTR1SWlKK0NFeUxFeU15T2VSTE5ZNUNud3BHODNXV1hSZk9QSktNVmtkNDgxT01sSWZqSkJQSlBnZmVoalExbyt5SlExMk1rVDhaWDdWM0xTSkRreWZkS0xXT042VGN0c2ZQaHRxdUxpdDQrSEYxRm9sVjZmaThkaStDK05PS3NmWmVrdkhXaU1MTVRJTVdsbDYyWDJXV1B0dnVlclplakdNWXhqR1NKRXRPbng3WTZJU3NaV2pHTHlqaUl4akd1MXJoRFRKRDh2azJsYUxWa282SVRJQzhKbGlaWWhhb1NFOUVPUlZqOGlHenlqODhheVp4cEhGS1Jqd1JRb0cwU1ZiVGFLSnRJK1BKUnRFamFjbEcwbEFjQ1dPeWZSd1pQQk9BeXhjNkpsaWtLWTVpblk1VVJtT1pGOFJMNFVpTDA4R0xKemt6Y1JqN1orZFB6UmlFUzBiSDJVZUJQUjlraVprZWkwZW43SmNKZjY0OGxQR081R2RwbUwyeFYzeVVpbVJqek5HUHcwWC9ybExoOEhraDdXWFMxcnNYWXk5TExMMHN2V3lUT3FmSmlmT0ZtTmlMMVhaZjhBU1k5V01ZeGpHTWtNZkowMkJ1YmdNUkZVTEs1Q0dOYUpDaUpVWkpEaktFaVNLR2o4b1NOdkNoYmpoNW5qb3lSWTc3dkk5SlIxUXBDWXBDMS9MZWlrV1JGSWJQSnlQZy9DeEU1VU9Xcll5R1BjUXhDZ2lNVFliQklna1RTRWloUkVpamFiWHB0TmhLSTBOR3l4eE5qWms2ZU1qSjBzb25nV3U0M0ZtT2ZNNUptT1pLWE1KaW1ZbnVsS2pFemNiaFNJT052UEZMSXpoZHlId1dPUTlLRWJkSkhqUmFNWS9PVHprK3k3SDVQS2xjVWlYdmpGOFkxelBpZFV2MThFNTBvUGRwUk04RDh5SXh0U2QvRXl5dGFIM3lla21aSHgxRDl4RHppWmpZbUxzc1F4YVdYcGVqMWVsOTdZeHlHTVl4akdNa1NPbmlZa3FreGtUS3JLaVI0MFp4WEFpTnNuQW9pTkRHaHg1YUtFdVlHV2MvVGNNa29ya25BY09YSFIzZW40MXBLT3FZbUtSdUVLV3QrMDNVV0o2WFE1RDBsNFlwY094OGlFS1B1eGRPS0lvbTBVUnhyU2lpaUs1MmlpVVVMVGFVT0pMZ2NlWEVZK3pKaGpNeTlOS09sbG03UmtKbTZudkZNak14WktGUGlNK0ZJUkdRbnBlNGt0WDUwOEU1WDN0akVQbGlQSXlSSXlNbjlrWDNOOFJFNkllVmFVUGNTcEY4SnFSa1c1d2pTM2JGdjV5V1h6SnJTeDZYd1gzTTJvc3Nzc2JHeXhzZWw2TVprTTMzSW1GbU5rWDhGbDYzM2ZuYmZZOUdNWTJNa01ZeVIwc0tncEQwUXU1Q0V4eTl5S0s0ZmtjU1VmYUloUXhpK3Nva29HMGxBZkJZeGUwZXJXcTBzVExFTFI2SWlNV2xGbms0M0RFendZOFVwR0xGUW9sYUlTSzdGRnNVUmFLSWtWMnRHd2NCUUpMbWloNjlSMGltU2k0T3grUnNaZk5rSHkySnVvUzVqTWhJc1JIVEZLbThDeVFlS2g2UFY2TFJpMC9mMXg1VkRIcXlSTWw5bHArSDRKKzFJNVRyYzA2Y0pvY1hGUW1OSTIydU5zc2lzVWRzWmVLNWtsYmRHMmh2c1ZkaTBzc3NlajRMMWtYV240TWZqS3pJL2NSTVRNYklzVEZvdmgvTkhxKzI5R1hwWTVEWTJOalkyTVpKbm1VUHF2SllpSWhEMGFUT2RxNTBZbnExN1Z3OU5wSEhZbys1aThpSkpFb0tuQjFQUm9jWFhZK3l4TXZSREVJM0NZbFphR1NtV2JoZG1IQVFocCtKYXJSYVJpVUxSaWZhK3hqSlFKcmFNcU5hNXNFTTBlcDZlV0p2VjYyYjdWa1prWmtNbkVKaW54Q1FtWUszWVpjZFVQczRHSmR2blJydWZoa2pMNWZsYStOT1Q4VDRmbTZjYXVhcHFaS0o0RzVWK3o1SWUweVNURnkyK1N1TXI5M1pZM3JaWmVsbDZQeVh6WmVuZ3ZSa2pLUzg2WTJZcEVXUlplaStPKzVuSTdRMk5tNGJHeHNib2JHeHNZMk1iSk14ZmFENDFRbUxWNko3bytGZWlMRlIvd3l0UEFodGRuNFpNYlkvYW1rekpFOERuN050bGNESG8xcWhGaVlueit4R2o5OE9MdDhSSDVlcThwV1ljRzBVU01UYWhJUTZhMFVMSXhGRVhqV3hzM0ZpTnc1YUppWTNyS080bENuc2VqV2k1TXNWTmRUMDd4TjZNZWk3RXpHeFNJeXNqVmJpTXVNT1hhWnBxUTJXUHlWcFdzcXZSNitCdmhNc1l4bVhqc3UreEVuWndlTkl5YUxzM00zSHRHeXpkN1RlUGtqUFl0eExrL08yeTlMSG9qZ2JQMHZTcTdMb3NabmZHc0h6aWtRWkZpWWkvZ3Z2c3NXckdrYllteUpLRUQwb21icDk4WVlzaU1pMmxqWTJOakdZaURFeFBTeENGcitxSEUrTkZvaGw3aXVPYm81TnZIWWhqNGZ0a09GRTBTaHc0aTl6OUtNekxqcHZzZlloTVROeGJGSWZKdUxvM3FTdlM5SVI1dzR0aVdpMDhhTFdMcCtTaERReHlKTWt6MVBhcGordTRqeThqSXlITVRFOVhFbTJiUnhISFR5WllXdXF3ZW0zOE1HS1JpWnVJQ1pGbDZxSXRzU2ZQWSt4NnBFdkVZdGtlbVlzTUJRZ2hVYllzZlQ0V3VxNkhwbGo1RU5uQlhIRzJ4bU9ybkd0R290T1ZudFI5Vy9Mb1ViRTBQUmxsNk5tN1N5OUVpeXl5dExHemNYMnZTaGtqcUgyNHBHT1JHV2llaTF2c1NiS0VVYlRhT1BDVE5vMElSS0k3R1dPWTV1bEpzWTBwRStseHlNM1NaWURHTVpqOElzVDBzc1RGckh6MUV5OUVJVkYySTRaK29aTVhnNEVKYU5Fb2ltMHRxYW5BZU0ySHUyc2VIY3BSY2V4OWkwWGhEMWVsa3R3aEhUWXRxeHdIRW9yUnJnb2pWMEpDRU0zS1NsdzVSOXJmRWo4WEI2dkZrWmlsYmNpSmRFWmtaYU9RL0dqS0hFUm54V3Vxd1BGTFI2SWVxZEY4d25RcG1LYk53cENFSk5rdEdQNHVSUUl4Rm9qWWJCbzZwWkhMUjhsSG5WYWNqTFIrNnJseUlxamtvbzJsRkZHMHBsTVpaZW5PbGpZNUY4NlhvNURZbVh5TW5JelBuc2k2ZU9SRmlGcGVsNnFEWnRVU214S0lsWnROcFd1NHRIR2o4Yml5ZktSWWh4TnVqTXVESG1PcDZISmlIcER3aE1zdlJDWXRGV2p0eUVNUXVkZVN4RWgrRm9oTVY2TkRYTGdWd3hvWTRrNFdSUm41SHErMWFYcnVMTDBlblJZUlJFZUgyTThOS3ozV3EwOGo4dDA1U3MzOFNsdzRzMnNaUTlQQis4SlBtUzhyeGVpNUp3Vkk4akhvbngxV0JPT2JGNlV2Z1JaQWpJeHlJUTBpa01ldGNmQWtSaVJRaENWYUlaUktGbDYxcnhyeWpieEdPNHYydG5CYUwrWjQweDQyY28zRzRzYjBUMDVMTExQSlFoalpObVQ3ZHVHWkJpWll1eUNjaExZWHVFK2I1Z1E3S01uamNieFNadTViMHZpWDNmaENhTEd6Ym9rVWRWME1NeG14VHd6ajRGMklpS1FoZVZ5VWNERWY5ZmpJb29UR05sQzRiOG9RaU90SWNTUzRyc3JtU01rQjZ5K0JQVkMwNlhFOHNsVVV1UndvU0VMdGg1M0ppOHUwY2pZdVJScDBLTzVyRnk0WEZvU0g5a09oZTF1VnhzaFNONWIwclI2TVpKRkRPc3dib3pWUHNlaTAvSWlaMDdJeUVSNU9LMFhZOVd5N2FocEVReXo4UWhJb2ZiNTFXajAzRjlpMHI1ZUNpV09MSllHU2pLUGJmYlplak1zaDl5TVU3SXNzVExMSVl6ZWJya3R1aXJTSGpza2pMR1NIWkdhTDRjeUw5N2RSYjQ4bTRqNDdxTStHT2FIVTlQTHA1aUZxbUlnSTRGeTJ4ZVg0MGpJYkVJYkUxcDRIWXhENFFoQzBZMEpESEVhSkRST0pPUHpJc3hyZExCajJSRTZJdlZDNEU3TmlLNWloNmNqazdmdWZodjNZbGV4Y1MzbSt4bjJpNDFvdUJqMGhSeFc5RzdSZWRpUHFiaGowOGsxeDEySHNYblJDMWd6R1FaRVhuNEhvK1RGQklmTC9VUjVGcEYzcDRFOUV0R3U5MmlVano4dGZJeVdKTWxGeDF2dHZSc2t6TStPK0V0cmhJVDBSaWg2WTJQYlVWRTNKaTBpUkYyTXlRc2NhS3BzNEkvWlNzZnRpejlVa2hmVnlvakl2Vkhnelk0WklkVjA3NmVhOExWQ0llZXl4Y0NFTFJDWWhINEk1Rm94QzBXakxHdEdTR1RSTWt0WmZEK2FkRmkycUo1TnRDODZMWGNSZWowM0ladGt6cU1zb1pNR2JIbE56RXQ4V3hpZkVTWisvckg0RVJFSm9Uc29mQnlQUjZTV3h2a3l3dFo4WHA1Q3RLMVF1R3FLVjR6MjFFWGFrUFM5RVJpUG5Sb1NFSVloNklYWXg5amREazVkbGFyVHhyWGJYWXExcnRmaVdCRTR5aDN2U1RKOHY0TVU2SXlJbUxINmFhWit4NUZCSjFvcEM4cVJDWGErU1VESkVjZUJFRU85SkgvU2Z0ZTIwN0U5UDFuSWtaOEVjdVBxSVN4Wk5VV1loaUVVVTZFdVdSSWpmdFQwVlcrRHlicWJka2l4Qzh4TEZLemNOak4zQzhORWlTSlJKSWFIRWZ4MmRORDFjc0kwa1EwUWtKMEkvNWp5ZjliRnBReDZTeVNpZFIxSCt5T1Voa1pqektMazAyanlPMUJYYVRIN1RhMk9NU2o5U0V0RUljZEdOYVBXYU91eGI0MW90VnFoRWVDTElFUlBzdnMydmNvYmRFaFFIclo1SWlueTVpa0tSdTBYWlpMSm92aHZzcmp1Y2RlZmdxekwwekhhTDdXekkrUGl4VDU2ZkY2VWR6RnVFaVVFSkcxRzFqNEZKa2NqSXk1akx0YUp4SklSTDdWWTNVV1B4NFBDRmJYQkdWamtKNklzNjdwdlh4K094RzRVOTByMHZWRmFRVmxMYXlqOVloajhvZWlZbndtV2JoNmVOUHNVVGpZK0J4S0doeE5wTDR1Z3g3WVk0M3BSdGNpUEJZeUtvcXk5SStOUHh0RDhUU2FuMFVHNWRKT0JVb3RUa1J5RUo3bzRFbkxMTGFZblVZL1dhMm1TWXhhUmVpNU5yT1VieHZSeG9mWkl5eDR6WTlzcUlrdUlDR3RHaFdSa1FJc1QwdlM5Ykl3Y25HS2lTWkVTN2FGbzFvaE0zOXZnbk85RWhhSkZhVU5uNisyeSsxcnM1TFBJK08vTkNPUXlRY0hxeGszYitMK082VFluRStyRU1RME1iV2l1b2NFV0o5clJKSDQrY2lYK3VVUjhQbTE0SHdLeWlPMDUwVXFMMFovSjlQMldibUo4UlpYRmk1MVFrWVZBelpOODRmVm9TS3JSalJaWndJV2ttYmhURTlhRkJrb29uVnppTkRLR3RKTGErL0ZIZlBGSGJGZlVnYmo5VVIrTEZJZmxRRUs2cmdlalhFb3ZUSmkzNDU5SEZrNFN4dkRKV3VCcmM4WmhoVDZsOHVOb1JSVEk2TFNoeDBVaWVqRkhnbWpxOGZERVRGcGQ2UkVoSWpFaHhxdXp5NDR4SjFLaGFvWkpDMFM1RVNReEZFbHIrVG51MC9GOEwrTzNyUXVDVmFwTjk4b3FSbHd1R2pHWlpmSC9HOUx1Ylp5MnhpWnZrUW03VXk3S1ZzalQwVEl5SXZ0Wk13cmRMYjdjaVJWSVRvc1ErRHk0UFh5SVQwa2RYZ2VETHJFaXVjVG9jaEMwU0dJWmpuTEFzYUZxL0Y4UDZ2V0VPYUU3SlJzbEdpTUhJY2RrbzBPa0tRcE5tNG1NbEhoclJqaVpZZkIvRzRya0w2NkpFYUcrSDRRcENpTWhSd1hRMkxrZkdtUGF6cVlienBrbERMTGJseXc5VEgrWUxsQjhuVFIzYVRsYmxlMzlXa1JMU0kwS0k0akdObGFSOFB6SldaSThaNDdaSWVpOGF4ZENFUllwQ2VxWkdBdmFSYms1RkZjcnpJUXhEUHhDR0lvb2VqNDB5VDNmRGZ4Y2FVTkRXbDZYTFRaWStHNG42eEsrNXJqUGkydGszU2ZQeGRGMC9yNUg5V1dJYzBodE1sUTN0YTVGSVVodXlFYUhIbHJUR3hhc1psOGROSDJUSngzRHg4U2h5WFl5S0Y0UnpUa2JqY0pwbmdUdGRYaFdmRzFUMFJGOHk0bW1Jdm5jV2Y5SkdPeG0wV2pHaGVaREVJbnhqYzQ3Y2R6YWlTZ1pQYm9ub3FHejgvWkV2Rk1hNW9hR3VNc2RzdTdwSWVuaWo1UWhDRkVva3lFZHpsSGFKRmU1UlBEY2g1aHo1c1V5TkVtamRzbGtqL0FMTisweXFPL3B1Sll2Y1I5a0d6ZVNrMklVYklyV0tFdEhwSmFTUWhWVFhEMHlvNjJIRG4vb2VpMVRGb3BFWkNZdEl4c2hRaGkwUWhJbUlRbnJSdG9aNGRpMWZLeXpzUXZnZnlNcnNwNldtazlyZFNHa2pnYUgzdUtrZFJpZU15U3QvREdMbExGQ09IRytSeTRzVWVMRTF0M0k0YThsMDB5SEdza1VoQ21KakdTTXBqalVXckdpWGwzYlJkSmlqeXR3b3M4amZEKzNrUXZBaitXd1ZQUkNaNWltSVFoVm9oSGtRdEhveGt2TkNIY2hkUFUwdmNqYVRnU2dNZ3hhdDZOV09JeElhR2pQQzQ5dUdPN0xFclJMaFVvM3lKait5YjBiNFhJckVUTnJSUTNLdnh5WnVrTnlPWW1YeExLNUdMZHVqR1hxU3pJdU0wL0tFUkV1RjRRaGRqZXRFZUNaSVl6Tkc0eTAvRjJMUkNFekhjakhqclNKRmN0Q2pSV3NTV2tkS0xvZ3hqV2lFU2VuVXoyclR3dnhkbGZMWXFSZHZib3ZDa3l1S0djb2FiS0dpL2IzemlwSFVZWGh5ZkQwR01iNWtKbnVFVDNDODNJMnRDZTF2M1N4MWNmckVXajBzVExHTXE4aTBaSkUwU3N1azJxUXJFK0xlajhROG9Ua1JseVpZeHk0OGtIam5xbnBFaXhIaFB6Rmk4aTBlaVI1R2Y5ZnZscGk0aytOYXNuQWNORnJZcG9mSXg2UFI4bVdPMlhaL0hSM1pVTFJmWnl2VmNDTnhZajY2czl3NGppZlhUZlVqY2g1VDFaSHF5Tmx5cW1oeEVoUjBYbUp0N0dQUjhhV0laTVl5YU9wVzE2SjlxRnBod3VaamdvNkpFWTBwK0Y1TDBzaTlFaVdpR2hPaGFNWXZETWs5aXU1ZjBubytFanlKRDRJcmhvZGxtNGxUVmpaYnR2ZXVZa3ZnNmpDc3VOd2NaYVVQc3h3M3pWSkx5L2JKOEZQZFB6UGhVS05IL0FFMVlteUZNamJGSmlubzlFTFZuVHE4dzlKb2taRXhsRXJRcUV4eWlrbnkzeEdJaEcwaUkvbHNWUzdVSmtXeEhrUWhhb1hoNmJhRU1TRUp0a0haK2FQeE9JNGkwWXhpa01taGlHU282aVBIWi9GeDlrU09pWXhjc1dqV2pMSWxWb21rcGU1K25TYU5saWc0aWpwdFJEUnhvY09FVWJTdVZFU0VMc2VraTlVTmtub3lSMTBmYU1Ya1haRk9UNmJwYUZ3V1JpMkpVS1JPUkZkajRFMlIxV3FvdEZqMVptbHZ5Vi9SL05Gb2lKWnkremFNVVR3TWo1a2lVblhuVHk5RlZWenAxZUd5aWl1M3BJMG0zY1lVcEM4UGtjT0pWVVBPMDJsZTVrQ0pGNldmakV4YU15SFNMZ1lpYTRsRW5XN2l4amx5bmFwWHhVdVp4NFB4ZUcyUllqcXNYcTRSYW9RbVJ1MXdJZ0lRdXhhVVVQbHJsYk9hSWkwWitlU1VUWU9BNGppU0V4U0o2ZmpHWkZhZlowR09zTVVJOENKcmJGYUlReGE0eVU3Yk5wNExaVm0yS2lMeXZNb2pod29EUXFGVDBVUkljZFYyV1NmTGVsYUlZeDZTT3FqZVBSNkl2VEZpZVI0Y1NTMGl0b3JrM1JWS2hEUDM5bHpvaGxjM291UkcwOEZqRU1meFg4TWRQeFIwajVlaTh2UmVXOUh5azdTNGt6L2xydFhoK1Q4ZmpKajJTb29hR3ROdHRGMjFQYXBTSS93RGtxSXkyeGZMVVNVV29vLzZXa1dSYTcweXpLenBsdHhrdEd5WkpNVjNLa21tbFRGd2J0MGhvUS9Dc2tKVnArZGZqOUxxZFVJUWlJa0lRaGFJV3RDcTJoY2lHaXRXOUZwdDVaSXBFNHE1d2NkRkwyc1F6OG1aVlV0SXE1WXYvQURpTHg1YTRZeWo4UlhCV3NWcForMFdORFZQOFNHZVhvNGk5b2tSN0Z6cTJNWXhqTnhJakt4c1k5SkdYeFBpZXEwNmJwOTVDQnQ5c1lFSWN1a1E4UHpKaTFZaWhvZWlLczJXWThmRGhXazlMNUdMVi93QkpvdlIrSXU5UEdqTEdOY0x4VmFObVRnblEreSszTEhjcUtLS0dpS0Z3UmRsMUdDWW5FbHRaQmNmVVgxNXNSWW8rNUlWQ0ZxMXB1SE0zYnBZdkE5SlRvbk1Tc2NXWkZXaWw3ck5ycDNhV2laK3lFYmhIOHZEMmRzUk1SR3p5SkhsZnFmS1pFcU5sRDVQQStHblpGOFZ5TXNmQXJFNkg1WndaYlVYT3pEL3NXWEc0YVdMUmtqcUk2NEZlWEg0MGk2SWlGN3BUa3V5cUZvbFo0SExsRWFKbEc3amJ5cUhROVA4QWtZMFFQeGR6SG85TEdNOGRzako0NnBWbTdPbHc3M0NKR0ExcHVPRDdqUnQ3bm95eENSRVJJWklZdjZpVjZmOEFJM1ordFZva2l5dE9OR3VYeWg4cVBob2w0OGk4RE9OaUhxOUp4S0dpaWlYanpKY0pKYkk1S3h1WENGd1hveERaSDI2ZjhvZ1VJWGhrakxrMm1YcVVqSG1xWFN6M3dHTm1XWnZWS2F0OHBqVkZEOFJYRmo4S1dpNWN2RXBjUmFQQjFrZC9UZHFaRWlKbVBSaUdSRlJIVmt5L2RkQ2tLVmpKTW5GNDlVeCtDTDU4bnBScmFpV0xmSExEWklXakdaQm9vNlJmNzRhb2JFeGRpOHVPaUlzZjJQeURKU0VJUTJYeXhINXBOZTFDRnBlckdXV042UFI5ekpuWEwzNjlOaTlTV0tGS0hBbFkvS1FrT0pGVm96eTVjRWV5VEVVUmp5bzZ5R3hqV2pZcGMxL1RscEh4K1M1RjRmR2kwclQ5NTBYbGwrNlhpcUkrSHF1U3RYcElSUlErQnpJaUc3SXNYTHRJVHQ2TXM1cHZqZlFwQ0krV0lXbVk2eks1VDhIbkQvR084WkptU2Z0bnlMekhsMWJtbWY4QUsrcmpZL0tmRElMVGsreVpIeUx4a2pzeWRpSWtYUkVnV1B5dVphZnFiSXNVK04xajRHUGcvWXlFU011WDFDK09CeW8zSG5TR2lZenFvV1BzWlBYcFAvYkhvOUVmcTA4YUkzY2FmaUg1YjRYbWhJU0dYcXV4ZUJNc1pmWlp1TEw1VEg0UTN5OUZ6b3hraitRV3NJdWJ3WTlzWXFoUjlxNFZhUkZxemdsenBIeXlMR1JQMk9ualNmQXh2UjZiVDgwZjlGZVg1aUpERjR0TmRyMFhsenNvZmhQU1IrYWZneDZTRjk2MDZqMjQxekplMFVrTmtMcEQ1Rnd2eWhKTTJ4UGNiUndNWnQ1WEdpSWpKS3pxbDZXV2IzU3hSczZUSDZlTExPaHNmS2xhUGN5TXBiWXk0ajRlS3hyYU1uUkg3S3BDK3haWjUweHZUcmxYVWRpSWlJcmhLa2x5MXhEc2lObzNQVGRUVDBvUW1ONlhwN1c5anVWS1M4ZnNXbWVDakpHMWxqem94a3RHZEovNnJ4RVl1eEVoY1FYYkhTeS9iWXZyZEZpc2ZCWnU5dzlFeDZPWnZKZlZUSElzZlpadUd4YXJWak92K3BSMGVPaGVVaEg3cEprUERQd2JwSmo4aTVHSVM1MGd4akphTWJMSTlpSy9vL2lQSlpOaThKYzZ5OFIxUlhONkxqU1drZnM5UDJReGZaa3hjeE92bHorT1MzTGtVVGMyNDJLN1Fodmo3Q1hMWENXbEsxeG9oQzhJWi9KWXJFcFNYOGIwZEVtTjh6SlM5M0Vza3lUTWJiaUtYRDl4KzdQZHdSVlBheVBBM3BYTDVJMWFQNUtPcldpSXdsUzh3SThuQzFlbGk3bnBZK3hlTE54K1FrV0lqS3hQMm1hSExXckpEOHM2TC8yWGxhUGgxd0xuV3hlRU42VVVNUXo4djIvamRrQ2Vxa0tSS1E5RzlWSXZWTWZhMzIzbzlPdStoampjc1NJb2hva05YSktqYVVLSk0zQ3RpanpLaGNrRU5hTHlKRlVYeHU1WXhvYUtGL1QvQURTK05QM2RaWEM3bG8wZmtQczZMNVhsOGt2SFk5V1Q4ZEs3eDBkWkxkMUxmdFJIY09mTWVYSHloT2h5U0VKSVI1TWFzZVBuWlEwaDhDMmlGcjFNZHk2VHBJUWZnYjkwbVpaSzZURmthSk50eFNhVDJPUDEvUDFzNUo4cFhTR0liTDRraENPdlY5UDJJNmVPN0d2dkFYdFBPa3ZMSi9aRVJFVU5QVDkxWGE5RjU4Rm00M0NudzVjWk9UTEVvVUI0a1RqeEx5enBIWFVSOHhGbzM3UlBoREZxaUVUL0FLWityekxsbERXbCs2WkljdUZwUTlIb2k5SUsxTDVucDF2MU1NZU1iTWYxYjBqNFdqZW03Z3BINUZPMlZRaHM4akljaUdQZ1pQUitVUDVxdjRGNS9YeHFpMmhFaUhnbFBtTEw1M2NiN0Y1OE9lcTFya1E5V1NPbGRaakp6Tmk0TDlzRWtMendqMVBjL0NSRHh1b1VpeHM5Um85U3lVMjJwWEpDOFJyUm15M0ZVWmRITkQ4U1JMbFFUcU1iSXRvVGtqZVhhWnlJUTQxclFqOG81T3FYL3dCYnQ2YVNTTWIwV2pSLzB6OWh3VHkrN0ZMY2hSNVNZeGk3RWphYlNuV3Q4S1NQQXBEZG1TajlTSEhjbjByT3B3U3hhZFAvQU82VkM4UHZXbjdIbHY2VUpFY2U0ZU5sQ0tKSDQyWHEyVVB3ZVlzYjR2Vk9pUXVQZ1hmMXYxaHk4YU1hMC82MmlFaWhMU1JEekpPMXdYN3YxK0R5SVpqTEd4c2NpN0d4Nk1meFBYblM5ZjM5MXZnYTRKYU5NWEE1VUtub2taSFFtcXFpVXVXeGNIaHZ3dEgzdnlwYk9vbjdZV0o4aSsxdzN5NVNaSHp1c1UzYVlseFBKdEk1V2V0enZzVFlya1JpUmh5bG9ucEdJeCtXektlV01TT1dPZkM1Vks0OEhrUTFvbXBKajhpandoa2pMLzhBbjdFTFRFSW9XajBvM09JM3V5WW9jQzFrUFZNdlI3U2NLUzdFOUl5UHhvbWhFUmVNMExPb3hlbE9EcWNPUlBoaUZvdXhhUUw0aVFRbFNIalBTSEV5UjRIcXRXOVB6Vy9rZXJMMGJPdWZzd0VQT1BTUGxGMEtWcy9XK0Z5S1ZEWWhuL0tLNDRSNUdRa09SdTNKazJJWTJiamNlZm0ydjRQeDhhUmxXaThTV2twQzl4dFFrTjBlUytXdUZHeVQ1WitjVnArL3JHUGdRL0RPb1E4dS93RGpkRndKbUoyU0UrVk1UVDBpU3RDZ2ZWUTl3cElqRVVSUUVrUFNLTDR1anlaR09Wa3lWSGgrUjhDNEZEMnRHTkk4bDhwajVHYjdIem9tZmo0MGZKbi9BUEh0UmpaRWpvdFdQeS9DaDdvZTBoRnpTR01lcjBSSGthSHdOWDJlTkxFY0pQd21SOHJ3MVoxdUxmQm5SeTNSMVdpRnF5UGxFZEllZXhrdVUxekpJMkpDSHE5V3hpbHg4Yjc1SFdQMjQvR0x6akVSRnFtTVpGY1NYUGs4RzR2aUJaazgyTGxYVFhKSWN0S0tIRWVpSDhkYVNtNUNvZGRxNU9UenFyWnlqbGxhU053NUZiaWtXZVJMZzh1VDVybWFIOEVqS1lNbitqV3lFdHNZdlR3UkV4TVV2WWg4cVVqRmRxVkVjZ3A4eGVsYU9SdklzeXllNnliR3VJOHBlMS9uSlc0YVBBdUQ5WGdmZ1lvOGpzYjRXblZQL3dDdUxWQ0VRa1FlaUtIOXFGb2hNaTZISzlXZjlWN1dOcUtuazl1R2UvUkxjVGpXalJ4MlJrS1NPSEZpRjQzbVh4MVVObVgrUGw3SVBtZWkwUWhDR1JFZjlJVE4zRVo4M296SVMwVFAxK2RIMmZpSDRiN0VNVEdJWXV5aDZUWjFUNWdZaGFLWEYwYmlQTFNLTnl1eWFJa2hJU0hvdFBDZm1KTjZJWnpwSmFYOFNYRGFZNXQ5eTQwUzBmUFluUTJXeXkyV2JqeXk5RlNKTmt1UktoL2FUMC9YbzlGNTBrVDg3OWs5Vm9oaVhDaVBrWEFsYWw1bndWUkcwUWlKQ1pqOGVkSkdSOEo3VS9yOWs3YmZCYlRYaW1mOVM4REVTNUV1VTZQQjVHTGdsTVdyMDYzanA5RnFoRU9DRElzVDBYbGo4SThDWlo1R0lscXljZU9ZUHBZVUlSUk9GSDY5SG9rTGJTa01USXlMU0puV1EzUTZDWHZqcW5YWXRZSVhsbTRpOXh1NEV4VFBVNVkxeTlHUFJEMWVqMGVzYUhxeUw3bXhqWk5tWG1lUDdZakZ5eGN5ZmxrUHJGOHNTNWFzUXl1WkVSbGlvUk5Hd1VSb21SMHVpeWVsZkFxdlZFcCsxUG1WRFZkeTEyOEcwNTBWRzNSU29xeEVpUEJMa3BKTmpFSVordnVaTTZuVkVkS3BWRWFHeE1Tc1FqeTUwMG83VmV3eFRNZk1vOENKeXBTTWxWS2RRVDNSVGFKU1RlVWJvZEVIbzRrWTFwWmRIZ1dpR0tpdVk2ZmpJbjhoL3dDZlloQ0VJaUppMVl6OFFtV1dXSmw2TmlrSkl1eFBWalhhMk1Xc1hSZW1VaC9yNmhNVDBZMXdodmhheExMNFRGSTNDOGJoenNlbGo1MForc3ZSUFNSK2ZtaitGYVBWa21abncvdmpJbUwyeEk4RmU3YVdlQmVHeXhTTDBhRndtZVJjS0w1RTFwUktJOUpINXJmZGZCQkpseEZGczlOalhMWEJiMHE5VjNXY0c1YVdMa28zY2wwWHc5UDJYTE4zWTFwK0xSa3pxVDlJaTBqeUtmdlJLbVJXa1BEZkhKSzJQeEl4bUpiVGN5NkpaTGxOa3BPNVM0VDAzV094S2wrcmtTczVKV0oyTVlqOC9FeXhkckdmeUhhaENJa1JhTFN6d012WGNXYmpjYnVMSHlNM0NaRjJlQzZiWS9EMGVqMFhrOGlFeUxNcDFLTU05MEVSR0o4Q0ZvaEg1K0pDRUo4MkxuVGVOaU53eDl6MGZZaVF0RjQxWGF4bWRuL1dJd292U0lqR0tKUjRTNUZSUTVHN2xNbTlFdEZTSHlxb1RMRzlHUHpJc2VpN0Z6MmVJUlhMYWlUeXlaQzJLQ2FVYkVvMWJGYWJFckVTVk1hZFVmbzFxa2kyV0kya2FKUGx2bjgvNmRuaEx5ejhGcXZLOC91UXplSmVSQ09DNmxCZTZMVGFjYlJKZTNIdVo5eFVqeTM3VDloNXVqRzdIUGx5ZHordTgzS25KYm8weERsN2F0VDloSHhFbDV2bXRJbFdMeG95T2oxbXovanIzL3MxV2lFSVFoRVpGaTBaUlZhcVJZbWJqY1hjaXhNVXhURmtXeXh5MFpRMW85VWZvcFVUZHJMeWRGUDJ3SWk1MFdrUjZXV01ZdkNHeEc2aVUvYW1YMlM0SHF2R3I3TEhyZmE5V05rbVpIYi9BSENZL0xFUjBqb3IzYUlaUXF0NlZ4bzBRNEdpTVJ4SkNXalNKSEdqRXU1dHRIMmxPb0RYS2pZcE5EUW05cVhPMU9LZEdSMlJsVC82azI5SlN0YVhROVVWbzVISXVSMTJYeVhYd0laTXpFbzlpRkV0TWI0aDUvNmZKRWJvZFNLc255L0ppOE9kdFM5cmx4Qis2YkplSHdQa1VsdGNoY2xzZklvNkw2bmdVU1hHamZKWXlQYisyZFgvQU8vWWhFUkNFZmk3Rm94Nk12U3l4U04xRGZPNFVoVEZNVXhTTG92UnJqd01mWlZqTE1oaWUzTEIySVQwV3U3anNzVExHK1Y0SmEySXZtY2l4c2JMMXZUODBSZmNubzMyU01yUEkvdDB5TWZDL01mandLendrK0ZwZWlHZnFHUUpJL1JrYnBTTEpLenhwSThqZ0xnWEpYd1E4dE85a2tSZ294YWlpa0xZVFFwTkUvTUpXVGpUN1BIWlRHOUZweG8zMjhFYXJWbjVyK3NrVE1HUDFKYW92aEg3NDBxVEY3Vi8wYi9ieU0vL0FKWTFTczQwWWg4TnNUMjZKc3FoZWZ3L0x0L21sc1Q0WXBqc2lMVjZJbTkwKzFNaDVqektoQzdiRTlINUhxeHNVamNXYmpjS1lwRzgzaWtSa0tYQkx1VDRKTWxwZ25jVTlZTVl1eGFQU3hlYjBmbHYyMldXV05sbGowczNjV1dXV2ZtajdINDdHTmpNckZEaVM5K0hnaUx4RjByNVF2cy9IZ2ZKUWx3L05raUNHUjRKaklqa2ZraURZNW04c2xJc1VpN0ljSyszL3ArWVVpUE11RTU1VnRjcFNOc21RZTBjNGtadERhYWw3cFNTSThqVCtQY1djOW5sVlFsMy9oK3ZUOWtUUDR6L0FQVjFtUDB1b1loSWo5VXloOGk1RjVZdHU2UG5ONWZ0Y1BzeGpmQ04yMGRrbnkrWkNmS2tOaWxibStiSHdJZk1rcUU3a2Y4QU1IbzlGcCs2UHhtbHR4ZDZsUmpuRmlwbTNXaEN4WkpDNlhJUjZSbitLZjRwL2hzZlIyZjRNaDlCTS84QWo4aC84Zk0vK055aytpenhKUWxFdlhjS1FwQ21ieFQ5dTRiMGZheVRHeHlhbjA4K1lQUkMwaUxzc2s3R0psODJiamNiaHlOeFp2SE0zRzRjN0wwc3NzWGpzUWhQU1EreGpKc3hyZFBhVFgrekNYN3Z6OGloc1dxSkVMcWJGNGpwdDB2UitHYmh5SXlHVnk5RU1TSlBoSC8veEFBc0VRQUNBUU1FQWdJQ0FnTUJBQU1BQUFBQUFSRUNFQ0VERWlBeFFWRUVNQk5oSW5FVU1rQkNNMUppLzlvQUNBRURBUUUvQVVSSWxiTnE2UllaVXBVbzZGSGJLbEtsV2k4RWNJSXRSMmhkRHMxYXRRaXJMRlMyVVVNUzluNnRxVlRnaTlQcThXZ2dpMEVFUUluaG5oSkk4OHBGemtteXdhWHlkdUdLdFZLVWFtVkJWaHdUWmtFQzdKRXlxdHZDRlI3S3NkR25xdGRpcm5KTnBzeG5SK2hvUStWTmUwVGxjRXZaUG82SkpFdkpXcFdDTTVGSFJYcHpsRzBTbFFOUS9zb2VidTIzeVZxVDhNNUtkRVZNRUczSlhoSGtxSkZaUGhzVFExRm80T3k0dENYMFJmdTBmVG82am9lVFUxL1EzT1dTU1RkZGo2RXhEZmdkcUhHQk1URU5qWXgyL1YvN3N1Rk5VQ2NrVzdHMGgxQ3JZbTJKK0JLU3VrUzlrZWphS21EVXcrRVdqa25Ea2Z5bjBqL0pyRjh0K1JmSlF0ZE0vSlN4Tk03dEJCcUwrQXhvZ1M0ZEV5S3VNRldYSkpOcEVQanQ5Y0VQaXJ4d3BvbnNxVVlWNHVzRWo1Sk5td2VEYkdiTWFFSVF2Vm54ZkR2aEZxS29PeUQ5ajlsYlp1WlRVVVN5bEZYb2JqQW5mVTd2QkhKdUIxZWh0dmltMEtzVlhvMDlXTU1UVHRJMUpxNmJvZGx3aU1rRWVoS3o0VGFDTHlrdWNjbS9GbFNLbExMSzY1d3VFOEVQaW5BcTFHRGN5dko0SFY2Sk53bmFrcFhtejVOV2kwWGkrbS9GbThGZFJOcVZCUjBQSFEyZHV5UEJxOTJuakJVNE40M0ozOUNZcXluVWFOUFZuc1ZuU3FsREsvaXhsRDBxME9scnNZaHVWQXZSRUVqWkpKSWpFV25oSEo0RStQV1NaRUlyZHBFK1N0QkhDa1RIVU5pNEpsQXVyT3pIZ21id1FJZ2dpelF5bGl5cEszSTAyUkJTcEtOTVNoRWpGbXl0cXY4QWxhYjA2YlpzcFhaL0R3alVjMTJra2JzbnlrVEZWSFJwYTA0WW1Ka21yV3FGSlhYdWNpRXhGTHlWczdJSGFDQmREc21kMmlTQ0NMdkpBaGlVandkaVFoRmQxZER1bk4yUlpPRWJpWk1NZ1JGa1VkM1l4a1NUSFI0czBac2xhTHRXMDJTU05wbWtwRWlTclBCRldFVk9XSzFGTHF3alQrTkdXZmlZOU5INHo1TktwcndTTjJtUkl3TGttSml3YUdyT0dKa255SzV4ZENFVkVIWkJCQkZuZENXVFk0R2hxNzVOV1FyVktScU83SW5qQkJKUDF3UWFmZDNaamZvYWdXTEswYzJpbkEyUEpUUkpwMFFUR0NKemJvN0VMQnFTMUNHbW5rUnBhVDFEVDBxZFBBM0hSSThqY0kxYTkxVHRJekJQMHlKeVV1Q2pVbERaVmxrV1NQSkErYnRCQkJvVWJtYkVQVFE5Tk5RVjBiWEFselhCQ2FLbFN4b2dwMHFxaW40azluK0dhbWorTWdrbjZVUlpYMCsrTHRBbzZFUDZZcyt4S1RUcFNGZzdHU05pS2U3TTFOTk1wMFcyYVZDcHdkRlZjRzlNL0pHRFhxL2dONUo0TG5OMEkwMlMzZ3JwaDVJUTBOK0NsV2ZmQktTaWtycGhqUkFrUVFmR3dpYjY5RTVzN3E2dEpMSlpOK2lqV3FwS1BrSjltK2VqNUxsajVTVE51aFp1eFgwKytMVXFEYkN5UjZIVjR0NTRxMEVYaWVqVHBhN0VobjdKc3hDdHJWN2NvbzFIVTRScDZUU2xsWG9WY1lLbkpNRHFrMUhOQlYyTjJRa1J3bWVkTEtHYVZNdVRWMDV5UkE4V1RnZGZvN2MyUkFrYWRQazFOT1ZJMFFRUVFhYWhDcU40Nm1OU3NqMFo2SG9zZExSSDNTeW5VYU5TcmRrZGxadmdqc1N2MlExZWpENWYwZFpNTlNaOENVZC9YcHFYa2ZvZ1E4a1JkQ3Q4ZytEb3ovSmxVSTFKa2tiWTNJaXYvUXJ1aFhkdWlTZUVpWnA1TktyeGI4YVpycUhDRXVDRUtrcDAvSWtRYW1oT1VPbHJzZ1NLYVJKaW9JU0hBNm9ONk41aDlqMFUraXZUYXovd3NYSlUrcnlTS3VCYWxOU3lWZDRzaFpYRnFUK2o5V3c3eHlnYUtWR1JLVHA4V0t6SzF2cWhHaFJ0VUZUbG1vaG9iSWtxVU1mUnEweGZyb1RtL21DQ1JzbXl1alRLWERFeEh5Vi9PZUNVaVVHbXBaRmtyMXBNZEM4Rk9taEpkRVJaMVFWYW5nYkd5VGNLdUJQY1Y2ZmxEK3FlQ0dPOEhWbFZBbW1WVUpLZUNLUjIwM0dMdmhNZGsvVkJCRTlDd2Q1RVNPNlZxbmcrUFJOY2xLZ3JxUld4bGJncHFLbzdPelZwbEQ0SzdmZ1pCMXdSUWlrUlE1RjBhNm5Oa2hJZ1NOR255UVJaalpCQ0ZTUlp1Q3AyaVRhemFSWk13MGFsSGxmOGpzam9kVGVMeFpIZGtKeXJPOFNKRVhqakhDaHdWUVQ0T3JJWXI2amhIeEtmNHllQnFDb1pXSkQ2eVRCVmxHclJCQXJvZ2ZaRm53U0Y2S0VJMHhkRldSMGlSQWtVMFNVMFFyU25sRDdrZnM3SkVwSmdra2JIa1NLYUNFUWgwSjlEb2dTSWhEeWFsTWNvK21TYlRlU2JNVjFhYmFiakY0SUlJSUlJK3FQSXhEWjRKSkZldHpVa2FTaEpGVGdxbDlGUXl0RW1XTldhVlNIVERpMFdTa2FJR05XaTZFb3lVMStCR2tlQ294QmhPQ1ZNRHFTS0t6OHk3UHpJM3c0SkV4aVFob1M5MnF0cHFUcEVpRTVIUkl0UDJRdWlxaUN1bVVOUXlDT1RRa1JaMmdpMkNWYUVRaEkya1JhUkVrMjA2SFVSR09NY0l2RjVNM2Rua2QxWnMwdjVhaFRoRmJ0VWlvcXlLZ2hJcVVrQ1JxVURVRVdSQkJCQTFhQ0JJa283RWFTUEJVVkV0aVExR1RjTEt3Tkx3SnprcGI4bEdSblhHc1pwM3BhZUJ2WThGRGxTVmFpUXRYSTZwT3pVWG04WGdpMHBHOGRaTFpMSmQyaU9HU1dibWhWVDJLR1V3dXlyUFJSUlBZdE5JV09oOFkraUNCb2l6Y0V6ZHV5WXJWcytKblVGZ3FadXpCV3pjaG00bVNvZ1NIUkk5S1I2TlIrT3BHMjBFRUcwMndRUU1nMHRPY2tHa2g5RldNalQ2SWtud1ZrUVVMQWszZ1JKU3JOQ1JCMGRsYWtxd3lobEtsRDFFbkJTaGFlNHFwMjB3aXBlN0o0RXpVemVTUnVEY2J4MU5qSXRCQkY1NFJhTFJhVFRnVms3U0ovUkJGblpxekd5U1JzbXlZbVNhalBnditWbUpJMU9pdXJZZmxrVEV4dEVtK0Q4aHZOeHVNTTJVTWVqSFJEWGQ0R2lCbzA2Wk1KUWhHbWhqUTVHdkNIUzBKcm82NkdvaVNyS08wSVdFTHUwalkySnlWTEJWUUpRYWRjR3RvVFh1UXE0YVNLWU5XbzFHSml5UEEraDRzM0E2aHZsSEdQc3BjRkxra2trYkhxUVVhaXFGYUNDQ0NPRVdaVndkNUV4c3JxaytHNHFnbUNadFYwYXRNbE9sR1hhYlI3SUk0U1NKbUgyVmFQL0FOUnBydTBXZ3BhcEthcFpTVWRXYUtxVHZvYXlaZURaT0NFanQ0RUlmUXIxallxaE9VT21SMENScC95VU1wb1NjbTdCVzVHSlNkRFkyUHNkWG9sdm12OEFoZ1JwdmcyVnZJbTFsRkd2NFlxazd3UmVMT3pZeEVqNFNKbGRYaTN4Nm9ySmxDSFZDSzlXWGdkUk5vNFFSeVRFeDBxdnNyMDNRUVI3TURLTU1vS1JXWTBPbVNxaCtEOGI4c3gwSkNWcXVoWHFacU0zUXpUcWtYUlVwNkZwd043Y0lvcW5zYjlXZEJFREdObFZSM2RMbkIwU2lVU2lVU1NiaFZJbERyUnZONXZKVEVwS2NDWkpJMk41dXFtaW41RFhaVHIwUHNWU2ZWbTBoNmtHK1IxUWZsTjgyZDVKR3lTU1IycGNPVFNybEV4azFOU1J0cy91OEVYZnF6dE5reE9SQ08relUwM1RsRTNScHNwWW1JZ1kwcEloWUlid1JBdjJLMVMvaUxBck5GYVp0S0VKNGdnZFVFeVZQYmtwcWJFL1p1R3hzYksyTml4ZFg2Tnh1TnhMZG9JSUlJdEhDT0NFeVNTU3AyaXlwYjZLUGl0OWxIeGFGMktoTG9WS05xSFFtZmpSVm9TVmFMVnBHU1RhUnNiSko0YUdwNEtxcHdQNkl0MFBJLzF3a1FuWk0xdEdNcXpkdE9yd1VzVEU3dERSQ0ZTTEloSWF3SmlaSjJOSTJGTklrVk1iSks4bE9MU05qWTJWUHdVNUh3a20wRVdnZ2o3a0pYYkhtMU5McXdqVCtMNVpScHBDaEhkdDBHNDdzMlJLS3ROTXEwM1NTU1NTTmpaUENTVDQ5RUxjeDI4L1MvUjBkY0VMSlRtNmZobXRwN0hkT0dVT1JNVEp2QkhrNklzbGFwUXhPeWRvdE1EWTdkaVVXWTJOakt5bkZOb3MyVGRJajdJZG9Jc2tJVnBHeEdub3V0bW5wS2tnbUVObTQzRFltSndiNUV5UmpVbXBwUmxHNDNHNG5ucDBiMlJDZ2YwOTR0NXMrU2VjQ3ZWVHZVTXFVT0IyMHE0d3hNVEV4Y0lJSXZxMHlwRXhNa1RKSkd4c2trUkkyTmpaTm1wSXhBNHBHeVNQcWdnZ2pqQkhGZFdxZmc3TkhTM09XVVVxbnEwd05rU2hVRzMyYlY3TnY3TnBEUkxOdzZoT2NESkorbjQ5RUtSMmZMcTNrOGlZK0N0Nkl3VTlDYzVzajVHbi93Q2phYlRiQnAxK0JNVEV5Zm9acTBiWEtGVVNLb2trYkd5U1JNa2JHeHUwRUdSa0VYWERvUStMNFJISkppbzlqU1ErelMwM1V6VG9oUmI5ajFGNEZWSkpJM2dUakJ1d0twTW16anliZlFuQk0vVnAwYnFvT2xBK0U1ajZJOG9ha2FtNy9SMEtsblowTHE3VzVRT21IQkZ1aWlzVEV4TTcraXBLcFF6VW9lbXhWRzhWUnVKR3hzVHMyTmpka2lMUEJoalRYMGQ4bmFDQ0xVTDJOSTJvaWt3dWhXYkVwWm9hY0ltQk4rVFVaUXBFa053YnpzYWdUZ2tUbHdOdERaMTBTbUoreU9jRUh4a3UrVXlKUVo4RXdzbjdZaEk3UkhnNklsRzBnL29TOG1SWUdJUXJhOU1aSnN6b28xSTdLYWhNVCtsMDAxS0dhbnhmTkk1cGNNVlJKdUc3SmlZM1pzU2tTZ2FJR2pvVlhoanBYYUlqN1lNaS9aUG9reVJkQ3RXL0JvVVRrV0VMMkpNL0ZPV0tsSWFUR05Dd04yZ3BTV1I1SWhDM1BvVkQ4anh3UXJZRmthYVBqZFNPekdwR1NOd1RJNDhrdHM3RTVPclFKTVNabEVHZkJQNkVOVGdRcjZxbWtaTjJVNmpSUnFTSmlmRjZxUTlXcDlFMU1oK3hKK3g2ZTdzZWl2QTlCK0IwMUxzeVNKazJnV20rMkpKZFdkbVBJeVd1amRQZG9Oc20yQ0dReUdRemF6YmFmVjRJK2h1QlpabzB3cEZsbEZFai9pamMyc0dmSkJWaGxWVTlGTmJIVWJvRlVma0ZVaFpHUVZZNEpXbXlxaGtLcEdsUnNvSG16eU1hbnNxY0liZ25hTnlKNWdkYXYxMkxOc3NuMkpwbjlDdEdSWFJCVnBaTmpSdElJSUphTlBWOWxOVWsycXEybFZicUlzbjR0Z1NVR0VZWTZVeDZTWitDaG4rSjZaL2l3TFFTN05xUTdKMlE3TlNSWlhsOFpmQ09Tdkk2L1EzUFpvVXl4THdpaWdYNktwYXdLa3gwUEdXT3MvSExrZE1EOUhSSnVOTVNzOER6MGZqcUlaSENTVFRyaG5qaFU0RzRRK2tOUzV0L1E4Q3BUVWlxMnVIYjlPelVpeGdpVGFRaHVMSzZGWnJJME9rZ2dnYUdVYXpwN0tQa1VuNVZHQnVXSXFmcXltektXZG1CblkwaVhTYjVHTmpZN0ppSC93QThrbzNEYzMrUFRDS2FSWU9pU1lJOWxWTWxTakFrYkY1TlRUOURwYXNxVzJhZWxDeVk2TURhZlpFOUhaQ0hwcGxXZzEwTk5kM2dSVG1uZ3hJcXhCLzZIaTBuUTRxRzlzSVdiSmp6WklnVmxkWGZZeGpSQTBORFF4SnQ0S0tZVUVXZUJ1UlAwSndTS3FEY01URTQ3T3hqRlg0WXhqR1EyS2xMcy9peDBKOUZWTFZvdEgzU2JqY1R4b1VzMHFjRklyekhaRWpLcWZaMWhDbE9haDFJZy9HamJBamNxUjZwK3ltMGlaVGtyMGxVc0dwcHVsaVJGcVA5ZUs3WTFPQnlQMHpyTnU2Qkx3aC9zcFVDbWVHUktPU3QwT3R5VU9leDNhR05EUnAwUUliZ2tkVWlFTWttU1NSSFk4R1RzZ253eGpWa3RvM2RkWkhUVE1rSXdZSXBac1JzNFRaTWtrYkhxRDFEZEpJbUppZDlKVFVhU2hDdEpTc3lSWnpQNkdoSk5zcWxDb2ZaNHliNFE5UTMxZWJRYWZXU2lHTWtrb2NDY21wcHFvcm9kTHY4ZHpSWjNTMjlsUlZrcVRLbGthOWlUaVVMby9zeTJvTyt2cVFsYXJvYUtVUVJkb2FJRU03emFDbEdCeVJhUEpCVFNkRWVTSkloai9ReE1hRlI1WlgrckpjcEpKczBtVmFmb2VMemFSeXg4VmdrUWxKOFduK2NsSXNFZVJMQlJsd053TndLZk5tdlJXTktDdFFOVGs3SU9qYkpwb2lCNHZUMlVXMWFaS3NPM3hYNEh3Y3lQQTFpQ2NFejJRbXh5c0kyc2lTY2xKMWRja053Snl4NUlrU2kwRHV4Q1JVN0t5d1FiWkhRYlRhVXIyZEVuWXlCMCtoK21RTkRZblBkblp2bkltSmpwVlJYVEYyWVJNdUJVcDRaVlJEd2JXYlNDQ0JDUGlyeUk3S1Y3R3NGS2dkVUZXcm1EOHd0VlBvZW9rSkpqVXFEVXFqQlZYNkVQQnZGcTVLZFZHNU1xRmFoRk5tcFJyVWViYWRXMm83SGRrVGhuUS8wZGtUMkx2SkRrZ1N4Rm90SEpDSzVid1Vmdmt5Q0NwaVdCOVdnU2syQ1IwVW9lR01nZ1pDRndhT2lxeXM3UG4xWk8wSjRaWHB1bkkyTmpaVFMzMFUwTlprcVNmUXFXdTdRZFdRajQ2d0pGS0hMNko4RGNHclZDSzZ4YW1EZHR6SlJxYit5bW8vTDdOVlQwS2pJa09oc2RFR3dobERhR2lDQklTc3pWV0JxSGJRcTNVRFZtTzdVaXoyU25nWDZJOWtDdXJKWGl5UThJUlR3ZG5mdGlHTzFDak5rUmFDQ0xRUmRNUTBWREdoS0IzZkNlQ2RreE03VU0xTktPamJKc1M3SnBYUTlSc1RKZHBIYVNuTFJvS0tSQ09yVjVOZm9xWDg4ajdLYWQwRzJFYWVybkpobFRTV0JVU2JCVUd4TWVtYklGU1FRUVVvU3N6VXlpcFp0b1Y3S2lwRVhteWNrU1JtOFNMSEZDdEFsWmtaT2xBaUIyZDMwS3pIa2dUOENSQWtSd2lUcTBFRUNkcXVpY2ZWK2pySEg5SDZFenRHclE2Y29ka0xzWEJzazB2OEFaR2tzQ0lIZ2t5elVwOW1wcFNzRmRPMXdmR3BiY3NyVWRGVlBsR25WSTRnVk1pbVlza2wwSkRTSWdXU0RhSkNzeXNyc2pRcjMwd3hyakdaR3NSd1hORUVjWjRTTzlZa01ZbGFoS2JlSUV5ZkJBdmRrTW03OUhra3E2NXNpOEVjRUk2eUlUR3BXVFUwM1N5THJONUpFYUttdEduMFUyWjVHMmlweUxKcmFDcnlhT202ZXl0WUtZcVJwMHc1SXlKK2lZVWl5cHRtWU5wVjBKY09oc1pXVjMwNnRqa1QzS1JyUEtMUVJaS3lRa0t5czdOazJSUEo1WWlxeUZrcEpoa2tDVm1aSGdpU0x0ZWJ2S0tseFkrenlTVGFEb2kzVmtlQ1JNYVZTaG1wcDdTTEp4YWJKQ05EL0FPUkZIUWpyTEc4R1pHN0pRUDhBWTRTSEhRbk5UU0VvVWl6a2owTENoa3BMZzBTSW0wakpOUmxYZkRSMWRqaG5lVVJhTFFJUXJKV1N1aGNHNEd4TzBralpKSkpKL3dDajlqR0pTem9wWjJRZU9DWlVKbU9pRVFNaVNMVmNIYVRKa2xLOERVWGpscVViMFZVdzRJSXRCRmthT0swVWRXV1J4MFJBMzRPclZaSWsyaTAwdWlJUXNDZGt2ZDNuQ0hOcEo0NmpHNWZIUjF0bUdkNVEwUVFRUUpjb3NoV2JHeHNrM3dmbVB6TVdzZmxURlVuZVJkaWVDbERVTVdDckpTSllKOUhlTFNSSWtxY0ZUOENsZGlxbG5kbVBHVHNlRHZuRDdHdkF1RUVFV2Jka2RDRVY2ZThhaHdOWGdnZ3B3MHpTY3BDeUpRTktaSEk1OERjRytNc25FaVo1bmdvWkluNEpJT21Qa3htbytFTWgraDBzMHRaNmVDbXVtdm9nZ2FJSUdLOGNHeVNSdUIxU05qWkpKSklteFYreVJzcEVURldTdFRraXlrUWxKRUV4Mk5lVHlmMlZMMFJnb1hzOGNLbkE2cEtmUSsrWFlwWi9RbWhKRHMwZjFhRHNnZll2MFNJMTZJYzJnamo4YXFhRUppY2tPUjRHMGxJK3BSaDRQMWFIYVJsSml5Rzd3UVFSZXVxQnAxdkJUOGFwOWkwS1YyTFRTTnFFa1lQeDBQdEg0S1BCK01kRUVFRUVDVWNwdTYvUTZoc2JHeWJwaVltSzJuUFFpckpUWDRaMlFKQ0VqOUVlR1EwVGJiSkE2ZkkzQXNqY0RxRzVHNEtIL0lhNFFRUHN6MExEd0p6aGlJS1o4aVpCSHEwV2dmc1hZa2E2L2h3amg4S3Yvd0FsSWh0b3J5WTZKUkNtUmY3RHdJZHBnazd0TnBnZkpzL0h1eXhSVGhFa2trbTRWUnVOd3Fqc2RKZ2dnZ2dnZ1l4MUpkanI5RHJZMk5razJqaXNka2ljbEx0aGowOTNSRHB3enNSQThIZlk1VE41a1VuUS93QkZSK2lZRzVIa21FVk9ST0hJK2gzZURyRFBKVUxBdloxaGlQMEszOUg5Mzh5ZG1mQWpVelJ3ZkRScjJWeVVWU0xLSjhGZnBXU2pKRXNnWjRzekxWa1RlU1NDTE5qYzlDU1hZMlNUd2tra1RGVUtvVEtrcWpVcDFOUE5Bdm0xTEZTRjg2bnlqL05vUDh5Z2Z6YWZDSDh4dm9meUsyVXk4c2tiSnRObzQwMCtXTVFoQzZHNEtkUkRxcHE3T25DS1ZpUkVlN01TOHV5czZvSmJHU05rall4NE5OeWhyZ3pzWm1sblludWVSQ09oSzBPemZnZy9vUlQreXJLZHBKSHgrSnF5b1pRNUo4RDdPemJETXlNUkkzYndSN0VoV2Jzem9iR3pzd2hzbjZwRXhNa2VUNVB4L0s1VUtYWnNmQklSQXhsSzhzYkpFeE1US1hnY3NpQk5NcS9qVWFlcEtLV3JNL3NSTm9HTWJHUEZtUVZQd2FUaGpVanYrcnRTYlo3RkVpbDlpdzRJeWYwZWJ3ZDRFaENHVmR0ZlJwYW15cVRSclZTbENJeVBEc2w1S3YwS1RIWldVdjJka1haSTNHUnVSMUkvSXVrUjVZMzlQUkpMSlluN0U1RXhNVEhrK1RveC9KY0VVcUVTUGhBbGRvU2xuUk5rSVJTeW1CcVN2VGFHb0ZXMHlqVWxZTjBpcU54SXJmc2FtekdwR2lMUEJFdVJJV1ZrYTRRSkloTWlPaENpUmQyVm9rU0l1a0laVjN5bWIvRTE5amhsTlZuRnVoNUYwZGxRa1FlYmREWS9ZM05uTHdVVWJCc2YwekovWlBvN0phRS9RdTVKRXlScVZCcjZleXE5Q2wybmhObFpXV09LRUptNHBxT3l1anlWSXBxZE9TaXRWSW02WnVFN01nWXhxMVRuQ0VoVWlWbXVQVEliOG1mQThMQXNJNnZNY0lFam9yeW1RUmVlS1o4WDVYL2xpcWtsRGNqeDJOQ1Yvd0JJUjFhU3AzU05GUDhBMlkyUDZ1c0UyNzZzcXZZcW9aSW1TU2ExRytrYWkybXNTTWYwenhRclNTS3MwNmlKUnFhZmthS2FuU3hPY3JoSW1TTmtqSGFwd0ttUktMTldZMFFRUWRFVDBOUWhYV2JwZVNCTGhVNFdSM2JKdFBCWVpvZkxqRll0VlBvcDFCVkpqbndMOW1DQ0l0TWp3VEkyZGtEWjBQNkhkWkdoaW1MTlJrV2NDWW42SnRKOGpUaHloS1dSQ2dZK1Vra2tra2traTRPMU5jRkdwNEhEUnFhY0VGRGhpY2lzbUpra2tqZHFxL0FsT1dKY0lraXpWNHRFNVpGMGlQbzE2L0N1eDJrU0VMaHAxdW5wbEh5cHhVVVYraGFrazM3dDBOeU5remFxdExzMU5adkNHVDlYZUxMc2E0ZVJMeVRhU1RVcDNJb1g4b1l4L1ZQRlhWMktwb3AxdllxbFZncW96aXljQ2MzbURjU1NObFdwNFJRcEVoQ3Vyd05EWEJMQjBMOS9WcTRxdTNkV1ZwSjRVYWxWRHdhWHlrOE1WYWZRbkp1Skd4c2tiSFVrVjY4ZEZWYnFlZm9nVEptOGVSc2l5U1pnV0JaY2prV0JYUlVvcmtZL3ZWMVo4RlcwTFc5azB2cXljQ3FKSGFZSFZBM0krelQ2RUk4RWlZbmRxMEVjb0UvbzE2SnBtejRMZzBLOENzdFNxbm9vK1pIWXZrVU1WYWZUTnlIV2g2MUtIcnowT3Bzbm0ySm1UTEY3UDJZdi9SRWtUMGJXVEdFS2tTOEg5Y2RiRFBBME1kbmFTZm9WMVo4SUliRlRBcVdiV1EwU3lXU3pjTmtqTktyd0lTR095RmRvaUx3UVJlT1VpTloveDVwY3BKdDJNNkpGVTEwZmtxOW01dXlKdFBDY3dOK2h1RmtTbkpMWForeWNTZGRDUzdWNUlnZ3lRYlg3RW9FSzhHdXZJbktHT3pIL0FNREhaS1JVRVFRUUlhR2hJVk1qMDVIcGpvYUdtaE9EVGFha1Ezd1Q0dGZSSk5wSnZydndQa3VDNFRhVHV5NEs2czdWRFVMQm1KT3lNSGdUOEV2b285SFhaM2VTVHJzbWVoQ256eDFWL0VvR01hSUdpQ0JMbEhOakZrU2k2SUVyUlpFRFJVaHBNcjBmS05PcDA0WitRbWJkV1RFeHNYQm9qaE5tME90SS9JZmxQeWV4NjNvYmx5N1BnblpYbmxISk1YMFBLUDhBMUJLSWsvUlM4UVllQmRpemtpOFJhTE9SY2RUL0FGS09VY0lJNFJ5WXlsQ1FySldtenNyTkRSQWl2VFZRNXB3eW1zVGtUSlFoTzAyWEZzZFVEMUI2aHVOeEpONEdpQjJkcEpKZ1RKRmRvUzR6WkM0SzdQMk5Uay8vQURaS1JZZVNjNEVzblNLVjVJNFJaQ1hIV2NVbERzeDhJK2hjRlpzU25JaWZBa0pXYktjaXh3cTFQQlRXL0ozd3FwM0ZWTHBaUlhBbkpJbkJ1S2F2WW5aV1kyTWJnZFJJMlRlU1NTYndOZWlJNDlDZUJWQ1lud1EyVEloREUrQ3QwTXgwanNhOE1pSEIvcTVRbE9XSjV3T0pNZVJJU3NsYUNPZXU4Q3haL3dERXhpd0lnVnBzc1c3dEk4dTdValVYcXBrZEVDY0c0a2tURnFDcWttU1JzYktxNEhWSTM5c0RVanBpeUlObzZEb1dSQ3MrYUZkRTMvWnRrand6YXhMd2JYRUcyRkNNcFlGVG1YYUNDQ0NDSUV1REdhN3phbHlQNkliRlF6OForTS9HYkdiR2JXclNObmJGZFdaQXJMQXhpRVNTVE50MEhhR2l0UmxDWk4weFZDck54STZvRzVKSitxYm9nWTBSd3FSRUVpWkoyUkJGcHVoRUVDVW5ZaUp0R1pHbThtd1ZNWlAwanlJbFdUUW9aSDB0bW81ZGs4OG9rVkVrSkc0VEpaSWlDRVFPaE1xMHZSVW1zTVFtVFpLejlraVltU04za2tUSG5vNk95Q3BlUm9xVU1URXlTU1NTV1NOeVNUeG0wM25ncnRjWGtkTWovaUxJclR5U0lna2tUaTgyZ2hzVkJIMGJtaFZleVUrRHZVNFErNXZTL0hCWktVUVZkMnBaMlJKRUVpemFTU3FsVktHVmFib1loQ0U3TjNRMlNTU1NTU1NTSmlPMUJVb1pVcFZreVNTYlNUUDFMaXJyNkdOU0xBbmZ1NlVrUmFlZllxZmRwSkp0SkpOcGk2SnN5U2JhdFVZNExBbk5rcEZTTEZxNmZOa1VWK0JXZlloNEp1MUt5VlU3WE5rSndKOG1PN0c3OUZMRVZxVU5RYWloendra2IraWpMS3RLbGxXalVpSUV1Q3VtS3pYSjJWOFdTa2o2YWFaSVNHeVNTUkRmQ2JwK3hXa2wya2JOUnkrS0VwRW9GYUxWVWtDS2FpVHQyY2tXUTBOSjRJakFoc3BSQkZtNDZKZG11RFFrUkZwZ29xSmxGU05SY254ZDFnV3BVaGEwOWxhVlNsSFYwSzZGZUxlTHNnNjRKV1hQVHFrcFRaMXdnampOK3hOZEg5Y0hrZU1HcFZHT0tRa0pDUWxlY2pTWlVvc2tUQ0tQYkV4OFdpcEVpeVVpR3JNV1NMUmVSVlFkNUdyTEFtUEkxSnEwUmxmOEdtL0RLMWtRdVM1c2pnbElsQWlPS3ZwcHVxRUpiVkJJL3Bra2tsV1F1RFVsVXptNklFaElnUzhsVGdtU2ZBOENZMG1RSXJaU3hNa2J2TTJhS2xERXhNVHMwTVhGby9zZ3BjRHlNUW5CTnFsS2dlSEJObWlPRThZc25BM05vdXVLdTNaazJnUzlrRWZWbzZleFN5YlA2WDZ2Q3NtckxGdWhHdHB6bGNFaENzaG0yQ0JvZzhERVZ2SWlsM1JrU3ZYVGdrVEV4UEE3U1NTVGFUdTBFd1NKOGRlbUhOa01mL01ydmgySlJ3WXZwZjBNWWg4UDNiOUNja0RGYlcwOXJrbTFLRWoraEtleVBRMFJaOFgySXBSK2lCV2dWbWlwUTRFeE1UR3llRWsyVEVRTldrVlluS3ZycVVRSkRHUC9BSlZkOEkrbVJXWWgvU3greFR3Vi9Oa1FLMWRHNUZTaHdJWFFrSkNXQklkb0dyekNrM0Q3RWlrWWxKRjBKRFJycUhJaENKK2lCQy9aQkEwUWFiakZrVktVVktCSVkvOEFtbTc0cml5ZVQ0UjlEczhXU3VoQ1BQRDVOTU9TaFM3SVYyU1NNZ1kwMnNFZVdKVGtaUzdkVzZJdDBQSnJyRWlzbVRhUldteXNoSFpBMFFMQW5LRXhzcU9oajRSL3dKM1ZuWkN0QWpvbi9pYUhlUFI1T2lDR1FMSkhMNUNtZzB1eVpzbkFuSkl4a08wRE9qdGtFQ1JsRVhuaHJMK0loV1JCQWhqbENkcEpKRlZic2dkSXNZS3NHOStSNXllUi93RFQwZU9DdjN3amt1Y3AzZzdIK2gyL3V5OTJYcXlGd3FVcG9wdzJoTzBpWk1HNFRReVlOMGpNc1dMTGc3cStvOENZaElTSUlJR2RrY0d4TVZRbUlpelVvcVVXOGpzeURyL2tkcHNoRWtuWjBUOUU4cHlaOGtKS0VJUS8wSy9SdFlsN0dySkdCQzQ2Mkt4TVZrdkkyZEVrblowTEpBa1k1TzBra21vOFdURXhReUNEb2FrMmtEVm1MOW5uQW5BbUppeU5FRlZKQldvZkYvZWx4ampKMkxndWJGd2VNayt6RlRJbm82N0puZzVKWkRQMFFlSU8rdm8rVW9xa3A3RmJ3SkR0U05FRktJSUl1aUJrV2Q5WHE2WW1Ka2p2MmJUYU9rL0diSU5vbEFoTVZtaXBHb3BVMmZPTFFRUjlDVmxkajRvazZPeDg1SnN6K2lwRTd1ekN4U1ExNVA4QVhzblBSa1V4a1NiN09yTzBNU3lSWkxsOHBTcEZncFloS3p0U2RqUjBMSWlDQjJrZG1PK3M4WFJTK1NZbVlaQWtiSkhwbXdhRXhNVHM4alhnYWhqdTd4eGdqN2xicXlzOGl0MWVCYzIrME9wdUVqWS9MSFMzZ2wwNFpocUJlclJmcTBDVWZUOGovUVdTa1RKSkpPeWx3U01Rck82dk1FanMyYXJuRjA0RXltcTZHUTdKbTRUUW1TaUV4MHlPZ1NnVEpHN1ZQUDBLNklJR3JRUnhqZ2hXUWtKWFdTQjI4QzQvLzhRQUx4RUFBZ0lCQkFFRUFnSUNBZ0lEQVFBQUFBRUNFUU1RRWlFeElBUVRRVkVpTURKaEZIRWpRZ1V6UUZKaVUvL2FBQWdCQWdFQlB3SHlUUGdzc2IrRE5hS05wUlExbzBWclFrTkQxclRBb3RtUGhEa2tac3k1TWs3NTF4TlE1SGtzaTNZcC9CNm1GL2toVGFQNUsyWXBVK1NlU3VqQW4vSWpLM1pLYTJqZko3bndlL1hRcGU0dVIvUjdMN1J5dUhvb3B1bVI5TGpqelJSSkM5SnVWajlGTDRZdlF5ZlppOUhESHl5ZVd1aVUyemVlNVEycGRpOVBDUzdIalVTTUw2R3FZME5mT2tPVlJLUHdqMjJMQ3hRb2hrcnNoVDZLc3plbnBzY0swand5TWxRcG0rK0NQOGRKeitpV1Zyb3h5M0syY3g2SXZkMW95VHBXWnN2dU94bkM1UktYdVUvb1UvOEF1aUU3dEUxYW94em4wUVNTNEdsOGxwSzBLWHlkazQvSzBZMFhYbWl4bGxtUldoclJvYUhyUlJXaVExd05hVm9rWTNSSFA4R2IxRCtDVGN1OUtIMEtUTU1iRmc0c3lOUkhtdmdxeFdVUXhPUkRHbEhnVXFmSk44Rzk5a1ovWjJZN01NYmZPbVpvVExJMDhTWlpDU1Q1UkxLMmJtUXpWMlpKM0RnWXhqTEZLaDg4aWtvb2s3ZDZkRC9vZy9nK1JHNUZvLzBZWnVMNU12cmVkdU1uSExMbHNXQ2I3SWVubDhrOFRpVzBMSTBZN3lkSHBwTzlyTTh0c0d6REp5anlVcnNVbDBodWlPVndkL0IzeU05Wm4vNkliSHJ1ZFVSamEzb2kzZkp0ajFSVFNxSXR6Vk1sQzFSa2RkRWNndVVUajhuWXg2SkcwMmxVUFJNYkdXUGxEUlF5amFiU2loclNpaG50bnREZzBOdENtamNqR1NWbTAybEVsd1JsUmhrbWUra3FQVVpOM1FoRUlwOWloRytFU2ZGSVU2UW9iMFpNVTA2WThiUW92b1hwcHBYSWFYUmpXMURaTzJ6b2d0enBINUpiZmdiTnhZeE1pL2pTUXZUM0c3SnhwMFVJaEJ0RCtub2tSeDJ1VEpqU2ZCVmNqWXl4TVVoenRVWXEzY2tFSklwRW9rMVVxSXdiZEhwNCswcVplMlhCNmlhbmk0TVg0NG15T1ZiZVJadnlKeitTV2I0UFI1TjhLTTJUMjRibVRkdXp2eGgxU0V0cVNrS3FFcVhKY2x3aHY0UkowdHZ5VytDRS9oRC9BREpYRjJkajBYQWxmSlEwUHhlalEwVVVVVVVVTW80ajJYZkkybzlHNit4elNIa3ZrM2ZZNHA4b2NLTGFJWlBzU1ROcHROcFBEWFJHTW9ma2pKYlpzRkVqaGtSeHZvampKNGZrMktqK0NzelpuTHJvM2wzMFlwdXRrK2pMaDJ1L2dXU25SN3FIT3pzOUtrcFd6TE8vNGpHeE1YT21QbGtrU1JjbDBPMitkRjJlbGhVYlprOVBHUXZTVWV6R0hMTW1YZTZKSWw5RWNTK1QyMExERWt0cm9SSjhtQ082ZHNhcm9UK3l5YzZYQTFLZktNZVZSNGtqL2o3c2NVK2lTU05xcW1lempINldETTJHVVRvOURMOG1qMStXM3NReCtGSFJpelZ3eFpFUEkzME9hSGtjbUovbnlOL0JHZENrbnlUaGFzaTZkUFZLeExSc2ZnMFVVTW9vb29vbzJtU1NnZThPVnU1SHVKY0kza3NrbVhla2VlR1U3NEVtT0ZqeDBLVGlZOHFsd3phYlJ3VDdKNEpkSWVMSXZnVUo5R1BDc2F0bVNmd1F5Y1V6SExnbnlYOEl5dHZnV050aXdvV05JbVAxVkxhYkpTNW85dHJzMm45RWZ3WXlSUlJCY0ZIcG84MlpNZDlFNGpHaWowL3AzTGxsVnJuZndOVytDTUg4azRKOUNUWEE0UDRKWERzN0VUUkQ4VDMwajN2a1dUaXpkYXNqSldUVjhvamZSdlVGUW44amRvVExPSDJaUFRwOUhwbHNtN01zdDhtOUhwWlZvZU5KYzlud0lVL2hpYXJnbnlSZk5JdFdYcGp5Vnd5TDNHYkhYS0l1MFJWbkJZeHk4WG94NlVVVWNJcHZvOXRtYU5Qa3F5bFhPdERXbU5JVWZzVUYwYlBnbENpY1BrVWZveFpIMUlvb1ViSjhJOXUzYk10dmd5SS9waWswUWsyaVA0eHNVekhENUc2SGsrRVBLMDZaSm1DZHFtZGs0RFRURTdYSXVobEZFSWNDaFpqV3hWcE9LYTVQOGFKL2lSSStuaEg0T3ZEMWRxbVlxdmtsTDZKT3BtU2RkQzU1TWozTVFrVmFKUnBjajB4VCtHZTRramMyN01iM0N3ZkpLRHZnbGtuRWhudmhrNWZRbWJpelBOcm9lcTAzZTJ5VVpOM0pEUzNjbGZRblFxN1JiN3N1eGVHR1hGQzU0WXZ4blJWYUlmQy9iMkpKQ2VucUgrVkhLT1NqcnNiK2k5SVA0UW9yNU91aW14eGJSa1ZDNEVZcGZES0VqTEpiOW9taWpKeHlUN0xNZkVXeU10em9VdmJkTWpuU1ZHWExmUjdqUmR1MmQ5RWJpUm1Qa2wvWmQ4R3lraG9vaGgrV05VU3pVL3hIa2srMlF6emlZczZ5YVg1WnNlK0k0MEtYMlQ1SlFadWtocStSSVNFdnNsVWxROGRHMmloS3pGaWJJN1lkRzZ4alNmWmt4VnlpRTY0WnVWV0xJbDJia3pQNHJraEcrWkdLYmtyU0pWTDhhR3YwcDB5T1Q2TTMzcmREZC9vYkwxN0tLMGJya3lmazdPUmxIWldxcFk3K1RISytTS3RXZEQ1WEJOV0pDZ1VZM3VXbVQvMk1UWFk1M3dqSko5STltZFhJakpJdHVQOEFRdU9VWlZ1NUswakZ5ZEljYTRNY0lrME5xSkRQYkhKUzRNWDh1UlNUSlVSbnRrSjJyUFVaTGRJc2l0ekhHaFNjWldqSFBlcjBXdG8zTDdIT1AyWlBia05JMldMRXovR1RQOFFuNmRRNUsraHcreHFoOGxJMndNU1ZrclMvRWhHZDhpblFwcGsycUhsVGUwb1pRaVhRL0RISGR3Uy9vM3hVZU9DY3BPVzhsR25TT0swVmVMMFRHazBkYVNmeCtsNlhwWGhrL2lVTkRXbERYaGc0N0UrTkd5Yit0STZRbHRaOFdadjVObnVTWEI3a2pGalQvTm5xc3JYNG9wOWlYL0VSZEZXT0NaN0tNR05KOEhxWTdNaGl5SjhEZndaMjdvaTZMYWRrWi9Zc3JQY0hLekJrL0VrN2VtUHNmS3NsMmVrbHhXaU1tZU1ESjZ4dm9lWnM5eG51TTl3V1FXUWptSTVFOVBVQ2xmQW9XT0JsVzFjR09HOGhncmxrbEdKQ2Fhb2IrekhIM0h3WkhzNEhtYkw1c3g4b29yU1M0SDRZNTdKV1BMK2JjUk92NUVNVi9sSjhEUzVPYS9VblIvc2IrdjFaSFFwWDRKYTVQNGFVTkROamFzMlA1SGlrblIxM29wZkJDVHVoRFZuL0FPVVNTVDRFSW8zL0FQSFJPRmpSamh1ZEM0VkdURkdmSi9qL0FHTkxiU0h3ekc3S0tNYXBIcUliNGp1TEZtbU51VHQ2SkNJWXB5NkkrbGw4c1hwVXV4WWt1RVAwNmZRL1ROZERqTEd6M09EczlML0liUzdNdWY2SnpzYkxMTExMTndwaXlOR1AxRFJra3NpdEMvRmlkbVZwUkxjdURIaDJsMFRlNlpGRDZJNXZiNkp5YytTaUtzaDZXc2RqaVVLSktQQS9GLzhBNkkvOGoyMlBkR1ZFRkdya1BuOVZXUGhmcnp1akN2a2VpMGZCSWM3VkZEUTBWWmd4eDNVekppV1JXak92YmFkazVLVXJXdk5udU5EeU5xanBVaDlpUXRLR2pKR2oweStSem9UczNGMnpNa1l1eWlNUHNzbEl5d1Q1UlJRb3RrTURmWkREdEVxMVNOcHRIRWxnaXlXQ1VUMC9GdG1mUGZDSEsvRGJ4ZmhZaXhPaUdTaWxMbEVJMDdNLzVQZ3hRcDJ4UGduSytocW1SSGhieDdvamkxMlVReFN5ZEVQUzdQeWticE5jZEMrbU90T3pKQ25vMXFuV2liWEswL2pyWDZHNy9Vektya2tSVktoK0RLc210ckZ6bzlNRS93QXFaRjJpV09NMTBaTUtVM0VuRFk2SzBwc1NMcm83N09DSldqUm1NRXFpTjdtWFhBbHdUZTNvbExjWWwrU0xRMk9SS1EyU01lSnk1SVlVaFFvU0tLRWlpaWloeEdqSkI3ZnhKRDFTS3NXSzFaN2IrVDJ5ZUg2UGJyc2FvUW5SaW5UTTgxRmZpWVZiSGpwRjhEbnRaSjdtUWlRbTRxa1NVTW44a1M5TmpYSXF4eDRGYjdFNjRSbXlPTE1UdGNra1VaWVdyR3ZLcksvWFJmNjl2TmlIcWhqZGREYWtxWjB5aGowaG1jREhsY2pMQlN5Sm1WSjVHU2p0ZEhSdTBvclNLcld1RDFCamZORVkweVRTNEp2NkcyOU1LNXNzY2lVeHZUQmc5eDIrallsMEpGQ1JRbHJaZXJRMGVvdy9LSDRWOUVWWFpTYUVxRXJOcGt4V1BIV21ObVZXa0p1RHM5L2NxSlNwSFpGRUlsRkVwWEpJOXkzUkowUExSa3liakZrYW91eWlyTXNLWTBQVmZwclN2MXZSRDc4VU1kRkQwclZxeFpKUTZQZGxGV1NTMFNGR2loTFJhb2E0UFVGMDdNYzl4a2hidlN0STBrUElTbU9SWml4dkxLaU1GQlV2SmFXV1dKNk1aSkpxalBqcDNwV2lqU3NYS0lpVmxVVU5FMG1aSTB5QkZibFJQRTBiYUtzVWJJWS9zNkVyMHljU3NqT3Biako2amNxSHlVSkVWd1ZwbngyclEwTmVWZU5GYTFadC9TOUYxby9Eb2t6azVJcXlhY1dkbEZGYVVjbjk2TFdoSVNId1I1Wkk5UnhvbTFMZzN5Y054elZrWXVUR3RyNEh1R3BIYXNzN1BTNDlrYjFZdEVJWTlFaXFMRzZOMm1TRzVFNFU2S0VRZG9VYUlzV2xqZkErakpHK1JHRmlsQnFwRGhCOUh0eFF0cU55TFI3a2FONk1rZC9LTmc0c29veFEzTW9yU3JNdVBheG9hSy9UV2xDZ0tLSkw5YmRjYVB3YUtzcEQ0SEpsdGlUSzFvMmppVnAxb2hDTE95QzVKSHFCOEVlN0ZGTGl5Y3FTb1R1a2paVHBtUnRUYW1Rbkw1SHh3T3Znd3gzVG9RaGVDRU1lbFVWWStCOGlSUXoxRVBuV0RJTmRIVDRMRTlIUTl2eU53TjhWOEh2TTl4bTQzV1dMazNHODNHNFVoU0UwelluMFlJcUtzN0doclNjZHlKdzJzYUd0Szg2S0tGcFYvcVFwYnNqMHZSREdNYkh5VnB1aXUyZTVEN0ZQRy9rVzM3Tmg3WTRpZ2JUWVVKRkRSUXVDSkptZDg2Si9KYWlqWXFzdzhvY2srek5KYjBrT1M1WStlOVBTUitkRjRvUXhsZkpkb3VpVEVyS0dobVZXaHJrb2pTWkZwY2lhZkovb1RVVnl4NTM4RzlzY3JMSFA0TExMTExMMXRWcFpZcENtUnlVWTVxUzQwZXM0S1NKNDZKUks4cUs4RVVMOVdTVzJKZ1hJOVVKV05VTWJTN0hsU0paTDZKV3h3WTAwY2xzam55UjZaajlmTmRtUDFXT2ZIUlgwYlNob1NPRVBrUXVUb24wWk5LU0xxckl6akpHMTNkai9BQ1ZzVHZsRUZVaTlQU3I4ZFY0cDZOQ2ZGRmNES0V0R2hqUk5Vei9SN2Q4czRYUlk1Ry80TndwMFdXV1dWOC9zUW1RbTB5RXR5c2ZnOGFhTW1HaVVCb3JTaWl0YUZFb1pCZlA2c3JjbVkxUTliUGRVZTJaUFhMcUpMMUVwRi9MTCt6M0w0UnVrYnZnWlJWamdiS09VWXM4NGRNdyt0akxpWlNmUnRLTnBzTnRsVU1tWkVOYWRGL2lmakI3ajNtckxmUjB0ZlRmeDFYZzlMSHBmd1VMUmxqR1pGK1E1cVBRM1kyTmw2T0V1L0ZWOGszOEl2NDB2d29vUWt4UmJOak9oSHBYcFJSUWlyTW5wL29uaW9jRGFVVVVVS0FzWlZISXNmeS9LeGFVU1pRdUI2TnBLMlpmVS9FUzNMczRSZER5ZkNMc3VpN0ZKcmd1K0JLK0VWcTFvbVlQVlN4Y2ZCaXpReXExNU1tVFEwTmFYOEVKSmZ5SGtpdWtVMStRM1ozcDZYK0dxMFdqSHBlbEZlVTJvcTJaY2x2alJ2NEwxUmJNY056b2ZwMzhEOU5NWHBwL0pIMHkvN0hzd1BZZ2UzaU5rRDIwVlJRcFJMaWIxOEN5Skh1Q2xFckdlM0g0TVNjSHdKM3FpdFhGUHNsNmVMSmVsZndldzBleXhlbll2VGp4MEtMYkpZYkZqb1kvRkMwYkhyWkpxS3RtYk43anBDYVQ1Ry9vc3V5eXh2U0Zkczdkb1NFdUtGRlVWOElsSDRZNHRhSmtNamc3aWVuOVFzcTU3OFdORWtTaU5EUTBQUi9YaDZUK09xZWkwWXk5TEZ5ZGFYcWtlcm5TbzdId2g2Ulh6b29ObnR4K1JUVWVqM0tIblk4alp2WnVOeHVOeHVOeGJMR1dXV0psaVlwR0RJMjYxU0dXWG81RHlHODNHNDNtODNGakdoclNpaWl0SEliR3l5eFRvOVJuMzhMd3Z5Nkh6MFJWTk5pWDVXei9SdCtSamh5TlU2MWhOeGRvOU42bFpWVDc4SG8wU2lTUTBVVm85VWVrbFVxMVFpOVc5S0tJREhvdGZWU3VkRWVXVGxiSG9rMk9sMGU0K2kvOEE0RkZhcEZIcCtIcFIwTXNib2NpN0dVVm95emNKaWJPeHJ4NkpUSE9qZWJpeXpOaytFTjYzNUpYcEZjV3lQNWkvTS9wSFIvc210cEtLVHNuR3RZVGNIYU1HWlpZMzRQUm9sRWNScldpdEVSZTEyUmU1WHFuNE5GYW9iMVMwYlBVZnpzaXFnMlBrMmZaK0tYQTVXVitpdEtLMHJTdE9QRFk2c3NUc2pLakRQZkVReGpZMlhyUWxwVmpWRlZvdEV5aWl0R1NKUFN5eHlwV1NsYnNmNlZ4eWRsL2hSMVRSRWZBdE9CcjRISDhlUnI2MTlQbGVPVmlkcTFxMW94b2xFa2hvcnk5TGsvNitObC9ya3pMaDM5R1hBNlNRMUhFdjdIeVZvblhqUlJ0WlhoQ0RtTEI5bVRFNGNrZXh4bXlVSEhXQ3ZzZHg0SWQ4ai9vU01FTnNkSk1iRzllaTdPZmc1TFltemhsSTJGRmVMR1NKRDF5djQvU3VkTDRMNG9wVnlSNVJkdmd0TmlWY2tuWEoycll2bGpsY3lhNUdxMFI2TEszK0hnMXEwU2lPSTBWcFdzYmp5WXBxYUtLL2JKMEpYeWRHWk54NEpYZmkyV1I1RytUSEdlU05rNDB2eVJpYmFwSWpqbEhnZ3ZiZE15NHVPQks0VVlLa1N1UEpTa1pNV3gyakhOWkVTZ21TeGZLMGpLaVZNakZ2b2poK3hSUXVodWh2UlFIanM5dWphaWtVaWlpaWh4S3JSb3F2Rm9raG8yR3dtdHFzYnZ4U2I1MHJUL1dxK2hTdmdqSndrUWRQbzRiT2VpTi9JdnlKVGlsU0xya2R0K0dLYmpLeUx0V3ZCclJvYUpJYUdpdEswb2hMWTdSQ2FtclJSUlJYNm55OUdUeU5FMHNxdGRrbHQ0WTlHTXhZdmNZNEtNYVNJZW5jbnlRWHQ4RFNhUHlYQ09ma3pSdFdqRzl5NUlxbnlUZzhiM3dIbm0rekZtYTdQZWkrR2NiL0FNU1VjamZBc00vbGl3UlhiUGJ4b3FLNldzZVhRK0NUTHZTSmVsRkZsMzQwTldjbzc2OHRwc1JrY0lxeCtvWHdac3U2TmFQdzJ0RGRsTDVObTZWUkthL0ZhWFoweFZkbkxmSTN0ZEh1cXVVS2FvVzY3WTJ1aHVQd1Rkc1hIUjJMWDB1UzFSZmcwTkZEUTBORmVVRzQ4a2N0OW5maFhtOVpNbklsR3VVT1VaZnlSUEQ4eEhHamF4UjNPaUVWRGhhTlYwZG9TT2g5RFZvZ3FIUzVZNW8yUmJGaWpmSitDZkFoK2VDSC9Za3hzWDNvdVBDeHNzczNHNFRFNzBkRmZYaTJvcTJaUFdSandqSDZyZk9wRTRLVWFKSnhkTWw0ZENIQ3V4UnZvZVBhcllyVHVJNHBSdDluUlZkbmZJaS9rY2t6ZWx3SnBvVHZnL0Z1bXpiOVBST3ZCSHBwVlB5YUdob2FHaG9vb2poa3hZRjhpeHhRa2tjRjEwYml5MTV1VkYzb3liSnNqUGpheENKY213MkVXNG51bnVObTg5d1UyK3kyeTJXeW15amF6Mi9zVVVpL0d0SVk5eDBxSnM3RWhLdkZ2NFErVGxjblp5STVRbnF2REprV05XelA2cDVPRVhZa3pEbmt1R1pZS2ZLTW1xNEtGS3VDQ3VRazJVOG4raU1aSWNiVzVDd3lZL3JSSzF3VUw2RnRYQnRYd3h4a2pqNUg1SWh3eUx0WDV1STBORFFvV1J4cGVWNlhSWmJIT1NQOGhmUjd4dlpiZWxhTWFzbVBzaFVsclhndEZXdkg2S0tLS0ZHeFlmc1NTNkpNYnNTRm9rUFNqYU5DSkw1THZvaXZsalF0RnBhMHpaMWlSbHpQSTdaMkpHT0FzWXZ4NEo4dndTSXEyUi9rMmlHUnhpMGwyS3FvL0ZmeVJXLzU0SGtlT1ZFc2Z1cTBWUi9yU0xvdmM3RTZMZWlYa2lKaTVoK2h4c2NCd0VxMXZTL0N4SEpZNHBtMFdxMGFKRTBTUkY3WGFFMU5XaWlpaWlpaWl0RnEvSkZDaTJMSDlpU1dzMlVkQ0wwWXRIbzAwS1Y4TWpIblJsQ1JXdG1UREhKMlpQUnRmeE5yVHBtT0hOc2lraXpzeUtwZUNMNE1LMzJkWXlDYzF3aDhmeUZDbGJaU2xaRlR4SWhEM0xiR3FLT2hPdE8vQmFvUkV4Y1IvUytCdStTOWJvdXl5eXl4TXY4QVZLU2lyWm4vQVBJTnVzWS9WWlBrWHFQc3RTNVJDVGc3T0pLMFVVVVVVSkZGRkZhTmVFVTJlMHhZa2hRaWpqd1l4RmVGYVhwMzBVVVVVVUpXVm85V3RNbUpUTmppNkxvVHQwUmladjV2eGFXd2kydVVLdW1SZDhybzVtNkdxNFJ6REx3T1gvYVJIbHZhVGtuOEVuZlhqZmt0TWE1SUxqOU1tTjZJYkc3WldxMFJXaUg1ZEhydlYrNStFZWhmWXhmMlJuUjc3RjZqSXVtZjVHVDdQZW45aTlWa1h5UTliLzhBWkdQMUdPZnlJb29vb28ybTFpeFA1TmtVYjBQSVBJZTRlNExOWFpISW5vK2grTmFQVkY2VVVWcGVqNGV0RFdrNHBtU0xSRjA3SXUxWjZ1TlRzZmhPWHVSVmZCamFUTWIydDJZM0MyWVpyYjJSblMvRW5OT1NzbFc0dm5nVktMVE90RitsTFRDdVJjTDlEWTJONlg1SmxYcXZKTWNsRld6MVByMVczR1A3T2grU1J5dExNWHFKNCttWWZXUW54TGhpNUtOcHNOcUcwdWg1QnlOdzVEWnVOeHVGSXg1NjdKU3RjZWQrQ0xMRS9qUzlMR3l4ZUQwa3JRNDA2STVHdUQxTXR5c2ZnaGM5Q25Vck52NVdiRXY0aWxLS3BFS2wrVXlNNDh0bC9RNm9ldlF2SkVJMk9QMFlJaS9ReDZYcWxwVmxGQ1FoRmEyWHBPZTFXejFIcXBaZVBndmtkZVBaWHhvcVM1RkZWY3gwM3diTEtyVDAvckpZdUh5akRtaGxWeDBzc25iNEh3Ti9SWTJONldXV0ptRVdpMHJTaWlxOEpPa1FreFNOdzVtOU1zc1dySHJuanhZckdyUTFYaW5UNE94UDRZdUJaSy9paWNuVnBqbkdqNXNrOXp2d29YaWhJaHdoZlJqVkxSRitUZmlrVVZyUWxwWG42LzhBZ01lMnY3RjVjeFA2SHlRaHhiTnNWeXlvczJXU2pXbUxMTEc5MFQwM3FsbVg5alpaSmtwVVdWZlJ0YUZ0WTQ4OENUSktoQ01YUXVDL0Jjc29vcStCeEtLR3JLRm8wT1AwVXhYMTRQUjZTVm9xblFrWm9VeDZyalN4UDdIWHdiWklrK0MvTmFVVVVJU0tzeHhzWEg2V05uOTZMUkxTaExWZVQwejQvY3h0SWEvUjJTYVNWZGloS1luUXJjMVk1cm9uQnZrNzRKd3JyU0UzQjdrZW45VXN5cDlrNVV1QnliNkhmem9temRMb3VoREpzU0ZFeDhMUmFXTWpxM1IyTkhSVmo4YUs4SDRJeVJwaVJreDdrU1ZlQ1IyeHcyOGk0WTNxblJkK0tGcFJRbHBGL0JqVmMvcWJIcXZCSFhoWS9CNkk5Wmg5cWZsV2wweDFmQkIwdDR2eVc4Mng3UWsyN1pYOWs0cVBOamZHNC90NlJtNHUwWVBVTEl2N0xHUHNhRlJGVzdFcUhQNEVySXdLcEVlRUxUb1QwVG9UK3hjbVIvQXRHdkN0SzByeGIxUmtWbGFlcHhVOXlHdkdNK0tFNjVRL0ZDMHJXdFZwalZpNDQvUzJYb3l0YUtGcXRGNW8vd0RKdHVhWGt0R3VORk9sUXBKMG9pajhvN1hCTlJmTXljSy9pVFZxa1ZiMmo0NEVRbTRPMFlzcXlMZ29yblJpZEZsZllvVUpENkVNWGxHZEVuZlJFZkEzWmVpRnJSV2owdndSSXJTVUZKVXpMamNIVEdxSy9SV2xDMFNFTHl3d3BYb3RGNHNiTDhFTHZXOUVkZVBSZXFQL0FDUC9BTFBGSlZiTWRQc2NhVmtZdDlFb3lYZWlsUkY3K21SbTFLcUpOOUU5MDN5VXVpYVM1WFpLNU1hclRITndkb3h6VTFhS05wWDJWeUtMWWtKRmZzUStPL0ZlTFplbCtDOGMyRlpFVGc0dW1VVVY1VnFsK2l6Qmk5eDIvd0JUN0o5QzBTc3FoUDhBVmZoZXZyLy9BR0Q4ZG9vd1VkeCtQd1ZreXAyeHJpOUU2SVpKU0cya05weC9JV1JKMFNhay93QVJwUmZHcU1HWDI1ZjBSa3BLMXBRb2xDV3Z4K3BhTjM0cnhmbXRhMXo0RmtYOWs0T0xwbEZGYTEraGVGbVBHOGpQY3g0bHRSTDFxK0VQMXNqL0FEcEM5ZDlvajZ5RDdJNUl5NmZnK3lmUXVYcGRGMklYbmVqOGtldVgvSjR0L0lsYm9XWEZGYmFGbTVjMGpMSk9teFc0anQ2Umsxd2haSXNjbStoeHJsa1l4YXMrT0NYOHZEMDJmMjN6MGRpanF0RnBSMS84UithOGJXbVRESEl1VExnbEFvb29vcjlka01ibHlTeUtLcEVzbGx0aVRmQXNiK1J3YTZMYUk1R2pINnRyc3g1WXo2MG11VHRVSk5NNkx2UkNMOFhwOGo4VUpIcjRjSmo4WTkwZmpqalgyU2xDRWRxaVJTbC83T0RKQ1VSN2tpSy9HOUUybndKMitXY0wrVE45dWk5dlJaWDQyZjcwNlBTUzl5SCtqaGVDRnBMdjlETExMTDhWNFB5U0xTN0orb2pFbDZ6Nkg2aVQrVDNXZTZ6M1dMTkw3RjZoL0k0UW4xd1R3dUpSUldsYVY1UlRmQ0ZCUTVrWlBVZkNKVHNWdG1QRXlHQ3V6YWg0MHlXRlBvZUd1aE5veHhsVzR4ZW8rSkUrZVVYeVNYeVBrU0VoQ1l0TE85SDVVVVVJOVpHOFJMVmFKOGk1aFp1alN5bVIrNUZTeWNHYUNqekI4RTFTUW5YWmxjSFd3bEdpNkZQN04wZm9zWFk1UG9YUEJRdVQwRC9Ob2Zna0xTYStmME1yVmZwZmxrenFIUlAxRGtPVExOeHVOeHVOeHVGSWprYU5zTWlKZW1rdWh4YTdLS0tLS0tLSXdsTHBIdHFQOGg1bEhpSktiWWxmWW9tUEF1eEpJM0RsWnZOdzJiVlkvVWJWdFFwN25aalkxOG01b3NUVEsvUldsRmFWNEl5UjNRY1NTSDRPNXU0bnhSZ2NPcEdSTEl0djBaSTErQ05rc2kzUUcvc3ExZWxDTzNvaHQ5SFFoSHBIV1ZhVVVMd2FzNi9SWXRFTFZmcDRYWm45VDhSSEpzc3Z5c3NURXhNeDVCYko5ajlMQjlEOUdmNGJQOE5pOUg5aTlISDVJK254cjRQVmVvV1A4SUVwdDlpVnNVRUtId1k4WS94UTU4am5RbTJKV2JhT09pVXRwMnlKalkyTmxvVCtpTXI4cThLMHJXaExYMW1QWmtHdkJmMFZ0TWJyc2Z0NW9WdUhKUmtvcmt6WXZaanVSSWt2b1NzYnNaZW0xMVp1a0wreGFZT01pWlJSUWtVVnJJdlIrTEVOZnF2V2VSWTFiTXZxSE1iMXY5RmlZbUtSQ1pqeVg1ZW95KzFDeWN0enRsV0trZGtDTFNSa21KV3g0MDFZb1YwSlVaY2xjSVoyZENaQm00dXloQ2xUTHZsQ2w5aVpaZC9wWGdqMW1MZkMvb2t2RG83N0VuMFJtb1JxVWVUM2xHTlI3TWpuS0s1NE1sUi9pUzVXNFRwSEJ4V2lMc1QrTkVJaHcwTFNpdkJzWXkvTmEzK212bG1YMUNqMFpNamwrajRPeVVhS1JTMG9URXlNaUV6Rmt2aCtQcmN1NmREWWtLaE1VNlo3bkJ1c2gzUkZjVUtCbGRIZkk0bC9DTm9pREt0Y0VNYjdZNDBOVm9uUS9zVExGSVRMRS9LL0wxT0haTGpvYThaU2sreU01UmRvM3VUdVJPUHlpVzVLbU52YnAvcnlRa0l4cTJMeGJHeXl4bCtTL1F2RGhjbWZQZlEzZWwvb3FsWjMwT1AyVlFrcEZVV0ppWXBFTWxHT2U1YTVwN0lObVIyN0VKTmxDaU9HaWx0WmppcDhpUlZjbVZiNTBTY1lrcDJLL2dUY1Z5V1FNWXVocXlVQnF0RXpnc3MzMGJ4VEZNVWhNdnhXbG1iR3NzYUp3MnVtTmVQYUl6akhob2pzYi9JeDAzejBaRzVQanhyUkZDUW9tQlZKZUxkRXBGalk1bTRzVWl5OVY1MEplSHE4dGZpaHV4ajgwSTdWa1Z5UnQ4aXFQOGg4L0E0WDBiT05FeXhTUFQ1cWZPdnJzbExhTjJ4Q0V2c1hBMVpzSEhramsyOUdQTkZya2xKVnd4eWhGZDhtVDh1aUt0OGlpVFpFaVl5RDBhc2xFYXJSUDRId2NsaVltSjJSTEVXWG9rTmpZbUk5VGczcmNpU2FINHA4bFcrUi9SOGxEVmVGQ1FrSkNSaFg1cXZCdWlVaHNzbElzM0ZpRXhhcnlYbE9XNTIvMHJzLzJMbmhEL0NpTXUwUVRVU2RXamlpTW01RFZjajBUTEZJOU5sM3hwNmVybHVsZWk0SXN2NEtzU0tLVDdKNHZvMk5MZ1RsUW91K1JRSTR5cVJrUWlCQWl5TEtHaWNMSkpvYnBrWGZZNDBNVmkwVDBUMVNHNkhJVHNyWDFQcC8reUhFYThPamhyeXJTaElTRWhkbnBjZExjOVc2Sk1iR3h5b2N5eXhNUlpkRy93Q3hTRXl4RmFMUmVDWDY2K1JPdVI4dXlYOFVxTWMrS1oxeU5qNFIydVJ2NEZwWlo2ZkxzbFpPWDQyZW83RUpDRXZueXF6YVJpbWJFdExNbklpSkFpUkVVVVR4MmpKamFFNjRJL2toeE5vb2lnS0JURWhJVWZzazZISTdJZVBxUFQvOWtPSTE0dmtyeVFscXVEQTd4cHJWc1kyVFkyTmw2SVRMRTlPamN4TVQwWGhhUkdhazZSVmFNZmsxUWxSVkZjV0ovQW83aU0ydUdKSnF5VG5IZ1c3NUpjcW1TNFZDb2x6NFJNY3QySTlRaENFaGZRa05OZUZsaWZKdXNzYkpDSWtTSWhlRGhaazlOOUNqS0RGK1J0RXFGV2lRa0phWkJpN0lMVjY1c0h6RWxIN0hFcndiM2QrQzBRaGlZNUhvY2ozYmZqUnNZeWJKTWJMTEV5eE0zQ2tXSmlFVm9tSmxEdWpKSjNSamx0ZGlkcS9KSytFT0RYQXFIUTJ1aVBkU0pMYXk2NFA3UkZycVJ5bUtjbzludVJhNU9KY3MzTWN2RkhwT1lNOVFoOEM0NUl5dnNTdm9pclBiNFBic2VPdGJMRXpjeHlKdGlFUUlrU1BoYVE4cUhtUnVpL2dWTXBDaWphaWl0RVpFTkVFSmEwVnJrd3FYUlBHNDlqUTRsRmVDRVVJV2o0MDlISDg3TEc5SDBUR1NlcXNzdlZNVWhNVEU2RXl5TXFadUc2UlBsaU1FcmpSMFBTaFEreUVibHdTZTM4U09OVFZJMnRjTkRUczNidjVqeVA4QWk5YU56Nlpmd2NHNzRGa291K2ZGSG8zMmoxS0d1VCtpS0lzeHN1K0NrU2lTWEl6clN6Y04vWmRpSWtTSWlKOERhaXJaTFA4QVJ2YkpYcEVpSjZwbGllblpLRkVWNHNaUlJKSjhNeWVtK2lXTnJzY1RhVVZwUlFreFJZME1RbHllbGhTR01ZK2laSWVPVldZZlRSeXdGLzQ5SXpZSGpkSW42TlRpcU1ucDNqNUxGb2hNVExMR3hQa3NjbXhpUFR1bVMxaDJLU2xQbm9kYnErQmNjaW56MFN1NlJOWDJLQ3ZjWmVlaHI2UGdyVDVLczc0S1h6b3l2RDBycVo2aEUreGluUkdSQ1FwaXlFcGttTmoreHNzc2J2UkNJa1NKRWs2Um1uZWtTckhBU29RdFVXSmxpbDlqVmlWRmVUMGVqU2ZaTDB5ZlJQQk5EZ2JEYXhSTnRrTVRQWlk4RWZsaTlQaStXZXpHK0dZL1R4dmxrV2txV2pHTWtRaithczlTbDdmQmc5UThYRFA4MkJrOVpGOUl3K3R0MU1lMlNveWVoa3VZamk0OWlFSmlrYnpjV0psbDY0WFRHNzhJOWlyMjdFbXFTK1JTMnJrNGx5Wm9KTzBjeC9Ja3FpUDhPQytLS29laTFRdkgwMzh6TXJSbFhJeTZJc1RFeFRvZVN5eHNzazBXdEVpaENJa1NKRXl6dDBoaUlpUklTYkVxRnJZbnBlaVoyTmVEMG9aV2xDNDBlT0wrQitsZytqL0VYMlN4NDRpbEZkSWVaanlEeUh1TTNDbTBMTTBROVhKZGtmVXhsMlduME5EaU9CdGI0UGIrRDJ4d05wN3Mxd2VuOVg4U00yM04wZE1zc3ZSTVJaWTlZQ1hHcW8rVWJrblM2Ri8vQUZQNGprbzhzeVZPSEEwM0NtYm5YSW8yeHY0OFVyMVdsRkZIcG84MlRYQm1pTkZDNEU2RXpjaXh1dVRjTmowb1NFaElTSW9paUNNdVhhcVFtMzJRcHZrblh3SVRLdGlWRDFzcGlYaW5RblpYaFEwVm9scFFscFBJb0dUMUZqbWJ5N0xzV05zOW9qZ1I3SlBFVTBKaXlOZEVQVS8vQUdFMUxsRkcwZVA1UGErU1dJbGpKWXh4SVpwUVZFdTdMMVNFV1dJZWlNWWx3Vm9sOW5LZGp2c2pMaE9KSElwY292M09KRXBxS3FBNHZiK1RGMVFrL2dhK2p2V2hGRkNYZ2tlblF6UEVhS0tFUDYwaXhzNzBvb1NFaElTRWhJU0lvbTl6WWtWUll1UklRMmQ2STZMOGJMRXkvS2hvb29vNk12cUV1RVN5T1RHeHNzakZzamlvb1NXaUdreHdSa3hmUnl1R1dReU9IS01lVlQwU0tIRWNMSjR4eG9rajBzSXlqVWoxRVZDVklXaTFSZXFSaUYwVjk2MzhDbFJ2K1VlN0VtK0xGUDhBS3h5M08yS216ZHhSUldsRkNSUWtJclNoSXdxbHBtaVRpTkZhVVVVTEZLWFJIMGMzMkwwWDJ6L0VYMmY0cVA4QUdGNmNXRml3OENpS0lrZElsRVNISGdhb2lKNk5IV3ZmZzlFaXhDRVVWNFVVVWRjbWYxRGZDRzdHeXhjbVBHbnlSalhSMTJiajNVdXlNcjVSdk4vSjdpZkF1VEpoVXVVVGhURXhOcm85UG4zOFB2UmF5Uk9CS0FtNE8wU2JrN2V0K1ZDcEVKVWUraHF1UjhNdWpzVDQyc2hKUjRQY2Z5T1RZdnNjZUN0ZUNpaEk2RXJOdWxGYVJSQlV0SkswWklqUlJSUkQwMHA4a1BUd2h5eHlybzl3MzJYb2tJU29ZeE5FYStCOUVrSkZFMElTRXRHaXRFeGF0RlY0SjZMU3ZMMVdmL3Foc2JMMGhBVWEwbEsrQ1VlRDIySk5MZ2RvdGovRXh6WTVtU044NndsVE1HZmVxZmZoUTQyWk1aT05EMVhpNWtaTmlGd2YyaVNyZ2tyN0d2by9yVGd2eXZTeFNGSmZJcWZSVkZhVVZwalZ2d3l3K1JvYUk0bkxveCtuakRsakpzc3NUNUZUTm9oTFZqWkdiajBSeUtTR2l0SEd4SVNFdkNpaEx3YUVpaGkwVDgvVVpmYlZJazc1R01YSkhHUVcxSGFIeDBZMXpiSEZQcy9GY0ZKampUNUpxdVVQa3VpTk1vY09Sb1JpeU9EdEdPYW1yOFpLekxBYThhRVNZK1dLTmNpK3lMc29seU5WcDBQOVNWbldpWkdmMlJhZlhoUmlqNGRtVEhSSEh1WkdLaXFMSHlTUStORndRbFRMdGFMb1l4b2EwakttUmx1V3JFaGVGQ0Y0THdhMHNzVDhYd20yWlo3M1l4blo4MFlZdHZWSmZJN2h5aFpiN0c3SU1yZDJUaXFKY0RJS2lLdnNsQ2lZaXowbVhhNkxMMWZCT0pKRDBvUjhEa042YmhUb2prUXBrb05NWXg2VUtGbTFKOEVxdWoraVA5NjBTYStQRk1obFZjblpRa1FWSXN2VnBOY2lTWFJZMldNbEd4cWl4TWkrRGRib1Q0TDFvY1VOVVFrMExubGFWWldpWXhrZWRGby9DNzBvZWlZbjQrcnlWR2hzYkVySHdOZktNVm9USEk3NktZOFRGSG1qYlNvUzRNOS9BLzcwaC9ZdjZKMjBVbjJkQzVJT21ZcDdrZkplamRFcVpORkZGQzdKdEpVZDhsM29seWJiWEk3aXpmSkhxY2Rjb254MlhyZE1sSytoeW9iTzlLTnRISzBxdVVOUHZ4eDVIRWpVdVVRajgrVitEMFkrUnFoRjBZM2NoUDRPL0JxeHJURzZLMGVpMTY4bDJVWFFtV2RqRVdSZDhlSHFNbTZZeGtiSmN1anBtRjJ6ZFhaN3NXUW1qdEVueFJKZkpEa2sxRkdiTXZqU0VTS3ZnVWFRK2VDVURieVJ4N1ZaOG5wWjgwTFZqUktJNGpwRGtiaHRsL0dsa0kzeU4wYmsreWt6TEpSaGNqSlBjN0grbEZjRzM3RmpTNVBiWXJYQTFiNEs1NThNV1RZeUxUVnJ4YjhFaHFocERZMlNaZEU1R0g3RTdFSVJRME5GRjBRZHJScjlWRkphTkMwdndUcG5lazN0aTJUWll5TG9mMld5THBqbmZCWDBKdGNrTXg3aVhaL2tRK1IrcVMvaVM5UkpqWWxaR05rWVZveVlxUGdtcVppZE14OHJ3Wk9rclpreVgwTjJTMStkY2NxSkswVlJkSHJNKzk3VitwSTdaRko4c1hMT0Q4amxrb2oxaXJId2VselYrTDhMOHJHTWx3T2YyT2FvNWJJY0lURXhQVmowWmlueldqR3RFSkZGYW9vcldpdEUvREc5UFZ5ckdQUjZmR2tGeU5wUGdjdmhteFM2SEJST3hwbE0yRVlXUncvSWxXalk1VVQ1RXE3TDRKdTJJOU83aG8xcGx6S0NNazNOOGpmMEw3R3hDR3hjNlFUN056WFp1VEd4dStmMHBrVjhuendMampTaTZPZFdxMGh3TVJneWIxVDhteTlMMFkrU1pWa0lmSXJZa0pDWmVyWXhpNGRrWGF2Um9hRjQwVUllajFhc3BvVDF4dmtzOWEra01aM3dTUWtOVUwrajhWL3N4cmQyZnhkSWwrWlNHeWlVYTVSajU1RUliR3liRkw3SjVEM25WRGZJajBqK05jK2Jid2lVN1kyMkptNDcwNUVKTm1QQmZMSlFWY0dSVVJKai9RaGRFZWVDa1JxclluYlA5RWtJL3M3OEdJeHkydXhPMVkxNFBSYXNrcUpucDhPOW5zeFNvakRtaU1Da1ZwWXhqMHVqQTdXckVpdGI4TEg1UzRFNzBYREV6MWo1MFk5RTZKdFBvWEhJL3NUcDhINU4yUTQ1SE8raTc3RXpoOEVIWEJ1TncyT2RFcDJWYTRHdUNpaEhwWmZscG55YkVaSldXTXY0OElrWVdZb3BkbkZFbndaQi93QkNWajA2Ry8wUWFYWi8ySU94RFoyUDZSVmRlS0VlbWx4USt2QmpMTG9zYnNueVA2UFN5MnlwazUwaU1STFJvNkV5eHZTenM5TythOFZveTlML0FFdFdkUHc5V3Z5T3ZDV2xEVkM0VmtaYlJNcW8yYjJMSU9YMGJxRmxaUEo5SHVzYnZSTm9mT3FQVC96UmRHV1c1MlM1MHRIOWlWaVh3TG5nakdoY0N0OUY4RW1aT3RFL0pJNjBUclNyMGpQamtqVldoTk5HNjJYUXAyUDhTL254UjZaMUlmUldsRkRSUXpsOUNqOWtrTkNUdmc1ZllrTFJqMFdqZWwvQmgvbHF4RjZNc1RUOG12Q3hpMFI2ejRIcFdqRXJkRThWQ3dPWlBFNHFxSXhzYXAwYitLMXV1UEIxWDZNSDgwWlhTTW94Nkw2S29pSkNiRk5YUkdxSlNKc2svd0JMVFhmaHlpRmZKRDZGeHd6cFVoWDhqYWZBdWgyem55d3ZrN1dxR2lpaHhPaHorQnNidDBpRWE1RUx3ZWw2UGs1V21Idnl2U3JFcUxMMWNxTjlpZWowb1haUW5UUFdLNDM1WTF6Wkhrd3hTWEk4YWZZOFNSbmhYUnNaWGxSWGlpajA2L0pHVW1TS0tvNk94Q2Rzay9vU3N4emZROGczWTRsZVNoOHNhNS9FYzIrenZUK3g2V3FMWFo3cXFqZGFwRVpmRDcwY2t1Qy9MR1E1aVBSZUxWamd1eG9oSDVFaXFGcTJNYUswZkEySm1GYzZQU3ZHOUU5V3JLT2hPaTdIcW1TTW41NGg4UFY2UVhGa1pVUnljRWN0OWp5Y0dYa3BvZWlXaTFyUmVDUjZlSm1KZGpTR3FReHBDNjhGMXdRaDhrbHBmQjM0eC9MOFRZNzRGdngvQmJqMmlpbjNxbWNGSXY0RmE1UnVyazNXNzAvdnlpWVgrSS9OaytqYllvMEpERm85ZTlYTDRHTHN3OStORmF2V3l5Nk4xbDJNdWhPeDZJN0lkdE1uR25XcjBUNHJTT1I5Q21LWEJMSWpjaDhzcndyU3ZLS01LcEdaakdOajVLbzc2RXEwWkJrWDlqcXRHaWl0Ri9ZcUlNcjIxU1B5Zk14TlBpaEwzT0VoUnVKK0k2dmcvRmRhbzU2TE4zRmZvaVlIeCtoalZsRmFQU3k5SG85SmQ2UVhKaVh6K3Bvb3JSbE5GdENrZCtYelo2aUhOaldqUld1NFQ1czN1dEtLS0tLS0s4YUtFaUViSThJenZrZlJWalF5bUxnWXRGd1Jrdms0K0J0SWNyNDAyYTBKZklvUTdrZSt1b3hGbFhaeGs1US94azVJbi84QVpmcHI1ODRtQjZQd1dqMHJXdkdoRFErQ1JSamo4a0ZYZy9CNW9SN1ovbDRqL0x4SCtYaSt6L0t4ZlovazRuOGlsR1hUS05wdG81UW5mbGxoY1NTR2l0S0tLS0tOcHNGQTJtMDJsRmFVYlNxMG9TTVVTZkNNbkxHUDZHeHNneXJIR2xvdE9iTFpldSt1ai8vRUFEb1FBQUVEQWdRRkF3TUNCZ0VFQXdFQkFBQUJFU0VRTVFJZ01GRVNJa0JCWVRKUWNRT0JvV0NSRXlOQ1lySEJVak55MGVFRWNJTHc4Zi9hQUFnQkFRQUdQd0tzNjk2d1QraEo2YWFYSnhFU2NpTWN5NWI1WnhEWUlTa2xzM0tjeDZpNWZxM3dLSmkxc2FlY2pJY1gxWk9WQnFXUFNQaG5EbzhlTDA5VkpGdWtmUmI5RTRsODF2b3ZwS21ka3VYUFVYTG5xMXA2bDB5TnRxcVlzWG5KeDRyMG5MSngvVHRuVENjS2RzelpXNkY4T25PZWYwbHdmVGtYNmVMbFZkUnRQRVJrNFVSaDhXU0t2MEVkTjRJSHg4cUhMcXRjeE5obFJxOHB6Rjh6S09ucFhOeFl2VnB4bGpXZFAwRTJTQ2Vxa1pJUXd1Y1NJeTRjUng0ZW00dXcrU1V6U1BoOW5aRGl4emkxNDdFaXIyV2lycE1NdVQrSml0MVVablQzNlU2NjVZc1hOaVJsbERtVWYrbGJvY1gwMWZRazhhaWphalpyZERHdnhZdEtTTFpGYTQ3S1dZZEw0ZFhqU3FZVUV3K3d4bGFzKzJ3aHpScVg2MWhoclU5UStERWZ6UDVlSWpFNlpMbkQ5TkgrUjFXbDlKVlBKTEo3RkJmcllPZkNTaHkzcHhZQmwwMXIvRVhKT3EvNkVnNWlFeXhweHBQclNnK1dSMEd3MjNPVlZQVWVvbGFiWXR6K0Y5YXM2TFliSUltRTR1T2VwVWNrdlc1eWsyR1RKSFVxanlody9VUTJMb2RuSU9ZYzVTWXJDNThRbUZPNG1CUGJMKzBjdzJHc2RTeTJYVHVNSjVFZzRtT0liRGV2Q1RDSERoVE8vd0RWaEpzT2lrNk1qcDFUWkxsNk1OMXlZeVNDNCtNYW5JYzBycHFjZTNVd1NOcFBta3ZsZjJHeFk0c1dYd1IwTUU1NXNRdWttTktJeHowNHNQZkkyamlSRHVTbWkrdXk2anJuZGV2eFpVSTFrODlISFZ1bEc5Z2FzRnE3ZExKRnM4S2Mwa3dlb2JESzVaSk9VMlBXcS9BNnJpUms3ak82VmZTY2l0aURmcGVZam9NS2V3WXNraUpoUWJVZ1poRTFiZFhOT0gyWnN0eHRUYXNhTDRkRmtQN2wwZmsvc1FYRXpZRXQwbXlqTDBrRWtucUxsemNnblF3OUcycXBCdVdhbk1tczdUcHJyUjBVRFVlNUpCUFZ6bzgxamswMnI0STArTERvZnhjZjJIMFgyRzMxbDZSdW9SZWtiVTRUYkNjbUhySHJGUE9oR3MrWnptT1dpcDdKSkJ0b3NOV2M3WjN3NWt3aUpwSmxUbytKS3JweVdjc1dPVW4yUjhJMkwxYVRxY2Y5SXlaM1RwbXllT3M1YVNPbnNhZENqVW5LeTZQRW1YRmpYdFI5SitvVktLdWFOR2FNdnQzQ2NPSFI0azZpOUg2cGpaQzlHT0gySnF2ck1Ua2pMdmxuTSs5RzlpY1hOR3F5OVJKY3VYNkM5Rng2YmRHK1JrUEpOSjZqWW1sNlA3ckZaUDdhcVlodExEb1NRbWhPWjhRL1RQcGNTYWZwUFNla3RxWExsK2hUVGZwRlJSS3ZTQitwNXFMMUU5WStpcGljVk45QjByaHpRZWFOcFNYTG5LU1lmSFN0cHJveVdMVXNXNmVkREN2c0RMUzlJNjlsNlYxMUVxK3Jlam90SXJCTkpHU1ZIeFUyek1OUnN6NU9aTlZqaFh2N0N2dGJIQnQ3QTlXR0hKNmRtbWtEOVB4THFwcnNNbGVaQmFRT2lFa0pJdzZvd3N3YnJvT091bHpIRGhwNTFFVkJNU2RET0pEMUVJbzlQVjdKSFJOcHN2U1dvMUhKckhUT2c2RGRSd3BxcG9zY0tLNXpIQU9saDhJMVppakhOSWpRWElVa2xCcU9QMjY5cXN2cFhVY3VjdUQ5eTdIcVhPOU9aR0lWL1lYSjZCeDlMNEc2T2F5T2lrZXd2MFU2OFpKb3h3aTQ4U3VjbzJFWTVYT0pGU2FUa201TkdVdlIzSlduQW5WUG84T0xSZFJzS0U0czh6b2MwbTNzbkZxcGd4OTlGc0dCU2NJNm9OMGMwanExYTNza0RMcG92MHlKVS95T01iVm1yMWQzUTJPZVJWR0xRTW5YUnIzNk9GR1dGOWlSTlZEZyt0KzQ2WmViTE9FNHNNNGM3ZEU3OU5Ic3VGUnhkSHljUTZWNGJETEJobDZNTlJjTE81ZW5OaVkzSUxJUlIrcVhXZDJPWE5LWlUxZUZiRDljNkdIRDBIS3B6NFQxRFlWZGRGY2VEOUNKclFjV0pSbHRSY2taV0djVlVWMXB4Q1l0aEV4b01ud05pR3BOV0pwL2FRcDVwYzV2Wlh4bmpKZnB2N1NOU2Vpd3IwZjhWZnRvc1I2VnpOck9xMGozV2RIaFVmVC9BSmkwVkVzbEY0VTlJK0l2VGl5V3BHYm0xSDFHMU9KUjEwWDZQd1AxcUwwU0lKcEx1bnRyK3pQUnRPOU56RncyUVZjVjFJN0NjYWNvbUhBaU5oTGpKU3crVzNWdnA4V0xVam9ZcDQ2OXRhS091bW9xZTJON1BHdHNNaU9JM2NYR3NZVW94T2R1c2JKTkdVYWtVZFJrOU92RlpValBPYmhYcldYWGpXWDI2ZENPdWZXWGp1cHdpZlRWWXZUaVVmOEFxb2lPeUNvbS9zazUvd0NIaHl5aHdvM1Z0MTNEaTZ4YzdmbzU2UHFQbmRlbWZSdldNMFVjYzJ5Y1RjV0l3NHI4Uk9MbS93Q1BWb3ZzRitvWDlMUnJOWGk3bkV2VXdSY2JGVGxVZDZRazBZOEREajBSVXk4S2RxVGsySjdXSFdlZ2Rjc3JuYnE0UTdIcS9CT0pUdlQwbGowb1dMRmlFTG5kVFk5U2x5K2x3L3BheFlqb2VMcWZJNmpkamx0M0UyUEJBMjRveWo0VGg3QzFlcTVMYXUyVmtKcDR5YjliT0lpVDFJVGlPNmxqMDlXNmorMFBTTWtkRzN1ejZjbkYycHhPUU00c0RyZWlNUlJta21pNFdwQnc1TjlDK2tnajJRNWFTSzBrcGx0MHN3WDR2Zy9sNGVFNS9xRjFYOUdNblQ4WDZBOGtuZ2Y4Q2JMUngxSklPZWtHRlNjaTVyVVdCUE9pK1BGUjZJMUpyc2I5U3p1cC9MdzhKL054cmlPVlBaWFRVbjNaZXBoS2RqMG5vT2JBdnNicEZIVHNUZGFPY1J5cU1PbzYwalFuUE5JenJCQmhidk5ZeVIwY3dSSkNNaERxYzJLUGE1MDU5MVhwbTBad0lSQi9MeC91VGgvYnJYSGFDUnhmSjhEb1RSN0Z4bW9yM28ydk5ackkySENqVWM4NGF5VFJ4aTlIMW9RMnB1cHpVdjdZeTZiTDdrL1N0MEhOaEgra3JqWThMYWtJK3N0UEZFR1V1THNPMWppcXlEcWc1RjlHMFU4NVYwR0pIU3kwZkdwT1p0VGxrNWxjaENTUGNIMUpJOS9pczlMekk1L0w1Vk9iREcvVXJWbE54a0ZjaEI4US9TZU5CMUhPSkRoT0oyT1g5eVNPZzhmL0FFRGJQZnBPTDZVTHNOaVRxSFNyS2h4SUxsZGRlVTVjbHMwMFlZazhaSHcxMjBvbFRtOXh2bVg5RFRuZk5mcEd4SU9uTmg2aUJYSXZTQkhVZWsxakl2VVB0MEhsYVJTQnVtbkVpSC9Vd25xTHF2Mkl3NGowL2s3SWRxZXY4RnoxZmc5UTJGaWNSNjFQVVFwT0lqR3Avd0JROWFuclU5Vkp3a3VYTDlIT3Uvc3NYSnBKNDZLTkNNc25GOU9NV3cySkdYcG15UmtYcGxiUnhwNHpYYlI0MXV0c3I5RHpmVndvY2lZc1I2Y0tIcS9iQ2VwZnVwY3VRZXBUMVU3WkxabzFZTG5QaE9Yb1lwT294QnpleE1sSnp4ME42dFI4K3k3all1cmtqb3Y3c3Jxa2FPS2t3SzA2ZUZDYjlCWTVsWWptVWpDZXRFK0RteFk4ZjNJK25oTGZxK2RKczk2eE9udzRrSnR2MHpLUlIwcEhSU3B1UlI5Tk5Yalh0a1oyMDVsZGpsd0tUaTRmKzAzK2VxWDlJTW1oZlc4MWthdDlaVXhXVS90NnFFMEZUUjR1NWVhMjAweVJwZmZKeEwzMEdWU0RteHEyeENlM0wrbGZOR3EvUThPSWJ0MjZhU01rWjMzeTIxM1V4WXZ3UHhDVTNGN1ZiUVd2OE1halplWitFaFBjWDlqZ25xdUpjczlISTFXN1oySEpPRmRCVVU0Y1h1dmtodFZzcm1MRXZ6bDVlWmZBL3dCUmYveUxILzBQOGpDb2ZBb3VXK1I5UCs1Qmw2aS90VTErS2ZPUnZweWZ6VlVaT1FWRVIvMDA2ZFA1NnBCV3JGSnJZY2tuOTZjTnhORCtKaFQ1OXJmcXZtbkQyU0tQaVUyd0pvWDY2YVJvT25WeXBjdWg2a1BVZXBDNmU4dGxaUnROejVPS2paMlVWUFlYU3kreVlrdzNPWTVUaXgyOW41ZWpaTXo1cmxsSVJFUFV0YkVadGoxcVN1RTVzUDdFTDdkRTVKbzlmTkpRWGZUWVFZYlJkTHBTL1g4SXk5Sk92eTA0c1dQUTJyS3RrdmtzU2xJazcwblZZNWgrM1djNm5KaGJ5cE02RjJQVDkzbzJXMUlwTWRYeGRCRllyT1IweU4zeVRXQ1ZvalUrRGlyZk95V0wrd09sL1pGZnNjT094SFNRckY2VE9lTkNUeGxralBjaWsxWE8rSldHK25CekhNckcrWG0xR2JKQTJMcUdHNk9OQnFUUnFUU0JpYXdmRkZRZlI4cDdGeFlmWTBWUGc4aUl2cDBQUFVPZ3ltK2hOTDBrbkViMXNUcWNQMDBmRitNSk9QaThrU09wWnkzdDNGdHFNaXYwYzJJcGVsNHEvWWtaQmsxZkhzWEZoOWo4b05qZ2YxWU03bDg3NmI1blRONmFjeEdKeHNPRWhEMUtUaU9iRlN4Q2F2RGcvY1REMnJadXI1djM2Vk5XRXJDRjZTV2F2cG9oSkkxSXBhbDJwdVdKeVBralI0dHZZM3czOWlmYXVINm4wRmJpT0hHa2thcmRERVUySlVnNU1GT2JFTTlJNkxodzJ5d1RXVTZqeHIrbGlkZTgxa2hLT2VCdXhmSzFYcnN0SUpTbTJXRW81NHJPZ3FDcCtoZUZQc09jS2tvY3BJL1dYcHl3YzJLdCtsNGUxT0dqRGRSZm9iRWpteHc2alpyVVpLd1NsUGlzdmsrS09sR3hFRmhWY2lTVVBVY3MwZldmcllKZzNMRm1KSDlqVmJMbDlSdFNlZzlXUzlJUXVYUFZYc1IwTDVXVE02MHZXMlIxT0x0MzhFVWtqTTNSd1BpeUtjU0UzMWs3cjNRbXR5U0NUL0J6S1hTYVRiT3hlbGlCaUMrUzhDV0xVYjJibWdzOUpJVW1hVFRjWGl3ak45eTUyeEZ1dC90eitvNXNPRlQwdDhIYzlTVXZTeUZrUTdGOHR5RUl3bDBKeG5OaUlRanAzVThhVHJOSXl6Uk1TOXpBdjAvcHJ3b0p3ck9JNThMZkJlUjB0a3VOU1NZeVN2U2NLNlVWbXhGSlBGTExTVWdTQjFVNWtwSnl1VEZZeVdJcHN0SkxVaFBhbjdIS1dyNDhEREQxNVNSZWJsSXhPNDNjWWJoYzV2cG5wYXRuTFo1STAzeVQwVnoxS1NxcVdQVDdGT2VKeXl1VEVuMUY1VW5DY1AwMDRjTzV5ckp6L1RiNE9XRnNMaVozN0VYeTJwQ2FHMmc2NmFMb3Nsc2k4TlA5MFk4Q3J4RmhNVHU0N25FaTBURTBLUVFRUG1raERuT1ZTNUN1UVIwQzlQeFkvd0JxYlZuTkNIbnlPV3VmZ2k1K1I3RHBKT0Z5Wk9Xbk1oT0ZDeGJwUEp3NGt0N2pHWnFzYjRxOE9HQ0tQcFNQaFhsRVZGY2UyNTNOamVuQ1JudU11WmtIeGFUREdINDAyR1NmSnkwWnFTckVDT3B5NFlPSXZCaU8zd010SEgzRzdMa1pSRXF5a2tlMDhlTytTRDRyQjhaZkZPdzQ2VW1LT1JXZW5aZnNwdzQvZjVqUHZXemxqZ3hpWVZ0NEZ3STdlY3NYeVRuaXJKcXYzRTBYNzA0UlRzaUtRYmpNaGF3eHpKK3g0SFR1TWxGUE5HUzFJelJvUHJwMHY4VDZpYzNaS3hTYVd6V2lsNnNlS1RSRVdUd0xLTDRPVW14dDArMkpMS2NHUDFlMXhxeDJ6ZjNhRGo1T0g5am53cWlqN2xqWXVXMXVVNXpseGRPeEZoN0liSEtJMWlIY3dsamtTRklXeHpJTzBpTHVZa1NSV0hiVG4yaitOOVQwcFpOOHNrRDZLMHRYbEpJdFN4RUZwT1pqWVl0R3J3L1R3OFNuUGpSRC9xZmc5U1U1a3ljV0gxcDdvbUZOU0t2VC9SekxCWVpMNWJVa2xhK2RlWk50Sk5HU0svNEdYdU1lcWlKM1BrM0Y0VzhsdUdqWWxnNWFOWStjanZTUGExWEg2TUl5UWlEVm5VY2ZOYXNya2lCYVBoMG13MjdxY0dCRy93QjVMVWdtcTQvcC9kUGRFV2pqcUt1Vjg3cVFjcHhZcmtkQStudU9tZ21rdTllR0tlRGgzRlZSc04xRVJyVTVrc01TbGhrVDVNZUdpTGhGeHJlaXJwTTNzaVlNUGNUNmVHeUVhRTU1SjBkNlBhbGxJa3VQUjhPZ21ERGRSTUdCR2JRM0lRbkVoNmxIWlQwbm8vSjZFUFFRNkhMOVQ4RU5pR3hZVzZhT2pmUWlqRTFzYzJWOUJsMXBSK3FUelNhUU4yUDhxT2lpVElqL0FMMFZlK3d4S3ljVHlnbUxEY2RSMVd4eSs0VDY4Vi8vQUJuYnBWYzVmMkdPR3gybzdlS3YzekpoUzZpY0tQaTc0dWduS3lvNkhLbkF2Z2puK0JzU04wRWRSdzk2OFM2TDNIWFhiUWlrV09KdVU4Vm5LNmRGOFZiRlJsUmlUbFVjL3RKVTR1NHFZZjhBL1IwT0pWbllkWkZIV0tNajBSVjc5VXZSZnhzU1JodDgwdG44VmZWak4yRTNQQjRzTXRIbzZYeXA5VEhnVk1QYnFXeDRFVWY2Q3QvYW8zMU1LNGVtVFNnbWlWZk5HYmlYSmZSYkRvTlZzclU1YVRtZE5kdHhGRUdwSWkwbW5EQW5ieUsxaHNTcXg5aEh3ODJUd1A3Wmh3WWU0bUhEYkRxU05XZFdJcE1yUjBJTjZSQTlPSktmeTBqdW9tTDZuUGk2emh4bzZEL1JuKzFSc1NNdXBhazA1a3lYMDVHb3RlYXdvajJJdFRtRkxqdkk5RzdhRnVpYko4YXpwcG92WmEzUlR3UllpNWFDWEdZNFVRYkYySEVRWEU5aHkwNzFUMnhmcXJmRkNEWldVak5laWFWOUNMQzloaGh4eis0OFdvL3B3YmlZUHBveUoxLzh6RDl4L1Y5UC9scEx1TjNJVS9ub3cyQXNLbGUxRUlMRUpxODJaaHUydnc0b3hkQXVhU012Q3V1MUZpcm9zbkVSQ0hjWVpTemszTGpKQ1ZmdU9vM2JwNE9GRm5vOE9CTzVod1lZUk5CenprNWNtOUdySnlrWHF6NWR6NU1Ua3pYWW41RmlUaFZPVlBZbVU0di9BSThML3dBUlV4SXlwbWhCb0c3VTVtNGk0aUhDN0tmOVJEL3FKUjhSR0ZpN3NPeWpJTXFDdmhXMmxJNCtuT2pOT0x2cnNiVllRazNwYkk0K1J0UjBvNDFXdDVHL0p1cHlvcUtNYzVjV2tkU2k5emx2UmVoWDZxOTRUUW5JajVMSC93RFJWYTJPV3JVN2tVU3EwdUlUTkhNUG1lcGlrMXRtZjA0K3luQjlSR1hUWGlMY1NqY0NJTU5pZFIweE9nK0JsUTVTeUtiS003akxvdDJVaTFWOFowVEszVmI1SFFSa1ArM053NUgxbVFtbDZlQ0VjbEhGVkVaS1QxYkM0VUVvM1FJaWR4TUcxSm9qMW5KTkx4a2ExSUZSanNXTGtTWEVwZW5hc2w0R1ZHcnNsamNkS2ZUK09salFpazV1SEY5bDJPRDZpZjhBdlBOSDRVSU9aWklaVHVja0hMZ2dVUm9QS2R5MzdDMlA3cVRwY1hlcUpobXJYby9jODFnZkZTTWo5SE5HcTBVNVJIc25SellWc3I5eDJnVGVzRWprRGpaN3YwaVVmb0gvQU9NakREWkxVOGtEWEdSU0J2OEFKdXd2RmNiQ1FzMGo5endOZEI4TUUwY25KYzhtOUhIYyt6RGl3TXprcE5Gdy93REZlcGlrWkp6OE9QN0xzY09QN0x2VzFmVWNXUEY4SVB3Mk9XUGdidWNTR0hFN2QxRjduRWdxV09IRktVNHJLU09LdmZPdmpSWGlyY1JyazFqTmVzOURmSnYwajZMVXVYSFJXSDYzaVJhT28zUTRZNXNjaWo2RDJQbW0xUEp3cERYT0UyRlJLU1drc1BhbGhqZWpreFNEZWovNEk3REREZURkYWMzcHhld1RuWERqUjBHL3BXeTA1djJPeENRTXhlNXc5eGZBbUpSMk1NY3hORlFZN3FTcjArYVBrVVZhVG9zdFgwMEg2TnhrdFJXSUp2blZPbFhpbWtabko2aFVSV0h4VzZMRGczVTRVRmN3NW55SnhHSmlFbWtmYzJRUmU1QzJPSlljMkxIaTVFVVJsTnhVU2pXSHBDdVFndElManlnK0x0K1NLNE1YOXZWeFY5RmNHTklPQmYzM0h5U2NSWVZiZUJPRjNFU3ZrZGlCZUkyYzVUYlJjd1lzVmxGWVRMeGE4NTIwR2xxMnJGRy9OTGRLNzF0N0p2MGVMNm4vQUJReEtKKzRpclNSc3RybTQxeUVjZkVXY2lsdmc4bTZqWDJJR1FVYmlOeUdYSnhTaHNPYm5LS3QrMUZZYzNFVkJxZnc4Zm94ZmpyMjBlSEY5amd4WkwwNGNUOEltUGlkekRIcUV3eW15bHhWL3BOeHV3NkY3bkxoSjZHQytkY3JKcnZWVXk3VTVxVHE4SzZzVWZYZjJWTjhjajVuV3FqRUVFMkZheUNJSXd3b2tXTHlNcEo2ckVmWWxGT1lsU0M5Wm9xZDhrWEdiTDlORnRmMk9NMzl5V0Z3clc1eFdVOU1xY09OTVdGckNZam53K0Rsc3B3S2x4Y09HVGtRWEV1SjEyRWZsUkNNVDZMNkwwZlJpS1BxeVFOUlJLVFJ2dldkZDBINmVlcW5vR01PSFpLT3VkQmp5U0tOK1M1SnN4czBVVng3QzJVYTR5UWJIQ2pxZWFlbzVyaTNFbEtQUmtJRTVVTFUvQTExSHBoK0Y2dDhzYVhGaDlYK1JxY0xzZVJPTzZIS25GaHZQWVRFanRpT0RGWTRWOUsyRzRVNHNCeXJ3WWppaFI3WVVGNDNWZWdjV2xxdm1mUWVzNmFvTmp3MHhMdDBqTFpkZU5XT2pib3ZwcDVldTRsTDVmR1hFZjhBOUlqa2JsaHJHRkdGZjRHbHlVTzlGOENyaUpMeWIwdDRKb3NHeEZKK0tmbXEvd0RicHY3Qng0UFduNUdxajNGc2NyM09hVVE0Y1gyTEhQZ09mMEhwZzNWZEZVRWkxRlF3dDNTcUkrWnN6VW5Nd3hPYTJSK3E0TVYvYm02SlYyd2lrMHRrbXJYSUlQR1I4S0VTNGhFSE5LSHFQeUx6M3NNdUx1SlBjWlNJcGVrOXFLclVaMm9yM1VXaTRTYlUyUHRwdFJrSjE1TGs2djhBRndYN2piNUlHdUxpNFJyZGhseFViV1pSVzZCWHJKSHREb2VkZWV0Y2RlaStwaXlYMGY4QVpKZG5PWDRPRVhDUWxpZms3T2NTS3B3NFhIVTNPSklUNEdaaHNhbkozTFNjc0d3cFp6WWlpdEpoVlRpdTYweFpNYStOSnVta2pKQTQyYVBUaXRsakozNGlOTnhmalI4NVo2RjhyNHYycGU5R3hkUStIMnZZL3Q2UDZ2MnBJalVYd2ZJeUZxK2E0bFFVbjdpZnVRUGN0QnZoSUd3L1pSZWI1RWVERGl4SEVpdWcvWStEL3dCbXlrbzV5allZUVpZY2hTMXhPd3d3eHdwUHlTSjNwOVQ0MUViTTZqcDBiWjF3WWg3NGQ4czAzNkdDYzNuS3J1NDJrK2k5VzZ0MEhUMm5ndzJyNmN2cEp3cnAvVisxUGlDOUZJeVhHU1JpNHlrL2dVa3VMd3p1aUNpODN3Y0xvVEpkRU9KdjNJazhlVDBrTWN6SzVoeEM0c1NDS2xoT0w3akxOR3NTZVIwVThYa2o0SlN2MUVHMG55Y3lqSWZGWDZyaHhJNmQwSTlDMlhJNHFrNmxxWVo1VkY0cFNxWVY3RDFqUmtqb0lGenYxRDRSL1lweThIMHlTeGJROUpFSEtybk1tZjZuMm94dFdSTWowaXQrdzZkaXpsaUpSU1VmWTR2OUdGRVMzOUp6NFUvOGwvc0s2VDhFSE1vam9La0NKWTIvMmY2Rlc1dzJQeVgrRGl0U0VjUy9FdTVZODFYemgwbnlSa1ZMMWpxbHdZdTR1SEZkSzNMNnkrTWs2RGRGSHN6NFNZeGV3ems0Y1BRUkdiR245dFlyZkw0b3d2WS8yTzM3bTRpMDlTQ29uYXhJL2F5a25FN3E1MzNHWENlQ01ib1RCOWptVGlNUEMvOEE1R3duRkNpUEJ5WFN2Ris0cjlyRjhtSEdtbDRxMUxVdVFvNjFmVmduVVQ2aVd4ZE11dStlMlNORGhicXJGaTJSdnFUNUh3NHZZbVMzUnhDazFUekZmTkh3NkVVNGhCZkJQNzF2OWg3Ym5Bbi9BQi9jVlZFeEpzSTVOaU81SGRCM1BCaWFGWTRsN0YzUEExMEhjdWpuRmN0SjU3WnNHTHhxdGxWeDhra0pTTkdkVEhoUzZwUy9ReW9qSlNLdFRtMFowRTRWOWdoQ2Fla3RsaEN4YWo0Rkcrb2hDOWRGem02WjhCSjlOZk5YUWVqNGZTVGxrVXU5TGpERml5OEtIUHNZZUdWL3FIWDVPTmVHanBoSGN3NFJyalExMk4yRTdpZDEzUEF2TkJNS1ArQ0xrRGpxTGlTMlg2ZW1ncjFpamtWZEt0b1JrdFNEelZ4OHYxUG5vb29oSXRYeXZsZlQ0ZXFzU1d6VzB1UldQNWlFVDFmTENFOUszY3dvOEtsSkhFckZpU2JEZHNrbkVTb3RXeFhMVTRjVURkOWg5eFVlVGx4TWhERHIvVjJGUlVjeGM5enVuWTlUbklRcmpsL3NwektPaTJIWHNiQ2pMOXhZak5qd2JUclBSVUpzTjJTcXJrWmFlZENORHlSa1g0NkthOHd2RjZoTWo1Mzc1STBiWjc5RGFsdWpmQ2MzVHljbytMcHVIQis1aVZaRlRIOVBqTEszbXVFbWtGamFuS1NlRDRPRTRyRnp3TVA5aGtXdzloMFdGc0p4OExrb1hkeFZzUGlWWlA4QWt5UWVEMDh5bnFaUCtKd3JBa0lqUTR5TDZodnNqaW02S01pdVhiQ0t2WXRldStWbnZoRTBrekxTU0tKMVgwOFgyNlJISXF6MVpLeHFjMmsrdjgwbnFZbzJJdmx0cVhkVGxSaDhYVHJnd2ZkYWNXUDA3REprK0Njc0xOSHcxVVo0RzlCdzB3d1hiWTRsV25DbnpTLzNPWnppZjhtRkUydUxnUnp1bzYvdWZnV1BoU1VkakQyUjl6aHhZVzdpOHJEL0FPQkVZZnNSc2ZOTjh1REgvd0FWMUh5TlIxV2lqYTBabnEyUkYyeGRHOWNPTEF0SGVsbTZLK25PcEEvV3dTU1h6dlQxSVhJd2tRYzJKVGp4OVJ3ZlQrNjA0dnFmdG14WWFPbFBPVG5FWVh0VG0vQi95T1l4S05iN214eFFMNU1OUDlEcUluYW4zYzQrejdpWU1QcXZJalJCdzdsbTNGdzRsZGpoZFVGZGZ1YnFjNXUybGgzU05WcWVTVUhGY1hLdVJxUDBFR0p1MDlMeTJ6OG93MmcyWGZwNEo5aXVYTGx5NWM5UmZMeFlyZFJ3WVB1TmhPUDZ0K3laL21LZU1yb1BoUTVrSEdSV0dVZkhHSVpSUEtDdzZvU003cnNkMElTd3V4S1Q4V1BIY2xERW1NYkJQWml5ZkF2Rmk4SElzb2NXSmVJWEVtSnhPSEQvQU95ZnlQaC9mY2ZjNWl6SllnZzRzNjRGL3EwNFBOSFFmdVRSaGgzb2xHSTZOYTQwOGRLajJQNWF4WGRCY2sxaWtEZER1TlNkRjhkdmIwd2lJblQ4T0QxVWRkQnppVE8xSHJKdzhSM0dTeFp4VnhjU0YzODBURkkzMGxWTnhsVi9DRS9Kd3BLc0x4dVJpZ2wxOEM4RUM4enJZNGJzSnpQNEdzYm4rS1hzSTJpNlhRd3FuZlNraXMwZHgxeVRSYTIxUE9neTlNOUdKeUttSkt2V0syMUdhY2o2TElQaTl3NGx1dlQrUnppWFM0ZHF2a2VhOFNTbmM0aGovQi9sUmt0M0YycDJRMkZkZVViQ3luRmR6aVhFeWYwakkvRWY1SnBKK0tyc20xZmcreEdrdjAxN3luUnRob3lVYmNicGtNWHowVDFta25PLzJPSHNOUjNlcloycDV5T3RIenpvZUMzdUNiSjFIRXV1c2laM1QwMGU1WTJMbmtqOWpEMlA4RXdoeUhoWUY0M042SXIxWkNWc1dQRkdJRzBreEpkRERpVHZxTmlyYXQ2VFIzMG4xbDZid2NxMXRUeFNLTlZ1MmVTS3RrMzBZT2JxTE9XSVFzV0kxSDBYMzZHTXpEYXJZbGxDTWw4M0Zoc3RIYXRoenVKWTNFNGNObHNLL3FGK1JsdmVLS3Fpc2dpN0RyUzdEcVBZczJTZEhoWDA0dFNNMHE1Q01QMjZsVlh0MHZrdk5HVWV3NmVvdEMwYXpqazVPTHRrWnA2VHgxa2pGcXdUMEtKMCtKclZqVjNMbis2UG41ZlNUVnlCVHM1ekk0NkhxR1JKSjdrb2gvZ1ZEMUVFcFcxSVE4YWpZdlVtcXRQSmVjamtkUGlicG5QSnpTb3lQdzBXVUxUUktXSFQ5aUVHNmRoazZpNUpHVy9TY1hUb2NLYTdMa2lqTzJaMHNSUzlOai9kTDFVOGVEaUZKR2I0T1paTERKMERwY2ZWdVd5U001QS9Tc1krb21qTU8zRVJpNFZIN21KVXJOTEVrWEhVdW1XU0VaRG1JT0xMQTJSTisvVHhsaFpwNmFSQ0VkR25VY2VMb09ISDlsSlBtcnJCR2J4a2FqVjNMRVY4SCtTZTUyUEluUXZyU1JvemxmVnhvdTJuR3Y4QUE3M0xabnVjc2FFVW50VnMwVjRsNmg2TlI2elNiRmlSaUNORmVxNVpQUmlQK25pSlJrR3dwMFA4UDZsdHp3TlM1dzJKeXpxeVdZd296Q2o5eEhydHJ6YlZpdGlFemVlaVFiL2wxVW9iVVRzTXFUdU10aGlCc1E3MXZTU0tNbVRsVjhra1pVdzlSR2t4SkFyamthUEVtUi9hK0hGNlIwa1NLdG1iVW1rWnZQUWNLNjBxL3dBaTlWRms2R2RTeGVDMUlWNitjMGw5R3plendTS3hKY25SVkJjSyszdmhFVkZiRnNMMnlUcjdWZlFuWG5WYkVObGpwT0ZMNHZZYk9Rd3paTzUzbzFlWTVWcEVleXhrZlBiVC9pSjkvY2VINm43anBOZlZxenBSclRrVW5XanFFVHg3TTJUY2k1emRQSFF4U1JxZUtlQjZJTnFLZ3FlNHdOaWdnWWpvWnpSMGJMMEVkTGd4ZHJleDc1TFVpa1pwclBUM3pSbnRGSkxua2t0VktvdWh4ZTV3cHpJUXIxbXJMMWJaNXBBMkxXVnUvVEw5UEhZWEF2WFJyVE9TRG1xK1Z1Z3ZPaTZaWXJDMDV0ZC9kK1pEMUYzSjBOc3QrcW4yTnpCaTFKSTlnakNxblpEbnhPY3VGdXB2U0R6a2RLem12azVpUmtRVjlQRjd6eXFwY2hDY0J6WUZPNTZ6MUlldEQxSHFJSUw2cjZNKzA0UG4zVjlWa0lUSkdWY0tpSXJyNTBQR2RzTmZOV2JSWDNhTlJ2WVhySFhLWUU5d25vWElveUV4a2FscU1za2RBa0VhcSs1Mko2Q01rNW45MlJlZ2hCcUliYUVaL09wdnJTUVNOUnNRc1VrMnpUT2VmMFh4ZFJ2N2hIVHUwRGpVc1dvMUpJd3VXOW5hNHZnWHNmN0xqZHlFSDlRdEdKSFN3NHNUU2MxczF1aHdyN2o0NnVDemRJdWFhWEw5SEEzZkpkanhxc01wQStabHlUN0tpclJoRXdpT2h6SU9LTDJRdlIwM0hOOEpDM0VUVmQ2VFNFMWs5eFpPazI2emZNOWVVM0pMNmtJUWlJVGpVLzZpbnFXbko5UlVQV1hPWlhQU1RxSXFrS005TDFqRUpSbHNSU1NJSjlsdlJ1dzd1SnVLeFlocU9oSkEyMldiZnFxYzBha1puTnFQYXNMVG5SUzVkS2VwQzV5MDVsVlMxYlo3Rml4YmgrRGw1am1SdEsrVng4MjlWNFJ1cVRTVHNRS21LNkMrQjNVOEM4TUl3LzVJRmNnWStjei9BS0lmVmIzQ01rVTN5MjAyeXloeThwdjBseVRoUTR0S09vUlJWY1lmc1lWM0cvcUxTTGlvaVZWaHFOc0lqZGhxSy82SWc1a3ljUXFXMEdSUFZBMks1R2luZjQ5clR0b1IwVDRaNlNSc0tGaXo2MDlINEhjK0JrTjJFMm9uQ3ErUllxeWZjY1JCRkhwYzIxSjk4ZE0zS2paTFRrM3pMVjcwNUZaVGpYRmgrQzJYbXlSMGtaWUxaR1FmRVc2dXh5em44NW1kL2FXeWNvL2NkYm5rOVRFWldPVzJ0NTk5ZlVtbHMrNm4rOHJYNjZhUm50MUU1K0w2Y1l0aHNVZEZLT0lxUVQxN1ZkcU10andJaWp3dzVBZ282L2NSTzI5T1VnVGlTUDBweFo0TnRQYzhaSDE3NTJKSXlRUGp2MTNuSktTZjI3KzVxbTRqa0xTQzhrRElrbkN3N0ZwT0puUXU5Rm9renQ3emJyT0dtK1d4K0tiQ0YvTkh5VEkrQXNvN1Y0ZnVPVDFNU282M3pXNm0yU0NVSHcrblRub2VYb1dyRkU4RjZ4azdxTXRHeUszZnJWNmlNOWowbnBwZFJzT0liR2tib2VwRjZEZXVHTzA1YkxWNk9wNXA1ek9rRGVuRUx4SEw4MWZFYmRISzVkMVBQU3ZWdEJzNzRmVDBkdWdoRG1VczU2Y05KUkZQUmgvWVhGdzhLK00zOTFlYXhkMG9tTENscjFmQ3FMU3d2dkVVblFraW05T1pFVTVlVWpuVHgwTWJWM044anFJVEoycjNxNDFOeGxsRGxVYWpqT3hkVjNJdVQwWGlzM0p5YjVKMEh5N2o1YjZja245dXJzUVhyc1gxVzBJRTc0ZFNjdHhrV0I5SzNzMnhFcjBGeUtQbDUwbmREaXdjK0hWdWZrZlIzcHVjMU56WS93RE9kMXBhbXk5Ti9FeGFVRTUrRVpDeDZhN1p1Rk5ObEpTQnVnbGV1a21yRGtETkpGTGRCQlBVTm9RYjZTNTJQZ21qb1dMazAybytEbHgvNU9INmlNdXZiOXptUE5qYnNlb3Viam05ZWFEdFdUc2Q2Umt0MC9qUm1rRTVHVWFxOEplaVRsY21qNnpMcXlvK3MrS09qbXI5UkNrOVkrUDlpSU54S3huV2FjTldOeDc3a20yUk8yU0pPRDZpT24rQnNWdXk2WG1rNXR6YzV2aWsxbjhrdFJ5RzBwNlJNS2R4RVNrRTVaMHVMdWYreDFTQ2JhVTF0azNUUHhKclRTK202OUsvWWpxNGducVh4VGkveFNjc2FMVThIa2szUFMxZDh1MWVER2pvb3l5aTJYVXNiSlR4VHNmN3lSSGV0cVBZbGRSdWk0MXV0WjFKSUlFL0p6UXFibUpVU1BQWVhKSWlWWk5kMG9xQ3BvelMzdWQ4bHFUb1NoeXdTblRQL1VPdVRZMnBmVXhLVEZMWkhZZGR6OFpsdzRySEJqdm4yejdHeDRMT1RtNXBOaDZRaHZsZzc1Tit4NDZCTnVndFNKd3IrRGd1eW5OQkM5Vy90c2EwNkQ2Y2ovVC9BR0o2Smg4ZnJYOFpXSkxrclNkUzlobE42MzhsaU5CdjYwOUl5NWRpY256WDhVYzVWZlBGTzlZL0I5c3UxSU4raTR1NmpyV0tSVjlDRGhYdWNzRzVNVjJPWVozRmVqM0kvU0Z0R2RIenVUMFA4WDZpYzNaTmlhZGpmSk5ldytuQk1xV3BOSTNwNnREK1BnLy9BRmxnU0xVbXNWY2JHUGg5UGJKWTNJeS9uUHRTMUpMRVNXckEySkJ0Qk1PamV0NlhOOHNTYkdGVlJCOEVEWWlhT0liamV6d2N4dDBMNUc3ZFhLRWFYTVAvQUU2LzhiNmljcWVraFMvM3kyWkRldStvdEY3RVVUdlMrZUsrRk9IK250bFlkZEdNS2ZmUXU5YkYzeVFNck9YL0FBU1JGTHhUbEh5dm9Manl6bnZTTTM1T1ZKRjRybUpwY1dpcDJUdVIySHB1Y3NkR3FDOUR6RnVtWkxVY25vbnpOU0NkS0RpUzJyUG93emlMVTJwNUxqRXVYeU9QcFB2UnFPc2lGcWMxZDZUbFhCL1YvU010MDZIYXFPZHFTZm1uSkRmay93QjFiQlhhdi9na3VwYlZSTSs0MmVSdUUyTzVJOWlTSndpNGlSVzduQzkwSXVlU2I5SzQ1dzhLZk92Q2RPMlJ1bGpSZE5DUjA5T21tSERLcUpnVDdsNjNrM0VGTDB2ckprMkprazgwdWIwblAvR3cyeFgwWkowOXhlOVlFVlo3aXJid21iY3UxWkZvOW0wOEtabm8yYStTUzV1UWQ2dWlIcHhmc2VuRXYySnc4R0JGaFRsVnlWSTlpakk2OUx3cGZwNXBPbXphREtjUGJ0cGNlNTR5TVRCMkVUb01LWnZ4WHV0TFUzckZZRndyYkVMZ3hYVFM4VWpQL2dUSXo1dGkyUi84bTYxL0dtKzJTSTZDOU42ZWs5SkNFK3krQms2anlPdld3VHJ6ZnNNdWdtRTRjSFlaUHZUeVF3dEgzSHB4VmF3N2VDemFQeG1ZbkozSXBNMHZYZW1INnFkNFhSOGpYeTdrVWMvSkorUk5DMmY4bDVwSlpzajVWeGFlK25ORzdrbDZ2MUQ2TFlVSHhrSVIxRDlxejBqNmNVZ25OZkp4cDIwT05UaFE4RXVjUjJVNG5HVlBJeDVjM294TWFpcm04a1hOMkZpQnlJSnlQbHhZZEw4VTNJbk5KdFJLN1ZldDlUZk9tdFBzK0pORHdNaWU5eFcycTJkTUtEMkd1ZVJJSk9VM0lTK1RiVlJNMXlhZXBDWVFpbGp6dFhtcEJ2VEVtODZFRDVJTnN2RU9mNm82YU8xWk9HeTE4YUtacDZKK3ZYTStLd3lWbWorOHZram9IRnhIZzNVZ1hRNFNLVzBVVE9wTW5EWEN0aDJPNWM1VG15UFQ2ZjFQL3dBNkwxM3lTcE5QelI5RFljU01zL1liUWV1SEs5WTBJcTVIc2E1ZUxGYk5QdmJNUlZ0Sjh6S2NwTURZUnZ1SisrZXpua3VYMElWMUVmRXI1ZlZYeVNoSTlIcGFuaStiR24zMEl1TTVNbmtmN0U1TnFRWExaMGYrclJoRG1Hdm80ZE5OYmZNL1VKazhlNkxxdGtqb2JzYmxtRVcrZi9WT1lTbTlJeXRSVjJGelhvMXppWEVMM3BDbmtVbWlEWmNXSFpkUHhrMkxtNWFsNithTlRERlBCK1NlZ1RVYjJ0S3NnMzZDWk16YVB6WDVqSjhrOXMwMFEyb3lhQ1ltSFlSRnQzRWU5Yi91Y1NqcDNvNXU1OFFTZjdJdU9SY2ZRWHpQUTdublEyTnF1MG5QL2s1ZE9PdGNqU2ZYZS91cmFMVW5MSFN2VERoeWN4R2Jlczk2VzBPSkVNTVFmeE1mZXlVM29xY0p3cExIQ3FINEVTaU5UWWQySFV1VDJHV3I1TUdMN1puN1ZiUjJ5LzdOenN1U2UyZWFxbVhlcWRHMmcvc0QwajlBcnJ0dFRGL2JGYk5UbHRralBiTmFqSEVxVnZSUzQyR1I4YXliajN4Vi9OUEFsWkl5TVB0aXpLeXMyU2FmbW0rVnN6RVVZbW5ha2FNa3F4dlhDTGtUUmZJOUc5bmtiM3h1bHhZZDVwaVh6UjZXSElrYWx2T1ZuUFVibml1K2hCTTFVNHU1ekQ2YzVNZVpVeFdPTDhaM3BaMTJHWnNXanRrakp2VzlHYzNHeVAycGcrZFp2YlU5MGFrZEMrbmdYeVlsOFpNSWkya1g1akpzbmthajVIU3M2TVFOaVFheDZhTzFPYjdaTnEyYkpBMWNiN2FpbmlyOXhHSFRVMk44MXFmNUpIb3hZazRlM1lSZkluWHgwNiszMjBHejN6U1dIV2thK0xIL0FHTmtjVjgyeGNjVmlSaTlZMGtSeDFKcHNlU0tObGN0bnhmR3JPUjZSODVmemtmSnNiRytidW1aZkZNSytOUmhxSm1YOUlTU1IwVTZIalUvK1I5RmYrUEVtVldveGJKQTcwNUhSVDhhTFVhaUtPbEc3RTVJVWZMUDJyYkxpNk9ENXo4ZHppMzdINXl4a2lSbW9vOUlpamk3S0o0NkZ1aWIzNXg5S05hY3M2eXYzd3FuNHl6U0ZIcTZrRm1NTWoySDNMaVp0aVpJSUxtOU9LeWtyU1NMVnVSa21qWnZ2cng4WmRxYjEvTkdvK0piazJwT1Y2ZGtwdFQ1TjZLZVVGVG9YcE1kSlBSS043TE9WcWNxdnBSbG5LeEhSTGxrdVhvMXFTUFM3SVhMbjVPSWVrVWdlbm1yZDFHdlNiMC9BcnpTY213MUp6T1lmbnA1cHQwbTlVRXpKK21lWlNPdW5vOWhpSXBIM0xVY2xEbFEvd0EwZnVmTk5xY0sybzZHNHIxVi9zTXd6ajFnYWxzc2FHRG9kc3FVZkkyYnhvYlpZSDJFMTJYcDQ2R2Zhb3JjOFVZZEt0VngwWFNkOUtkZUI2TEZmelR5ZjZKSWtZM3IySk55d3lyRkZvKzVZMmVpcTVGTDVmSkdkVENteWFlMmJmUisya3hHZlpNcmJkQTJxdjZEUkVMMFlnYWowUWtkQjFvMmhjZGVtVmRzdDYzcGF4SnlsbkwzTHVRbzR5UlcxWW9qVVVZZmZKL2JUd2VLSlQ4Nk9McS93Um92UjgwWlBuOVNRTVBoR2FuRGkxNXlSMFAxY1A4QVkrVHpWcVBUKzA4ay9OUEl3ekQ0aWEzckJIeVNUVHhtUkJEZWphTWlyNTBHeXhxdlMraE5KNisvNkpnZGFTUlhtSVFZdFNPamdub01YL2FZc1BaOG40SnBBaVloaHFUVGNzUGw0bFVsUzlaSW93dzZWYTQxK3d4dFc1T2ZGb292ZlBHR2s0ajFIcUl4SHFQV1JpUTlXRTlhRVlzSjZPTDRPYkNxZEUyUlc5MFVUMkwveEFBb0VBRUFBZ0lDQWdJQ0FRVUJBUUFBQUFBQkFCRWhNVUZSWVhFUWdaR2hzU0RCMGVIdzhURC8yZ0FJQVFFQUFUOGhYcVVHZVlIR2l4Z3JUTUpXdUpjQldTV3FZd0ZDRjhJb2xrbzFxWjBodmJWU2hxNE9XQmRZalJMWWxycUc2aDZqMUR1VlhNTU5XM21PUVN5NnJMWUJRVk1JVmpibURJV2cyUzZnK1pkOC9GNW1DRS9jS0V0dmNwM0JTRVdKY2ZnS0s0N2hjaFRVRDRZUHdNYnpKdUFrb25Fd0lJa0c2Z0F5c0t1NDJibEY4eG5NNDhKNm93cGN2US9BdHl4VnN6TGlCRnlYSzIxOVJhWWlJWFdkeEs1S1ltbGJxSkJ0Ykc5K0lyanY3TTBob2lINEl1REJMb2lHYnVtTmpjQ0d3VHFZQ2tDdUQ2bUc2bEtaMkNtTEVoU2paMllaVnBVZkpEaU5TeVZFM2xjdkFEMjVZOHRxOXNQNW44Snlkbm1IV2NSelcvY0o1dUFyRUQzRUVlVmVobG0zOHJDdUMxZzVad3NxS0lHdFE4SXcrRURXay9pY0JSN2kzVDdZOFIvTVM3VHBtMmR4M2lLamdtSTlZYkltWUtFVjNNaTJXRHNtYkQ5TXMzdVhINUFCdUphbVd0T09vY0tWTE1FQ2IrTElUeHd4WEYyWnFlV0FseFl0d3hNSW1DM0ZSVXRNM0d6dUc0OVFTdEVYQmd3V2Fyd1FjSGJkY0VEb0N2RW9rMWNOM21VY2grbzBFQzgxR2xuOEh4YzNEY05UdE1QaFVsUWNYekJXQ0h3b1RSVGlYQmxid3dFT0xHVWNMMUFkM094bEJuTWJhaGR0L0UxaGxTaDQrQnljeTVmelVNbzdzci9DRUdLS0RCK0VrSzFTNktzUmlKR290bVc2U0dVd3dFQUdnc2xSd2tBVVJOeEhKbVdwaXBnSUFybUNNeTYyUlYwMk14Ylc0V0JwaGlwbG1PNWQ2VFdMTGl6OEVVVzRMTFZBWTRtUkFlSm1HSmNaYzBqSTJSUlFhamdaeEhSQitENFZNYzUrTW1JdjRLcGdsQ2hMMjVqbHhpRThvNytHMnU0UXdNc2RRVlRyY3Y4QU1MbmFENGl6SXpNd2FZT0lPWWxzZnpLcWFqZDNMYU9LNmk0N2lMd1FtVkFDMWlVbFV3OWNSS2F6Rlh6aW9OcmJpV0lXS1ZieExwS2R6UEpGVzFxQzI3bHFtWWhkcU1TOHBnYnNJRlo1Z2kxcVpySm11Sm1KS3FDM3lZOXpKVjdxRUt2ZzRvaUtrRlF1c1dZVGhRUGYzT21QcURJc1B4TjRxK1dWQkJLalB4SGg4QVZBOFFndDhPcERXc1BaS1lsTG5kQUpraVV5a25WTVpjb0ROWG1CM0hFSmV2RU5SVmt3eEYzY1djUmExQmFxY3BVc3VXS0RIMWhtV1lxZnhFdTR4aGs4dURLSFpLRGhsaEZKY3UyRFc0cTh4OHFnbkx4R0YxSFJWMFIydVUvSmx4QlEyODU0bEdsVE1VVk4wZGFpTExpWUVhaUFBakhjcmV3NGpCZzRnL0pWWEwrb0poUUtDRGhCWm5jTlJRNXlsRmtvTkxpNFk5ZmdoUTRseFZRNWlwRGVzSE1TNWdndk1xTXdiek9ZVGlQaUE0VGNzSmZYd29NVUdEQ0NyWEZ1Q0NpVnVVQ1JsZ3RKVUxOeTZuVUJUcEl0YTVpS2pjQmNVakNoZFJWalVVeDNFQWJ1R01NQTJNTmtGYXBqV2x3a1dUUWpiWE4wbk11TGlLbVpTc3dZTXZNV0l2Z1E4eFNLdFM4d3RGWU54ZzBSVE44TFdaTUpjdURuNGI3aVcrQkhDVzJnbW54V2pvaEJ1VnZNNFVjdmhaZUlXY3g0bHpMMWpGVmpyQmMxdTRNUXROSWt3STF1Mk1FV0xUakpCZzVpSGw5VEsxRm9xS3VKTnRTZ0c5L21FOGhzSFZreVZLbXlMV1l0QmF2bGl5ZUlGVXhiUTRJaUZtV2JMVlJSVTNMQVhLMnc1T1lOd1FGUUVLOWJqV01KQkVFVEYzQ0xnRHFCQXJNQjlrN2pWeUhtYURNTnNKWndSSmFxYmd1TGNwc01zRUdzUWZBRlFYQUtpU290K0FDSm1DeXcwQ01DeE1Zd2dyNFZ6QXpMc3RrQUJIZVkrSlJpRGlQUHdZdTQ3WVFZTUdLb1NDVEltMHBWQzNxVWJlRG1jU3J0dmNTT01zOFJMalV6UVdTNnd3aWladHpFbFVpbFMvRExFb09vdXc1am85a3VWK0xETWM2WFJ4SERjdm1EUUcxeERCWlVJYWc0aXMzRnJFVkVJa1JCeWZpRU5mQlFJQVdyUUVveHRaOVFkUU4rWVFodUZ1NEV6OVNvcmpVR0daNWgwamZjUnFzSVlaek9aQUd6RXkzS1M1c21EcExNd2RRZmtXWmxWL2poQmd4UVlSMkJjWkwwUnltb0ZWcUNyQkxXRURGR1l5NEp0RE1yTlVOMUJKeGlPcWlFUVU4UmxWd1lCdVdNNVlDczFFVlNWS3ZFVnVDb29abGhjVllSVTNDMFdYS09ZWGlsbFFneEJLUnA4YlJjZkdDS1ZCejhMaUpXS0t4YzVhYWlzbkU0aHRobk1vZVpqTG81RXZ2S0p3TE10eHZMWEVxbG1TR2ZnVi9Ea1NzREVGMVVvVmR3VVZBbFJVUnMyeXlLRFRxNHhhRTlNRDhRcFhjSE5FYk1OVlY0NW40TEx5eFFXQVJFYXROVGU1SHRhZzlySGpwNmlVYkthMU1PV2xJZ0JTK3BZeXVZWmkwMERpTG5Nc1hGWjdncXNXOTVoYVYzQlV5UnljemJEQmVkejArQ1FaampPVmg5eEVlRUtTb0VUdXhQRVNpZ3hGeWpabHE4U3pFRU5MSnpVZUlhWWczTThTTEZRdGlwekZGWkFiZ1J3MUNuT1NwTGptQmN6TXg4QlVxRTVnTWVwclRVYWlpRFJtYlMwcGN3WEhpVXRSSEVYemN2T3FKNnpLdGt4M0FYTUlXdjh3OEZuZkVFY0dJUEdJMmR3OG9VNnVVVzVSNmh0MVQyUnpPdS9nZkdTNWw0bHdNZFB1SW9aQ1lqUUt5a3VZbGhLR05BWmVBTVFZb2xveTB6THFWZFF1cFlJdDRqa3FSbDFGOGNUWWFIbWNFR09wVlozQTdnUU81cUh5NStMU1Zlb1lpWGl3c0Rmd1cwTXdaV014L2NDUDVpQjZZOGFROHdiK0J6S0dNNmNRWU1HS0VzdW1JakFhalJLY1FsdFl5MGFZRldNSktxMTVoa0tpVUpSRk5MeEF0VzRoaGdXMFdvMVIxR3djTVNWNWlRM3VKZTVXcXVBUlNOR3liUzJxWXFZeENLTURCb2ppdUQ4VmVaN1M0NFFnaHcrS3ZjWnptZEVJUkJNZkVnb0xuTUsrVG5OS1d3bXJBTHhBeFlybFhEdHVZbTJJSnV5NDNETERIeGRialUzOERiVXBuWDRLaVdkMThIY0dYQXlSWlR0SE1jYmxFdXN6VDJPbk1OeVdMNENTd1dnNk9ZVkVCT0w1anNvcW0xaUtJbkRNQlJEUmZNUjcvKzZlWWFLUDhBc1N0b3ptRGJibVVrS05SVXlPRWx1Mkx6RFZkRVNnd09JUlpwZVlwemxpeWphRW9Gck1vM3hHRkdlc3drRzd1QUZhcUJjSTlZRHFvSGNxdUprNWx0Z3pFckpWUVY1SW9FZ2VsRnhCVWZ4WFV1UFppNXMrUTFMS2pwbTZVd0tJUTJiaUl4WXFDTXJFWEVMcVhFTkt1Wm1adHd3Tys0bjNSS0hsbFNwUS9CbWdpUHVkQ1hPSWRiYTZJYjFVVkxZTGRFb2xTdmxJUW9DU3hlUy9VdjQxR0U4akV0M2M1Y2Jsd3V6ek9iYzBTMllOdk1DNkpSaEExYTVsaE1VdTNGakV0ZVkwTGxENGxVZk1UNE1NdFdvWkJWYmdJWWcrWmZVSUpDRSsva3hNc016V0FjMW1VeWo0bEJyZm1WWlRCV1pzeEx0ZjFGUkhSWTdDb01TR05RV0xSTEV4bVU4VEtMZDZRWVB3R2RHU0NYWnVDWEJjQkhDQlVOeDNXV1Zid3d1ZFdSQ05abGlqOVJaV015SVFrTVFVZDdZcUt4QUZRckR1TEo0bVZtUHlnMmlQekxVdVVYZVlzRk1QS0RmeXNTaDNIck5ybEo4aTROVHlqS080c1M4MUc0eGFseFdiMWZxQ0hGSzBEN2xEYTJSQmQ0Z3F6SVFhdENwVEtFcVZaZFJMc0l2TWhGRmhwMmx5VmJMR3hDRUMyVTZZWnhXTjlzdlVLUXZ6RnJNMG5URFVHaW9GMGtVS3hteHpObjRXU3F4VVRkTFlzWVl3RXNwalhCRjBuUG1BYXNFM0xxQ0dPWVdNTGFvNGwxMXV6aDlrR0ROeDJQM0FGZzJxYkdFb1MzeEtwMWwxYkJXRmhxdW5XWXVTaHBjSVZMZzVQamtySTk4VEVNeXkzY1ZXTndWQzhRVXRRVzVFeERSR0tFNjVjRUdFS1hCekRWcWVjSkF5bTZnRmZJcmlER1k0WTQ3K0lPSmhPU0RnK2ZOQ0VCZFhHWTFHVTFIR29ac21GdkZSYzQxTDFjclZ4cUJ5T3BjVmNXOTRqdHVXU25USEZZVnN3TnFuY3pEOVlMVEdrZk51b0ZZcUdZaUdZOFJBZFJsUURDa0JlQ0VCNWxRQm9LZ0J0R0EwRUdZZjBzU0d1eXlQNG1BYlNYN215eXk0bmcva2lzWUxxTUtYQ1VreWR6bW9GQXFubUMxMVlRVUZjeTlVVGU0MzB5bHpMY1NoamJBUzN0bFpjNGx5TzlRM0xvOEdDVzZSTXdtT2twaDhFWFV2NElzUlZ1VVpnbzdsSHdBSEdGbURFRm5jY3J1SktvdVUyWnhLR0VXQkdFeVp5SFVYQ2pETUpjVHVHamNzZW1FR0RFV1V6QTdpb3N6QVJEQkx4MmVaZktMandGUlVwWUNlWlJsS2U1WVlMWmdJbW9nb2FaUkFxR3FscWxHRm1TeFFZM1ZzVFZERTNGYkJ3a1ZOb05ud0xGTEtsOVFZWmkxOEJ4RlV6SVF1WXVJMVlhaHVOSTJNUlFoUmdORnNBb0N2RVJRcGZSRlhDVkJ3R0FBRlBiRlFGSW11R1ZjQ1FRNUlHRmluTXB1QkhNcnVWRFdwY1h2MUd1a3FHRndLcUYyTEc0S1dtNHIyeGlUaUFJZUpTWjRneHJwNWpvM0ZkeTc0aTFYbUxuTVJLTHFQenFaYU1yRlpxNGwwVnNKUkgwZHh5anZkZFRwYkk5ZHBxT2MzbmdpU0R4M1V0ajFpNnhVelZUMXhBTEk1YjM5UkRTaWNXK2liaGZiTzZmaEdUK1kyQ2cwOGUvVUJxczNwZ1VVbDlTdG5tR2xrdGx2TWVNeGVmcVdiaWk4eXJaOEV5WVA4UXltalpjT0FRWEF4QXVNYlFVNW1tTVMyS1poTldZOFIzbGl6aVVsTVFGeEcwcStZVmRTZ0pWTWVHQmE2aVREV1poZnpoSGFBbUUvTXcxY055SmZZUHVXeStjcHJFWVUrb1kzcVdGR2hFeVprbERoeDFGcmQvVXRjRVZMampVVjhDY2ppS3hpNWF1WWMzeEQrZ3Y0V0xqTWVHWHRiZFM2c2JIbVhvNG1PVzNtQVd5eHR0R29DWXJXcFV1azNLeDRod2hnaU1EczJzUnF5Zjc2SmFzOFN4eUl5OTdsM0xNUUNuaVZnMWR4ZDBWUXhsVnVmaFUzQ0FQTTRoejhFUGdoaVBpRjhzM1pqWGNOWXhEV1kxRXdFMjNMQlBHVUJ1cW1tSjF6QzdxTzhFY3JpUm1HQkNRZkdJalRoZ3dZNkRjd0ZZSVh1RkxPWlNHNllBMFlFV05UYlV3TFUzQ1VJTER4dHNWalVXbnhDWEVaeTFBNEhFQU5YSFZzVUtDZGNSQnFDam1MbU95UEVMUlJlcGNVdWUweTNNSmxsbmNVUGdFWXFZRDRZSVdsb2NSaHdHcFFGQVJRWnc4eGpnMTNHbFY5RXVBRnhWdkJFdWhad05yQXM0ekNocXJZbzI3enhMcDBUTHVJSm1WejhLSFVTQjVNOXpRbUpZYzNBck80UHVGRzRwS2g1d09aNmp2VVJWall5cmVOUW9hMUVPTHpCUnE1YlpyTVVTMHFNcXhyM0VXak13YjUvVXh1VVh5a2R4QXRVYktoYWxZVXhRUWtESjB4TXJGTFhxR21aV1Z1ZVdXQW1vcXRsL21VdGh3NDM2Z01JR0E2bVJqYVl3NXhsZ2lBaDFnM0QyY2tjQ3lYdUJCbStaYWxGbW8xS1NvVzFqeEVjTmZVUmRzYjFtL2dDSlNzV1JFQlkvdUoxUmVJVUtEWlRHL0VRUUhVR29Qd2wzekxzaEZBOHlweTdtaUF4RXErVndabDNEM0I3aXlxNFpYdDM4RVExY0RONHR0L21XZHNFblhNQUFWaUF1WWdNVEp3UndXdmd4V0xCY0FHL2loTUVKek1jZkM1bkJOc3dBQkxqK3ZnWmZ5VkxOeksweXc5d0dKWERLTFcrSG1BMEozRURUMUVTK3RUQnUySXVaWGdqQUJwM2NNMm5KRkREQkdYTCtDRVFqSnJVQkdrZ2x4Q2lWK2FaNGY3d1ZHRVlwdDhId1FmakJDSHVYTlFweGlXVzgxWEVFbVNObnpON3VVTlIrQzg0TW9PUUdKVWgyeTRKV1lJU3RRM0RXWWx3NFp3aVhCaUs0WXg0OVFOQ29UTzNFZW1YcTREb05SS1ViZ1MxYWdnUE5RQ3JaakJqQ0c3eEtjRUZGdlV0V3BaVmN5dmR6Qm1DY3d6TVJCV29oZHhHc3VjUldRZmdNRXFYbU1BbHk0SnhCZzFCUkwrTzVaMXZ4SE1PZG5Ic0hXaUVDbEJncUVLNHFHYWhBNVphNEw4c1Nib0JDQ1V2dVhOclJFR1M1YThTeHhNM1lWQmRGeklDRjl4Nm9OOVF0MXJxQ2FXV01RaUhHSW53YVNrc2g2bW1JdXZuNEM0aTF6QTUrQStKUkNXTUtyNml6YXk5M2N0eXk0WnpLOUVLaGtDWHNVUUFicUtITkVMSUFiU05CeGRZWWtMRzFaYTJqYUE5UlpITFdCTncxQWQvY2UwUjBTZ3E1VEZNRlVEQkdqZ3VCVmNCaHhMdFdRRGdnVFJVRlAzS3lRWnFCdjZZSnBWOEdwenpNc2JFK1MwVjV1UFhNVnk1bUR4THNESkFndUJWQjhDRGlPcWxsek5RWVBVd0pRTVpCZXY2SWhZaXo4RERFVVV2TUlqbFhpS2ViK2doTW1BQlpjeG1oTEJqRDhIbUlrSzh6QnFKclRGNHhOcnJFUWVaRE9XT0RjYVl1UHlVcTg0bVRVR2N4TndaZDRsNWl5dXBkNmx5OHdGM0x6QThBdVZwVU14M0d5M010UWJsMWNEVnEzdnhNRE9XRGlDODNCaldYTHhGaUNVbHdNakQzSDg2N2l5ck9UR2NvUTBmQVZQVUlRWmNkcFU1RXB2V0lHYWVaejZodnhHRUpORUJVeTZibGp4SDNjRDNBbUp6NThUc3hObWJ1YTVqdGpLQ21ZUTlTNm9YTER6RXpiTGhHWFJ4TGxoSzJ5NFdZaUFVQklkMUxnc3U0UXRuM0NscDlRODJKWWQrNWlodUVHM21OQzNnanQzZ21BZHhGNElpbGhxTU9ZN2JsQktkdzNvcWNRWksxOGRaY0h6TGhBeS9oNUlNV29VWm5LU1pKVnpDUS9NRkNoZVZsRUVxSzRnUE1TRWJXUUNpRGJja1VOVUEya01VWGZNdmZZZFJVYzNGY2JsUkZ2QUJHd3czRVh6SExqVVlNbVlWYkd1WUVNWmdOcVJnZ0RUekdqSzRnUnZoMU04UUx4QTFtRmFpNEJtWGpaaGFnM2JMVk5wU3ZNc2xNWnVoOXdGRlFjOHkxbXIxQVdNSUF1cG9DRFVIQzhRU0FCVXFIaUtGejlTbG9GS3g0bHdBWXBMd09TTUEwTDJ4V3FrYUtjeElBVUxTaU5EdldrMHkvTHFYMHBSQkdqSVVRM1ZLcmFWQkZUOHlxKzRHWVlpem1DV0V2MVFJWjVsQ0E5OHh4a2cvRVVaTEdib3dKUW9kUWJVMlE5eTdqaVVhcUhZT1NJak9tVVZEVHhGQktudExOeE14WlhCM0Jsc1VTNkplTTFMdFpFMjRmaVhjNlBneXpDRHU0aHlYMUxNdU9ENElmSkxRN2hDVmdJQmFyRVFtSUs3YmxBWWlpdDF4QUVxQ2ltWU9jUUF6RTNpYmJsM0VYelhTUXdNdWdTSzBWS1Y1aGhPRXdSMFpsQmRTaGVvNGpYY1lkaDRpcUhSek1Jb2htWTBobE43aEdOMW1IbEJ1WFBLWFV1WGN2NUZwSldYOFlVYXlocVZqd1Y4R3ZnSnQ4R3VvWTh6U0d4NHo4TEpuVTF2eWgrSTVqREJLaFVPdkVyNm1tWUJXRzRMY1puT1BrTU10VVlkUWQ2aS9VS09lWUlQSkJpV1RtSmFrMlFZTEZ4MkF4M0dRQmI0aGFBd1FCUTJzcFJYSEpBRVFvbHlycnFJb3QxekZWdHhHTFc0c29Nc05QTTN6QUJURUZEbUF1NEtTeTRwV1lORjVnVXZpTGlvelQ0TGx5N2x5N2pFai9RS3hLRmhPa0dLWkdJR1lLcHVZcnVOaTRvNVl0eGNkc0FsV3JxSkRDcFZMcHFLc1BFdFkwMW1DbmliWW0yeUJ5RFc1ZzRidU5pVmtsUzZpbWFqUFdHb1VFSEJ6R1Nyd1piaVdBTWR5bFpjeFR0SWxGa3RXS2xLN2lkTnhTWEJTUzRXZnh3V3p4TUpVK3lYbkxFR29kb1pDV0VUTXk0cUdhbGx2cUtLM2h0WlFLOGE4eXhiZlVGa2VvTEtnY0daYVM0WUxXNGNDWGFqR29hdXpyN2pEYUUxKzVma1lKakpWUjNWYTJ3USs0bE44TUpwM0dhNWw1bVMyT1NCTE1FYmNPQ0p2TEVvRjFuTUdOU3JOUlBVdDRoOWg1Q1hZS1NLb04zUmtoRlV6RFRQTVVTUnhBcURGak1jd0dPNE56R0ptUUhNWWJlZmxhMVVzaGxBNk1HWTlDSFQrQ2xLRzBLVEVqbHEvNnlMN1VLcFd5WmZhQUprckM0eThSMEpkU3lLS0lsaEhkM01EVEc0M1BUNGR2am5EdU9sTndWd2xSWU1ONWlsUW81MUdrNFlORkVVTU01aWptRVBkV1JiZHBnQVYwRVEzaWU1bVVENmlOY2VKdG5FQjVnZHdEQm96TXNGOWZCZUplSXBFa1ZuaU4xbm8xRGNJZC9KQ0JONExwcWNlbWN5T0U1OHc1T29JdTVscVlTNWozRVpNemR3blNZUGdENDU4RVV2dVhueEw2bkU5eEd1NE5GWExLaVhNYVQ3ZURCVE1jcTFYRUJ0Rkx6Q0ZITU5wYzl4U3h5bElocGpDMVlKZ3RYSFlIUGlNMkJhekpDMVVDclRjcERPSmxkeXc1Z2d2aUJETW91V0UwSHhmNU5ENHVYQnFYaVhtWGlPSmNhb0dVckZKaUJPSWZHV0lHcWpHSDVsT09vU2x3TTA2K2tRV2lEdUc2cmUySmd1SjdZaXJCclpGWGVwZFdGU3BWempPOXdJWHFXUTRiZzNiamdtQlVvNmx6ZGVFVEEwOXd0QXVvQytWbG5Ga3JiNGdLdzE1bFVCM0NVem1MeTFLNlAzRUpTVE9IMlRDN2lyVWM1aXdSR1pxbHcyd3ZnZjNpaW0vY1Y2TVN3WHE0WFlJYUpLSm1WRndMQ1VGMVk5eTRXc21VT2hjcXlyTkdBb1hwZzVJRmIxQzBDUmcrSlp2R0pScUs4T3Bhc0ZSVXhYUE5RNUpReXlnVFVwVXFDRk5FUHFUVEZDamhJRVprNWdvTVVjVmtITU1FR29iVTZubGo1U2k4Nmo4N0ZYUnhINDVnWFM1VG1aT2FndDdZNTVqL1FmSjgrRHBUdmNXY3lneXl6bVdpZ2dEbm1JVGNMT0RWdHlsZ2lncGlOc1h1V1JWOENqVFc1Vldsa0srYm1YTUdYOFhLZHNMM01WRWNwaU9LN016T2hCeXl2aGZLN1o2bExnSmtoMnFleU9YbE80cEFXcFliaVd4QVM4NGcrWmN1TEVnMUJ0WDVHbzhRK1RSRHVlWURCRmRJVWJ3ZTQzcStOeEVQQkRnaTh0NWdYYk1YSGpNdEhFejJYUFNMQ2t0dWN5dVZtdk1YUFV1V1Mrdmd6THpOSmhTSXdTNzZudENXQTVsb1dPT1ltU0srSVpZcnhPeG5uTXNRV0lWSzFjSmtYY0l3T1puYXNVbUxsdzZ1R0dWUzBnS3NNUUVVWmxxb2lVektXMzhHMEZWR1BscjVKY0hNdjRFcUlyTElTS1FyRlQxcU53d3NrZXJMSWV5Q25tWmFxQVFwVTBTelFNOVFVNVBJaURUS3M2aXJXWW94Z2wyMFppbzIxS25NcHNidUl2MmNUWXQ3bVR5QnFVbEN4eFJFeWxCd1JFclFRQmRHSWtBYWlHbDBTa3hhc0FDNlI3aHhaUXU0QzZiNmhpTnQ4ckthRzVROHdkV1hIQlMyUVVmdUpyZXlLbVhNYTh4V3hSdVdFQ1lERXV3TVFCSzFXWUxhWUVNRUE0U0FUb1hpSEZ4ekVyVUxKeXdNaVdWcUVBVmppQUtqVHpNdmNRZnRoVjRoR1dvVlE4eXZVM3RJVTNMQ2lLaTdnZWVacmIxbUVMcEIxVlFUdUdvd1hxVU1NeFVaTndDYmpzM0NhbjRDUlZDMDdHNE9Nc09zYldYVlhiQTdsc1RNWjUxRkJ5ZVlzcE5TNjFmRXZsV1JPaW54VXFCRWlmMG45STB3Uk9RK1FGNXo4eTVYRWF0NGxNUTVsbTR1Qm1LL0F1WTcxRm1PUGpxa1JJYUdoKzVnd0RBUjZTN2c1enFJNGcvY1lZdHFPMVlXdmNOZ0FkUlk5L0N6RmFnakpGdnA2ZzF2Y1lxNVlRU09OTXVtSTdpOHhZaEttbFVVSVJ6TncxVUlhekxsY3diRERiSFNscXBWcUcwWVNyeE5Zbmk0Y0dZTU9ZUGliZXBkYVplWnI0cGxtVmlWalh3NStScU1GOHpHdkxMRzVkY1preXlrRW9KVU1HNXEzS1cwdlpPUEllWE11ZE4zQVRjdTFCWXQ1Z0JiMUVNOFFWZUlMcmlMUlNSQlpnSlFmSnpOY1JiWTdtLzYxZmlDbDFjUDFGT3NRMlFZRnU1WTVpWGNCVThRTmp4MUxLd0lBNGJpNmFuNW1IaGo4eG8wOG1vTHRnaXFnMFhMSC9Fb00vaVVYaG04bnFCZEZMNmdveG5tNGdkN2xUYTUxS0xUbkxBY2p6Z0lWZWI1WUJxZmNTbkE0alFDMjhYRUJiMU14ZEhVVkVYTXUzSmlLRFNSczBYMUZhVGNyVU1NWVdvc1dFOFVvOXdnanhFQTB4SFlQY0ZMZTVZYmk0enhFUnYxRkdYWFU5d1hMcVdXR2lYR21BaUtRY3h0WmpwR1dHT25NWEZ3RGtqUG1qNWhIZHk2bVpYNWwydEhNUmFETW9BbnVBTkVTT1l2anBBZlVJb2RNTDBrSUt1QWlxc2l3eFl4RndiZzFLMnRDV1k3ZTR6VmJaNXhnb2hnc0xnRHFJS1daZ0o1Z09KblpSSThzQjdsY1Bpb0VxQ0ovOFNNVU1FWmhoMHVZY2tzTVJWUE1SVTZoT21FK1NBR1hNRmlpN2lENHJkVGVxaVg3eXdVSmhnZ3B0cjRDSGNvUnR6aU5PWUJ0bGJReHpSZDc5UW1JQWNRdEI2bG5Qd2x6UkxnRXlZaFl1SFpDa1V4eEJaVHFlYkxRS0xZaXJ1SWcydmNOd2hqNDB3bk1OL0dWRHpLN25tTGQ0aXVmOXhvcGhIdlNtVGpjZVpURGhINHVEOVFxWTRqNWxSS25FNGpoS3ZMOFhENEVMdUEwWEFDbDJ6MWdpVzBUTmk3NGdicjBFSXlaUzN2R0VaWWw4SEVBbTJNODVwUEJFRzNVdW1ZR0xqS2EyeTFVeE1oeExHVUN2akJJN1lITUZyQlVxVjgxSFExQU9ETUVLdFM0Wmh6VDhGbWx6cWdEMkpZd0JaaGRxTnNFRm9hOHdEUFc0MjYvTUN0cG1EV2pIY0ZjM2Q4U3cyWklyVzhRQlZ0SkFyblVwdzlTMHVrMUVzc083aUVWOFlKYlM0dlJBVVJhUEVwUytJa29XV1dBS2x3SEFiT1lyQ1lEZm1JdURTbE1CcWhhS0NyemtscXZNc3dzMkNXTC9hVkNJWmpNR3VJb3Z4MVMxeXpnMXpBWnRNRmFjUlN0Nm00TndTZVk0ME5SRVIzM0V6RjJjeXVlTElTcGNzYk44eHl1c3dVRzhud0VlOFczTWN6aVUxdUVaWVZjOHdhNXpCRzQ0eEVkekl5eXQ1ZEV3ZHpMVVVJbU53RmxQRE1hMmxFY29XYWc4T2ZqSVh6T1l4NGpZNWd2Y3BSQXRWY0c4d1U1bUlybUNFWmtvSmh3dzBzeWFZaWhUZGZCQWlXUktZLzFId1FpcG1BRFpjTmxDREhEQzI4UlFsbFl5bUVNMElOd2xZQzh4V21XNmxNRnlSb1lpRDRsZzFVMHhMT2NRcHpFZE12dEV1WjJLbVFLVzdaVGtjRVJNeE5iam9sNWlLK0t4QkZoQ2pwakpBMU1GUnRGbDlNWVhxOFM1aGl1NE9ZUTFtSE0zL1F1TmN6QVhsYlBaVndITm04VGJabitESW5sVVZ0TENUbzl6c1ZGcUJzNHZFNWovRVlGY0Z5b014K0lVeFp4Qnc4eGJNU29GZVp4aWNUWm1MOVRYRE1FamtCdDRpQVV3aWl2WkZMd1JVWFl6R2RYbU5GVG1NR25FQWpCVGt3UkNpUldZRWR4Um9Fc3JTV1VZd1VPSUk4elB0Qjh3U2k0cFNYQmJXWjRLbW9zQ3RFVnBTVVVCUkJTSmkzTFNIbWFpeDFBQXZpSXRPWlpWOHNLWnVMaTlQRVZEakVLcFI5UkZTd2xMTXgwcmNHeEc3NmwxVllqalYwekprV3pTM3pHaVV2bVh5UDFDQnlXNHFFR2kzbU5qWEdHS3BvcG9qVUtaZHhpZVRpWkxwZkVBNk1PNWZMc2N5aTNXblVBQjBsa0FWbXcxTEtPTVlob2IzRzBnMTh6dHhCZVhFdjYyYWxpajhqRGRrcmU0MXR4R1hlU09jdXBjc1hjUUYzbUlRQTM0SlNXN1hnajFHenhMMVViWllNTEZhdWdJOXFmekFyT0lPSnhobkYrVUFtSmhlZlVzSmRSY1psaU04QnRqMWJ2SkJhVmlXb2l1RFJUUDJpMFozRml3Zk1WWFVUM0ZaZHcwdXR3SzFnbGExaUtSU09iSllxR3Rrc2FnZ1d6TERHSjVna29sU3RpcXVJVWMvRERtR1ZLK09JYWY2VmFGK292U2gycDVrTzNFY1FjaEhkVEFyY29TaUxOM0tEY1R1NGpMbk1DMUhud1FYekhwYXI1bGtJcUNBWFVER29BeWtVUmp2RXZNdVFXc3dLWUdYTFRFTmhSbUxPb3dMM2JLR3BRWVN6aUxuY0FsMW1XUlptUEc1bXpBQU9aY29tUmlMQllzV01LeGhDRUo2WmNKZ25oQ0lkTXVtOUdWdU9MYVNiYUl6VzFFcHZSRXRpQnVaWGNWUWRTeTVxUGlLa1RSTDhRTXN1VjNEQzlSWG40TWswbk4vQkREY3FhK0l4b0hpSWFjM3BoUXVRY1FDMWdoSkxsMUwxYkVWWmxpamQ0dU5sYmcwaHVWWm1kK0krSllmRXNRckJGNEVKTVE1Y3NFV0lOeXEzRnhOdzBlNVFzb1BFWE1aMEZyRndpQWFtTHhBdjRDRE1DU3JpVkthbjIySXRNdlFWdVVvVUxCT1RQVTNhdEhVcU1iN2pkdDRabVk0bDNGUmxyeEZUd1FhcHU2am9iREhFdE50NGlEZ3c5d2RjSEpFSUN3Q29veTVjY3haRldpRWtnSFJrZ0xWQ3lXUERVS0ZXWTlqUnhjdFpXTHQ2bGl6SEFsTFEzZUdOYTZxRjN1TFhpQllabEt6cWRkUHhjeWpaaUpsUUU4ZHdHMHo0Z0ZCR0J3RjN4TTR5dHMwZVpmaVdYbVVHU29sZFNxazcxRFpLMUpjVndSTW00NWh1WUZLbFc1Ukx6OUVXa05lV0sxS3ZNSkczQmxMSTNtUHVDQm1JWTZ0Nmx0TnVXWGlHR1dKdGxBWmlITDRoMGxUeDdoWHFXTU9vWlZVVWZVU3lYVkdvOVYzS1VPb0tJdkVJUjFVQm5LczhRRnNxNGZhcUpTT240SlUzVjhBdWljVlJCOW1WRlFMaCtJQnhLd2g0VDFoNHh3MUhEVVdlR0Vtb1NYSExxYkM1ZnptWlFFcEdZSldJazdxR1YzTEppWlNraUE0dTR1N3dnY0lweUZSSElMVVpNbFZBV2tuaG51SStRNUo1UElOR1lOa1VJWjFLcUw1bHczOEt2TVZIRVMzZVBpNVJBUzdqSFVXWXJFaEJtcHhPdmczQ0xxYW1vUUwyOXo4Q3hlc0VMV3laUTdqeHc3bWlSRUs0dmlITWQ0U3QxdUV1NEVHTGNSck9HSzFHZXZsUytwZUpxcHpPNVZ3ZUdBclZRNmhBdWtpaTQyUTdsNmxISEVONmJnRmhFSERFU0dHb0F3bTRGVXNCZThSVnlXUUcydDZnYWJJdHN5c1hjY3Q5L0RiNE5pS2lEVXc0aUlveXdEenNXdU5TN2FJQ3pNSUFsY2p5L0crRlZoTHlxQTBZalZEdm1VcitURmJYY2R0M0Z3R1lOM1p1RFFWaGpoNUlLem1YaUpiZnl3RmNNcmE4VGhYTXN3YVZMQnhReFZ5SE13TExiaElQSVp1R2dYcmlBRmpaQmdRUHVFclpjd0FqMEVvc0Nrd3cwdVhkR0prRWo1bGhDL2ZNQ29VTjB3MVlYdVpibHVTYUlPS2hzaUtpNGprSE1DZDRwY0d2Z01HM2JnbEZ6R1ZPSXJkbnVDbDJDYzVnblFaMkhFTmtIWmRkUzFrZUlvV0M5bUdZQmx3cHpQSk0wVzRxSmdkSmF0aitjZFZjcVRNVmwzdVhpWEhobDdxTG1XNml6WHpIYXVEVjlTOHVVRktUbUJWVk5jUTZRS3hNenFIV2lha0dlWVFJRUltcGNaaW1wbkhpVnp6OEJLeEczUmJFU3lobEExYkREVlFUaUNjUUdxam5DYVZBdkVSMU9oaXVvSnVOaUNtRE1zSmM1ZzlUYlJVMkV1TEdaVVFVeTBIaUFRZFJscWp1RUtJRGhDc3NnQW9DQTZta3FaWnFialZGaVFhalltb3V3aW90bGk0V0JWeFp4RUVYT0l2UHdvc3IrQTNCZ3dXWGlLaUtLMUlhaDhHNE1KcWFqbUdHekVVdWRUTjJxb2NBc3BONGd6ZTl3UUUzNWpNV1ovWkNXUVRCaFJuNE1FUGk1ZG1aV1BqbURtYWwvRnk2TXk1bUdKWTc0bDhmWkhsb1g2ak1ySFV0QTc2aGRGekxRYWNTNitHRldNa0VGTEFKVUFNYitNZzNOTk45eXQ1Z0hSVUZQd1ErVG00V0xnQk1Yck1yb25nNmp4TlM3aGduUkxYOFJ3cU9UTVpyU1ZwS2RFTlRweVJCcTdqcFdpRjN1SUJyQ3hjRnBCczFnSUwzbnhERFd1WlMrc1N0Vm4zS2kzVUxkYWkzcUFxbHBnQlFzN2lvRlZ4RXF2TVNPM2g2aUpEWnpVYkprQ0lNTUxpNGlPTXVHQmFaVkVHbnZSSkVjYmpnRFR2YkVZVTZFS1FuSVhMS1Z6ZkVGcTh3VVdzUVhvaTF6Y1hHSWx5Y1NvazNBVmtnV1h5NE16Q2dkeXA5UXNTRTVleVo4S0hXWU0wVnhyTWFxV3JtNGFjcmJEazF4QkdXM05ud3VJVWl0ekZ4RlF2QkZleDJxUnNpalpTazZZNGhxQzUxS0hPSUlxTExsL0N4dEVnWGh4QUNNVWFSSm5CN212RENjbjBRbEVlWmFYZTRuYW51YVVRUk1JK29FMmxEbURvWXNTNmQvQTB2UHdSR2d4Qkt2TEtlS2hsVkFxcWdMeEJNS2x3T3lPNnJFMmlaeEtheVJQRlJBSlp2TTBvSlRIbkVPaUNtcFhiVXZ1eU9XeTBidzZnSVhNMkk4RnhWTHpIVkdvbEJnRGNlYVdBdmR4V2xNU25jcUtvbUJIS1lRMDdNUzBXSTh6QTNMUllxc1dXRXY0akRVckEwemNIRUlFcURFN2luYkZnM3pBMWNHeVhtWDhFRzV1RXpBcVJZb3o3aEFPMXNzb3RrcEhYUjlSS0ZZODhTcFFSYmhDRENMbXBtL0Vxcno4UGlYUGMzOGtIR1lSZS9nVTlqdUU3Y2JpYnJtS3FtU0tJMjB6YVhCOW9wU3NTbFlZQTRZQm9tZTRMaUlEVjRnQnhLM21LbUpURE1DSHljWlBnTVF0VmNETEErMktad2hQa1Y4TENZRUNDcmdSNlN5bTl4dHQ5UzBIam1XckdZSmdYTEhSUkVxaXN5cXptaU9RYXZ2aUdieE9OUkVjT2dsQ2lzMnNVWEVkYmhtMkNzR25UY01XRytJMFRsZUNFcTZPUGNkOXN1YkplNmdqVHdpRUZIVExWU0R6R0JjZTRXeEszenpGUnNnM0RrWUhBRUR0Uys0Rm9FREF4WGVuTUMzT2lDeUdwbXE0NVpsMWpVd3lPR1lLQVlZaXJ4aTRYRU1TK240S1FVeTV1RHhISWkxY1ZHRm8vY0FvVS9jc0tGZlVWS3dlb3M1Y3hDSmNyUkdCaUN5TExpeGFtR2tPNExtYkhrOXl5cWNjUHdFSXJFVWFjd1pjWDRBb3MrNStpWjhWMVJtT0srOVJpL2lKZlduT1lKY3RlNEs2Z1FSVVRqdURadXZjYW9YcVd3RnNPZVlPcFllR0RnMG5rZ2dlMFpJUlpEeEtNeEtZamlGTFVGWmp0d0lpTVFnQ3N5czFQQkJVSGlCV1pZbUNBdmlCMnpIM0t6Y0E0Sm1zeHpPVmlMaldJTzl4NlpnUnFvdExxSVRNc3hNdVNFcUZNVFF3cVp5NDlRd2pRQW1FTnhpczVsWmhISW1sVmlCVWE1bkptb1JRWWltSFRDRU95SnB4OFczTVdjeklyRlJibHhjUWdWZFJrQnhnUUJ1cERFdkVMbUdISDRNSk9ZMzlTb2U0dnd5cW5TUWJobUVIcVBFeENDM2FHTW1JcmU0Vk5qa2VJcFUyMjFrZ1ZhbHdPaEQ0SVcrSTN4SFdaY2R6bkVmam1ibmo0NGhxRXE1VDdJa2tNVkVLSmlPMkRFUUpDVzRZbFN1WlpaS0lsTVFCZmlVVk9KWmdpYmFjeFp6TG5IeGJtbFZNSUxMdjQxUVVGUktzcUZsMWJCbTdSbWtKaUJNRVN3M1VzYXpGSEpLS2pxYWc1aXNyd3hmVXdWbEc2VmR4Z0Y3L21CSFhxWmJWZXBYZ3czUnpBdW1uVXRxTkM4UXB3ZTRKNzEzMUFXcnJUUmlGc1F1YjZpbXUyeHpIYUd6SXgzZU9NVkMzYlZ5Mnl0M3VYaTIreUxtV0dJeGlyT3JnZ29VdmNBa29NUlNMWTR6TW9GdDRsYmVyM3hOeFBPNHgwVUVIQXRPWXFLcXU0aGNORVMzUkZlWmhReXFsVGYzSERNa1ZpM0dsSTRpb1ppdGU0QUlZb2kwd0taTXlqalF3U2t5eTV4S0lMeEFMZk1CTW9TWFdZSTdoNGxWUmN1aVhBTkRtS3Fyek96NDFyeE1OTWNlSXJMR0ZPWmxMK0xxTEtOc1JaZ2NRM0V2YkwzSWRHQ0VNR2VXNC9sZ1h1RnVJRmVPWmNFQXptMDFBV1VwekFWUVE0aUZvby96RnJrL0U0V29sMVJSMlJScXZxSDBVZXhpWUFIbmNyaGJkTVJrSStTTE1Ha2xyWEVkbUpTRmxRQTFLVE1EcjRMckJtQzVucUdYTUJYR1lvY2tidkVFWVlabEpCVWwyV21lNWF2aVBJaFhNdU5Ta2dYUE1iR3BjUytjaHVPTk9LbUNkMFZTNTFBaGNiZHNHWU9jUlluRXR1WjBqemliL0UzRTRvZEM4TUd0M0h4RnFYY3VwY3VMZm5xb3ZRdm1KS2g1anNoZTZpUjBTZGpFVzBRVUwzTFc1WGNZNlR4TERVV0tqdFVXWVB3UWNzcjRKTng4VVV2RVhkVVRHNGhpY2lVOHhjVEFPWmZKRHRqTTFMZzhSY1krREUxNG1iOFIzbVlMWXRtRDQ0aDVqa2w2cUxXdHhTMFJ4R2xMQklTbFN5UEtNclpnaUZzSlNSYWlROGMxSE10TUVRT1lyY2FpcUszVUFGSmNVckJDSHk4bEUzTGdVaTkwSGNSUHg3cWdmZndUZUs0SVJvUmFGUkZHelBGeFdTNjNURGdpUnRNRTJ2cmlaQnZpTEppN2xUc2p6bHhGUmVTemN1c2xOekVUd2g1bEZ2SzU5b0pRTFdvdHJiMGJsNWRORDFCSWFxQzFGbDV6R3I4SldGMTFNV0lYVzRZeXM2bHVSMXNtZ3RIZHhlbVJnR0lVRExkdHc1ZVRGT0l5VVhqT29PaHR2aUNLSkc3NWxTM0oxMUZSVFRHVzVzbEZVUnRUb21lU0tMRWRsc28zTFhpSTVnM0V1aUxCY05rOHdXdGFDQ1hWNGw1STRZZ3FvWlhMSlp1c0VvY1pyYk15eUtyWFVZb2o3aXU1K3RpQ0k1Wi90UlZ5ektLbGxmQXpFK3lZRnlUZ3MxRmx4QkR2bWJxWlFYYzZJNnZFVUhNdTM4RUNzZzF3eEVXd3AxekhRYXhjRUM3ZUsxRVRzT1pseFQ0Z3RtT0ZqcmlBS0lwRUIxY0NzeEI3KzRFME80bmJCeU9vUyt5MUx4OFJWYTNCQXBtVmNTb3pHVlJMdU40aXZFRE9ac3JGUk5WR3pXWUJlWUdHWTdxTkNnaW9wSTF4RGNiK29pdUlqcUFxY3dHRnhMWnNRbExVY1E1YWhET0NNUkxJY2tnWnVvZFJZekZqRXNJRmJNa3gyUWZCWjFLS04zY01HVU1IK2NFRkVkSkJ1TDE4RnVBdFlpQ3FPb0dVSHVDWFJBYllZMU5rSWFyN0ovdDJJVWlDSWx4WXFtTzNFMHZQd0hxS3ltRVBnZ3k1Y3FYWHhrKzQ0bDM2aHVmU0JMaXpYeGVacU1ZazNETTR6RnI3akdNSmN1ekh3ZFJVTE13dTQzemFZSVU1WWkxU0JHNm9ac1FnRTNFZHhBNWlIREU4bzZnU2lWTG9iM0V4Y0RWOFFoditpekh1S2xlQ0xXYUlKcWhNdXBoR2xaaDhBMzhGekhhQ0ZDZ2w0bUhOSzZoZ0haSEliM0ZuekZkWCtJTFc0amNmSzhhbkE4c1d0dDNxVzhZdUx2QmhSY3hJS1RVQTFXOFBNU3R0VjFCSmNybk1vQXNaV2FSNmVZSkRZbUE2aldFUk9KYXF3ZCtJY1dvNFdCWkZzdW9nc2dYYWFpbWVCS0FxenB1WjF1VlpmTWEwYURLcFFwZWJsWmFYbTdnQnFCaFphcTVlMGhGck44UzdxRjN4MUZiSlRIWldpS2xxT1k2NmlwcUt5NEplNHZNVkpVOFpnRjRnSE80aTJMdUNtb09TV1NoYmRIRVd4UXFEVFhjS0tjdVlRZDNGYll1WlFCQm1zeHY3K0ZWeExJYVM0V01SaHpBRldiZ0poekx0eW1qVVVGQUcxaEZpdnpOb3JCVnovdVdzYVc5ZVkxc3hCbkV6aXJwWmVsSHZaS3NnNExyanpMa1JEMnhFVVZtcnFHS2FMYUQvQURCVEpaQW5HdHdMMW1WT0lpdFNsVWhDYnhpRFZKTE1nQlFZaXFZdVhwSEozRXNXRHFYdzdKWURwSFVBYWgvTUNzc0lRbFFzSllaaGRZWVdGMFhMQjRpVnVVanFJdWlHV2NUTFRMcHVLQ0NaZ1ZhUk9vRm1aUTN4R0crSWdzQnpCVVhFc3lUY01zZUdYWVUzbUlENmhhckFvUUc0NGRRVytvdU14V3dVRzZqc1Q0NHlqY3dqS2RNVHlWMXNndEZma2h2Qjh3cmRHZ0lBdHl1M3FBRnhTMXhBSGNBUXVKUVpJQ0pWK0lBRG9NcEcxZ3hQSzVlWExpeXVlSUlKSGdoYjZsL0JHRUlRS21UZFFvVnVWUmQ3aXc4eDhSemo0dW1KMUZvaktDT1BqaWJQbFkrUGM5UzU1bDNMQmhRaUNwcmlBYlhVQlVJUTI1amF4c2x0N2RReEhNOHBReS9tYlFLd0FLYlprWXQvQTRxSHl5eHVaU3FBY3dRVVpabjJvRzhSNUk0RUNDMkJpQ215ZHN1eVlZSWJpR0NXR3lnUFdSSVBjSEVNdE1xZzRIbUR0d01YUENzMnl4bDVpc0hNU2NibEdtZmNTckYxcGhWcXJOOVFvVG9sNU4xekhNTjZmTUZZcThIbUZuYk5QOW9WQktYSmlJZHZacUs5Z0NMRXJaZ2lsamd1QTFubUFBdkIrb3RtVTdoRG5UM0JaVVVnUnBxL0xxWFk5L1VJZ2x1VGlCMU9Oc0dQQmdYVmp0Z0JvelVxWG1jMndidDFONWVrV21XMWNhczBKZ2tBVU9TQzlzQ2c5eFVMM0JMRTE0aW01ellJbGJOUlp5eGFJdWFpMTdsWEJHcHM1Z3BiVUJkVFBURk9KbytMd3lsMXFPdTRsUXB4TGl1Vm9JSVlaVmQxZk1XN0taeFVidkxWeWdPRmJjanhBWGJmdUNzSnVEWW9QalVwUkRpTnNhTTRsa0V5NXVOQ2lKVDdsVTVoZ3Q0NWxsZjJtN2xGM0VOMUtEZ2dJcHhLcnhLUlE1M0NsUk9JeEYybkoxNmpFNURDaDh3Q3JZQ3NTN0N4enFYWjNObW9OZTRVYlc0dkFKaDVRS1lSQTd6THBheWtLQ1ltWE1xMjBLN2xXZUpnYXJjcVpDTFlMSWx3a1ZYbUdka0ZtTU1GbVloR3R6dWxnd2hjRGN0YXZCRWR5amlheXBsM0FETWRKVVp4Y2VzNStQR3hlNVl5eUEySU5xRlFLY2tvMFd1TFIxYU1sRUZHNEppNHBjSEV6SXdMeUxIREZWVlBaNGxqUm56TklzV0xPVzZuNG1Lc3k3Ym1EVU1Rbk1JUWdNcDR6RmZVQzJIVUFmRUd4aWI1aTV4THFNeldweE5sUjZuTWZoaGl6KzhZbFM4MU9ZT2ZVdkVFck13NmdsYnRsZzFjRXpjdVhMUUlEVjhRWERpTGlvdGd4QjZRQTRpYlIyL0ovU2d3bTQ4UmhPQ0dFTDRqYU1TN1ZmT0JIVUVERVNtb2pGVFdKdmJpYUJTTXpDd0dnMlJLdEVvMDFER0hxT2FXZmpCTDJqYzlwbVYxSFROZXBZamF1cWc5MHF5WTI4ejJwWGNad2J2TlJETUpwdnRoQlRucUJoa2F6TmdNUExMMFZaZTRoWGdJMWJOd3R2WnVXTFMzVEZhSzRYTVFvNUhtQ29QeDNBWHNMOVJFM3FXaDc1bGlBVi9lR2FKc01CQjlFeDdScHIxRTFXdVloY1IxRlN5N0VXTEJZTXh6QlFHcnlUQXMweDN0cGpYT29pbEVjQk1FVll1TzVKZFUxRVhpTDhYQWNSSjlRT3BaRW5TWmlXTlQreUJqMThDdU5TNFAxMnkzK0RSd1NpZEsvcVozVFZ4Q0FiNTh4dkoxV1NLeHc4K1kybzRKWUZBQmpCUys1UXBDaGRYY2RxbDFzaFdGWjRqNEdremNxUXIvQU1qWTViTHhjQVp2alVVVE1FYTZpUXUxaGRFcStibG0zbm1MekFkdFhFUHpCYll3aG1tM3JpQ2hVNUJBV2tXdGJYSFVRS05qcGdHMkFNRVlXOXdRbGw4UUtXUVJoYUlNMlN4Q2xVU2kyd0Nvam00R2NrUVNtVVNpQ21xZ1Uwd280bEF1cGFyTWtBMlNtRmdWbGxoWk4waDNSRFRZcGl3UGNVb1NCVXNSVWpxekxzc1djczdtV1hLcnpNdUpmd1J5UW9ITG1HUUtBb0pwTW5FdWlLeFNWek1Oc3BJRlJYRlV1d1hrSVdHb3NXTEtSdUVCSXI4Uzh3YnJPZmdoTTM0blB3RlFTbk03aUlVNW1qdjRQaDl6YUw4SDRpZkN3M0x6bVBpS1MvdVh6RndSYzRpYkFqLzdCSUdsRndLQTl5akhpT0dNd3FJa0QwcUttTHhHdUlDcGFpUlM0MktGeXdhbDV2VXV6dVg4RVVkSDlGMUdkWE10dCtCSFV2VUNBSm5ERGNLTVJTdFFGeXBDTjFIZVpjQXpMQVlxVUtTeVVhaWtzYllPckp0bk00RFFReUZZSnBveURjVjJyVXNxbUNKQzN1SlZGQU0wd0s2ZktYeWxIUE1jWFNyNklkVHN3anMxYlYxQUNnd2h1VmdGWjRKVVpGbGhhc3FZNVBMTE5xclVHclpiTG9zbzFaS3VSeU1jTXQzdVdzb3J6RVdnNGpPVnNJa0tNUG1YT1Z4RnlhaG5QTTBuTEVwbUJHempFcVFZZkZMQkM4eEZGODl3UWNGUXhheFdGaXNzaW90cUtmVVJ3eTg3aXVJQlhpSlR5aVNqaVdabVF1Tm9NU3FDc1FoOEVya3FwWTFvTkU1bHBodS91R2c0ZFJFdzhZaWFYNitBaDk0NGxodkhpS3MxaGozVEEyQ1M2YThQY0FwZU9ST0lsbE5OZHloUzE3alZuRENiY0hNVVh3d05WWjRnSG9lWUZsdnFCcFFpMXV6cGlnaTZ2VU9HNHF3dFF5NGpDbTNpSmRwa2lqTGJhZkRBQlRkekFZM01EdURlNEZaaXc0Z3BsY1FXSWFHNWdMRUFXWmxCdTRDN2pTUlRSQWVZa3hxREc3bEc0bG1JcE9tS0RFUnVreExqRXNEYzR4RUZXbUpha3hSMVRLVFBId1JHQ3JsRjNISEpOQTRsb3N1WUE1K0N1S1cyWEdDMUJZL0tWQ0dRSWNIUkt6TEZKbUJYSWhFSFdKMDNCaEZwdUxGTWdkSkt5NFplYWl4WXNXQTF2TSsrRFptTFVXWUsvVUlhK0RNV013em1MV3BjOVJaVVpjSmZVYmpIeEZyNFhFYVJiZ3hhYUl0Nmo0bDVqaldvQ1pqWHI5eDJzSzErNWUyakVXMis0bDF3d2c0YmdMcVplSU1zNWw3aEhvd3dMMUVOL0lqditoMUF1RFJDQzgrSlNRbTF6SW5Hb2xnYitRQmwybVVHNWt6RlpNbDIrTHNDWWdwWXNoWXZVR3c3aGx5VmVwbGRzd3dMSWdTOFhNQmN2dHVvcUhtSUFjcGlDQU9EeVMwdUM1WG1QMktJNTJVMjh2VUFxclJFUkNLOHdZeFpHcWlBbDFaMUZweDNGUmJ5VFJ0K29pMGJxSmNYVEx1U3VaVWFNUWN0M0FTck1HSmRIRXNGVmdSeTNBdzN6REY1aXNZeEs4VFM3bGp6SGU0UnFaaEJET0RFUzAzVUJWbVl5RndNVlBUQ3FsaHZxNGk0dnpWVHRnWmwzaUtrQXhwQTRRVVlDT2cyUTRjMUFQa2d4bUs2VUdXYThEVUp3Y055bmNGaVdCdWxpSWVJcExpWHBOWDY4UUc2SWFERzRocXl1TWN4b21OU2dIQXl4aGNQZW9hRVZwd3dsWFBtRVdMaGxFb0RucUNOT3dnMDF1c1ppSEw5emNvYTNHVzFQQkNjam1hTFpxWFNvVTNLN2pVczRHWkJNTXdabUtkTzQ3RXc2WlY2bGpFRU43bDNxV054Q1ZjTFNsNGlRRlpScGlVaEtDQkRNVk9PWmh6S3NnSnFVNFlhaVJpMllpWXpBc0hVS1NDRXFaWEJscmN6QnVIZGtKSm9SbXFuRXZPNFdpTUJnd2k4NWpLMkJtSG1JcmNCQTZCN2ptQzFHRE10dzFBc1pYR3ljU290dURMbHk0bzZybHk0c3VYS05oQWt3VHdpcXN4WWkvY3VYTG1SR0h3Skx2Y3ZNdnFMSEh4Nm1vUHhmVXpMdUxYbUxLaTM0aXJkNmpuQnFmM2ovRXV6TzVhY3d5MlIyNk53YWZDS3NyRlJIMUFpNHU0dVppVG1LcStJVzNxV0lMSUxGZHNXMGZhRkxtVm1EV2liZmpVVVdaelExQXJEUE51RCtoZVVYbUxFYmo0YUdybGp6TEttQ3ZFQmFiaEZDWmppazFCeVFRR3NvZnZnalZvd3NNSzVnVTF2bGlyb3VXNEJzT1puclhtQmhlRG1FNmlGVzhSb0EyYUttQXBhSDk0NVF0aURnWFhiRkxTMmNRYnV2ejFMdHNiV0MxRUZ1WFc4d1VwVVZJTFdHTEF2VXltVlpwd1BtWWE0anNCK0lPUllvcndUYkVXakVzZUpnb3R6blZ4WmxLSmdmREdkdkRBS1ZVU2pOblRHSlQrSlFZejZpNWd5L2gzZDhSM2ViaW9uRzJLTlZOQTNPMkVWTllsU3I4UmkxN1kyd2ExbDVZSFE2L0VLQ3pZWmxLYlVBV3JnSk5BQW9jeGxCd1BLUkt3M3lTM0VBeXpjYmdzOHpnU05Wa3dZVEVzQWNYS3l4eWNQTVJKeWNkUk1sM3dwcGl4eC93Q3hWeXk2aStCUXp4SEJrRHd3bkpBWjh5bFkzeXdSWWZjdUtlWlkxVzRxdnFPNU9kakZNZGtXMnBWWmcwWUlLNVdCZEl5MjhRQ0F6Z1JOVVRHRm1WSU9NUVZFbzNIU0RLR21LeUMzbVVXcFZKZHRNdEdvYlNRSUlhMUtMU1dheENqNmxiK3lYRzl3TUY1amxpTG5heXE4emJXWXp6QStCejZOd2dBb1BobEZYeG1YWVJVc09rRWN4YnUyWExpeTRzM055MStaY3Q3aXhaY3VXRm8zZlVwL3hGYjRaazhNRHJVTnpmeGZ3K0lMMUxuUHdMZW8rSnROL0I4c2ZFWE5SYWNTN2ZVKzQrSTVQVXF6TWFBNVlGdTRBVTNGbWlEdVRFUWlHWmN5WmlMZmlGU1ZxRVZ1Q2tBdWVJd29KYXFneXhtTjFGc2kvQk9QUHpjV0p1UmlFZFpnOUJETnhtVVB3R09vOFlsc3dyRWxNSUVibVV0d25uZ0lrQ21MaUVnbHpFTzlRZFFvWTEzQm92ZGtSVk1KTEMzYXVwZFVYUTdnVGZCaWNCdTl3UUJ6aURhUnNxcTR6QUV1WW9xQW1BQ0pXbkNjTVNnNHR4VUhaMGt5dXdZelZ3d3R6c0lvRmZxWldyaVVGYmkwN3p5UlEzMUxMU1pQVXcwNmh4WW81ZTRsRFdaZFhGVHVaTTNJaXlKcjR1bTR3ckdLaERwaDlFZHZCRnpnZ2IxQXhIQmErSUhaQkc2TWMvN3dKaVhyZ1YyN21sTGNLUUdNUVBoWlh5NEl6TEt0ekF0dnBFaXhiNnJYM0FBNmZlSWdBQm5Hb1pXaTZOMXEvcVZJUUFFREs4UXFGbmkxNVlxTGxvdkRCcXF5eDR0S2hNN3M1dUFXelVJTnNVcFpBR3dVN2hVbW5rU0FvRis0bkxGK1NWTVpuYXdMZFJ3MjE0aG9DbnVFUTVjUUc2VE1BeThTaWkvVUJLZHd2TmltTUkrbU84OFFSalFmQVFVUVF5WmcyUnBNekJRaUtHWnBHN1dMbTVjc2F6Q25Pb3E1Z3Q1aWx4V01XV0tqVEdJMjNHSk5mRW9HaURLd2JUY3JqazZZQVhoaTlRaExzaURGM0w5Uk9VUWxJQkJhQVpZWUJ1V0JIS3ZnSlc5eTRGNGwzQjh5OHk1Y3VYOEFPZUNXcTlzdVhGbHk1Y2NFaGxYTTQvaGxFczF1Vnl5Q0VJcEdYOEx6TGVQaSsvaTVmMUxoOGN6Y0hMQnQ0bXI1WlUzemlINFM4NDFCbDZOc0FUQmNHR0hLNWd6UlJLanYzRHRXSUZyc21TVU01WXNxNGxBZVNBRXhBYmRYTEI1alJheFhvajhrMzhyOEtaU0tJUVcxS1FxQkp3TGljSVVDY3hUYWFSQ0FoSlM0S3l6SkVwcU8wRFhxTlkzbmNzQVN4bHhvZ3R0d3RSTENzMzZqc1l1VjdsaXlEZ1ZtT3lWWTBFTmEzK3BTYTEzVU9JM1VzU3JaZE9Cc2wzdFcyS3FEWFVBdWJPcmp0b05SUndsU3d1c2twWldUbVhUckhVWGsxSHhNa2ZQY29XbTRqeXNXeGltK1NZeENqQkNDM3pGVlQ1YnFFMWZBWEdraEFVZ3AzY1NwclQrcHRCSHNDWUxaaC95aFZZcnRpL0U4elk1aXlHSGNGTkRtSnFwQ1ZkcFlTN2hvekxZbUp1Wmdzd2lPNm0zclZ3b3NjaWNjUVdJbG5HT1lwYUVPanYxQXlsUjA1aE93SnBkSHJ1STFpZHEyL240d0xzdm1GR0dqR1lGUzh3cG85K1ltc2lSWGgzRWd1ajNCcXpmZFFJOTN6M0Z6TCtDSWdJUW40d1Nsc3E0SWx3TGpwZVFaVUk0M0FyZUE4eStyYTZxQmFvMFJhVW1PNm1PekZTcHBkeTB0UHlTMHpCRGlDU2wzRmVlb1loQUxaQWdwR0duY1c2M2N1dUlEam1Oek4rSTN4Rlc0NFY0alV3MUdpaXhHNElsc0NIK1lCbERFSlVSdTQ3bkxqN3VYT2ZvS1U3SG9xVjl2ekRkdnRoQ3FYM2N0bGhJSGQwZDFFR0I5RUFjaElla2FpSEZOODFBcWxsOFNqWm81Z3JwUjdnZ1VGL2NOYTkrWll5MStwWXVTZy9NdndmdVU1RWxJcC9NTGMvRng4dmdyQWR5NDFnM0xseTV2VXVtamNSbHVKWUY2Z2padTlNU2N5emZNV0lKN210ZjBERFBFSWQ1bExsL0EzRWlrTTZtYjhSYjlSYzR5d2NMekNMZGNUTFJHd3N5d2NJN2R4UlRRU2lrSEdvTm5DeWl6bGkyL0JTaVhGcHNpbTFtMlk3WUFPY3d1VTRpTG5NcFJVVnZ5ZjByRk9SRUF1RU9lMk80NmwzSEVoUFQ0T09Id3NvVmRTNHdXMHhEc2lESVpzMWdEWFhFSlhURVJ1Q25xVitZcktCbURQWFVYSEN6SGRKRlB2TndjVXVwbG0vcUdOc01OdW9JcFVXY2FKWjBrTmlDb2xNdFZxc3dPSUxlNEE4b3Nad1BFdzh4THpUVHFEOGtvOXJDNjl4ZGFKbGxsZ29EZCtKazFvanV1NHNUNEdEVVZCTm1NUzRuTlI5YjR5c2M4cGxQYVdyd2hSWmNJNzJEQTBPWHFhWU9VUU5Vd0huckRCdXpjWi81WVVRNG5LNXFMd1MxRGlNVFVKNWhjRVZ5ejFDMUEzYlZTa2FhSmh4L01BQTQ1cmNjRnVIaGlLcTNuZmJFUjZpcnFWcUNpY2hCa1hVRkpWM0xBTkZ3WG10L3FBVU1SRWF5akRXME9lR0llRVRkOHpiNG9EYnVVcWZseEtVdVFkd0FHRlZDZzBFZWh3d1JSVlVOV3pDSEZkUVZ5TFhjdk1tQXdTbHVtQWpZNTFCYklrREZYTktNbzFpTzR6RGNzekNHSVJxSUdwUVZLRzRBbGtMWjRsREpCUzVTMXhMREVYbFlMaW9CTVRsaXFnQ2NYQkNKdDlFQ3EyOFphbEcwZWNhbmxidEkwMFhlbVhhQStZN2hQUVJzeXNMZHI5c293YVBjRFpmM0xYdmZjUSs0ajlRWEZ3WnZjUytaWk02aHoweFF6UFdKWW1FOFdONHBVYlJUZVpaMWlBaFpjMWJUMHhnVlRXb3J0aWRNQWR4c3hCdURlSVFRTVM3S0ZOU3FoWVNZbDNtS0lZam1EeExuRUhtWDQrTCtHR1p6R1YxQnJjeEY2aTN1TmQ0SW9aT1lVN1EydlVzV3RRYVZaVXNqVVFsc0VFZHVqaVZzQTEzQkM3ejFFWHo4WWlGVGt1TVhCVVpUWm1ZalVHMmJtNEtDZC93QlJEK2hpZ09ZQkJCL1VGd0YxektoNWxyZndIcjRQTXB6Q3JxVUVZZG53cDFtVVpscmFTZ05UMGxZK0JyZFFGTHZNckRMTElKZnVXWVBNc2x0c3QvYVlDbnpDMzlrYzRJeGYxSFYvaUZ4YnA2ZzJzTzArNktVYUJsTHpuekY4WWpYdVU0YUdXamh3VEppQUt2Y2RlWnZER2xYOVFBS2M4eEVHYjB4VmUxNGxLRWQxNitJeVRoQmkvZzZsbmhCOGJ1Wnc1NndwYkZTei9CQ2VlNnZ4RnRNRUE3cHFNT29oZE4zanpMQnkzS0d1ZUpqTlRnTFNYVHRCYUh6cm1hWndZdzVUS2VvR0Z0WCtwdWJVcC91L01CQ3lneDU5Uk5JNTVMM0FVVWRPb0VVZG1QaW9aWExJRFFHd2hjVTQ3aGRDTkF2VXBDN2ZCVUdxV2wwUXFzWThOd3BaclBVMmlBTHBseldoYVloYUMyaHlRa3NyVlhiQVUzdmlVR2ROYjNVTjUwdWhtMlU5MUNESDV6S29Hc3lyZHdnNEgzekdhcEVpRVFod1g5VEdIRnhYUjJRcnFKTWpGZWJoTEZRZ1M3WlVhN2dxczB5M3VBdk1YR0lGaXJtSVVTSXdFeWxBN1dveWhjY0cvd0J6QTByMm1abUwyOENzeUpEeGNvY0E0MFJhTllJdTkrNWN4QXIzSy9NY0RFY015N1pHZ1pwWmtocFl2QVJpSFZlWmxjSVpRRGd2ekJsSU5OeW5FWUxabEsxOEhPT09ZTTBRSlF4TEdVVGxQeExma09HRFJnT0lPWXZNZktPV0RncUdZWTNLeE1JQnd5N0NTNHBhU0NtWE15ZW84aU0wUVdEeEMrWTM3SmRFZk11YmpxRFJCbTk2ajRoSGN1V2F1SU1CRU9LbDRzM05LWW9PSmRaZEhFR2hNRXBRWXhLMDVvN2hncHh6Rmx6Y0Z0c0RNOE14bHhXb05TODNOL0MvMVYvUXNXWHFKeGRmSVViaHdYS05SaXFER1lZaWVJcWhuNDBta3NTMjByREh3QmNUQWl6QUVSTHVFV0pqaU45R0lsTGVMaTB3cFJLWkpUTXhsQkZjVHVSN3N0TjNMdHc2ZTRaWmxGNmpSTHpVUmZ1VWp5UzdOL1V1c25NVzEvdktjSXVlb2lzN2hkb2cwdWFoNDF1TGlxdGlEZ2lXeTZpM2NseS9FWm1xaVlWRFZwRGQvY2QrTFFtNndZWFRVQUthR0dRa09MT2xicWNnSHFaUS9xWlZGRW9DQngrSUM0OXlucUlIVzVobVdlb3FsOHdseWVJaVY1Y3dRaHRwb3ZsNGxBUnZPWFdaaVlzcHZpSzNuaUFFVlVxeGkwTmN0L0c0NUtLeCs0RTNoNjZpRkRYMW1kdFJYUlpFZ28yOERMeVZhd1ZWUnFtOS9VdVBCekt1RmtLdm4xQ2ppQVR6TkcyQ2lDSFUvR2xvZ2dlYmhBRTRZSUtxaDk4UWpxSjFxVStmRTdGZGtyS1hIdUl1cnQ0ZW9jWHpOWTZBcmhqcW51Wkltc1RrWUZTMWwweEN6YnVGRE9TTm1DVk9Nd01zYnl1b2xhVy9Vc1BTR1dZa0IyNVlvVmg0dVU5SmptRERBaEx4VGp3UUhBd0lLYm1ET1dJM0dvMld0UzRTcFVDb3JKVjVoaGxlQ09kRUxsdFZLbFNvbVpjd2hYTVNwV0l4SWpMT0pSeEJXNGk0ait5QnlTOGhpS3BtTFVkUlp3L0IxSEJHckx5WERBbXlDSzJsR1RpR2R3SXJNVENEbmN3R1plTVpoOEVkeGNSYTl6Y1dpT05iaWh1TkNQUWdsd2FlNHI1bG5VdXRaWlpiWVVVaEVMcEZlSUFGdWVpTnZCQVZvZ1VWOFhOUy93Q2wxODM4a3U1ZVA2RlcwY3dkV2FtVURtWGJocGhzRzV5SUNOcG5Vd1NqY0RpQkNHQTFVY29NeXNhZ2lOUWR5M1VwTWt5QkxJcGdROHpqRDh4eFpiN25CL2FKY24xTklhOFRIR3BidVc3aFp5NWlEVGN3ZVlaVThrRzNHNWh5UVMyOFMrQXhjTURWemNxWGJuR3gzRTE2anJNTGoyUzhtcFJ6Q3Z1VlhibW83cHRnZ3dtaGNCaXZnQ3hkSkEwWHFKWjFNVE9KMk5RU2pYVFV6ZCtpSVpXcTRpTUoxQmVTZy9jcnFPNW9zdlVGWnFDT1dsTVJhTHN2QkZlekFWVkw3WndMbVRNZEtGYk91SXphWmNrUEdZQWxsbDRDV0FIaGRPVDZnWEVoVk4zY0M2Z0U2ZHlxNkZ3QkFYa2c4TGI1Z0NxdytZZ2hjSlFvZnVWRGhYY051S0haVGJNVFpiMnVZSURLcngzQUNVU3QzM0RPTVl0UmFJSXdsNlVFQ0VPMjhSVUlxOXo3SnpyaURkMnVTYnRPcFZ6dDZaUWNkeE5ONWxLYXJIYzRybElWdElqY3U1VjNORVZNNGFnN05ScDJnc3NIbGhkVjloaVpvdTUvekdISjd1aUlNaDBNRTA0UG1YTVFLOFNzYXpMZ1F4RkJLWlVDQm40cVZLektpUkpYeFZRTVFKVUpYVXFWTWN4cXF6Y3FWRWlTb0hoRTM0akZoOEY4QWFLZTRpQlVjNW1aMm1UTmJpMndRaGtpbW8wYkdwckZtWGczQWhtWWFvUzdvWVJ5ZkZ4WmNYTTh5NHVZc1g3bDl5NjN1TFcyZTR4OVlsM29ydUtPRFJBUU5NUkE3dGdyeEJXL2k1aXYvZ1MvaytCbC9KQWpoNnhCQzgrSXFwS3FEOE1HNHRNU015ekZaTFNwMlFaZ3g4S2hnb2dZaVBCQlIxVDdqaEUzMTl6QkhMNFZQRDROaXRqRGMzNmpxbHZ3TThSNGl5dFE1eWcxVFo3aTZYREcydFMvek1DcllHb0xoM0Z4VnpGN2hhREJ5NmdYNGdqQXNBNWw2akxXWTMwU3pEbTB1T2t4VjRJUGdjazRWTTBjdzhKVlV0UldVdzRpclNLcUpuRUEybzUzSmw3Z0pYbGhMM2VQRUFHdCtKa2pCVkhMZHdZRDhJdCtveUR3anZNb1pOeGFsdHlvUzVlWnViU2xONTZsMXF4aTN1WnpOQXl2RUFaS1l2aFV0QVZ4bUFLU3VkRFZ3REFTc0dZN1c0Zk1zSW9waUVVS3V1WUp6VEZEQUhwM0FxYW0xV0cwVXZtcGhsby96UDhBbWJJMXlvZ0kyRUdzYllsOTRFUnlBZXJ1R0FDakYrWTF5NUc2ZHdhMlhHUU5WbjFBWG4zNGpqc2didHBsSStZcmIvTVJYcU1sUldKZFpsa1J0aGVZQXRhbC9JdkVjVmFkRTNiZnZNRjFMTkdnaWEydm9ORTZRR0NJS1hxQytnZ0E3ZTJCbkZaZ3lFZ2g5UVhtVnpLcVZ6S2xjd0lrQ1ZpQnhDNlVLUk15b2txVjgxS25FU0FYSFVxTWZoYnVpSXhNU3FndUNuNFJmczB4RUdTR1l1b3lvcEJtSXVOd1c3WXBjQVl3TTVuUzRsNWx4T3B4QTVoUjNEN3hpOFIxbUVEY3VQd3R0T291cHpQS1F6Y3d4NlppZWRTZ2poMFNsNTFBNGxsN2xCcVhTZzNGaTUvcWE0L3BhQTN2NFA2R0NTTjVoVzlRWjFGWHVMUHVYdU4zVVMrcFlGRzRiQmp3QjhCU0E4UUJITFVxSkV2VUh6aWJMelVycFVQckJlNFV1OHhGanpCS0dLbE9JZzQzTVA4QUVTVWQxUENvbml2WHhiZkNKUjMyRk1hYWJwM0xvbDVNTUtTeXdXNElsdDFPUkp0dlVXdVlqQkxtV2IxekhiRENzeXhidTdnYkpSZ2JZMUpWaHoxOEh3T2N5Z3g2aXFEaUtrN09ZNkhFdExxRzlXdXFtcVhYTVpSZ3dZRzZqYW1JSzEraWRLenZxQ3ZZWmtkRlFqV1dCRlZUcGNvZmxSb08xakNhT283aHl5bGVaZjRtUWdyQ3didjREVFRsaUFxMTVqcTRnQWlDM2NxbE5vNllrVExXcmxqSXA5U2dSeCtJM0lXKzcxS0hMK1lpbWE4a1JkMmZ6SE12cUVxY3BaNFprZ3lZVHNpeXZNWi9VWEFvNmpHaFpyWTlSdDdYQnFGQlFJOGpxQWJwYzd1TThsZDFEVVQ4U2k4bXlvWUpkT290dDVxQmU3N21PdUkzUE9pVU9vTllZVnhkTVdDbk1FckxxWHRWN040SUxNeTRJa1ZWNWlMV1ZMUTFLdEJhM2J6RHZtQWNFd05FQ2xxaktsUTZscWxRSUVyTVNWQWxWS2x1NEt3d1d6VEhNWUNLdW9NL0ZmMHNmaCtHUHhjV09ZS2dnZ2wwekNaUDRneEJCb3hGZTVVdVpaekhCRlp2UkVCcGlNTk80Tkxabm0rb2J6Qjd6RWNYUGFYZk11RFV2dUwxSEFYbUx5UnU3ZFJjN3hGelpMdHdRUXVMRlR3UlNyck1veXk5L3RITGNNdzh5KzJFNEdLUC93QkxmNkxsemY2bFJQRXV1S3JQTUEySU1Gd3VMSXFNUll0bVRpWUVRandmQlFZaGNzYnRmbExXZFdXZTk0Z1c2b2lzVlBIUDhSeWxEZk11VndOUkJSVFVvbFl5ZWFnSWxCeW4zTVBtSmk5UW9pTHVpTVZVU1AwbFlNdmNFVlBWc2liazRESkJZUWVVSngweTczTExnREdrZDR3MndSN0ZTMTh6Y0lmRVppeVIxREppRFZYTlUwRjlRb3J1RUdRaG1WUmNJR0x4ZnFGTnl1SUxiQjNPRVJTUHFMcVZDUmJVZkExRzg0Y0k0ak1TYWIzTnNhK0x4VXhuNHQrY1NxZS9pNFZxb0NyNWxheUNZTFpjQVhSVUswd0N5YWhjM2J5YnNpR3dzclVRQlRUQ3N0UE1Ob3ZFTytqRXN0aXZqaWJGcm1YdXp1SzJ0T1lncGdhMWVJZVF5OG5QMGNUbXlGcW9sVzdHQUFCUi9pQjBuV1NYcHlSVWJHL0hVUmQyUkM5aFRxT2xXcDBOUlZ5NGwwc2NNQ3JQZmNaSHNZTWFpd1ZRRHZtQ2hSQm9PZmNBWm84RXZqWktkaXZYK1lrblhVQmlRT1lCeDhWQWhDVXltNEVDSHlDbCtBdGxKZUtyR0RiRmJNUnl6SjdZeW95b0VkTXZIeXpmd2x4UGhqTlJNUklNd2ZBVitvS1owL0FZcGVJdFM3NWc1anhNdkV0dlVXTzd1Vitybk1NQjIxQzd1Rm9EbUNkeGIwUmI4Ung1aXBNUGN0ZDRoNml5M3VpS0c0dWJaZnpGbHUyTGV0UWt0Z1g0aUJheTFRMFFzNWl1djZBdm41U3Zpb0ZPWTVaVkV2TXYrZ3l3MXVLN2xrZG94MGpNZ1lPRlFiSmlLanBZdDFMaVdSWWxKak1KM1I0bDhscis4eTZRWjVmY0V0MFJlTSs0NTAxQmU1Wnk3OFJGcWtyWnJ6QkIzTWh5KzRONGN4ejRsMzVPZmdSNGhSbGdZT1ladTVWamo2aVo2WTA0U0lHOVJFVEVhUUFpWWRuY3NQNE14QTRUdURCRENzdXdmTXhqYk56U2UwS1ppc3Y0RUladm1LcWpSSlJCRStCRndObGsxZUlack9XT0R6TVQ4THpLOEFMbG5uZmNWNmdUTTh6dWR3eTUxaVU4NTJseWFsdGVmZ2ZGZWZnaWdGS3VIbU9nYzVBK0kwMVg1Z21mdUtiRlBmY3BWQUppNGd4RUg5UUN5MGlCbFlJdHR5b0FvaUt3eWVjUldyd2RTNEFWekVJczRsY2hBdlV3MXRtTndzdkZTNVZoUThWS0xyUXlUTFRyVlJvMk5ubVdMZUYxZTRoTEhNY3BzM2pQVVpLdDJjeDUzRWpOS2pTcmhYY1ZtK1lvS0UvUVMzSXQ4OGVwZ2JwNkliMStZbTZQdnFHSG52dUJmRUNCQWdmQ1huQkVHNllock1kd21VTVFsR0JNL0tDbXNrWS9IRWZpOHh5ZkZ6OXdMcXBUZFJSc2xsdVlqakMzRU5sWHFETlZFTmtSSUVja0JkUVFWRWwyV0dXQ1hjcWxvZ0dtejM4eGh5OVFWN0lOUzRvdlV6VVdPNHU0dEVXWDhXTVlncUhKTlY0dWVlV2FhaHhjeTJ2RUZXSUxXU1lHWXRuTW9HSXBNeHZyRXgzQTN6T0dBYzNQSkZ1ak1UbGNRZVlkdFNvV3duQnVLSzQ0VENiUytQNk02bW9Dd0J6QlhQemN2NVZSVXVYaU9TS3FpTmlHeHVObDFMTTJaZ3RBTGVpT0JKcGpVQjN6cVg5b0dlTkVETXNIcVdMMkllUDh6L3N4VDh5eno5U252RU14YldmemNHdit1SzNkRXZOajlTM3FwZjVpbnNsbFFiY01iNGwzNGwrS0poTElrckxjVE1FU0pNc2J3OGtlKzRPUGN1dmhTVy9Gc0M0K1BoaDhTRTNtdHpFU3dHWFlnd2d6bVJGWitPdDgxd1Iya0hOSW1Mb25OckxYNGdyZnY4QUsyalQwaE5vYWlwUG1RK0NCZ1ZmRW8wM2s2amFBRlZxTUE2SlJZTDZ4Q29hYmR3c2cwNnlSQzladk1vUjNESFA0aEMyMGgrWTY1cXZPcFZGR2l0MUV1aFdNYWJYY0ZGRzNjYlBaYjl4MUNJcnh4RldSei9NT29nZzh4aVVHbW5jRk1JaEs4bEozRVRiaVc4M0hTbVp3V0wxKzRrbDJURVNnQlZjQks3aDN2VUlBWnJMQXdDKzVpNDBLMmVlbzRiV0dZSzFBN2dNSUh4Y01jNmx2RExwVnhZaW8vTXd1cGNOZjBiUUphajExSytpWWxnZVdZMS9KTEZvdm9XYXBSMUl6azM0cVhRS3p1S2VEeEtyRmJwQnRJZTRNdExQcEcrdzZySVF4QUI2UkJ2YXVpWUlRNXFMM2g4dkVUcFdYcGdyV2wzdEk2aTU1R0pCVytyV1ZiQStKcldUZTJDbWc5MUFzV3dESzMzQUhEY0JyOWM4UjlRTmlUUURMQml0ckRwaU1DS3BkUWNabTVkUk54Y1M0c3ZQd0NYU2duTDJkUWFyQmd1RzVlNFpXVlREUEZqanVObUo3amJtaUNEbk1BTng4cGxyTUJkekE4Q0tPWVVZM0tzRzQ1UzhSUlJaamhDRnMyNGxNQ204d0VzbFc0SlN0TVFDSk14ZTQvSk82WUVHWExpdG0weEJFbVlOeEZWRzArMmFXTDdsSTVXbkJBMHJxQUthWS9VVFp4L0tIVnVQTGQvbVgyVVJlRFBpNEE3cTVWczUvaWFVMCtwZCtDWnVGR3NSUk00bDRLMUw2eEJXd1FJVWEvTXFuQjhQM0Q0SlcrSWE0ekJSM0hWakNqbGxDU3NaZ3pBQ0M3N2lvZWJveGV3T0UrQXNLeERSY2JmTmZDaEQ0TlVQbm1PdFJXWW5aSGNHbUtjUUJvek9zekxiVFQ3Z2VWU3d5ckxaNGhEb2FJb0dZL0IxQm1ONDRtM3dmTngvRVFkWDRnVlZkOEJHS29LYUdWQmk3TXdHZy9jb2xWbURhMFdQRW9LbE9YRzRLdGd2cVlFVnVMcHFPa2NTM09XWEE4VExiSGd1eEticURGNDlrVVVQMUFWS0VBMXc4VnpDaFpneFJFRkRKejU4eFNyVUJjWU9wZStZZUlWT0tJQUZHWGJFSXV2MGN2M0FORlA4QW1JYlZqVllsaGZqdm1EQkNQbUJBZ1podUJERVg0WEVHWERNQXR5eStZd1FwcHEvY0VXb0J5dFFCc09odGlXa09HcUdLVTBPMVg5U29SSzZBSy9NV3RRMmkxK0NMMlN0VVgvTXlMUzlzYU5qekVSL0F3WEtudTJZOFg3aXFBRG5VUUZZOGhNc3NCL3pjVzg2NmxuaXZ1TFhVcnhtVW1BRXVkS3VyakF0THJxQUhUNWhVd1E1U3E2bUpGVEJpVXExdVdKZDRnT2pERmpCK0lmWlBOekE1WTVpNHZHQ3EvUVprYVRKTHhCekx4OEZjVVhNdTVuNXYraFRKSnpOem9TcnBnK21wNVlCcGwrcm5DaTR4c1MxaEhjY0tNUjZITXRsVXdneXpDcGN2RXUxVHVLS2J4Uy9qUmpVb1pUY1MzRTF1TGJBcU83am0yTGUyS1g4QXp2Z1ErQmRTcGdrR0pZWmlnc2JKZ09ZUnFWS1A3ZVloWjc0aHpaNUlPdUxsWHR4TUJSamlGLzdsMjVoKzB5dXFPNTBEY2FiTW5tT01CTCtwbk53ekhQT0ozZGNmQU9mREF2RDdsZDB3SzlkUy9FREdDczh2bVdHbW9sdGk3Z3c0d1lsVURtY1dPM2k0a1M5eXU4a0JJMHNwTUNPU3Fvc2luZjhBVHhPWVJSUVpWTVc1anhPT0tOOEJna1pZajNkeW1EeExHNG1ZYmZFcUhNWWZHc1Z6YnVLSHVVYmk0aE43aVpodTV4TnZnK0NVNXhDa3p4b2xFSTZsVGdLUkc1Y0ZFVko1SXdWVkpzbGprcTllSXdVT1RIVXhBNmM3Z0dYT1pkV2U1ejFqaE9Zdmk0dnlDV0N1VWlPelB1V1FkRnBUTlFBbFMwR3RrTUVmOXk3S0ZCRTdtVGRZNkpzL2lYYlJsOHhCaFlhUi9jUTBtSUlQVEdyVHhMb0ZGQ2ptWGtaT0s0T29seFFlWUE3eXp3Ukkza09HV3JmMUJ1RVBnRlIxRTNWZDVsRjN6VlZ4THpGdjNEckJTZVpBUlAyYWhLTkRHREZ3NXU4VzBSdlQ2Ti96RUZMNmFINmp4cXVXMS9MTjhBSzBGRVJyR0o2ekczSFZTdE5RMnNsTDFIUitLZXNUT0llU0dGcG5vZ1ZBWTdpQXdaNGdWck1xSXg3QkE0alk4a0ErNDB6VUFZbE1BV1ZVU2VVUWFubDhxSlp4QTNSYkFSS0pZS1I3R0xCcUV1aVhITndMWlVxVi9RRVRBSVZaaFhjUkNpTXVKaHZFcVl6OE50UlRvaTkxQndmcUNNWmlEcWFpZzN0ZzFGRkZpS0QzS2F2aVdWQnZFQkd5S3EzT1plY3hiaXJBekNMOEMyVWJoQWdaZ1FsU2ttUm1EbUtzeFJBbzVZQTBZOFFMWG53d3diLzFCckx2dVo1ZnJFR3lIMTZqa0wrSUxlZnhNYjRSYTVxL2c4Y1RqRWZQeHY3Z2VJTlhmNW5BekF4V3BzOWRTelpxYmFxamNMYmVOVEJxTmRIMUI4VHpXNGc4YjU0bXZCcXBqVm11STBXbE1EVGdjK3BjS2x6VVNvaHFKVVNKdHJUV1NjMlBRNS8rTGlpaXFhSml1WlptdVpJTnR4Nk12TUtjTU1vVXZLNHE4enpwekw5M0d2U0ZtUzVmMGpaK1ZaaWwxV2ErSXg4SHdWekZXdkdJVXdHNm1FSTJjU3dMaHBlUWpDYnBlRjVJcWJXWkM0dGc1VGlFMEdqSGliT2dodWl0bHhoNWpGbHk0TXRDNnY4QWNKdGFEaE9uL0VCQ04wdGtOcnV2VVRlWmNVdTR4WWF5MWNRWFY1MUZ4akhYTWREYzZhWVo1V0d5N0sxQXZHcGZnNWpHNndMWG4xSzVkNnJxQmNDMmlCQlpRRmN5eVVMQ2p6RmwzTDJqVzJCZ3gyZ1piOUV0aGxZeTBFZFRIVzM1WUJ5Vzd5WjZWS1BOUUpUaUJyVVIrWlRyRUQ4a3E5Ym43U21wdFRFcldvOG9ERXd5TUErSVBFS3ZtZHBoS3VmVVNKakg1bFNPYzd1TU5OUkpWVGNQTVkxWHhWZkNSSzFFaUVORENvRGZ3UTdpNWl4MndJSUhpVktpU3JpSmJnbEdpNGc2aWJXQnlXd05hbGdJU2h5UWExV09wNEpRNGdDM3VYM0xTcWlhenVXSEdTVnkyd0x4aGllQlNGbXlLTCtrRy9PSUxNUWFZMEphc1FFY3BkaU5YRjhDMkx3U29FRUdJRXFCS3VDbURtQ2d2dUF3TlNySjNuWmdnT2ZjdStFUGJQc2l0OXk2Y1RXOHoyUVllUGdaK1pjNWNRTVpsTENPSnkvZ0tmM2d6Nk13MFB4QU1ZWm0raVg0TVc5TTNweitMZzdjMDlNV3pxK1pUV01jVnhCS29FWVlja0dmaHhFbTRMSVZmOWlhdmEwL0hFUGgrZG9NR0RGWHdKZnc0cWY2TEZOTXU5d2hCVVhpQmVKZ01EUFRLT3ZoMU9ZeHpjQkRrbGtlWXRzWHdabXBUbTRZYzhSRjBxRUdqUnd4NHZZNEhUQUtMeW1mRVFjbzlNdVNpZHZjMWFGWUFITXBvcStKZ3NySk9ZeGpHWGFqajA3anBQSkFWUXlDU3hjVTMrWTJ5NXpxOWsxTnI2ZUpjNHVYVExMUjFNZVRmM0duWEVXeW9PWlVoYWJiNWxpaDNsWTVjRW9aZGtaRjhxNi9nbVc1eVZpQjgyQWJlWWxqOUFkVnpIcSsxbDRaRFJvaDBLZEVEZHNEMUFyaU5Od0sxcUdYVUR1WVpWTU5YQm5NVGtpSkN2OEEyT0dINWlLUVloM0hHZVlFTStvem5NNStDb3RZZ3hjWDhERmx4ZHkvbGJqRUdrbDNOV2ZSUjNVRE12RXVPR1lJSUVxVmNSYTFLd1lWTHFIMUM3UVJrMUZxN0NOYWdnbG1hbHhhM0Rra3FyaXBSazVnY2xRR3FDV2w4a0htWEc3eEtGMmZjdGNTd3hVdGt5UVUzQ0JpaXk1UkZiY1dYRlJibDFIQ01aWlZ1SDFBQzVoeENTS2dRN1Fpb1ZnR1dIQU11M2xpVlBPYmZxY2x6dXlMVVZNOXcxREU4MUNyM0MvVXY3bW5FdnFiT3Znbjk0QzE2bVVlSU9MeTRZTWNUc2dsVWN4cG5rekdIR1pYUTFyeE1HVlRGWXdSK3Bua3NpZzFxRnl3eHFMbGRNZSs0OU1RTG5KRXFKS3FPQzl3REc0Mk01QWUwWWYwM0hjSVJSWmlxVnVZcmxaRm1LREJ6bUh3T1dzb0RaeEx1SkxGUm1YRm00eFkrWmpHb3VtYzQrTGdLMFB3UW9BaGZiaUtuMXpGWVZzUHpDaGMyU3dGSXZVQXUxSHNtN3Y2MU5iK0YrUmlRcDRITTdVQXJScnZ6QWtHMnprbjcwY2FNQ0FPNGhCTFNadDFNTXFSb2U0bFY0ZmhIc05jalpHc2ZDNXptTE1hVmVxUDVpcFpydUVGMzBVMk1FRndRS3hRR0t5KzMvVUFBMEVPU0JydDNmemRYZkU2TTkwUXVwSFRHSmJVWHE5eitFQWVXRDFDK0luSWdGNGR4UEVwUzVXcmR3S25rTGhyT0p0dTJWOE1Tak14WHd0Y3gxNWlwZVkybDhTd0tJZkFjM2llWXZVdWlLL1V1WG1YTGw4eGZoVll4U1hqY3VYRVUzSEhOVE0wbExITXdmd1VXaUs0SUlKVXNoZFN4S0owRTgyRkRCOVI3dEpRWG1Va1J4Y0N5b1hobVI0dW8wdURHWTVaMUtDcWdOWXpCWDRnTVJ4dzJSRm9pMVRDK29ia1V4RUNEQmwvRnh3K0xpNG8rR01hRFBqVGlDeXA0WWVFZmdJSXFCRUFjdWp4QlNWQmZiRURwY0RFR21NQW5zelBaK2ZsRFkzRFUzdjFQY3ZQblZ5K3ZqWG1hbmp1RGRZbTlsVnFEanVHNkh5UGNLWk9WeDZpVUU5UkdSYnhxRGljck12UVVWeE9pVUtXWERGNnJpY3hWeE9PN3hjRFpPRFhtYmVCTkFLdjlNRjNrU0pmR2ZQeHpUejhtV0VPUDA5TVZCU2YwWDh1REZDRE95ZEVjWlZVMFNqYTZqeEIrSXhVNHd4MklDSzJMaURNb2xud0k1VkxCcTB6RFNJTVhlZmhiK3ZnWU9NdzhhbEFjVmRYNWxybTl4Yk9aU3BtcWNtNWFOVmZCOHJHWFcrWmt0bHE4Vng5eTNRSHE3Szh4NWE3M05NZGExWE1FdFFjWnVKZHJmVVJmNkZKZVlMcmhnV29SNlpUakZiNXRnV3hnaE50KzRxNGpEY3daWlNDOC9TOVRMTERGZWZqRld0UmhMRmlzNjl3SkpLYkFZKys0MkFnRks0ek03eTI4d2F3eXk2Z0VRQ3pjSEhtYjNtcFRtVVBjUXhLWE9KeUJGaTM4TGlXUzdqRlJCdmZFV0xGNmpycVg4RExseTVmYnVLUmN5NVNYRzBXWEYrU0dLWW1OU2d1b080TDFNdkVYTnJ1TFV1S0VFRUNvaTZsdEFRUnBscGpGUnl4TWdKY0FhQzY1Z1hVUXJ4SDlvNFpnbDcrS1p5a2ZjcTVhUTJOd3J1WHNlcnFVR0JpSnFIZW8xOHlyeFVTbkZrRU9KbGhpSHlzR0VVbGxSWnR4TzZCQkRBdjRHTUpVWVBncVZ0NUNEanhOSUZHTnM4b1pQaDFpcGY1am1QZlVHNVRVcWFobGdWSGMzekZxWExLUzdlcW1iaklXcFZiOVNrRWhpeU5jclpSZDhrZldGZ0JGekVSWFI0OHlqTjVtbWpGNWxNL3A5eWhMSVlsRjB2SkVCMnVFL3ZBcU84a3lPWW44eitYdzRobjZsdW9ESWRYbVBRWitINWZoYStSRkZVVmtyK0pTV1JYVnNFU0tYOHIra3Z1TDFLdHhhMU54bGd6TXAxTGxOTTE4R3NiL29HWVh0NllGWnZFRk8yb2k2R2lKdHpIZndzWXl5bTQyZjFFcmI4REkzVVRXNmpvRmlWeHVKZHF3eHN2NFl4WXpzaWJMYis0R2ZpTGFpeFg2SVJwbGtYbkFQSExBVmMzbG04RkYwQWIxK1pSYk9yNHVGWlF2QlFIMUQ0QU8weXAwUlJHRjI5Uys3Zm93RVc5RlFWZ2xtZnFETDZsTmt3YmhxRE1zVE9Jc0wzeEx6RnpMaXhZTExpdkVFSXVKY3VEM0xseitJVG40cURaeWxhdFpreEZvUy9jVUxlRTRqSllpWnBqNlZ4ekJxQnU1ZXdKVWJYWEVMYWw0MUJYRXhVMmlCNUN5TG1MUk53WmdnakxVQURHZXBVMEZNdUZseExOVVN5c1ltYkVXK3BmRVZmNmdCRzBFWXFPSTkzY3J4bUpqRzVvbTl5MklFYkdTT1Y4eXN4UEV3bTE2amVVamtwaGpKSEViT3BjdVhGbC9DNExnUGlJWVlJRXFWS2xRSlVyT0o3ZERsQXgxOEV2VUtycUdQbCtGNzM4Y3ozR0VmZ25oT0R0aHltM1p1WW11Wm4xWTRFeGJ4RHhMNWdDbHkyaWFjUzc1RWwzWld2M0F6ZkxGUW85eXVOazBZK2tGTzJaclVacnNZSUpzZ29iaHFsdk1yUWVYd3l2aUppR0l0a09mVTRNdlUvbitsakhUOGhnd2NTcVpJeHd4VUU2NVoxcUtIaUQ1ekxseTVYeGNIdjRIbVZtWkVGVTJabFZINUdYTGd3YzdocTc1MUVVdHVZdHZYcUwrb2p0eGNYaUxYbTR2OVBFd3k5UmVjUzdpZkN4akJEWmlvN2cxc3VHYjVZRXgzREM5WU1aZ3plb1ZSN1p5OHlxSzYzRVZRUDNFQWlyQWFmZm1BVUFIaUFpSC9VVlppV0xFQXhNeTdjZzZnWXhQcWVvWmJhOVRFc2wxODNGbHhjeTVmeGY3ek04SHpXY1JKV29yb3RaWVFUTU1LTnhSa3FJVFNDeWpKcTRBdEJmaVhKRlNrM01hbEprZ2x0YllnbU54STB3bXlKdE95RnBNMUxhZU5SVzRtekFBaHNsVmZjVEV3WEFGZkpSOEs0UVEzVXVURUFDdHlxcTNBQnBWNWlYYVVSTVZCUkJUaTVqekhVcFpGRjJRTmdQdUFiUDVqVEg1b0RZZmNwNGZtTHBYNUlJdzMzRU9QZ3dCV1NDNWd1U1pFTzhPbjRLNGlQRk55OGJNUzVjdVg4a0l2NnNud0VURUNCR0hhOFJGNGxVSWFnWW12dU9HLzY5Um5yNVBNcWRRS0RVTk1HcjVqZy94R202bmQ1OHlqcU9zeEtCd3dNWG9xWHR1czRnMkV4S0hHVFZST1hyVXZ2RUs0L1VXdEZ4Y2xjUDZqRE5XOFRETDNYVXl5YjRUQ2ptb3h3NDU4UWlOcU56OHZnNVMva2JCWWxQcUk2WTQ5ZjFHUGdHRUdERkZncVVSN25XeGZnN0pSNXpMNGd3YjM4a3U0cmZjRFVwclB3bTdtSk9qNFA2Ymd4ZW5pQ1p1RHhMbHhZeS9oaXk0c2ZVR3ptVWNCRWNzWS9ESDRLekJiNGxpQkVWUnNrVUtrNGVvRmJZTnJ5d1JVZ0J0NTlFRTJnelR6L2lCUUZkMXFjWWllV0RuRVJnTEt4WkxlNWJmbURGZ3d6TlJaZmNkeWxnRmlCa1JsUFVDK1lJV1JKY3M4UVYxMUU0bGswMUwwTllnRVpMd1Nwd1RoWkRCUm1vQmR0WDNDdzBNQkVTYlJyaUpWTVFncGIyZFFiSzFMZ2lQcUlSUXVBT05SMHQ1RWlaczFEREZuTVJUeEdGamg0bEd3YjNEVjFGbW42aUI2bDdpeGxFVWlnTjY3bDQ1eEM0c2k4UUlKbUNJcFJMSlZNR0RGeW9KVHVWb1lEYk1YVjlaZzFuNDRMbHJudk4xQ3dWUEdqOVJIZVgzR3VwUWxLWGh1RktQY2JhU0xXUXVXNXF2RVFUREdpTk5heEJHRmZSbWwva2lRSzltUHlRRFgzT3lPOC9YTWNId0Z4b05ScHd3OE14VjVsWFNwY3Yra2gvUTFtT0tFTnpSRm5QeEZxT1lCRlZBbm5xR1NYdUxCSEx2NDRoS3o4YjVnNXhHbHBnUmJGSTNlUG55VkQzR2VUVS93QUVidjFLMHc2T0hxWFo2SWJ1RUhEc2pKanVKcUhJdnFKM0tnQXJmT1pZR2FDWGttVGlYeWRHV1dWR25tSEpVVEVORU42YnhGbHExTVVERllqNGlJL0JoNWptNXJLcVB6QVJVelNLcXU0cDhLcUZqaU9FSVFZTlMwektJZ1JHYTRad0pneFJhMUJqbDhEUHdIbUxMZzNFakpGcnA2aURnZ3k0VjdsL0JMbDNMdHpMK0ZYY1grbCtLNXlpbm1XOXhaY1lzNWl6RlRjTjhaaHBidVh1NXRtQnBTbE5jUDhBaUVzVkY1TDNFcUlVc0RPSWNGaEF4S2xDNVpTQ0d5Q0d5QUxTMDdTSTNpVlRtQmtBNEF0WWc0UHpEdEFYbHFCYzB1RkxxenNsRzVoeEN1aE1CdHFGb2hmcUN6ZzhRaEZCeGFZaUExWStZd2dZWDhTb05pMmNScDQzQU9OT0lwUUxoYnVxeEJFSnZVT3hOWG1vQldPeU5GSFVGY1g0bGlCK0lDaDVpRVhNeGFZcXJJbEc3M0dBbVJnZFJGRlNzeXl4NWptUXhCbUxndG1Fcktja1lpUVpHMklvdlVvdWVJQlhucUp0UktZQmxMaVduSFJMa0cySnZmRDhCR1hFZkVvREVObzhIRWRkVU1RS1laaFBITDlSYWxUMlA0Z0p0cTh2OW9qbytpQzBpc0xLcXZjR21YOFJxWG1paUZXRDh3TFpxYW45d1lBMDYvNDFNNnN2bVdTM1EzTFFiL2lLaVdYTEhaaURWL0NEOWx5MHRYT2JzNmN3dEMzUFVwa0o3bGNyekJiQTZxQm1EVWY2aUtMTVVjY1pGQ0h5cEJsMW1qQk5zT0lGK29RMUNITXpmQVMrcy9DU2o0MHdqVjhpVWVveE1Ndmc4U2taNWhrc3hVdTV2azh5c3N6S2krY1M0c3ZrWlg2aUhPU094THZXblAzTDZZbDVzejZsbXJvT1NYMjF4TXhmNGptbWd6Y3VMS3R5M0xpWGwxR0s2UkxPTThRMEsxRE1scm5EOFhGeDhEYmpadXhIUU9LYlcyS21maWlJUWFpZ3dnd1lzeFJlWXFsZ1JuTXY1Z3NSMlF2Z201WlVZV0dyWXQ2aGplWmRheEV6VURGdTVnUEg5a3NRWVB5bFdZU0tyMnNHMzR1TExpMHk1Y0h1WEZ2NEgraXdHeTdseGl4WmZVeVpSdVVsUzdjd1l5cThPSDFMQnNVLzhZNUplOWtCQ2hIcUs4Y3d5cGFDQ05qWTh5ZzV1QkF2RVNzTUdGdWswVnVXOXdJRUM0RUJkUmxyRXMzUWVvd1d2SVJRcWlXTUdvdVBVY1MybmR4YkxzOFFNVVloQmR0ZFhxWFpIekcwQjU1aVl6MUNWa0loYmhtTmVIbkVyVjRndkszWmNzaFZZYVlxRWhqSkNKUUVaY3FyWmp4R3EyUWlKRlMyUVpqRWVhL0tCZGplWWlFZUxxSnFuaU5xTnpzbGhzYytabzNSRm13UWp0NWNUUzNXc1JHK2ZXWTRnZHpLcUJCYlJGYXhpWlE0aExvaFVkekJNODgrdTR1bW5WOHNlN05kNXRsMEFlSlNLcjlvQVlBK29JYU14YTJRUjJWRFpwVjZpeldTQlp1RmVEUE1EdWo4UXVxbll3QnRQdVA5WUZZc21BM01GaG1MV2hqb3ZNeWdYWFRHeVgrNWswTUMvTVlwY2FIZjlaQnFLS1BNZnhLSGxFZHozajVmQ3huS3RTb0JnaE5wbzZuVVdFMFFnVnFHZFJPb2FKcjRxRXFvY3h1bHFuM01RWm5yZncyWWc1MFZLc1dwcUl0eVdZcUF3YlFzVjV4Nm1YdVFheis1ZXZQOXhXYnJ3eFo0ZnhDNkdVSldVVzNpSnBVdm1EUnc3akNqcmJ6QUhBcTJwU1pHL3JjcTQ2d1pqeWZITXBxSmZxV0tGNS9xSksrZWZrYWloQmd3WU03ZmtGcXRSaHVZNUdIRkM2aW5FdWpNSG01Y0c4UzYxTGkrWXRzVzlSY1psMW43SXhjdURqNXVYTGx4WmNXTDhMOEVINHNGUllzWS9KTEc0b0VTdDhmRzAzekVwclRMeU9vWmkydUhwT0pZRzJ6ZkRDQ09leGdsdzJRQnprZzVneXlGM01UbktVVE1BMW5jQVlzK29iYUlBcW4weW9ib0tqbFUxTEtVUUxieEJIWE1RU3FsZ1dYVENrQTh3UmlvcVZabmtoRkdXQWZVU2ppQkZHQVNSRWhqK0pYdG80V0FhTEhaQWtSSGhqdEJzZUdBbWtnRTNCSERyekVDbU9wVUc2NGlRZ1IvVExCRWMzU2RkRXoxWWNGUkZOMmVvV1doZWk2bDlLRjBtb1pRV25lSmtJMEhlWlpVNjZOd1hWcjdXTG9xb2JHWllVVUh3NVpadlJMaDdnaUxiS0NraUpkVm1VUGJFSVJscTREdGVQVVlORTZZK2pxRVVMUExGQXB4bW9RM2kvRU80RjloaUl0bVBMQWU3Z3YxNGk2TVhEaUxJT3J5SG1XMVIrNElwYzlrVjFNUE0xN2xWbUs5UllnS1hTTVNoc2padWNrSDRsRzVabHVYWklLTURwNm5SSEQvQU9LcGkxOERsVUE1aDV6Mmg4VE55dlgzRHY3aGhJSE1PT1ptdW9jOFFoRDQ0Qmk0eGtQaEx4Q2lFdDhUSnhVZnhHdUQ3Z2YrL0FkVExKQnBqOWlCZVNxbFUxenpHM1ptWkd5a21RTFRFUWF6VWJqSEg4UmVFSlliU25GMG1tV2RKRFFjeTZNc2Y0eEt1Qm4xNGlSM2R4cXJBNmdBcGN1ZmNNTThaakwwUVYrMEIrMGR4K0ZqbUFSdk9KYmdVc256WDlDOVFzaWd3Z3dZcW1ERVRHcWxua2dWVEFWaVdZbHB6QlVsc3VYTEl2QkdYd2lveEJ2Y0dIa2wxajdJTFM1ZGZJTXVYTGx4WXZ3dndTNFB3L0w4ZS9nM01TS0daWHlrb04wNGE0bHhLN0R2ejl4ZDNEQ2JKbkRBN09QWnhEc2JOeHJId0VKWmwwVERoaGFnQTdmcVloWGZpV3dsTDFCQWgrSUFSWE1OTEg2bDFVc0hJd0dtcFZNRVNVanJaTEdLVlZROW0ySXV6REJCRmd5NHBzbHk4Wml4L2FXUG1JTnRSQ1U1R1ZkZk1GNkY3Z3BxTFRDU25ETkRjd0FwZTdnNjVHVlcydjFLdFo1QWxiTHpkdUlpN1hsekhiUUhObUtqRlkzRnRXbjNxSGt2dGdmSllWMGs4TVM3M0hmd3VJTFpabkxqNHVoWG5FQzh4VUF3WEd5bGNJNDlTMDRKdWpTOXZiNVpjKzRRTEZ6eEdaVWRMYktXelI3aE91WmdlNVNhZjNMYzU4eWs4R0luY2FSTTZnWksvRXlITlJacW9GeEhQNWxlZHhLb0ppWHpCL01PK3VvSGlJbXRzTzhSck13ZnFFeG4vd0EzQ3V6bUptVi9RZkpGRTVuWkdrRTZnK1paRm9GaXVJdEtxN2N2eHZQMURpZHU0NzhNYVo0bFZEREJlZFFnckxtWDBUM0RIRUtzeGNLcWhqUkRweDhHQnRjMGFBbnBBNFN1ZjJqcUo1TG44Uk1rYUdrSmxkenVNeWJJS0x5SG1hNWNlb0w2ZVNWTTRZeEtzM2ptQ05OampNTHRtblVYSVY4eEUwR0RmQzB5bDhRWkxTWmp1K0pyZlBpR1FkY3l6ZkxjVkQxRXRTOXhTb3ByN2xndkVZaGxmNmlSSVNwVUZUbVh4TCtBWmNHREZVNFpvektmZ1Zjd3dpcCtOd1lxdzF1WVkvRHFYVDVpb3FERTR3NmR4aU5qTCtCbC9OeTVjdUw4SHdmQy9MOEw4WXd0OWZIOC9BeERCcVVEYzRwMmQvVXdrUlUzM0ZEQmprWUZFQXVqQmZKNG1hWjJnWjVFV0lOODRqU3RCUDNIRUx1T2NyZHhTbHJqUjFDWVcrWmdVOFRKTHhvaXlxQ2dGZVplTG1VL01CZWlVRndrWEVjc0E1cVljWENEbHpMRzZpdER1b3FZbGVJQ05sUXFYcElObE5Nb0xQd1FLQlQ5d3pieXpHVVYxeE1tVzN1SUZ2RDh4bWlwMnY4QVlpWFljS1VTMjJ2OFZOR0F5OWk1NGxWY1ZmY1NjTDl4VFA2bHJ0dVZkU3NWQW94OEh3WDRjekJiTHNORUZzeUVDeHFNbDFSR1JzRmhlWC9VV1VTcTJkUUxMSVZ6UzFCdldnaVJXUHVQR3Q3aXJnck1IbmZpVnFnZUltWGFnc3h1TnNXbWJWS3ZWeFh6cGhDN1IvaVhMeDZqVDZsMlpqaVVGYWgxTElXaUpScUYxTVFjUVZtTDVmNmpDSksvcEM2bFlMSGlTenVPNmhWb0ZoWTJDYlpSWE1nQlJCNmdpWWdRZ0xqck1PR2NRaDhjSnM5VFY5dEJNc1BVc0dBbkNhQXdYSEFqcU1YeWxXaHJ0Y2FQQkEyVmlKdHFzek5YdWErRllGZVpkZVc0TnZYTVdsK285bDh4VlI1Z1A3SGNFYVdZTXJsbFpxNWdxMW1LY0RaekRyTGQ3alJWMDlrcFM3YTdZWkt0aHhLMFJ1WkRsRDhRbldqRU5qZ1pneHR3eE1LUVdlWHdINFdPZmNTT21FOGJJL1VzcVZqNVkvRE5mQ05rSU1HS0tCekVlb3FubHFGVmlCYzZucjRINDhzV1BtVmJaSFJ1TGNHWjVSem9abmIzRTNseTRNdVhMK1YvcElNZm00L0wxYjgxQWc0bHNHYWpzSnMvY3hEUmRwZG5SNUlTa1p1b3BjZ1dCd1FHcnVuazlUTU5RNnd4UzJwT0hFcEFZbzVLemNTcmNYd1FCQXZQY3NLY0oxRUVqbUFXMXlRRkE3NUpvUzg0bVV0WXBqT1padUFoTmtvQm1JY2FnbVRxY1ZGVzVrNGw4M0dvdW83S1NtWFRxVW9uUEV5M1dJNE01ZkVBSnFaV2NFeVdqVDBRRXRGZFhtRHBiNERFdGdBZWVZcmtiaCtEN2R4L1h1VXRGQS9NTjBYN2lxNEE5RUM4c3FzeFA2TTM0K0xxREZ6OEMyWUUyNmwyNWd6Y3VGNmxtaU9pTmQxeTllcGFObUhqeExER0JjdkxLQUJpaXBRY0VVVWNrWFpYM083N3pBRWx1Y0VLckRtS3FPNStVRDNDK1lITU9mREJsQjlYRElsWmxLQjQ0NWpUNFR1Qm10RXROdHhCcTV0N2dyTEZ0UUpjL2NzcnVicjRqRE5sS2kzb2kyWU9IeE1hdmcrSCtnSzBRQzNpTzhWRERHS0UzRUJOU3FSYVpsYWxGQ3FKVVVsczlKcHFXSmo0SHdjVGYxT0plb1JiMEdaWEVOcjFSdUc3aXRDOEVPVGN2cW5VTDVHVmZDVE8xTmNReFhaQy92M0hacDh3VDJNeU13bmVKK29MYmR4SHhESDhTZ3hxTFRJUjVGODRoQ3QxTFRWYXpFSEI1N2xSWjFEYmdrYkJ0NG1EV0VjbzlqTGY3a1F2L2pHWmZFdU8zbUxoWG5xS3d2OEFFV0ZJdVdLMk9idjVkZkQ1bmNIbnhHdzhPSW53L0RBV0owWEYyaWZGSHdEQmd6eVN5S3VaVEZNWFVXTXdmZzl5NE5zV0xEU1hCQzBEeXlwRnUycWlMVzdvWGNzb1ZEVjFReE5tb3RJZHhkSURHUXFFT1J1cnZpRWFNMUJWcTd1cWwxTUJURUg5RnkvaTVmeGZ3LzBvNmhaUDlCQm1HNEwzOFV3aUZJMGplZEVyUzdjbXo2aVZYRlJ3Q2N6M0FtNnA3TnhHeE45eXdHSzR5eDdBT1RKTXBoMXhFSEdmY1J2QVg1Z3pHcFlVNjZnSE50T1NWWGFKeEFqU2wrNFBuOFFEVG12VUF1Qi9FSGVMbEhJbjVoTkZEN2xEREtWaHpFM3dUa3FYMlAyd0FXcCtZcTRSNGFnS0lIM2NjV1c4WUpqR0h0WXUzVThSVTJzYTJzRHlZY21mTW8zVDd6SFJwOVFEc3NkM1Z4Rnl0M0QvQUVnUmxzY3QvRjFMbVlSUWFnem1BaWFpc3dXa3VRbFFVM0FHK2wyOUVhQUEvd0JTK0Q3WTBPK285MXRpcUJmcUJHdWwwUWl4dnFXTFBlQkJBdnpBRGx2eEZXT0VWYXl4VjNpTDdtK1RqQmErS2d3QzNyREs4eENXN0pUZFp2aVlCMGx1R2pjQkJYK0l2L1ladkxLaU53WFdsT29rdFhSRUdkVHMvVXNBTC9NS2ZNc2xQY001UjRtTGpYemNkeS9rNXVDTVVVTGZNc29ZSVVFSXdUQmtpRExRUWlTd2NNSm1BeFREcW9GWTVnVERDTkNLVjhWVEJEekdLODFjZk1sT3dVd0dRNzFVWnoreUZuakdwbzY0cXlxemM5TXZiTU8rNEFwYTdITVEyZUlZZEVITzUvRGlZNHpMem1ha0VjSllOUDRoamF6d2ZmaVdsaUQ3SFVwcFpJUEdoMUZicGk1WnRxSytGbFZ5bFp1TFlNMUE0RlgxTEdsSWlBVWxGYjBqZUV3TDNGNDNGL09ZUjE0akwvWHc1RzVxSmhHV0ZHVFB3L0RFaHNZZ3J0RXl0Skg1SDRSZ3dZb25ZeFJkUVZSUWdmeExnVkFGWGdqaThHL01vams3Y3l3b3BYRXpXaThWY3RwTVk5U20yVmRxNFBxR2tFRXNvcUJzMlVLd3hSYU11bXRRcEZ6SG5Vc3FGOThSVUFhV215VkVWc1ZkN3pGWldyZFlEcUtid05WZjdtN3Evd0JSQmQ0bTZKWC9BTXd1ZHVJQUtDb0l2d1FtMEhFT1NkRUFib3VGbEJRb1VXRjZlcFkyVlQxeEZLcVlsd2FqejZoTkNycHpFQUVtcktpMTRKNTRUWU52SmNBaFFQcElHc2JPK0pZcEF2TnhMcXhkWlljdGgyeWdDUVh0Z1B1S1piZGcxQXEydjVtUnBmcGdEVGoyeXdiQU4zRFhkOGN5aHpzZHNEcFpVMkIxakVFNGVybGh1eWJLZmNWd0FQVVR2SHFNaklydUtYREtmY1IrT1pYUHk5eThSY3hjVHpjdURVV3RTM2xoN2hDbEJGZEdCOERNdVhXb285MVFRTnE3Y1JLYTNBQnZSeDNGS1g2T0lpRnJsNG01ZDBSbDZZNm1IbzhwTERtNFo3K29aRy96RmJRbzhUM0pnMHhNck5LL3ZFWVh0UXl4WU8xTFJyeFhjY2dpdmVRSG1aV3RERlpzL3RGV0JlMXhtYlVZaHFwVzU0Rkx1a2hzcGJPVHIzRXJHVXl0eDA2cnoxTERzdU9yK3BUSXhkTEVDOHZqbVZXbkhnamJyOXdDdERIR3NrRmFJZzhWRW1xZmkvNlNWQWxaaHFDbU16Z3JFS2x3UFVvU0FpWVdPcDR1eGxPalZRUUNsa1FHMkgrb1kzS3NzL0ZRSXJHZGN4eVhHVmRJdU1hdkYxQlN2Y0l6K01BNDRFcEkzblJGeENQbmlHUldEbVd1NEtPVExGa25CeFBZc3hjYkdNM2lkQldKU0RZYWN5emhldUprNDNtWjNLZ0E2ZXBad2RSUDgxRnhxcFF1d3h3ZjBnVnJKQVRWVVE1NWVvdWlleEdkNjZtOFRvZU1HY1JjVldlb2JycVhuNHF1b3YxWHdZc2R4L1B3L3dDb3ZmRVN5dTVkVnlRV0R1Nml5NHNyTTNFZHdLUlcvTlN2aW40UmcvRXM3ZytZb3NRWVdJWllROHZQcUNXTGYzT1F2VXNickRxbUlyZFVZVk9ZakFGdnRBMlVwRGZjRFFiSGt3eFpvNXhkY1FCaTI2TVpJTzI2L0tzdFYwY3IxNElxVnlHcTVKYmNhcnljZUlCSlpCUWJtaG9NM2RRYWhIT09Lamdwb2NHNmlKbUc3RXhYMUhNcTJDblVZY0M4eW5JbFFPVDZKc0tTM1V0TGRTMEYxQnZFSXhRMHFlVVZOUWhaY05mRGFZTXFKaVJxemlNQUpTbCtucGlWTVhlc015emNiSE9HR1NhZzB3ZUxsNGpCY1FsNHdzWGlXTllsQ0k2aVdCbzZTOHdNcGIraVU2MTFSRjdaOUVXM1I5eEZ0RFZySGxzK1ZZM2FZMUxjQWVvcmlLY3kxdFNQOFFDb0JPUGwrQ0xMaG1PdW9zdUxjR29pOE1wTHVmYzV1TGJMS3l6YnM5UkxPdXZnaXVDYnVCekZtL0JFR0RSdjNFRnkrYmVQUkVWTHgvTXY0UzFWblJMRFlpbHBjRnNFSHoxMURHZzNlV1hHVDh4VmdJZzBORVBLRXlFTkpEdTVNaGYxTVlLOHZDK0E0SmwwdHJMUDFGQVFEdFdRRTByTE5VUGlvekFac3RZVjRtU3hyZEdtV0pTSThQY1FGeVlyM0xwdFc1ZHJkTG9DSkJFQjN6RUNhenZMRU5VV2JVeXpHK2V1NHR2UjFIM21ZdkwrNEYxWDh3T21admR3WDVmMXBRRnJLMGFQVUVNUUExS0RVQ3lBbUFnTnhWYmkyelBERU4zWERDZE9vMHdhNWhxWDhFTnVOUlkrQ3prUkRQOEFpRzhRY0VJQU9sWTRHczhlSlFBcTNNVnZkemNVZWZFdllhRXpZVllnQ2srL21GVTlEVVJNZGJ1WlVHVjB5WnVCOGsydzhiZUdEVnFwbHlNNXB2aVdBY1ZMdEpyVXUxM0VPZG5KTThIOFIwWkhtVU9mWEVQckkyYVI3ajRCTU9KWnozbnVYNGpGeERXb21QZzM4OHpWelpob2pxcWhqRG00bm1WRVpYeFg5VDhEOFl4VkdkeXFCQmU0aFFNcktnSExyL0tWV2hjSFdKVE5vREV3RmFNZ1hETEM4NWVZRkU0QnhkeEZoS2MyUW0zQ09GZHdqS2lHUE1XMktRRTgrNVF4bDZxcTd1QzFGVXdqMzNCQ2hZZlQvY1d3aWw4MS93QjZpV0FDdXh3TUJPcnF5TlhFZ2JDS1c3UHhBR1F0SEp4K1lJSlZUdFRJZHdUYTB1d052NTNGRFRiU2xSR1lxMEVGSzMyQ1ZjYXBVZUtNTU5RZTZsaitnU2xZYmx0MEJpUjBmaWJSVG1MbUpmaGl3UmcxQml1TEV1RmR4M2d4RFh3V2N3VExvWkhyL1V3SlA3UWFidURXK0lTNmx3YjNMdlVIaURpWEx2aXEvZndzWlVwcUNNb2ZDaUpBNVlrU0o0aG1WMThOV1ZDTUNOUlNMV2FnNGk0cVhQdUxVdWh6QlM1K0x6TE80eFJ5eDNwNWlPOHZ5TFp6czNnZ0JueXdyOFViaWdEUnRxR0xVQmlBS2JEUFJOV1ZudnFDdzY3TGJ6TWFBTHpmUHFGTG5nNElpU0FVRjR6NGxVcXVmRUVERE5oMFFMUVJJdGNUTmgzaU5rR28vWnVWUkxMTVd3U2lhT3YxQnFSR2dacDdpY1VuMUxHeWhlVnl3c2hWeXZFTjJ0djFEZlFES2t6RExPMyswUzAweFc0RmdWc2I4eHZnaXZ1SDNkUkRWNWhnZnY4QXFycmJCSWRzTU1GRUFxL2dnb2FqVnlRRG1KZW9CS3JNY3FycVBIOVBjTlhkSnJOMUF6Y1M0T0lROFQxRFYvcWZ4Qll0THByWmdsTE4vcURsY2I5elB6aDlWQzVia216QS93RFZNMVlCTEpZdjNtTlRnUXU0NnhVSmRuL01wZHRhSy90QS93RFJ4OXhFNG1CdDFtVUxsSEh3MWx5SWJMbm5jUjQxQzhnOXc5V0NyNzl3Z3pwcUZPVTdsRnhLSWdZbFBQeEk1SmRhM0x0enhHM3dSeEFGV083bkVadE5vL0YvdU81Z0hpWmJORXFEMlJJa1NKSythL29xVksrS1BqUGtpS0JsY0FRaEVXV0RvLzNFMHFnYUt6Y0ZxQlpXVWdsV05HaGlXbEJxaDVqVm1yeUNNUXBWUm1Ybm11SXFIZnNaU3hoekwzY0FvRzhaaHJJRXB0ZCtKelZzTU1WTWFPUEVjVnl6ZU13M0lweHJ1QXV5bDRGM0cxSWhSZ3czMUxVaWdxSTV2NjZnZ1VGemdUdkVhb3JRc09vaFVpRDIzTmlYTHlZci91WUFXRU9XOFJpVnVpOHRWQkhrVzgweFdtVjlRcTg5VGFFY2o4VnFMRjhNWXNkd2U0TWNVTXNBV09wbXVYeEVCTlJVMGJKWVlrYS8zTHB6OXdTOFJZUGNHRFVSdTR2VUpaY1dLWEZpaXk0c1dMdVgzL1FRM2lWeEhFU0dENHVMR1hlUGhtRVhxRGNVb3pucUxXWlkzR0RMdGwyb2l5My9BRkJxL09pWUcvYkZ1c2R5emExV1lqZG9lWGlMZVZQQkxzdmlLcUpWYmxVc0grWUZDRGRRb2JLT081UUthQXhiY1NOcmorWXJGUXdCeFVPSWdlQkhDNmhCMVQxRE9XdmN6VUdPK0lsc3A5d1JvT2w0WUNBbkJ3ZnFHckFycTEvdUJjVnZ6S2F1NzdqV0FGY0xEZU5DYjZqd1ZybU1xYnJmbUFpbUtqUnhpUDJsbXF1WXUrZW1DclZSeHBMSUExaHJjdHl4UGFiSVlvM0N3ZTRWVXpBQ29kU3FNTW9zUkxzeEFwQ0RURURKQlpadU5KNWxRaFRNUDRENEx1RDhFSU1meE1KY2sxYVYrOFRPUC9aUlVhbXpWTjdnditHSUMxWFNMQldiQWdzbzhKVUNxNmVXRDFtSVZXQ2cyVm00TzFONjNNQlVNYjNjekdOSnFGd2FYbHhDa3ozRjNraThmeEZldTl5N0ttMzFNSXZVSzV5ZnhIWEx6QXhFYVlGM0RQaUJlcDRaZ1Z1VTFMaS9CaEg0ZFNwNVJqT1k1MXhPRXhJQnU2ZytFbFJNWEVpUkpVcjVyK2dSS1BsSExNZlFkKzRDMTJob2xBYndIWkhKTEFZUXdYM0xLNXgzM0JGY3plWVVKOVF5WFRnbVk2TDFBTWg0OVI2OGtTOVV2ZW9DdGQ3My9pQzJQc2dXWjF1cGFZei9BRkw5MGY1L3RCdGNWeGNBSys5N2wyTkg5MDZNOEw1Z3JnMmFlb0lFRm9MT1lpZ0ZXeDE5U3gwVWRjLzdnVWt0SUxkZW9ZcThGMFpUdGw1elRTOGtCdFVqSlJWd01XMGVlSVhKaUsyQ01mbC9vR1VQeExOeFlMaXhFenNtVXdyT0oxRmY2R0dZV09ZQzd6VVhCVENCekxsd2ZNVlJZTVVpeFlzVXZ6TGx4Ym00UllzR0l1NWR4WmkzcVhPSXRTL2hZTTJneG1DaUNITWQ0K1VJYzVsbWxFVFp2K29XMURTVkVvMWdNZTJZWmN4WkRORVZOTFJ6RFFBQVVBUzd1eS83UjBHaGxGZWVwWW9zQnlMZkJNbFdYYnFOQ3NucUFiRjhRZGR3ODJKVGhuVTVpdGlZMHhVL3IzQmRscDRnTERCemNFM3VVRVFzaWtOcG16U2ZjTXRCOGN4VkJFQWcvdU1TZ0E5UWtwS1Z1cWl1cGI0TnhCU2o3MU5EaWN5bTVRZUlpdEN6dVlERi9tZVJnUjNNR2pVVHd4RElNT0w2bElGbGd3MGF0WUNSamtTV0FBZVRVRkVHL01BaEtySkZWektUTXdGU3FwWWdMakMxcVczbUt4SFRNQjZJYStDTUJUTlFtZlNHVk9tS2hXanh4T1k3bVF3b2tVNnYrWVRhbFJUSGh0MWN1UzFwMmZaTGd1THkvaVdidk0vRC93QVhBeU45OFV4cmQ1aUhTN0xpUzZoYndPNmpVVFc3Z1Z4bkVNUGM1bjZqdnBnM2VOUmIzOE5ZRDNHYlpkcW1Ea2pEZ1lqWFVlUGlMMURQeFlZZkIrT0kvQml4T1VGVlVWRDZpb3JnaU41akNzSGNUNFpYeW56VVlrZjZMQUxkazVmNGlCRkVMckVwYXRwZUw1aXNxNFRBY1FWWUcrU0ZYWi9VRDBRc1czVjU0WUw1eWtvQVJ3eWNwL21PZ3RnS09heG1HamdmTWI4RU43ZGE0aTNXTDZpcnBqVEFDOS8zbFhoL081UzZxZjFDYXd4bnpMWGhlQjdnODIwbDU2OFJFdVI3emZxSUNLVlRYVUFxSUE0cHBUKzhCaXUrS3I4OXhFYndPTExUczdpYUJrdSsvRVVXWFdFT0lwWUtiOVJRZkQ4TVkvT1NBbWZvcjNCNURlcllHd3Y0UU94Szl5bkpUOTFGZElQa2l4RTU2akF2My9zNjl6WVg1SUJnSU11WEJ6bVhpTkpiTGpEU1dSWmNXWEYxRkw2aTUzTHRxTGJVMGk2aWw0eExsNGk1K0c1dEJLeEJNMkFUaEpDZVlNeGxqcGlLMi84QXh6WmJIY0MwTFYvTEFwdDAwVFMySmVlT0NCVklEVTI5WEF3Tlhhd1UyM0Vvd1cveExPVmNNTmlhSWdLTUhidFkwdE44WFc0V0ZPVjI2aUF3Tjl3dlBMRXZMMFFRNVhRZ1pjdGRRVEgyaFBrUVRaK2lCZG8yNG85d2pJV0xPYUpsb0N1Z21CYlV1NEkyM3Z6RVBTSThMTzBGMDVZZzBrVlFiZlpCaDNLbGhDbWxSZDE3U0lOQ1BOa1IyWTlTdFdzWGt1WE5GRjRITW9GRk13eFJPU1V3NmVZRVUyNllMYjRpVzRNeFVWZVlGN1pSaGNUWm1VTzhTdkk3aXBHclBKRDRKMUdQNmlxRy9FNUNxSUlCQnZqYjNERkdXS09JUmJpZmN6RFQxSEc0Vm1pWTgyL3VEVU1scWppSmh6Z1BFS0dEZXNZalE1eHdaVWQ1T1plVTJ3NkIrc3k4R3RFdE5ZL3hLQ3hoanpMTDB1ZXBhbGN5am5Nb0ZXOFZFbEMwYy9HL0ViRHY0UFZmQTlFVE9JNCtDNnFiUU1abkUyU3N4aTdsTlF6anVZQld5S2pITUYybE81UTJFRE5SVnhGVk1yNVNWRWpHSkg1b2cxWlR2Z2dHQUtnSWl3WVM3WGZpVUZHRHE5d2JkWmh5eHIrMFM5WTQxbUFxRmxYcVdodXpxNVN4cS8zSFlyUi9NUmQ4L3dBUnBWNzFCc2ExaUFERUNsdjNYaUFMNHg3Z0dUUHFGN0diMTRoYU54S1VYN2dKVHE0V1BKeFViNm84WllrU3YrZDFCRmYrMW1Nc3NTNzZoanBiS01YQVUyQld1dnhLQXVzbERlaDdJazJLWnkzeC9FZWpBV3BuTUU1QUZiWVZLb0JpbmhsV0gyZjRqMUdQeng4UHhWS2p2MFFoU2N2SzcrSm81b0loZUNQdWhCS3NlNHQ2MS9EQlJvVXhnUXplWlVpeXRuL0pEWU1IdUQzT1lPSlFJc01Jc1lmZ1htSXFYRjh4YlpjdkVXWFVIUGlLNWdUdTl5NE9ZSUUyNGdlWVpvU2ptY3ZiMUh0ckU5UkZKU2wzWXhaeEZ4UnY1NC9wT2JnMmkyTjhQVUJaemdEcnRsMXp4cVZsMWpJTWZBTnNHVkxCcTRiZ2dCdXBYSXliaUxRcmZKeEUxK0pZRWFSNHFJQVZBNmdERHZpRGtxc1FZemZyaVBOOHNBV2E5Unlnd2N3Q3dIM0RON1g0bDRBKzRvMlJLUy9OVDZ4eitCVDEzRlY4TVI2Z3ZNQU5rcWpIdDFGalBNeGVtWU9NeVppeXVuSkEwRlpOK1pXaTNDZmlBcmY2bFRabkZXa29GRVhKVHNtQ3pqY0tOaFhGU3FYQnFPQmJUcnFDQ0NNYlJMM2lDN1pncFV1dThSSVZFMW1mcVJFSVF4Yzhkd2c0ek5zeTJTRUR3emZVNlhmcUd4ek1lbE53WnlYVzQyUkcvd0J0eEx0TVJjeXZGT2FpcFJBQnpFbHM1M0MxT0Faa0FLNnhNY0xZWUNwbzMzbUM4emc5VERnUmJnenhtS0lYakl6T2VXY2NSMHFlQ21meEZsOXpmaU1TQmpxT2dMaHBjWGdDWjVucVpwSEV2eERuZ20zeFVaejhLTFV2Wnl4YXlaaWxtYWZNR3FSTGdtam1FR3Vwd3FKRVk3Q3h6cjVZeGxSUGhqTjR5eTlIY3hnL3M3V0pHbFFicURJSUxWdE5SQTIxem5pVWdWeTdZZHZ6SEE0MzdtRGR1TndEL3dBRUZUa3VwYTljekcrT1pXbE1rT0d6ZDNtNW80cThYeDNNR1BQVXFxemF4cm1CMjNxVURkMVhHcFdXbk92VVZjYm1GbzkvK1FBMFl2TVd6cDlUTzZ3Nm1DUDZQM0doVktkUmdXdEk0ODRoQUFCNHVtLzhTaTFZdHFKRlFXeGZmRXBwRnN1Tm4xRWJXRUhOdWRTeFhBN3Y5UWtvcTF1LzdUUTZlVHVCR25FU01maCtDMHRRbFpoK1Q1WUdvWXlnV2wyKzRuQnhIclVyQ2N6VTRuVnRNYjl6aUpjQThaZ0cvb2kwckZ1eHFENVAzQVhsN1h3bURJdjNCZjAyYnYyZjRTM2FIaHorR1hSUHlWRml5MkxMaVpmbVhMaWx4V1hCeEY4YnQ4VGV0eXF1Tk56bXN6Q2FUbEozb3Q1K0E4WUd0UUZaSTVZL2N4MlZLSmtuUmlib3NuUDlQR1pUMFkrMkJiQWEyQnFKdDh3bEphamN1S3ZIVlNoUzBNRkVDcGw2akpjbjFCQU5idHFOb1ZsYXZVV3I3YUNCc1hGUUtDWXhsaTFwbmdpdTNlSlVDQ0VMUU81b014bDRJWmR4bkh4WFdpNHQ5VnpVMCtJQ1JIZVJtVmlFWWN3SytHcXg4VFUwU3E3Smxod1I1VmdNQVFFd1MxcE9TS0FXcWVtTUVLQmtielhVcTJpRVNnYldNUE5zZFVoZGNNQ0pXVHBockFEN3hFQUdnekd3Tm5KQnlPNHpjcjNIS3hnQkIxbk1BdTl5bEs2Z3cxTS9BWitPTTV1R1paUjRSMzJaNGp6QnAySVhDand1V21VdGVaUUZ0MzVJbFJVNXpFMW5XOEdBZ1pLNnd4UmJkaG1CZWlxVG1QbUxBQzNhd1U2Rmh6S0NyK2FYQ3IvT1haNThSRkZla3dxRExmVVUwdytPZmN3S2ZnQy9NeFBTTWN6aWZGK1lzVU1NUnl5dVp0cVZ6Q1A4eHlUSHdXSW42Z1Y3aTFqaVpVNnl4QlltYmdBc014cWFZeW51RE1SVTBJTFVjZkwvQUVzc3RCQU4wQjduVUpRRUtkRHhFS3MwbkxLQWpZWkprNkhubVZSVlFMdThYaUFNcytKaUx5UXl6RlRBOFlpNDYwUmFOY24rSmhhYllMemgvTlFHN3U3Tk9wV1dNZUlESmcyckFIT25WeE01OHcxbTF1Z3ZKbUZqTmQzQXQ2c3oweXE0KzUwL3VWZnpFemdCYzkzS0VRVk1vdUNGMkNOVlRYYkVhRkVLdE0wd3ZKVXBWNlBNVXNWaWhNbWR5bVd4U3JlNFMxeFhEVXdOaDAyM2ZtRldoYlpWT2p6SzlDamozQWpUR0o4TUVtMG9sSFNtWEsrdW9JRWFNa1U3aTB3dGk1b2p2RG11WmxNUGhVcjRKeHFBL2wrcFgvUHg5Y3hQTW95Nm5NQVZrK240aXlrSGxUK0dJMkVjSlRGWmNXajRYbU1MRnhOcUlOR1psVXgxR2hNR1dhR1BidE8yQ1hkNWx4cUhoS3VzTUVyRUNuQ3ZpWDhUR29MVlJ2aEpSTlNsYXBscTFpZHVibHdoVE1yVm5aL1FiU0p3TVorQVkyYTlURm9iQlNBZTViaUhGOHhHbDN4Q3h2S2tVQTZJMjJyRG1NRzNMeE9aWVRhbEFOb3c0M1hSS2dDMG9ML3FiUEZ2NGlNYjVuSVJzcGRnNGloRDZURnU0MjVpeENadHFGdkVPeGJYdUlyQkVnZFJpRThNdVlOZkVsRDFjSXVpcWl0YTFBSWx2UmJ1K1lWTm8yck1wQW84V3o1OFM2Z1l2VWExelp6MUtLcWI0eHVHWVF1aTgzRFRacVhlVFJ1NHRyWm1KQkV6S1FScnNsOHVVSERpV1hFVlVZdUtJcVN3VGFRZ3dOYmhDR0xseDM4VWFqT3R3OXd4dm1XcHNidWJxOVptWnVXWnErbGNuY01sTWZaNmpON1NVSS94RldBMDJkeGx0QS94eEI2SzRXeFI1cm5jSnFkMXoxS2piMk9FdFNuQ29jd1VEV0pnc09GUlJWZXBpMEJPZHdZeEhNUGc3K0tPWXNKNm1iOFIvRVBnb1I5d290amc4eGo1aThSaS9CRVZxTGJMemNkRGU0bHM0QnpMS3ZGek1RZ3JNUUxjVTJrQ05TemFKRkdBNC9vVDVZa3NiVFZmbi9TQlRxeXR3N1VBTzAzNmxXNHFpaXlBS0FIaUJ0OXFkU2dWcS81aTBGNWdJbkpmTENxOUNGakZhK3JtQjBlWmxRei9BSGhVYmIvN1V5M1VCNVU4emhpL0J1SG4zclUydDR2R1k2MW1WWjFPMy9FV0x3TFY5UmMwNW1ORHJPWThKaEZqRVh3NTZkVEpVV2xXODFCd0F2UGVuL0VBSldDcVUzY2JVc0tWUmlXWHdkcTBuVVNPbkZ3UG1Bb3RqYWdtVEg4UzZaQURiY0laUk9FS3FCVUNVbFVjeE1BcDNtVzNvRnZtZTVVZml2d2xwTnZFV0Foc3VXR29abW1keDNMb2w0Mi9JWENCeS9EUm1IajR5TGpUVThuVXJGc29qWkdwV2crWmUzSC9BQlRMdER5WWZURnVabDFGaXgrU3cxNW5zWXVVUUV5ejc0cWdGckVXcUQzTHFtc1pzWUhaTUhKdVp1b2czR2xBM3pCZkRDbFdZWmlYS1hxcmdPR3ljNnhjdTlYTWxKVEVwcTRBb3BsY05mRmdlZmc2RmwxeEZUVlZjVHBETGY1bEFFYUNnTVJNTDUxS0M2TzZtSFQzR1hRZ25IVUlKWE1Hcjh3emlGQUF0MFhHdEljOXpCWWM2SVZmVzRHVTBhaXlpQ2xYdVVCTU5LaldqUkNxZm5qci9DR2E5d0w1dStvRmVlNVp6UDFCcGl4YytKZUl5eWxjNGlwb3haYUprL2NRRkJzN2dGS3NITmNSTXRGSFVVd0pWWDFBSE5VRzh4RGpjWkI0bUJlZDNDNnFUVm1JUWJIQzVEaUtBclFVMXpGS3JpT3NSa0kreVV1VHVLUHVXaUp1SkJacGxPVHNtb2VmZzJRM09tR3Zpb0pqQnRLVmJ2Y1NnNDFVc0dPWDhSb0k1ZXlZVkY4M0ZiTjFOcE5jazg0NXVHMVlFcnhLMVQyZzZBMzByaUloZ2l5NFM5Z3J1SW9GNkZRSlVJNGkwVnVZbkJ4bnVEeVZ2cU40RVVEaXhicnFVcjFNWEdmaE9HWXhxRG1MeEV4TGN6M0dtR0VxUFJpb2JuTVl5OHhaaXo0aEZ6amlONVJGMWF6Q0FEY0xHS21Cbm1aaTh3VnR6TEhVQVNNV3pjWEg5YVRkRXZ4TmRNQi9tQkZSWUczbVpVY1g0bnZnODdqVTdBNGxWaHZ3M0JYdm1QTjROd2RQbnFhUzgrWGlCRm5PT2tqWmVYdlVyZEhPNEJwMDlkTVVHczlkUkE3TzR4SFZlTlRCeTNmVUt4blA3bEROdGZ3ZUpoVlY5U3pMbUtZNXJHSVE1SHZFTnAvRTczTDFCYzIzU1g3aUVSY0xsVG1VSTM0V3hTWFYzK0l1WkFLWklMektick9Jck9SREx3eWh0VU1xNUNBbXBaeUQrb1ZoaEUxekVRZ1Y1Mzl5MWhiVXRUU3dGcWF4ZlJDb2NPV0pIQlFOdWlKSjVLckVLdmlYYzhJTitKZHNiaVl5a0o5L0FQTXFNcnVmdWZxYVRQbVlZR0llQ2ExTThrWUp4QVF2Ry9EL0FHNmxpcWZzK21JMkJoRXBQaHkyd1RtZEVhYWxubWlLWmxnWEJtV29BcTZJRWM4WVloT1JEQldXTGNVdnVXR0t1QlpzT2h6RU9GaHhjUnVqRXM5U280dDZnTzNNTDRNd0o5UnhjNU9KZzUweXMwWkpZUk1NYmU0cXY3eHdpZ0Z3dnhXaU5JM1JnTytKdXQ0cis4UGk4WkZzMUthWUhWd0dJVXl3TVlCcXBjUGNydnB6SzRNRnd5TUd5M3hBdlA4QTh4TE16Qm9sMEc4N2lyRi9oRUZjSzd1TGFqZmlGRFdyNWdWMkdZNXI0R2NkeDFlRVRyZUlnckhFVmlVQXJtYk0zZVppWTlzWEVIRTNsaVFnYnVDNHhIMnVQdmJFM2N5MjdnSlRydnZjSldtNmFMMnhKc3BOeXdnQk1DRGJ6QW9STHZKcXBRb21LejdqMmF2d3dvQ3EyVlhpUGlXNWozS1dtTG1jT0h4THZKbTQyN2lqU3lxMHhiRXlOeFhWOGtOUWIxeEF4T1p6L1E4a3JyTUJwZzV6S2JZNENKeVdISytKV2JQanFOM0x3N2hNbkZ6aUR3Zmk1WlZodTRBdit2Y3RjbWhVdFliR2l0ekUySGxxb283WmdjUTlFekRhRUZBNW44WThsNEl2M0w2K0RFdXZjWE13NHY0WWF4THgzT0NNZmhlQ0RPSTVpeDB6QzVreTZoZkEyOUVHYW5MR2dFeXdVTElvN2pMVk1jUU4xRUlUWWdHMGp2NGY2bUtIL0toeXhiUTdBZlRFQUs0T05YSEtNaGkvNWdEd1o3eGlFOWNlWlJBTU9LZzBoY3RtVDdpZXI1SUxOSW1NZFJ3SzQ3bFV6bW44UXp4VmYzNWk3bkg1bTRhWGNvZDV0OFNwdEs0N2dPS3IrR0F1MU81YmpGUGQvd0F4QXhtNEdLMTY2Z2lZYXU5UUxPOUgzM0hXRC94QUhCLzVHaXQ0MDB4YUM4VnFvdWkyMWMxZzl4VUNocm9sS1ZMcjlTd2dZR0JSTWs3TXdLVFFPSGI0Z2dSWlZMZFFJVWFWM0RBT0x0dlNRWkZSVlJkTlNncVdIVjhjeFp0SzNCY2tOb2c4UHFaSXRjSTJlQ2Z2K05lMlZib3Z6L2FZY1RhZm1IRVlQd1B6R01xSHdvRHpFK0srcHRLdDNIa2g0SUozRW9xcFNzNG1PY1NwclVWakV6S0hZbWhoUHVZdVUwRFhoNlplYitLWVZ6Q0JCSFRFdGlVOEQxTzNVZmlOUVN6VlFBTFE0VnE0WktxY3JsWWd2TXVwVU5GN0hNQnJuZkdwWlVYamlHTC9BQ3VaTG0wd2NYQlVMOGlVd0RzOU1WTEVZNWd0WEJXYlpkdUdzNGxQUDVnRHNpU3IxR2tESnoxOEpENEMvZkIzTUFrVXNKbHJVQUF6OVJLRG02Q0NEYjNGYmJsN3NiNGltckk3aUpSenpGZ3phR0l5ckxCNjNMYXVwVGFqaUtGMVVSQnFpcFlydURrckZkU3NyTmNTM2R1NExYKzRGOFRJTHJSREUzeVFHNmljUVZ1Tk9JV0phNkluUys0TVZCV2xvR3MzbUFTc1loU1VaVFV0WTY2akpzS0x0Z3RFdkpucURUR2czRVFRcHZlSmNDcnZpWVNxYlpWRWZxT0kyQkxIc2dMUzZjWEtYZ3J4OEdHV0VKTmhyMUdHSGMxTFhqRVVZRmxLdTZxRVVOemo0WFh4VFU2UmxGNzhTc1FBVVRXY1N3YXhjWFBQTVBDTnN2NmxTZU5qTFlvYkpYdE9iSFVjcGxkVjNLcUZjRi9FS0FLTXVpNUpVTEI5TWNBWHVVN3dFSU83MTFHcko0cUJWRjZmR3k0Rzl0SDh4aTFtREFaajVqcjNOYzRtR2laK0djekNHb1BXdmgxTUR1T3ZVVlJoZk1CS0N0WHVZdWJvcVBDNFA0bGpMc0dpV2xWRXVLY3NGMzFOdFN3UmdWUjhKL1h5Qk12UkRDaGdlSUE4dnFJUTdIQVJOTVZYaUFHN3JFcWpHZk1DMXlxOUdwZ1l2ckpxWnhiV0poWnQ2UU1XODFpS01zbVo2SitaZUtWMWx6bVB1dU8welVOb3cvek1YUFR4YzRPYSsybWNUM0VDbHFLbkx1K1psV0MzUnhlSjAwUktjVldqdVVvaG5ncmZpQU5iUGpGUzBNQWc3Y3didFdsNGJuSnV4eHI5RUFWRk9LOGU0SzBNQzZmNXFaSUZCeWhjR3FoWWU3Z1dyWXdwL0ozQ21UWTRST0hVcG9TME01bVlqWVNpOTl3eWxXYUIxRVk0VkV2a2p2eUZUVEJwaWdLRG9oMTNCVGlHQzU5QkJ3bHdZVFJLN2xmQWVJbjRsVG1CbWJaMVVNWmpreE1TWVJYYy9pWmZNQllRdUpvNGxXVEpFNno5eEp1Q1ViSEZiaEtYTDBmWFg4UkFtd09FWlh3RG1VbE1CQXF0L0VIV3Z0ekFpcUdWU3BreTJ2SE15dHU4VzhSTUw2cVFxWjlXdEkzR0FXb2dkc1JrdG4xQlROTUQwY0EzY2JLNnVsTWt4Mld1SzJSV0RsY04yMUtGUTg5TlNpVUJ3OU1wRzFYVlMyQ0U0N2djQkhET21WVGRXUWROa0hjUTJNUThUaThMTXJkL0FMZFpyTERSZUpqM0xGU082dHVWS2lvZWVHSWh1K1lBTDIvcU9KYVc4OVFxdXN5aGYzR3Q2OEVWQi9hSllKaHNLbHh0eDRxWkE3bER6ckJPQWlyVEl3V21uaUdDbVZ4cEFER1lOVnRSQUlzZHl3NTVnc2gyakJ6RmlXNlFxeGlJYmpmZFFyV0g2akVlYzVnR25EYjNLUVM2dmNSSWRFWkRGUURCaFRQUkRlUUduekhsemhZWG1CaXhzMlgrS21JMGMyM3VVemN3eFV5bExrWXFIQkprcTVrN2dYaVVkVEZjTU1HQ0pEY05VenpENDJHT0hqaUlyRHBPNEZqVzh2OEFxSTBjSitTQktlSE1vZEVNRzM5b1dUYS93bTlFOFhFRGxNR1ZXWmRsamhOUVRhdi9BTE1jcVpyVEVwYm54R3NkRkRnai9ZbWsvaU9NRXViaktCRmpmdUJoRjRpOVF1UFB4V3IrVjNMaXU2aUFWd0V4aGJhQTVPNWxodFl4eE1NcXZIbVo1ay92RXVlNHFIY05rZHdTMFc0dTRzWS8xUHhXTm44RG1CMFpSd3NiYmRJNEd1WUEyM3dURnMrK29GWFJqb252cU1EcXVPb08rM1VYWmtsREY3dXQvaWJLYzdxVW4zemlKYXNoL3dCUkNpK2NXdVdNM3k5YnRJWVhtYklMbTI1cC9TSUtHcTY4RTEzUnVvcmxWMXA3SU5wZTByaU9HR2w3Z0RPekdqVlB6dVVwQlI0NitwZ3hwTnZFUVIwZzJEM0JSR3dYZitaU1VaNnNjUDhBaGp3eVEyT1I4d0F4a09uRVViRURmcU1DRmw5LzM2bE8yZ3YxK1phNEZ1aSttV3FnMDRhNFl0dEswUjk5ekRscmpEek1xaWlVQng5UVZEbHhrdlJlcWpLZyttV0RGNXEvVTJpZ3hiZ2phcUtQeGxDZnVjRi9CdVhtVk4vSEZRQlpoNGlWaVlpaDNpVVlRVVozTU5zZHg1RGNGbWlWc2l0MUs3bFI2WWZxVTk0WG4zSHEvUDEzZk1xQkxvb2NWVXFERUt3Y1E5VFF4OXhYWnZoTVFnM3JGTHVERllHTTFjc0xma3FyWllORGVzdzFack1CWUV0TlV3bFhYM0dObFRObVNVRVlOV2plSHd3UVVCNHprZ0JiZzJHR0FGU3JBdWZ6TmczZ1hNcENscXVHSUdxUmR4V3ZFY2N4OFM2VWJhSUs5Y1FsRFpTZ2E2aUZWcmdlSWZHK1VDNDQxOEphVnRQeE11U3dMOXdPd1hxbVhpOGYyZ2hPSWpvQlpwYXFBS3UrcGhLMGRFdkRXcFRYaW5VdzF6S3ltODk0bXBhOEV0cG1XSVFZV3dxR1FEZk1ZVTc0aUpwTlREQkR4Rnd3Qkl5NjIrb3JOVGdDT3FvK3hqRGVjd0JLZzZybGlHbFREamlDbExFRVZVNVlSUVVMdlBFQUJpMVFHS2ZLRlBUNTl4VndxaGZuTVhLMXorSnB6T1l5cHFVRmJOUlZpemJBNGlJRHFXRmpZL0F3ZzNGZnFHZmcxQSs2amtyVlNyaFp6QTRsL29pNEtyK1pyNGJnRk5VTjB5MG1NUDNVOG1HSXM4WGpxRU9SNitvTFFGdHJVQTJtSHRGL0FoZGxMb2x2RzV0SHhCZlNQbWNmQkwrdmplOFROeGNTKzVjY1I4UTFMbHg4VERUbVlYSFpiSEwvQUdnZ0RaUVh6RjBHY1RMUkhTRjhzR05Ud2c1bE1ZcmJqOHZ3L3dCSzVFb0Q3Z0h1RFY5MXQvTVVRaTVMUmlyZGZRN2daTys5d0duYkh1THM0YnF5QUdTOHpQVEVIMFhFNGViNmxDcHAzYkZ4VHk1MUdwMDMrSW5DeWl0WkkwN2YrYm5KYVZpLzlRUUc4K1c4ek54RG03dTJJZ001ckk3L0FNYWdlWUNjN2hRbFg5UktxeEoxMUROWTFubjl5MGVXQ3pGeExSWUJWblBpV0ZGSEpmSVE1bGVQY0ZGMW5TUXJZWUdhS3k5UnN1L0RqWktkYUJvV1VDWnJPbGxGZHBlSzNBSXF6V0IwZFhBd05GakhIY0FCbzdMSG42aVNxTHNwRE54QktWV2djYy81MUNWU2tvWG0zaU1XQUE2T2U0UzVRTmw2OFJ5TEVNanlrUXdsWnhOb3RpYkRORVpVREVJUTh6MXFFdWNaaGllVXU3aWJMQ3E3bDVxQmpMQnpIMUMwNmc4Ymljakd1eVpiUGZFVGlwV21WeXVWMUhxVS9VcUs4YVo1MS9qeEYxQk1pYUhaQWdWSzRZTFlhYllhY0dmTUdReEhxVVZsdDl3M2NISmpVRUZTMUtHTFZWVGpNck5pU21qSkN4YlplQWFKVjBGOTFuOHhBN3RqVHRtSUEybDAzUXcwcENUT01NQ0ZCTTJHL0Vwc280MjZxQ0VMYzVNd2dPZzFaekVWdHRPOSs0MXFsb1ZmY0JrYnZxTGpNdW82dEU2NHUvZ2hEVU41dFVjb1hrckROK0dBaVU1YjVocXk5OWRRRW9JTkp0TksvVTFKZmx4SzdleExVWGQ3Z0tyalV5THFKYmU4c2ZoeENyQ1VaN2djczVnUlhxVkR0S2xOUEV6QUdONmxwdWZobGpCMlNtV2kzRnd4Q3VITU83aUFZK0I2NWxndkQxRG9SOTQxQVRjRTRXNHk4ZUlLc2dVMXpBVFFFZDhzV1VwRnpkN0k5YnJtY3lVS3ozWFV5VlU3YmlidXlQMVQxTmdNQkhlYy9ESEVyVytZNFh3eGxtQmlWNG1rdnhCeERKQjUrQnY0RG54QXhyWHdDcXVZZ2N3MitZdWVDR1B1V20xTXR3N1BkQW1CV2VaazN6QzRHcnhpV2FwWWI3bGc4OHNQVlVRSnRDaDdlSW5PR1owN2xQYUNhY1FQZ0xxWURaQm1NYld1TVdFbG5xTE9maTVjWXNYTVZlV0psdUM1NGxoMXE2alRidHhBTDRyTVZ5ZHk4VmNkUVZNSDlKL3JvM28vbHhFTExvNjdnSzFnYWxVTFhmSk5ESGlDdDBjMTFHdUhuekhTclhCWFdaYWlsNDNVUmhsZjRnV0xKenFWbW0zZWM0NUlERkZ1TkRVcW5IZzQrcFE1ejJERlBobGlaZmJGTFE1c3czTjI0YkZXbnFVamZDVytIeEJoMEgxL0VXVnV3VWJ4ZUY4dzdzY0Yxb2NWL01Sc0F4ZWpITXNWbllZM3ZiN2xwYmRKWURyMUhacFZ1ekpxS0M0V2E1cUlBdEl1cmRrU3BYSWNhZ3BDQVdOOXpLdGdwcjN6aUFpTGh1S2xBeXUvTU5LdENjVmZtWWpnZzVIekViRk5EWmRYL3dBUktxVllnbUYvM0xRb29BZTdaYUtVRmFmZTVZQ3hkYzU1aFF1eGJ4Y0RDS0lWWG1DeTdROU9mOHdoWTNCdXB5RVVydU9ZWllmekt6OFYzQ3BrUStYUHdGNVFhY3h1UXp1SllweE1CRzNGT1N5MVJ4bmNPMVpqbHUvekMyNDRGaW5tSVZuRVJOeXN3VXh1UGtOcnVVVXNYRG9mNThSTTgxS2VlZE1HdlE1bGpqTUtHcU41YWpnb1hYSkI0NEtBZ0FXS2J1OFN6ckp3UnBHVjV6Y2NFelZJZnd3d1FDQVZLUll3TFBERWxDN2FPQ0F1RUJtM1RHZ3RSdStudUlJaTVvUTNLVkRWeWFmY2Eya3N1dzVnR09rdFBQWkFaRFJ6NUlpMnNlNDgydVlWNG1XRUpiNGp2TzVlN3FuNWhDR3BuWEVDdmlCMWdZaFFyL3VXcGF5d0xONWQ0MEJ6M0wwVFBpQkJBZFRFckoxTmJGRXdjOFNqSlVkdk5yMUVJRTFPWHhLM3E0TW44eTRXMGxMRWQ5Y1MvQmNhc3Z1SjJ4QlBxTk9ZZkdwNVJvWGYxTkREcG1lU1VZbXNSZHZVdGdBbVFIZHhOaWFpMVZiSEFIRW9DdG04RlJ5cTRyaExZVjB5RUlHa1NiNmlVeEtRc0hYM0xWeTBMbXVJUkN4cms1Z0xhYk9NZkRHZmlSZ3ZaaGo1eXlrdzFFRzNDeStlRUg4VFNIVThQZ0hoTkdLNjFLd3pFek1PWVAxekxhem4xSytVai9xWUM5L3pNd1hkYWdPWWlHY29zWVBpNWVuTEtiSXJsVzFPTzQwbFhhTGU0Nmk2bDNIektZR0RIbVlHTE1hN2x4Z2JZdkxMaTFGK3BwZmNJZVlYaXRNb01jL3pPNm5CY2VxYllEZFFsam5CQUtET1pSVi9BMy9RZjZUUWpJcjY0aXRvbFkvTXRLYUtiN1lBR3dIVjdpRjd1dU9vc2h1N2dDcWQ4UUx0ZE82bDdYdHJES1d1a3pMOU9XK1QrMENIU0w4eHlYcmVEUktNcWVuYk9Dc2Y5aElDWXRCWHZ3c0FxZ3FBeloxS0hRTExRem0rWHFLYURFTGQ5OFRLbTZ3dDIrYTZsV0ZaYzNkK2NRUlZrUnByTnZGOVJiMGlnbERoT1BiS2FvRGd2STh3REE0V0R4Tmk3TjVNRnhWZzgzVlBQdVdGQXJXM0ZmNmd6amdWVHhCUUJHZ1JEaU5FQmZCNGZNTENCVHdiS2dnNDBBMXhNQXFWbWp4RlZvS0RJUEwvQUJNbXJvck5HVEdZaVdMc293TGZNcGF5RmtYUEdSZ2tON3VoMzdsMEFhTjFsOXh1QWlXdE53VTJZTDlRbDNlYXVDM2dQanpGUk0yRU1mY1djL0krTlo0akQraTV2RW9PNDVjd0Nzc1F3dnJNK3lOQlJCVzJFdzFNSmlBTnJaWXNGdzNFQ21rcXIxM0F1NnpFL1VTNVozRXJETGEveHBIczh5LzFjbGV6cDh5a0RLOVRTZExpQzJ3bWNTdzE4QXh5MEZtRTRZTFpYQzd4QWNDdHB2VlM2anl2VWI1d05vYmlGQ3BWQm1MRHRqV0VoZ2h6Vm5tRkFLcDJjeW16ZnJaTEdyVlp4eVIxVVFjbE9DTUZjTkxxV2d1UU45a2FBTmd4elY4VE1Ec3lSaUNZNm1kcWQ4Vmd2RzRZWWRTeloxV0lNUUNMQnVvNVhpSHdrRVBlWmlWMndBRjJYRWpuZTQxd2N1cWxCSE81Y0Z0ekZ0b3FHUFhVdFdaWDJaM3REaWE3UmlXMHRhMUxzT3ZNdE5WTGNJNGR6QWh1TmN4YzdrcUc1UGlUWXhmTVZSb3o5UmxPVHFNWllsNmppWkdiZzdnNVJDSkZNblVTSGgxRXhtcmlYVlBQTVdsRnVzUkJvSDRpQlJWcnA3bGpuUVpsSUZZdGxtWlN5S0FMRmhrc3FNQncrWldvL3dCNFpjNCtHRFd3cSt5REEwd2ErTmQyWWpzemlLbnd3UWFqOFh4TUNHREVEUGMzdU9NNWJoVG5pb3JmOTRQNWoza2hYd09JUGQxL2FJN0tqYStKVlhZNFlPTGxUVHpVUzVodVZOU2g0K01wbWNTNWVKZ2FtSGNXcGI2U3EyeEI5eHhETVhoRjNjdlBtSjhSY01MWEVkQkFqZDZnNmNURWlvYXVKZlV2MXpBb3RoUWlWenVHOHhSVy9EL1hVZkVmWE1JSVVWWG9teFF6UVBpVkN3anYxRFdMNXJ4Nm1MZUZyajhURHA0aTRaamdWdXV1cGhnM2l2OEFNcll1cXE2aE9CZ3UxMW43SXNKSFdQTXFWeXFMNzlTandXNDVyM0Vkb2xOZ00ybldidGxhaWNuQTNZN3orNGtWczNWTjJjRTE4SlU1UCsvY1RZenRyaGlRRWJWcXRQOEEyWUlJaFRhNHYxRmFvRFVPdy92Q1pDM1ZZYjgveEVUU3RDQ3REQ3N1ZVRwaTBTZ1c1eVg3alNJRkRaL0VWUmloMkRxQXpJRXc2WDcrcFJZQ0c2eFhxTGtVK0F6L0FOVURaUnlMM0VyUmkxZE96KzhlSmhGOWZubVdacEVST1htYXIwRkRmSE52bVlRcEIwMS94NGpMQThCaitZdEE1SU5PblVveWtzcDZ1SGFaYnl1L2dCWElIMllUOVRKSWJtbzRTVlU1bFZORlRpakVxL3FHUE1HRFpjTDUrVlV3MU54d3N3SzZpcHJxWjdLZ0NaRm1KY1ZHNnc4bThkUW9veHpIRVV4QVpwdVd2Vms1d3c3bVdQdUN4SGNTbGdheCtJNXl3K0N0UEk5bm1KdTZ3OFBFVUloYmRzTVI3MU9EVUdXc3lvS1dYQUFDTGRWNGlWRkFhd2JnOTBheGdLMEF6MUd1TnFXNHN1RFZJV09Id3dMQUszZmtnaFV5emIxekxjRHpuS2VKUVhvbUtNeWx0U05zTU5vaFdJcVFwYnc4UktyVmd2cUVBZnVFS0REMXU0OFBURmtITmZLb0Z5ZFFrQlE4RUpOdmFTalZ3dUk1RU1rQU1OMUFhdmw3akpyWkFpV2FtT0JOZXBRVm1BSlJVTEpoajRSTEdaZXU1VUc2M1BJWUZXZnFHcXZ4S0xoV3BuaWIvSkhmK3hxY3BVNTFMQnVBSzFxTFRYTVM0TlRBZzFaaVpyQXFXSzJSVXovTUNYSnVKUzhRWE1jaUZSRnNweENGc2prbzVuUitKZFE4Wjl5eThCVzdIOVJMQSs3aWdOMnBvREREU0JMYmZQVVNHZDNFaXdDdTNCRXJ6VVdzOCs0cXQ5L0Q4cThueEMyTGpRaTFPMFUxMHk0RXlNVXVFdnFNRy9jV1pWYmJuQUd1SWJKanFaY0RpVTZZZ2FzT3Biak40eERVd21qcjRWTDhYTVBoM0ZHRnZINHJOL0N4dUY2SnZpZW80TXNZYmVaVUxtWTZqbGl4UWk1ekUxMXVEUVpxRkdZV3hUR1phQytEUkxGNVloem1MYkVKVVJWSHdnTXhjeE1HYWpIK3ExeGlnOXYrcGJZd2F6RUZGb0Q3WHhDcmtWZEZTemx3OWtJVGJtQytEVHdqS1cxdC9FeVU2UDNGcXE1SWQxZGZ6TUNxV3IxTXdEK0VWZllqRFVVcnI3OVI3MXY2OWVvQi9pSDhlb2lYZzRYOS9VQUNKZWZxTkNsUTBpaS9Od1ZiVzFwY2oxa2hjalFqZC84QVZCS3NMcWpnZjh4V29McHNlWTFnbEdCcko1ZzNGWjQweXdWQWRXWkptS3FnVkRCN2lvR3BkWG4xS1FJQ041WEJBTEZpM2c2aFNCUVFvWEgzNmlMVUJvYTVmSGlWY1pCcE9ZZ1JWR2NINWlDd1JHaHVOdHRSV1M5TjhSbEZVY0dxK29hRWFicmJiR2lnSTRRejZpS2NJVXQ0OHdPYlJKZEdibEtDbFk5OHNRV3MwYk9abGM1RCtJMXhtMzI3Z1d6dUUzT2Mvd0JBWmdiWTRQZndRMFBjVldhWnVFdkdZZTdqMGo0OHpOZ3hRMHcwWHNnRytZMmJIREhVdFFZem1GY1EyRk5WTTlOeXpMQ1N3TlZBcG5jZGVmaE0xOEhzbEphVEs1R1ZucEg2OWtxcUt3WW5SeE1LSFM4Y3d0Q0N0WEF5Z3RHcTVZU29BV0RzWm5jV3gwRUV5VTR4Y0NqZkQvNUZnb21WUXhMR0ZLMDIyM0FnbER1NENTMmkzR0JqU3prYzF3UjYyRXdoS05GTkZrZHRDTG5FTzFLZzR0aXFoeEhlOXgvS0tpM002czFtSHdTb3BxN2FLbW5xN3h1R1FZQU1YY1NpcGlDem5NQUpTd2NFckZYTkVaWGtjK1dFTlhqcU9MSlhjN09HYzd1WURFdE04UitjZzh4S003dXBrbHcrTnlrdHhrTExkWEwvQU5qTG1vMXhCanFaSzh6SXN6ck42aUZJMHpKYmlWYVJTeGQ0bEtvMWU1dEhpV0l0MG5FYnR4cUNyOHhiS2NNU2wxZ2liZEIyZGtMQjFXN2kwM2ozQ28zMXVVdTBzdlVzYkQwSTRZYVlvMjJxNE1ySElybG91YXdYeGlMeHhDeDY0K09Jd1IwUGZ5SWxrV1dEMm1tYWgrQmd6UG9ZZHdoNC9FSER6OExyaURTYTdlNWs1bjhUYmR4S0JhVEk4eHJuTWNWL2s0cWZ5aGdnejhJR0UwZFRITUhGbzdpN2wwWWk1WmxxTGxFem5Yd3VMSEJqNFl0NzJSRnpBcGFmdUJRckVGdC9tVzQ2bUlORU1FdUN4dXJoRmpOS2wvRDhPdjZMQlZJcnoxK3BaZWpkZWE3bDZMa09hdkU3UGRRWFJhN3QvaVdiUHozT2F2blZTd0tZaTR2N2lEVXNEYzBVNXppVkhEa2pJdGl2cVo3NjBuVXlSTitlZlVUVmNvenZtV0M5bGJ2eGNickI0YXQ0SmF0bWJ6bGMxaVloVFlYUlNlWVVsQ1dXMm1halFhYnhuajFIYWdGelRuT3NKeEhnMWRMaHIrOHUyT1JST3M4OXdVYWdzQURhSCs5UkJLRGFsMGVMcVlIUnBvcjFBME55cWhnWWt0eURZTzJXN3RFeTV1dmZjVVFSS05OWlNBUUFicnBxWGNTQWJ2Ykx0TEZBNzBlWTFvYnhwd1ZYQXk2RlZRd25NRXppSlI1cXBzM1NKaXNybjlZbEhDQWJvYy9jUUtKcTY0ZUdLQldMSzFZWmhMQ3JBRjRDelZUTlhGSVo3bXQ3dUFLc05oNk16ZjNENFYxREI4cGo0NWg1eERVdzFIelV3SlpVWEdKZGtNUzRmM2N3Q0ZXcENzSEVxWmlKenVlSlNyZHhSYmNUR2NvRzYzS200TDRtT1RGTEwyeXEwMHptWUo3bElNWFgvdDZnOG9teDdnOWtFdkVWRkFqbStvQ2lnR0sxY0dwTGFCTHVPS1JxZ3d2VXFnVVl6QXVrSVVUSUVhaFNqVGpGUVZwSjI4d1NJWmtvcXlJQ2dyYUxWZTVWOUlaT1NKZXhNbWxqNFVUWVkzcUlNdUFxbzdXSWdOVTl6Ylg1bkpIUldKRThwVUphNzBpRmR3aEhjMFdPNVZESHVCVUFWWFV3M2VPSTBxRlA4UlNwcGNwQWdEV09TTEFEL2NTanNPMldLUnh4RnlNcWd6QlUzY2QwTWoxR3pYUFRMc3pMS0ZyMmczaXorOHNUYmNYSHJxWnR2MUgrSmxDMCs0ZHUrb21sUzMrSW10MXVLcGplNEpsY25tRHZHSWlyWDhzVlFWN2lwOE16T25YVXZWTW95SXVva2F5WVdBS2krcWpVQ3VpajFDamtzNjdpMnR3T0VFN3pSRXBaaVo1dTV6VFV1OEVxTzVhN2ZsK0NwaUJGWXQ0dVhpTUJ0cUdSNS9tV0Z3WVptcjRneDFETUdOM2hsaVcrb1ZEYVd2TXM5c3Q0UTNtWmFnTXRSYzNOd3o1aS9BdmliUGN5WDlSNkdVWng4RVdwcUozS0V1TG1jdWp1TDhMdGp6V1pYZVI0alQ0L3RBQWViMUV1K1BiQW1YcVh0dVlodUhlTmZCTCtPeWI0Z0FJMnZ3TmYxTVEydFFoY0JHT0tJRUlYZEtyRWhTcjBjeGNDNzRsd0xqRjRsVTNlTXk4Wnd5NTJxbHh1TEIvZURKV3FIRVJjYW83ejZqRXpnWU80TUVVMWFmNmdBTWw4OCtpUEE0eGZLcHBQNDdmZlVGS2lqdFI1NWw2V0lSZ2RuQ010eHVSVFdiOXpJTEZRckxXTzRYTmdwdzY5UmdZcXNLVWlmekxLVUNxU2tPei9BRk40S2cwZC9mY0NvQlc0YVAyOGYzak1iUUxkSGZpSXBWV3JHcnZaV3BWQzZiTkZzSkhnTUJmOXVvTENBcldMcVVFUmtsNHd3UVhSd0J1b0JiQmRYZVBmbUZsUVU1RjJRQXZBWW96aVdsMjJsR0twNklZYWt0UmF0NVpZQmFBWGdiOHhnOENWUld1S2dxaWF1bm1qcTR6WWxpNUsyY2Z1V2FnQVpOVlgrSWlpQjdTdEVyaXptc05WWFAzRTVsaWc3UHhIOEVZYWxYRE1HTU5RMThFOVM3aVdtWTQzT013eDhYQytKVXVidUsxS3J6TGd6VmRSV1ZtZHFVbHJ4V29vekZ4MUszYTVnZVZRKzBGUW55WDZpV2V1SVA4QXlmcURxRCtCMUhkQ05wVHNnSm5xWlFMQzJ6SER5b1krQ2lySFVCSUs0WlJXQ3BaMFBVYklvZlN4SmhhSW5aRTJiVzhOV1NoeXh1cGtRcXRwNGpMQmNwUjJ3VVdCUmJxSUJzdEc3ZUlOS0crWmt6SFZxbTlUTlU1aXEwZHJmMUQ0TlFpbGFyKzhPM3ZVQ2M0ZE1vV2NWNGlpcEFOd0cxNDZxQ0ZCcldDWEc5Z3dxR1BjSE5mM0haa285d05LZnFlby9tVzFXdjdRbE8vVXF5MU1hbzNOM2xxS2k0ZVNJcDFGMDZpV2x6SVlnalpkd1VBNjRuQm9RWVhVRm9vejNEdyt4aFJZTkRPVERxWi9mY1NuTmtDSEZTNmIzQUNwWU9vdHlpd0tEYkxXeFYyYVJoYUorZW9XaldRWmMvaUR6S0JIbUp5eTk5eXlJTkcyWnVNdVhINUc0WUVWTGpIbExtWHVMMHprTWpIanpCNmkzbUQxQno2bW4zRnp1REZ4QVNNL2ZuNEhTbm1BRGM1bURaTHhXb3NNeGpmRWE5ZkE1amd3aTFMb2k2K0s1ampCTFd1STdsL2lNZFlpb2E5WExXSzMxR0IwMGR5N04vYzhsNW1ITlFoVnFVQ0VZLzhBejVVcjlHWTh4YXMxZFhMT0x2QkFGRytXZHl6aUgxaXBvQ3ZWOXdIRzJZWkJ1dXg2aHg2NmxET1hmaUdaTFZLcGpnM3R4MUtHcWE3eStJT1dLL254TDdWdGNlcHdYVmlYMHkxNEl0VjBmM0lKQ1lkTHhUL3R5ekVFMjAzWC9NekZOVXZ3eTFKV2x0c3plNVJYTEcwekZFM1dyb3ovQUtoakN4b2J0dm4zRFlHZ3dxRmY3bFFidHRpWlBjUXNpd0dYUHA4eHNtd1ZFcXM5REJRalEyck12R080aFlDamdhVHlSRkxxM1R5Zjl4S1ZwRmlsREg5cGFWb1h2WE81WkwxV2pqNjl4SWlxZ3lHZ2lNS1doMDdJc1NJcGpPVHo0Z1haUW1OMlBmNWpNckRhdXpxRURjc3l0NUpRSndvdG0vVUVLVXUwRDEvcUZZS0FDcjVyZHpCQVd1bTdJRldzcnVYYXQ4d1d6d3Y1SXNFN1BoZUNKVitaV29RWmRrTmVwWlpnbVR1TjRWaUhVWVZ2eE9JTmYwREtJR3pHNDBveFdaeEJSTWplb2lickpGeEJsMlRENmw4ZUk2WWdKcG1PVDhtYlk4SDRyNHFnOCtPSCtZQmJMbENHQ3gzK29qUzNONmc0bzlIWDNFS1VBNUwzTXpoUWd1RHVManhGbXBiTU9hZlh1VUJ6UXBUbURCdkxFMnhPcEVXQzhjUVNRb0VEZ2U0ckxBRmxjTXRMNTRnd2ZPNVluOXhYcmNXMm1QSlVWWEMzOFFwMklJU2xNdmN6UW1lYnJGd0ZPNFhWa0FCdHVCN1JBUVcySWplSWhUZFV3VzNYbUlvTW1jU3B3L1VjdG40Z0xYTDcxRUczUnhFV3lxT1lMZW12RUtDekhnWEU0ZERGM3pOcTBoc3pjZHFaZVlxRzhzVk44UEVwUm51RVJwNWlIbG1zU2d1bFA1aXUxdmR3VWNhamJ3NmwyS3V1SUVDWVRKdHl2VVVUYkxFUE1Dc1ZaRTN1S1FvcHpidWJxNXZHWmFmT25EL1FLYWhsNitXUHc1bDRKY0g0dVhMNmxTbUdyNml1Wjh6YkQ4WHljUzdJUGZ3WjZsNThTNEx1cDBoVGJNTUU2bHdjcmk5L0JhS3pHTUxtTlllRVZSeGwyVVJhSmNKUkZ3akN4enhMK29wTzh4cXptYmU1ckJuekVyMnlqdkZRSWx6S0ZYS2ZpTy9pNWNUMGw0cUttSzI2cjRmbC9xOHBYOGt5Y0x4VXU0b3ZmOTVXQ0ZBOHcyeFZIWDlvVnZUdVdVd0hHbWFYbFhVdnIzdmN6YnJtdjd5bDdOK0l2VVA5dUlIam51ODFMSEpZNU9mY3FuaE5RVTBGcGk3L0FKbGtDQldWTndnVzJaVEZaNmdWWXdvYlhWWi9HWXFnRG5YRjErcGFLNFRGMWR2TWFLVzJLdEZNQUxXUlVMTC9BSDNBQ0dRTUZ1bWJtbDBWVmM2V05LMW9RTHZ6RWhKdEEyRFhUR0c1VmFLNG5EMGFHODFXQThTeUcycjJYWCtRbUxRdTdLS3YvRVNzYkM4am5Qa2lGaFlqNlptMU5EWlk4Y3NVQndxaFA1aFZMTUZxbWNaL0V6RENNNE41eEFzalpvQTU1dnpCYlZzdC93QVNpS29xaWJ1WlIyb05wbmNKY0dneWpxNExCWkRhdXlPcThYc2loalkzUnhMbXRXNG1YZnhoaU1IWkQ5eGlzVGVtR0l3UXVrT1kwc2pLWnRDM05yUHEvd0NZSG5jOFg0MUs0aFY1bVpjSHZpR2RwQUgzTG1INmwzTERMMWpjQXlxYUpaZk1CRjBaeEF1c3ptM2lQR1lDYmgrR05FQmY3U2pPZDRpSkc2aVpoV0JMNG44d1NZWVZrMUc3cFlnbytybHJXS0xydURZNU1GQUtaUjFLUVJXd01CQVNSWFpmN3hWcUhJN2lRVnNNQmR4YUcyODBSc0dhVHRpcmlYVzRsVmVJdHZxTHA1aXNlV0NwQjRxSHdTMVZaUTZnakJXUWVJU3phR29ncEdueEhkTHpMSUdsN2hRdWhJdW51Qmt6SzFuTEVwaDFNQXN1Q1RCdU1GNGhydkQ1bWs4UW1JNGd1SlRjQ2d6TDN3eEx2a2hDeStvQ3ZjdFFHTG05L0VSVXdJVVV2VWJidHJtWG5OaG1Pc0ZpT0hNYWMzV295VUcrWmNNMHdvcWZVMFN5NWZiTDdTaDA5eEtEekIvb3VYSDQxT2V2aGJZeGZBNmxud0lSK0ZGS1ROd2pidzNNZzh4ZGN5N2hYR0lmaURMK0tlSUhlSm80WjdsUnB1ZTFNR0hCRnpMekIrQmpnZ0Z6RktqRmVENFdGUlhDTDNEY1dvbFpjMU9YbU54M05EZTNVd3B1RjVxanVjMUVOVzFXanRqdHVmZy9xWDRZQmVXcFVjUzVmOUgxWVAzQUNLMWpnNGhJZ0YxbW5FMDZTb0swRk04OHdBM1ZRZU9XTWNqaXJuMEtmeEdVcHgxdVczZEhIYjRqUW03ejQ5ek5sVndYTFc2L2F1NVlBbHJQUktoTFBMQkxXQ2hzNmIzdUlzMVJ3SUxYaUF1UUJtN3EvZmlZQW8weDMxRUNnYVN5OCtvaHZJQU9EWng3alVJTklONUNzNDV6cWVTNXRxdGM5UUtnQ2hnMzVzOFFCdThtMTBOYnJtSkJFS0IxYzQ5QkUyc3JkcE1nWlRZbWF3Yml4TklLZUhXcHVGVXBFY2VUMUNpc0FidTg0MUtLMWtVcFIrNWoyd01OTzN1VUNySzZlREV1bG9BTWptb0VXVlJvQzdmL0FDQUxvc3lxYnFXQ0lnSERqSFB1V1pZYmFOMzEvZUJBcjBCTmNmY3NVVzNZQmhoZG9Bdkp4WExFRGhYYmIvSjNGQkFDNnUyRm9WV3QzRGZYL214WVZGeXpqRXlWNW5iNEhkVGpFQmN6RDlvZWN3L2NyemNFbVdvWXZFNU5STjkweHV3WWpiWTJ6aWNTNzFuNFArSlR3d2FNeE5MS2x3ZnhFS0RLa3JNTXdvYVJrdzFGQlJFbWNUVExKTTh2eERPQmlZWCtUM0cyM2NxYzQvRWMrZTROMk9Ub1BKRTROeHRSektPN3VaeTZMekxNYVZ0N2pjcWV5WWdjMDJ2Y3lXMkRvOXhpaUpaT282VkFvaXBjUlc1dHpGdmlMRnVKMURNWExGdjFGVGFYTUcrb3lNcTI1U0Zxa3dpM0RYRXhJbFBjdU5XcFo5Tys0bVNIRHF1NFhGNGVEeEU0NHBBVTBmbUx6YzB3S3kwY1UzVUZtRndGMlhaNGxCM0Npa281Tm01Z3Z3RWJHeDlzdEtOeGhXM3FDaTEzSEdjNWwxZ0lkQlVGdUhmRUNpcVd1WUxWM2d1RFNYbldHSTVOblVYVG1Wd1ZGMUs3TDErNHl5aTNtNE52YTRMNVh0OFFKWmNwVTBWVVZjb3hJT214dkVkNDE4SkhFWDU3WFVQekxqL1VYQitGZkRMcjRCTWlRR2pua2d5K2R3ZW9KOFhGZzRoSDgvQXJGSUt1MHlZakI0bW1KaG5CSXRRVmwzekJXVzR0R00vRlQxUEUxNWxEVUdGSFVvY285RTQ3OVR6cXNYS09XKzVaeXYzQUZ4b21kc2dLcUFMV0xqYURnK0QrbS9tNHZ3L0Z5L245Nys2RlRQRFZ4V0NscGhEY1ZvMHJQOW9DL1hNc1FOdVcrNEdidXpDSEVON2VKbzRYbmZQVXhVNDhjd2NqeG84d2dMMDROV3h4N3FWMFV0bGNNTUozZ3ZKLzVERE03QS96QUM2RlVYSWp4NWdDa1Z0VGVtOTFMRUprRzNPM0xuWnVaaUVZV05ma1pZRkNEUGp6S3Rib0dpaXovaUlBdTRMdHdlZkdJQTNGb09nczVybVVDTERiVzhmbmlCUXFsQ0xuL3FtQ3RsVmhvMVlKTFNESUt0ZnZtSzZoZkkyTmNaSG1XQ0tWYW93K0R6TEtMV1FjOEt6L0FETGV1VkJiVjRpaDZCbnROWEJWTUtNamloL3hFQmNDMkVRQ29VdE1WTEZwbzQ4WHM4VHZvWlpNZG4xRVd4ZVN0R0RQUGR4VnBwZEhSMUwxTmVBMVhFU2tWU1VaeU1RRXdLdnRFWTdVeFd4L3hGd0FyTjl4VkhhYjdxRmVxbjh4NGZVNWZBemJFd3pPSVlna1cyNFJMZjJUSDhvbWIxb2pUV0xsKzB4MFFQOEFERXZsVk0zRHI5ekx4SzduazE4RXBHTXdPNW1HVHFHaTdYdUR4d1NZT3JsZksvaUF0dkVlT29ZWjNBVDJ6QmJlcTFGWG00b3pqcU5YZk1CbXgwOGoyU3NXZkFlK2s0WnRZUFJMdHpsNml0MVZmekYwc1VjUUVGU3RFc0hKYXVYVEVLYnRxQnhjVU5hbUJadjRjeTZaVkYzQmN4cDNEY0p6Q3pTbnFFd2JxNExEdCt5SEVWOXdCS1JPcGdXYzdpQkxMRmxERytQRXJsejFGZHdaZHBZQWJTcGRZYnJVU2dQeEZneU9vSVh3bk1TMjBvbWN6dmNSUldSN2lsOXNkbUxHQ3FXczl4UGc3Slo2U1lBOHhRZGd6dlVBSWorSTVabjNBaFpBM3Vzd0F3TnBFRjkrWW9xSmJBZ1VkOHhRUU5FYU51WFVLdTZscTAxcWlWMUtPV2VvNFdzbmZ5dHczbUdJKzROUmpINU01blB3c3k0c1c1Y3VYRDc2L2lBM3U5a28xQmkrRytvT2VvSkJ2VmtXdHpYRXViUlNiaTV4SDh4YjhRZHlpUGFLTGpxREcrWnRVYXVZWVp1Yzl4SXhJeDMxN2kxbTV4bGE4UnpWWUk1UVB6RWFDNzhRVmdLOHdBaDNPTGw3K05BTE5Lb3paQitvTnlSSGdaM2lhbGZVUk5pZi9CK0gvd0JQTXlEUUozQUdyaTJtQys0M29HTHVLc2M0MzNIQW1PWWdzd292eENMZDVYRWFzYU45KzVtTjhKSGF3M1hqelBJSzd5NVBVbzVjOFJ3ei9aOXlrY3VMeHV2VXFUWUIxL2YzQUVqVGRFUXRHSERvVXhYaURLYUJTVm44dkVwc1VVY0MrajFGU0FMeW1FSmNJTDBYU2NvNnVGWUdFQmNsYlZsbVZGc1FLRFg4d1hyTXl0WVR2M0ZRVUttNmJ2anhHejZBRkZCOXpVdnhOWFBNS0JDZ1ZRNnp2MzVpY0lLdG5PK2ZjekRzWWwyb0FPVUhmQkhRdHBZM2lpYzlCU0kyOVo1anQ2NlBjQ2FGRFpqTUlxTk9kSDZqYUFpY0xXamlNQ2hkWDViZ0JRNFpyajZXSWw5RXBEY1lJZ0toYmQ1cGhob0kyZzAxQzdwQ05DYmpzR2lxcDh3YUFaT1RtRWFxZ241ajNCeEhlSXdpUWp1Qm51QUtyWnVCaUR0TFZ6ektwUTVPcFlyUkRFL0tLenJ6TWl1Wmo0b3JYVXVsRVBNOXpEQmdlT21CckxjV3RiRVFJUERFQ3N4NE1TcTV6RUtiaVpHWmJuRFhFS3c1aG9ZZjdKVnh0ZzhmY2JXRENjemVELzV6NWlvdHpuVUczZEVzTlc4TUN5Z3FQMUVGUW5CQ2dKYWVlNHM2by90R3dVVkxRMXVLNXR3emNDdHhpM0xJMnRQTVdLL2NVYXFsRlBtRWFveEMyTVlZRXY4QXZFdEVTdG1vcVFNUEUrMXhFYWF4S0tGWWN4Z0FZZ1YwdE55M3JVQVZvcGVaa2t1dSs0cThqUVlaZFlDNW03Q0paWTU1dVpCcVZIK1VMaXFhb09mY1RiVWJRelJCeVo5ek1Lb3FVTnR4SE1JVUtERGRPWG1JMkcvOHdMTFVhd0VwS0MveEVBcmQ2aVU0dy9xWFdRcitaZHdDdUlGNEZTSVc3OVJCWTNLQTlmSEZWQnA3bWRUVXUySHdPN0xuRTUvcXJEY0p4OERGbHhmaTRvRFJKVFdIazh5bUxFR1g1K0Y5VE1HTFdhaWo4RjM0aTVqSFdabXZVV1hYajRMeWxYbEZMaStZdVNPVmJqVlJRMVBGSExnbGo2alF3M2NCN2RRelY2OFFzdmg2bE9YTEtDM2lNNW5oU1pOMUtCYlBtREZFK29aeEtESkFHNnhBVnFJNmllb3pZUDFDczJsaFJYaVpHQmFsUHFQOVN5ZmIrWWFqanJwaXR1RGltdCtHTVZBcGd4bTZsaStZeVBOOFIzNE9wV2pGU3hzelhFRkU1YWF1RW5Sc3JpVVp0NzlkeEF2T1ptOWt4blJHSnQxeHVWYXltUkhkNnIzRm14QXErRTd2dUtqbDVPNzhSQmlnSzdjajRJbVJRdHplSEhqaUNnczhpblBIVndxM0VMU2hYZjV4TDZ6akZjTHlYSFZLMDV0UGhZTm9iSEptbkZjU2ljYnplMnZIdU9sSzF5UUpaTmxHekZmYi9FWVhBT1F3Vm52bUlXRGVGeVo5UzlMMDRERkIxR3cwYWFTOGN5M2hWc3BiQnR4eENBRG9MT1FJVlZWTUZjZjdqcUloTEJ5dzJlYXNYWDE0am9xYkNodzlNWWxtclZGSVY0NmlIZEFGb1kvRXNGWEFhVE5ITjhlb3FBNlZjQmxsamx5VnBJcUtwUnIzQUcxVmJBSFVYRlk0ZXBUM3dma2lqU1hEV1pjdUVxOFEzRzR5ZkUyRDd1SEY4M0VRRitKWU9hN2hhYmJibUJlSVFnTm0wOFJEbVo3YnpLY09ZbWN4bE11M01ucnpGcnVPWWN3eXVXTjdsV1l4TU5ySGN4anVLckdtK0lhU0JlRU1NS0xHKzVxcVk3ais1ZDNIRVJoRzQvUjdocFV0TUtGTnBIUGRRelFwSEhaSlFxMURVQTNETlRsME1TOHVDVUhIR0k0R1pZampFV2FnNWl2V3ZncGh0U2t1RVNIVkFOY2tWTnJYTUdpeGE0aGlsNXlFZFoxQUExenpLbkdZQmE4M2NQYUlNV1lkN2FlYmhqWkhWYzFpQ3cwa0M3MUdzaHFDN1hMNWxRaHQ1cU9tSjlzUldTK3BRdFhIY0JRc0cycUQxSEExQ3JUQlZYTHhLUVZOeFpsVkRraW9XMVVwMmlqZUNJY2JlL0VLcElnb0QzTW5qQnpXSTZBcUxpSlFON2l5VE0xRDVjdU1mMWxEdUU0K0JseThTNWZ5TU1OVCtvRFgrUkNycG41UVlHRUVYNmwxVjVqbldJZVpmMUxtNFdIY3VLMUx1OFZIZTRyekZ1ZmYxQTgzR1hkMThiK1M2OHhCNXc4UnVxOFFzNHpHekkzQjNoNGdWZHRyQ3lXcWlxcUdybXVlQ0ZqRXd3VGlkbnhwMFRXVVFXYkNZZmlFVWdua2w2bTAyUloyZkMvTmZldCs0cnN2Q1pzZ1RSaHBQcVZaTHZPUCsxRHlNNElidDU1RGtmRVFVUTFUVUhKV1g5UTJXNE41M2NNM3dlNVpWdnl3NnEzcEd4cjMzT3dXdDhRV1RZRDh5bzBWZVMzTHVqdUZoWVdpcEhNdEc4SnAvbUFSWmhLZGZjZktxRFltUHE1V1FSS2JBNGR2aDhUTFJxQ3F3SFBIRWJpcVYxYmlqWVJyV1FEWnYzN2hNSzJxcnQ1cGdJMEpjWDkrNXEyTGJwejY3SVZLd3JyWXdBVkFGNnUvOE1Vd3NBSzNmWkJXK3lneG10bUlFY3VRbVFJakpJVUFLVHU1bGhFVGRVLzFCb3lGN3ZWY1ZCVnJZQUIzMUVrMUpRMWhlY3pLZ1RMZTZMMTVZYk5xRzFxbDRxQU10dTdveGlEQ2F2VTVycVVBWTV1RldSQUt5clBtdVpWaklpbHBMQXJMVlhVV1c5SitmTVhpRCtUbVlmbUxId0duM0RFZHk5VHRDRnZCQmg5ekg3bHF4ekt0L3VWRldtMHMwMi91RnpJeFZGZk1BNFQ3bDFkTWVBM0VaN21iT29PUGlvYjFMMGc0OHlwc3ozRmNUbWNTM0dwVjhYRWpVY3NLZHhvQmxNZjBpMlo1L1VBUEpoTjRpMXNqY25xVmRLbHJDVmdZeDFuTXBCanA4Si9xRldJcmkxVkVxY3h5c0ttMFhNQnljVGR4ZEZSem1LSjhHTG1MR3A4UWlRVGgzQ0UwMXRxNFVFelZubVlGTEYxVXdNNDRLZ3RXMm9CZEhpQ0lINkpsa01FVHNoNGxhVTMxSEZaaXFaaW9pTGNkdDdpTERYaVlPWlFvUnVLT0MvVXRWQkc4YzNpWktHSU1LTmZtVUVRdk13T0hudUJYaTRwUTNWUmtEcnFXZGp5UkJ1OTd6TUN2TURRVmp1Rm9sM0t0QTJZMUEzVmFsV21UTXNNYk81amY5NVcwMUYzNWlWNUlmQisrUG12NkdNY3MxQ0h5YmxQQkJOQy9VODM4UTdQNGcrUjlTazJKQmlvckVXbG8vSWxHVEJ1ZTRQVUd2RUdDQkZ2VG1YUm1FTzBNUTg4eDdSWmNJWjFQMUdtWjZsL2Z3bHd3ZHhxSHFPVE1RUzF6TmRaNGprdlVNM2VpZTQyVkNaTW44NXBsTllsZkVFNG5obUNWKzVXcU56eCtCcHMzT1FQaDJmQmJzaHdrUkxsZ2lEVFRIY2ZpanVpL3BGeGgxd1FtTHBIQ2N6QWd0cU0xVW9oRUs1alk5NC9IbVdxeHp2Smp4RW9idWZqejdteDVnSzhCY0ZxTjVMenIxQjRNMWRhYW0wd1Q5azJMTHR1N3dQcVhzV3FVYXhOS05nVVp1eEpjYW95YU9Zb2hab3QyWUZnc0dyc3gxeE1veWhzTWgyOXl3WEJDck5qclhpQ2xXallGc3A2bFJFRjdKZVhjUkJxcWQyYUFseGlGZ0xDbGxpVjRSREtQV09HRU9Ua0s4SGY1akFMb3VBM2VQMGtzSzB5SUFsOTEzT0tEeGQxUlg4eGVDK1IwNTRpTTFRMVFoVXNLaU5MRXE3M2lHQ1dEdmJYanpBWlZGbXcwZWZNSzdORFpiZy94QldZbzJGNjQ0M0dxdEROaHgvbUFOUEN2UHZ4TENDQTBYcTljUUFJWGF3Qnh6Y0xRWFRaU2NVZnVXdmRQclZUR2s1NGp6dkg5cGhVZVF1d1k2cUtiaEx1STE4YWh6QzZoT081dDd4R25rbDZheEdpbUFnc25MeE41MUFyNmFpamg4WVpIWHdIWENWSUxLUU1MV0FPN21XSXBXcm1ESlV2T29ONU9JUXBlSjlrc3hOTlpTWHdRMDNmTUtNckpCYXVJYzQ4eWx0d0IvTXZOT0t3K0phcW9kc05OTm5EeE1LNWlLQUJYUExHYnhPVWlORzVwMVVjWWlvaXhHTEtYYzRuT0lRTE5Uay9XSDh3ekVRejVlNENnY2JqbENyRk1vVnRidk54eWxRT0RsUzR3Q0YxaXA2a1NoMWtIY2NKVjNFdlJBbDM2WlJ3N2ppTDFGVFpoaWt3c2l3cTc3bHJxdnVDUG1XSUZhNW1lRWlNbkR5d1FGNU9ZZVhYK294RG1FdVVvYVQ2bHFVdW9aZHkyUVlrSzRsVmMwN3FDZ1NJQ3dzT29ydGl0TjZtdDFIZVBtNnh4MUhEaHMrZlh3ZkQ4S0w1QXVBV2JSZnFPR3BPYmF5b3crNElxbjRtaUFmVUF1c0VPdFV3SEpmcUVma3NpbXlmVTZUM0NyRmt3Z3BLbFI1Z0ZKSGtnWWRvSkI2ekNqM0xPWmdPdmdVekJwWkZJcmhRWWx5MkxIUHdlSTVoUEROVDNFMVJqekdpdEhvalZ5aUtFeDJUNmxDMjlTcXNTamlIMThOY05RSlZ3aXBVcWVDVXpscVBlSEw1Mi9DWWJCUE04RDRsSUtNdkhneE1qRGZNYzdiczFjSEpOOFZFQzJITk92TlRGV3lJdDlqUnd5M3M1TjFBd1ZFR0wwYzlRUlZ0TCsyUEIwZFJLTmNhcmtnQmJBRzF4NmxGVXJIcSt5WG9XdVROMVhPSmVVZEpmYjdKVFV6dk8vdTlRQVdxQzNOcnovTXBGcStGYlgvdjd5aFdTSUp6RjZOMmMySEdvQmhWVkJyTmQ5ZUlndXUxczdBNGozbUFEUnZFRFFteTJzZmoyeTFxVnQyT1gvd0JpaGw1dDVkVStLaFlKb0Z6MUI2QUl6bHBEejdaanNLdWpmalBjR2xUQndjUjFBNUdLVEhuL0FGR1ZRd05oeXJ4TExWQnJqWFVTb05HQU1DOXhVcm9iVWQvWFVWSldsYldCUCtxSXNCc2F3Z2J1SW9ESU5ocnR6RlVVcHhoY3ZqcUFBOU4wTHg0bERBcnh1LzdSaG5sTDlTaHN4RjNxSzQ2QjBVL1RVc0dhWWhMcmN2TTNDWFdUYWJ2RmZNbFMzS0JGY3BldHhXK1VDS3V1NExtOVRKSXBsRU5rSEV1NjVpVXROcmVibTBpa2FlNFJ4eGNaY0p0M0NudUIyNGpobFVwd3pQdkpXeXpuVWNseTNtaE03aSs1Vjd6R3EvU0RtMnlLamlPTXNjd2FJczZsV3F0akhlWXE4UVRWNmc1eG1YYzhpb2djUldydmNXSzVZc1IvY1dLTDhPdjBoZStJTVFxbEhYd1orZ3VPTDFtcGVnVEdvc2hhckZRaHFNczJnSXZtSzE1dUNyMVVIZmNKZEp1WUhBcEx3d2J2T1l1ZjFDM1RGN2lMNXViV3N3VjFFSmpFQXN2Y0Y2YWlMZDZpYnRYN2xXaVdSb3oxSE5FQ0dvaU9aYXJsWXllb2xLUDZnUnorNEY0NGdzeUVLOUVxSVUrWlh3bWNabFNveXIxL1V2d1VycWM4TDdqcU00QXU5d0RBQlhVTWRTdzl3azhZbmhLRHFKZUhNb09Hb2xqbmhqWExtVlphUVc4UllxK0JFS3M4d25NaXNHekVzZnFYTDZnM3ZFNG1reTh3eW1XSnFENWl3b2hERVB6T0lEYXpsRXVKZVhSeEtKbkhVVW13MzBSaWcvc2lyWVcrNFlHSVp4QXU2aDArREJBNmdQd0Q1SXdSQmllbzYrSmxiK0JBU1dhRHJ5d3M2czI4dk10NGdUVFBEQlZNQ054SEhJSXdMdEVLcVZEaXlza3AydGwxMTZqUUxBL21WYkpZcGwzRytSL3RMREtxczM0Z0Jid2JpUVJHd1Q3L0FJbDdacVpJMDF1NEZsWTRUVDRvZzBQdXFPSy96RTRWWmx5NUhtVlZkbWs1ek9KcDV0eXYrSWNObldiR2R4WGFMbXIzWFVyaWFab3lQRy9YRUVNYVBKL1ViYTVlSmpucDhRck5sbFhLTHdWQ0szTlVOWThWRjVqWnYxenhLczNDbll2eCtvbllpa0RYU2VKWUI2L05lT21LeG9RTENsbmNNV3dxcnZVQzJsWTNscnV2RUdSRVZWNit2OXdTdEJWQzIvOEF2Y0lnc1ZYWWVmTUZGMTF4VjAzaC9FTFJEUlpTM3UrMlZkVkplME1WOTdpZGJSZUVMZngvYUlVRmEwOFB1SUlLVkRDMVd1WVNCUTVCMGVmMUtpamJ0NFh6RVdwbXRSeXpiRVpkVHhQOS93Q0k2LzdpR21IN21XeURpYVBqWDNMekJxWG5KbVpLelVCcDFtZTRaYURSMU1JMXFJRTNjUmkzQVJaZURFZjdRTEdwaGFQak15bzVQTTdHVXdZbzFDNTB1V1hidW9nMloxaTNjL0JLbDBYNWkvZVo1amdWTE1lcG95OUlpQ0hXWTBxcHRFUWxDRWZGUWMrNWg0anFXTHJuZm1LNll1bzUvTTVWT0dMTVhFYitDR0crb3hFb0ZySjNLMlpWek1DaGs3bXFsM3lhcU5qZ05kc0FJVFphdkVFVnB2OEF0QlFtN2dSei93Q1MxRFdvMEZyL0FKbVJqN2dPdUlUTFlRamU2eU0zZGtjclljZHhVRG1iUDdNM3lFYTBnVFVOWUdQamNSR0EwekkwUDFDUlgveUVMbGhjbDFHeFVxQy9NckJubVVSeG1Cak9vVU1BRUN2RVJHMkFBWTM4RFI3Z29pUi9ySXVaaTExRjhNMWN2TUVaQ0FHUHREd0lJeFlTdTFsZThUZkRLVDNFdlVWSDNxWjZXTDd6RVRkMVBDWk1rVWF5UUZsOTR1V0JST3BnV3lFN3A2WlZiK0x3V2UwdytGL0MyV2g1UVlONmFtZVlZMUZpbFM0WCtZMUFtd1RDbXZNWXJYM0NBeERPSlZ4TU1Ld2dFQ29IemZ3c0dYdUxMeEZtSVFERVZuZE1NdlZXSHBQNWxMQzZ0cEh3OXdBd2czVzN4OFJDa3U0WEVjQk1BSnZOM3FvbE1YUVVqQVNLcmJ5Uk9FMjU2Z2tOL3dBSVV5SXpEZjZidVlvYmJyZU9vR3pWTEFuRmR3Q1plUDNMVUZTOHFZOVFMUUFTaWlsbGJyS0JZZVlYQzB1amhvNXpGdGJZQUFTNkwzY0JpWk1tcyszc2xGUUtGZTA2STI0YnQ0dXovdW9Oa2FzTVVRR3dVQ1NrcXdDNk9YeFhNWWdzWkQ1NmhmNFlVci9xbE5WVWc4L2lPTGVXQm9LM251Q0dLVHRMeXZBOXhFVUk1TFRIbnpFV2dHRmk4WG1CTEJMa01VT2R3d3NDOUZLM3hjdXJHQ0xWb3ViYWdHd3FObGk4WGZpQVlFUXhSYTh3d0JGRFl0Mkp1T1hnV2szZGZ4RmFEQUxBM2ovc1JVcUlMcmUvTHhHMWJBSVp3THA4eFlBRk40eFp4TG1HMDFpcWVaWnFyd3JHc3pEdFZjUExHcS83TWZqaVM0OTRtWGJpS3lFQ2NmRnhlT283YitvN3hCNVVkUWdMMlN3ZVlheDFVeXZaY0thb05SVmx6ekxYdnVlTUVIa3lUSXExKzV1eldKYU91NFlqMk5SOHdoaXVwZWxTaU9vR011WTIrQTRRaHlmZnd0YWpVQ3N1NHZMRXZKcU9tdmlsUUdoa1g2YmxVNGhkZXBsa2d5ejVpOVJmM0ZyVVU0KzRzWCtuaTZoRkNBbzJjM0dMM09QVTVFd3dVVTdNMVBKS3pESU9hYVNXUm5lNHEvc2xtMnZiQXBUZ2dJM3VLMmhJbkpTNDI2TXNGQUZhZHphaHp4RmRsWkNVYmdOekRDUXorWXNMSWdpMSs1alFCWE1kdEY5d1UxK0kyc2J1WXNaZkV0R2szTEduVUFuVUNyWDRsMXNvTjFFTFFOVEJ0Y2tHUzRwclV0U21hbDFGejBRSVErR3ExbWRWdUU4VnhsOHhZUTFDVEdXTUdLQ1krWVV5a3NsSUgzTmNWTS9qNzNHanY0QlhtT2VJaFkyMU1aaGlCK05CM0FjVlVCTVJodUVzNTl3eW1vSFpBL01mdENIeitJWHFmbkVHRGNYa3FOR3JoeGE5a1IzdUFTN3pMT1dYWkVHMFB1WXg4UXpPSDd5N2loWTMzQkFvbEpxWU00Z0dvQ0JLK0JENFpjWG1MTzBXNXhMcVhGaXl4NE9PanhDVUJDdDlzR0RyWTVNRWdvTkh4TDhFMW0xS0M1UzZnZVRHQ3VZallxOE1RZ1k4bk1XN0VvYlN0eDNhQVhSbzhRbEhQT2M0aTBPeEs4eExEZ1Z6MnNyTmJTaGxRVFFtaTlmN2lvQXMzVjVZM0pYUnlaVDNDZGtEWlcxaG9xdEdNMVdlNnpBd0N0N3RvM2NRc1NEQ00xNGVwV0FsbWRPdW9nckZCUTRESEJBQ3ZrbldxKzRsdENYVHdlSW9wZzNlQlE5UkxrczhtTjlSakIwamczWlY4UzlNcEJRYjV3UDFLc0hlR2kydWNITUt3d0J2WjFIRnRGZ0x2cUtSQkM4TVpEeHpFWEdqUUdFZkorb2h1UVVBaUpQRkxWZzgrSWJHSVVkMTc4eGtHMEtyTndNbTZCUVg2aXJXUzBGNXZiSGFLbHMzci9iQVFsSFp1OGNTanJCaFp3ZHhLNHErVXlzb3EwVzBjekdpZ2F0TnhjRGlQd3hQQXcyazB0bmlLb01NUU1TK3BpeTRhZ1poV2N6ZFc2MUZnclRmRTBlYWh3N1pZT2VvRkFvaThWTW1OazFNbHRNcmdNY3M4Ulk0SXdxdXB6VmNjdy9QY1Y1WmlYV3BsS3ZtS3UwcHR0akR1NjRnNWluaURIS1lHTVhlQmwrWlZ2cUh3USs3R1BiOXdzZDBRYU1ROTdtSE1DeGJvaTM2aW9xT01SWXZ5YitLaXVJckIrR2VnWU5UaUFzemVqMmN6Sks2WWxBMUVzalhkTjF0NW1lNE5KZTN1T3FiSDlSVktFOHhJWktQRWVIT1BFRnNMeEJoYjNBVmJKY2loUmk0bVV2VXROZzJVUTJyekdQTVRGOFIwNWhvVnV0Ulp1cXFYakRXWmNWQlJlWWxPSU1PSU5HUHVOTGR5cXB1S2F1V3BmTW8wT0hpQnFET1lMbXgvRUpldGNmRlhLblBuK2g4U3BZc2FjU3RSaUYrNEFLQ0NmQ3FJQ3lxMjFEeG1WSDRmaFpYaUpYRVlxQkdNWHhGZUlsTXlkUlBjVEdaWGFVak9GK0l4TDJUR1Rhb1hKSUdGYjh5dExyNllDMGZ6S3JkNGwyaVd2TVNHZjVqZ0w4VG54RUNrWDNMSGYxTVpkNVp4UDFpMlY5eWtEME1BREdDQUdwNGZnS3dnQ1ZDQkFqTHo0bHhZdUlzV1ZpNVZ5czNDNDJSMGMvZ21BMEtYenRabE03czRudVBERjg0bGkzSlpDcHF6dUFCSEV3MDM5eWpMOU9vNlVPWHRoR2dEVklmNWxGQ3hUQW1vbGlxekpYTUt3S0dUM0JWZ1FieHIxTXJSdHZDWTF1TTNXNkx3NzFGeUdXUnFtNzJ3QlYwcVVYaXQ1amtMT0tjVjB5Z1M3WmVWOVZHblIxZTFTWlM5VXlDM1IzS3VidnlQMFZLY2pRTjA0OWVXWEE2eU9NWG5uM0FBeVcyVXd2bVdRUWpscHUxNFhxWE9TcXJSVllpQzBxbWdSclpqTUF0bElyTHRHWVp3TjVmand4YW81MmhjLzhBbk1vQUFVNUd6NmhvT3JwUTR5YkxpTWFvdWl1U3Y1OVJBVEhJMjlIaUlDdVVnVWg1Zk5PNWN4VXNUWmVOdjF6TVJVS0MxYVBWZHhTUUlYaGFwNFlnVUNzS3JMN2hGVlo4NkpZR3k3S0hpaUlVQUNzS1VScEhtd09mdU9LdVZ5eHhrUmZuS204djJhL1ZSMWxlWXN6aUYyUmFjOHg0NWd3M0txeEdGaEZxVVM2MXpFS0RlSWFYbEVwUUJQZUlIOUREZEYxNWhZOVM3cmFyeExXWEdNcFlKWUh2ekV2R29VV1paWnhDOG1vWjhUdVluYVdPcG1wZDZnTVE1QzRQRjVpd3RVRndlU09uUE15dTQrdUl0KzBUeHo5b3JZa2E0WU9NUWY4QXlYbnpGcjJrb3dSSmxpeGJseTVjdURERTRYNEsyRG05d2pQYXpuaDZpb0pzNG1DVXZnZ2dLS0VTcFppcXE0b200a2JNODlWQVhzV1F0SnplSXF2VitJbDNldUpZdGZ0Z0FFc1ltL2NNQndNRmx0Zm5VQ2dQaUZGV3ptREZaZ095S0ZvL2lYTlNtUkY0bGw5WmlRYzRnQy90Q1UyQVp6R1dwaUs4Uld6SUVGdFZ2VXMxWXZpS29OdEVYRGxnVzBaaUJ5V1NxMUV6TlRGWTNOVmVwZWJ1bzA0bGFFRktXd2pnZ2R3UHFVK29EM0FyRVFQTEU3eFBVcGpCRE1TcDVva3BsZk5JbXU1MHhNWmlqZFFjMW1mWExUVmVaZHVBN00vRUVZSTVta1I5d0hPVnd0djVMN1JUYk4rNWJ1WDh1Ulk2OHdDd1VUeDRnZkFNUUlId0VxQjhMVEVEblVvTzhRTDl4ejM0bG9abGl6RndVN2dZakhCRVV2aGRlSU9ldHk5c0haQWVBOCs0Y3Q1anViUU9jUWJpU0Z3R0R2Qmh3akJlaXphbUZqVGxoYjJrTmhHdnNtd0I1ek1SL1N3cFJCNDdsS2hhYjh5b29BNXB3a3crTnU5bjMxQWdTa3dCaXBRZ01hcFgwM3hFNUEyZ21MNXVGMG1qakFIVjl4RUdCbTExWjU0aUFnQUNJb3JyN2dWaTBsTjUzKzRVQTVRTTdvemY1ZzNRTENWdGUvekVLWFh3dG93TkZWcGtwSEdmekZBQUdxUytkTUVMQ2xsR0ZqYkJUbDIxei8yb2dBQUdoS05uQ2Z1WElCeVVPVFpCS2lJSXQwKzMxQVpaQnRNaTh4S3dxeW1GSzNVQlF3SmFwa0dsdmpNczFzQmZoWHVDbGRRcHNsRG00S2dhY1JwS1AvWXdzZ1lCYXRqQmFJRm5pdWZVcnBSU2EzUkxGUjVYbi95YUFYQ0RPYTU1TGlPb3hKVVhFdjFpcWU0cnBja3UvaVhpWEx1RHVjV1ExZXVZWFJjOHBUd1ZBU1l3NW1EY0F1eWxVclNXWWhPQnVwVEJRTUVFYmhXQ1VMekVBRzRQSGM4UktYWHdOdHY2alF4eExuTnhiMThLejE4S2VLK0w3aHdSVjUxL01zcW1UbVVEaTZselRtREdaUWp3Slg4U2t6Y0h1VzdJSE51UHhLV01HeHRvN2lyU01ZV0xMaS9CZWlCVUJXWkk4UlFqR3piTUNNcmpEUkczWFVBVUxvY1FQYmNYQUNDZzhSb3Vhb3hjeURQSE1TTmpTUlFhYXF5RXlyazRZSXFzYldINWw3SFVJRktLNEhoejRnZDV0bEttNXJEalVlbzVyaVp1N3pDeFZpaW1LRGNianFhV09HV0JObnFLeS9NdGF1eVdTNjFEZWFpMjRhcWFrcGx4UlRBalp1S3JhdG11T1A4QW40S3ZMTGp2TVNuTWR6TGcydzhTUUNBQU9pRGdNUUdVWDUrUEUvY0wrRmZHZmo2aVJZZmN0ZFIrR09Ja0ZrL1NPZkVjSlhETWt2TTdncmVaaWx1alV0OTlTOHhBci82QVF4eXdnS28rSVZNdFFWQ296NmhDRDRWZkJYWmVZMTJ0eElDdGpNT3Rzc0FIRGNYNlNsZ0h1RGlOUnd0bHQ2UDh5aW0xY3J6REF4ZUI0aktqVWJZdUw1Z3FER29QRVNZMk53aFMxTDl4bXFDdW1WMEJSTjZqdTdpdlVwNXFiUXVOR0lGQXVzLzdoVUNyYnROSkxjRVJja1FHMWlndWlqaVd0RXVLeGExQ1hHZzBCZHQrUEVzY1ZOVm4zQnZ0V0xjYi93QndOMlJVRTBWcUZNNGw0WURvN2p0clFGSTBqL2lCcVVBVzd3M0M2Z0xiVGYzRkdFMEdSL3ZBb3NKUTU0NThRZDFVbzRwTTNtV05DMGFESlp0NUplTk1LN1B2ekJRWDJocHYzQk1EYzVhcUxkblNZWURQN21YZ0NWak9jMHNlQjVFM3pqeVJVQlV0TmRkK29Bcm9LZ0hNSWJ1eExOODh3S3JDK1FkRUlyVU1hcmI1N2lWcVNuVjV2N2dpcWpRWFR4L21JeExzNHJpTWJLOVFHS2JqUGZ3cmppOVpDVURjazg4azRpNCtYRUlhbW40WERESm1WanpIRGx3amRDZVptcis1WXh5Qzl3eFdIVXk1aUVlTGxuT3U0dXJIRU4zd0lxdHVwa0hqNHF0WWlvYVJac3pHN3hBWXI0ZDRnVW5OS2NPSmxRWllnNHRSVGZNWXVKWjVSMTdUQlB3NmdIeldKK1pZUTlwTHB4QmU0SW5nUzhKY3V1WmNkYi9vdVc0Z2dnMWdtYW45VGFIeHFxcmNCSGRVcHY4QTVnb1NLbG5UR0N2V2N5cEtJT0I0bUJlVDZnSlJzZFloZ1plSWh1cy8yZzBIQnpjRUFZZWVJcTZNUUs0S1BNTmI0WWl0NVdVR3F3UklCUjdsZ3NLTzRzdHNSbE14QkZneTAxTHpRREVHbk5SWnhtNXJUcTVTd1c1Z3lZaUhJdVloTlpsVWdibDROL3hBcXB5L3VEdVZUZFJ6RkQ0dU1YRzVXRllGVHQ2aEJaYkt4cUcrcFdJRkVaNitBeEhHdjZHZnFXUkRtRlhXcFZiajhWOVJJSFRIMUFFaWR4SllTa3d6SnFCbVpQVUp6VTI0Z04xRXAvOEFrRjRsZUhKQndjUWRRWXpCVUpjY3k4UWhCcVhHTnZES3FyQ1NqYTdsaE9IaVliSGlLN3VWbG9TbWtFaFlNdkFSQ0p0YzMzQldQTG82OHhVTzdKUktERTArSjNCY0hjRjA1WDZnQ1RJN3hCeDMvaVd0QWQrWmZ3UU1WM3FYZjVlSVZyVzd1R2pUOTh3WWpPWXVRNXpNVFpyTk5mYkhEbGE3VzdQRUVNMmx2YS9VcFkzMUgvWEt3T05DY3ZjeVRzZ0JiVC9pSUpkdUFIVmJ3eTBMRXJGOStDVW9iMjI1cnovYU84RExlSzlHeU5RdU1DdWc0VW5PTWlnN1BNTnhTMnBiTldsZnFOU2tERmxLNy84QUpiNENxTE5yV20vOFRMQlZ6clozS2w3Y1ZaQnN1aldqQlVZdEF1RzNYV1lWb3VhcWhzektsSEs0QU1uOTRHd0tlMW1ObUxiY2p1dXY3eWxzdGJiRnhXdFJWeHJKRmVaelcyZ0hydUVxUkNsYTFCVmJhdWhUWC9zUU5GbFp6RXJlYmdadXJENWZsMVdQb0ovcVpGd2tYN21zckdQY016bjRjdndHcjFQVGVKeU9JMHlNTXgxL01SUi9KT2YvQU9RWmk2OHpZWXJHU1ZCeEJlclh4bGppQlNkT1lMYzRLaTc0eEZjeGs5US9jU3JqTzNFdGRUTGdqZ0orOE0rQk9GY1JhaXhNUW9XNVhFdXFzOFNnUm02WURIM3I4eDl4bHhaZnhmOEFTRUg1bmZNR0p6REJNaVAvQUNFVUxHdUdhaVFsMTI4eklMVm1yaFNOeGg0VFlJOFYyUXV5eDBuTWJ2TGJDUU1temtnaGRLakVydloxQUN0T0M1WVlBY1V4WGtmcU5Ca3hGQzgwdTZpQnBNd0pleTRzTURGWENEamNBS0tyWnhLQ2lLdU9JTGxOeEJSdDFVdHltRllQRlk4eEZvWm05YjVpMEdjdTVuNjZpVTZsUDVoRk5LZ0YwYXVWR2h1dHdVMUg0QzR0ZVloYVZBNSswQVRDSGlFY2ZHOWZBMW1HWTRuSHdaaExIaUJsNWk5S205a1UvWHh0a3IzOFZMNWxRZlZSS2xkd1hiY3Fud3dXUVRrcWRNcjR3N0oxYWhvekJaTlAvd0FYQTlqREFNVmlBWUNDV0dDek1DRVlhbHdaY1hFcmRRWHhGZWJ1VXU0eEZsaFMrb2x4YXBsQmljdHdSTjRPTzQrcnJBUzJ6cTlSRzNVcjJWTUE4eTd1TjFraVh1R21aM2M1OFE4eWdYVGhsS3RxK0dXTXA2cU9vQnA3aGpiazMxN2lLY25jUTFjQldjM0tCakVXL1Uwem01elBsUnd5N0xxMzZ1V3VGdUJ4WDNFVzJVVkFOM0xzVElTbkw3alRHd1pvS3JwbCt4anZuZlhVZGxGVzh0dmYxMUhaS213L054UzBWaXNydDdqUXUwQkV0dnAvN21JZFdCcmhmT1B6RENoV0xkVzUxOVJ0dzNTRGRuRUlxYU9IQWZqekU2aVlTK1ExRE5rNHBQM0dxRU1PWFV0QXBGb1hKL3pMVkJia3Z4S2F3OEV6dU1XQzhnNFBxQVhKUU9UY0JWUW9xcjBmVVlnTjQybGYra1NnTkdWWlFvZ0NXbXZ6TzY5NTRKZUhGZjJnb0NsajV6L1FKVWFta3U0WEdOUGhKeVBFZWNhM0ZZd2kzTHFYV1lzOHk5Y1JMTXlzQ3ExRmR3QmpKaW5pQmpkU3paaFBlSzN0RjMxQ3Nla3l0TkdaazlFWnhtYmpONmdYSENqVUM0TVM2bDNLcnN1TjNpYm1Kbk00WWllSS93QVFXa2JCN0lLeWt0TmNGWFAzMytaZFJmNmIrSzcrQWw4S1ZLc2xkWmdkRUxieE1MODdoYlVYaTdPQ1lvcG1rc29KWTNUa1pXdG02eHlNVXJIaTVZbG8xczZpNXNUbmpnbHkxUmZjSUxwVzFkYWdCQjI4WGNWSWc4d2xiaXptWEN2R2lXWE9KNEtxQUV0THVNSEpieEVoMEozT1RmOEFhS3hYTnpUQnJpUERodVU1SXJadGVZc1pNczQzRVdOQnhNcm0vcUZoU1ZXcmdGOVFIYUE2WXJTVVhBaFhBUjFkWWxtRFBxT0RlNVZ1STQyMU5GbUhxRDFBd3dZQVlDSFhVSzR6TG42aFVQTXFiMUFobmMxOEpQVTFOSGNTL0Z5bjRKcW1WbTFnQStKaHYyVHhIdVluRXlwZFI3NmcwcGlydExJK0pwaks0alNKQnVYWm05REVQZFRJa1ZCci93Q0JLdG1jcFFET2tFSE1NUzhTK3BZdzhTNjRnRmlucU5ERXRLU3ZNVk9va0ZHV0Y3RzVjU2lFQ0Z6RUpqeENHR1dFdGxYQ3V1b3pPb1EwYWxnMy9NUzR1QlU0aURGUkNzcEREcytJWVJoZkpCWkw0STFna3NseXJ6bUNVR0YwUzNMVzlETFd0K1NYeFhETXE3eCtZeVd1NDZnN1VyWmU1Vjl3c3N6NmhrVUY1eEFNa3JpRkZ1eHljbHgySFZKakt2aUcwYlkwdUlPajRYc09pQm5XVjhXLzZQTXh6Y2dPNGdjTGVxSEg1amVVcWk3ME5hL3pCM200RFgzMUVLWXRiYTVoV0hiVm80cC8zQXdmT3JkSFB1QkNsRkt1ZzhZbnBTcUlXMXdWcTJxZ0htN2tJNmd1YnE3aXV4QldLTnZVYlZYSmlLdkZodSs0UlRUdTd2YkFNSjR4RnExcDhSdEJVSzRqR1B4WHdFeVR3dmg0WmMwNWVaV0hQTXNxRUg1U2I4UnhtY1pnb2plNVMyMFFzRDRLYXpVcUV2d0dOeFM0NVZxRFRWVHg4QTA5VE53UUhLYm5FR0xKRzZ4RmpyRXVwek1CTDdsU2JUSEMwanZVYWxQMUVTb3QrS2l0ZTdsLzFJK0k4R1dMY0NNOFE4WUdMcUJjc2FsVlVJcVhGVFR4QjM4anlTcUNVdFZQWFl4eHJTMWNxU2pWd29qc2NMcTVSbjVaSE12QnRnclZUZXBYRXlYRHNRQUMxdkVLVlVtZGJncG9NK1lyYldybENvUFdZdENrZVlrMlkvaUVkcUpRc0Y4TUNMTTkzRklIN2drdmk1Y0NxZ0lXR3lYbW9pYUxBejRsanRnc3ZpQTN6NWllY3l6S1pnVWF6RE44TlJOVmVHTUNqY1ZBQlhiT0dkcGxtZUFOc01GR2FvOFJPRFVGRUQ0MTVsWEFoY1lIdytJSHlRYmM0K0FOckYxTVE1amd4K3BsTU9UTUM2L2lXdEU2cW1NVW85eGQ2TlJjdUpmUWpzRXBpcW1NbFFkYmxXYWowZ3A4TTVka0YxcmlXamlLdVA2K241VWdVQk9JUVp6QlVINVBNQW5Hb2k0aVZNOHN2VzRudU8rY3NXcE54RGRZdU5WT3BVNzlRc25IbUZaYlFPMlpNdSs0K1prckwxQjRGL2lWVUdnMnlrSzVpcGhsNWcrSUFkVEpRRlZEYkRNTi9BR1lvcHJtT1M3YlpJVmlKZUFnaFpUZHFJSUVCVEltNFlwcGF0THlFVkFGRmJkUzROMzVnVmlMdVpRRVJwSEZNdTJQOEdPbUZyc3FBN2Fwei91RjJGZWluanVWUjRiMHloVXE4d0syeDFVYTZDV1l5SHFHR3hxNlNZUG9Rc0lKWHBRcGNRTnEyVlArL000SkZpZzNSR0VnQzZjWCtJRnRGTjRWVUJFRlFzNWlDcXFXZ0Jxb0pRVlUzM0VFT2txMEZJTHpnVGdLU1g3dldLZ0NRUmViTndJcTJDVmptVUZiam9sd0tVSEFZaWlxb3NzbHpqcjh4RlcySktyY2RzSUVxT3lzTmtBMjgzWjNPN1RraXlWcGlnNTl5OHk0TnplOFJ5UTh3YWpxNnVDNWVweEQ0UEthbjJUdDNCYkQrMHdVdFRtc0VYbHZVeWJqaE54d1M2TXh1czRoaWF5bFhFT0FnWEZxRnVmcjRYaVhVV0tHWTdpUVRVU2IxR0w4enhGWDh4aVNvSmdtRHkvaUFORW93Yi9pYmdUS1ltTXhtVm1wVnFpaXVJZG9LaTZGeGFjUmt1dFJUSDhSTFF1b3lBMk5iNWloUURrSDlvYVZWdng0bGc0V2FjMUtCZ2wzbkdwY3drTER2d1JKTHBiRTRsWUVzQnJsaW93RS9tS2FkTjFmOFJvYlZ3L3hCUllLY3VHcnpoQ0xRV3ZQRXFYMzVqdDB0eE5MS1E1MnhEU1M4S1djUWFYY3R2Tnlnd0MzbDNBdTM3bDFoYWVwZGpzV0pTbC9NV3JFdnE0bkZFVmg1alFmMmlodElMWVIvQ0FmOHpDOFd4aUNJSWxnL2Z3akZFcWp1SDVudkVDVmNJazBRejQrSDRPL2haY0R2NERHRE1NbWovTXlSNEl2emw0ampuWGlYYWErNHAxbVhkT21vTHBhOHNLM1F3R2poaVd3bnNndS93QVZFZmNkWWxkSUs0Z0I4UTNNd1A3bFd0TUxubWFVMUd4OWYwa3RzUFVxcURNT0lGc0NCWHhSS3I0Y3lxM0dNSkNYalpETGV5RTF4eEVwZUxJdWFoVnkzN21FRGVkUmdNR014bW4yNUNJRm1VdGlxalIxTXVheEcxektzNElqcU9PWE1DRDRpeFFYZlVFUGNKbXBraHBjUFRBV3JlL3pHaW15K2VJdXk2M1ozQlZvMjZybUlTcFRlQXpLQW9RWkNHMERjUmhXTnFMb2xBalNhajcxdjQ5d1U0RmN2VWFjbUZCckdwa3hZdk5uSFJBTkdVcDhUVnRXZng3amhOSHQreU50TlhuZjdtalJYOHhUaHhkbGQvalUxQXFHTzcveEtoVkMxUnhCVVdneXVIMVhVcFVkY2NCR3lMUnRXd3YxQnVDaWxwZGRGelE0eks0d2IvQXpYdVlXN0Jpdjd4RU1KZDBHcW1RRmxkdWpvN21ESzR5WS9iTWhIbHVnMmR5MXB0QTRtUzI0NmdjaGlPdFZmd3F3UUlId1JSVEVFYU53VUxMOFEwNkJzaHd2aE9tSWJyOFNoSzVnc3ZxRFpuNUxHQjN4QlNHUEVTaXJScWkrRnh4dUg1WlREU3k4eGNZdVlyeVpVeG0yNHNyQmNZcVVodkpvamxydlU3SlpEajRWZkY4eFJvc0FDdUk0V3hXNXg0ajBFdWRhSy9MWlh3RXJFRDVwS04vQXpPMlc2SUtxNGh4bUJLdGdYbHpQREJPSWxZbUxVdGlvRjU1MHk2c1hDV1BKTE8xVjVNUVJWcmR4QWlUZUw3SlN3UWlaeEdaUURJOStJaGZ0bXp1TkNQTmFmeEVFdXcxbUZsRmkvdGxjVWJObk1HckNXTjRsTFlIc2pBVVVpQzZRWmpyWmJ6Zk1RcUJXeFlqZFlJbkFsMXRIY3VteG9JbEw1N3VVRVJaZWE1akd5cHE0eTdoNDNGdGJVR3BaVXNOc3VzUkFKN3VBcWdnRzI0cmY5NHFNNzVYbVZGMkhORnNvVUJBL2NwdlA0bVNqTU00WkZxR1QxRGlFQ0VQa2JmRUlSeEwrR1B4dE00THRnclhFUEN4OWJsNnZIRlFVcjl6amlQaksrSW1lTEUxNk9jeWx2VFQzRzBBTmZxQm5WTWU0cG16RXdNRFJ6OVovTVRPSlhFR2tpWXFJT29sUkJ0Q1VlbU80a0JHNDE5WWZpdm1nRDFLUDRtSWdncVlRbkc1aXBYOUNYeEV6dU9jVEUzS1hFcWZNQktXbUk4bGVZS3Vabk1RQzZPZk1zVmRrWkxxdkhtVUlBSUZMS2l4Vnd0dUpnc3VJWjdpNGxFWU1NeGp4OERpQzdoZ1Zhay84R1VVdWtHMm13YTRnc0pwYmNhaHZGMXpuY0lYSWRIS1FpM0ZxWEdZZEZRWU11QnpOU05uQ2NlR1ZSdlJuQnFBUlZ2anhEQm11SzRQRVRGbkxuV1BVRnJ2UkRCYTNpSTN6d1l1YURaZjZPcmxSWTIxbHN1WHBWME5Hb0txV0ZwYm0rb2hFc1I0RFhpQUpWZ2J2ZzZpVlJHeGQzaGZKS0VwUzZVYXQxS3JXMTBWMk80aDJwTU54b0ZEblM5aHpDNEVFR25yeEFOS1Y1enp3eXF5amZPUDNLTFFXTGw2WTFTWkRXWmc1MUx5WWpyM053TGx6Z3ViRnpMaFF0T3FoQmVZd0Nzd0JMQzE1T0k0dDJPRU9mTUlBM3pjSC9kUnhmQ2VZdVoxekx2Y1hOUTJ4cXJOeFpmeTl6YXhidURwcW92N2xJYjMvQUI4R1lGdVdNdTRFS1hZbDUrSGNWUWM4VEx0OFhGODVsR0kvTVhsbHJRWWpwbzRqZ0dzeGNyM0twN3I5dzNpcXQrUGdsa0g0b2VabHl5eWFMM0tySWU1Z3d2S25pQTJ3ZG1YekF0dXRjelBxQjAzQWJ2bGlaOHNiU3NmaUJNTUZqekhObVlxZ1hCcnhBVkNyZTVxS3J3dDFDTklKcytmTUFFUVZocHNmTUlSczhoeEZCcFJIWTAxRzhtWG1WVmthN2dhR0N5eHU3ak9nTkpwaUJYTGhibHdGc0lGYm9xUFNZSGhndDdNYXFGc0trU2ZlSUJyTUcwdnRpcWhmTEVnS3pRbG1meExKZ21LaWhLNEJhbSs2Z0kwbFh4QVU0SW9QWG1KVHllWmJOM2U1UUxVVm1IOEd2Y3BENDBnZHdQZ2ZOWENWL1JYY2N3SjZnelVkeS9NcmFHNDdkL3FITnN2RTB6ZFRNajl4dHR1T0V0d3U0d0kwdjNNdFpmd1lsQWJKeWJxTklPbmkrWXhKeHFWTjVlSWMzbHpIT2RRMWtpWWlDZFFFWUxIR09vNWh5Y2VJS1RWTW1veURzK0toTjlvaEFRWW1KRE1ETUp6S3hEelB1WEg0cnVVUVhFQXlRWjh3aXRrQ2xMOHh3MUIxcGk3bTlGd2xWK0NKaGtjcTVxRWVvVkVzRUpXNnEvRXpLZnpGdkVDNVZhbi9BQWlpNGxDM2srZlNaMlRDNGR5b1VjQmNRbHZDakhVU0F0VU9PNVM0djNLMmxkNldXQXVSbGlOMWk4UzBNM0hqTVY2aTJ4QUN4bTZNUE1WVlZGbkJ6RkJMU1ZBclp4dURZV1pNNWprcCs0QktIQnZzanJqWml1SURRS0RWSEhxWGxWdG5WNWdCREpxdDdsaXRnR05adUVGSGJ6Yi9BQkNZdDB6cjFBckJacWcvdEtTZ21LQytvRk5DeGZxSXRCV2dTWkVNbzVCdVBCM3pjQlkwTUhpSUNuUm5MekV1S29PNXJtMk9zMTZpVkJjc2hoZWJpTnRmY0FOQmRTOC9XWUpRT1RjVUdDZ2lZczI2aUlOVy9obDFMa2haT0x4RnFEeEx4OERHNHdZTUt1bUlPaVU3MEdXQzBiYXVIazJkVEpMUFV0WTdsZVlBMDNLV3NLRU5Oc1ZYQWllNitEZzJkVGJNV3h1WldNQktHbmlabEVDMVhFdllaV0JISHFOS0dIbVd2SlYrTi9Dd1lSUU14VlhMSjB3Wm5UVUdWclVvVW9kWmdWNWlYdUFRQXJ0N2xSN2lWbWRncmlHbUlDR3FNWmd6ZlVIUGpxSy9VZjhBZFJWc2dERWp4RUZMRHFzMHpLQUlQMHdyVVVvVityZ0RIblFjSjFHRzhacC90Rk85RHNkWEtVQVUzak9KaFRKaStvQTBycEsxRXJxb01LVnJxS1dPSFVwYlE0L2NJOHFkMUJiWlBNQkN4VHh1VVhFWEZXZTRzQWJoS0NvUFVQQ2FxMDVnRjU0aUhVWEhVb3R0eHpBelppdlAxRlFVSTFsWUlkeHNiZnFFZzF0OHd3UGdPVm00bEVJWStEekNMOFB3VFZ3Ymg1bWJ4SERtQmNaV0JncC9HVElyblpIc2R4d1RqcUNsUXh5MlFBWXhCR1M0b2JmNmxYU1RpNFN4RFIzRjRDeWQ0Y2lQNVFUUCtwOWFnRnhxZnRpb2pGcXNPL0QvQUVaMGJnd1FZZ0tnNmhpRENETHo4Y2ZDK1BpcFdJdzB6ek1qRkJYUGN4V2tLN1NBT3R3QmNRczFGR3NrTkExNGxMc0lLN0FKWmVLaVVUdHpCWlpGOEJldmxNc3dRUnNTOWM3SXRqQjRocERUNmloVkVIVXRFUzNaS1JsZDhSd1U1NmdKNVpnY3haY0JVUzZDT0hpSnBlL0VzUTRUTjZqZCtEekZUWWtIRjJMMmNrSGprNHVVcldLcm5QM0FBSVdMaDZnb0tDK3Nrc2JRTDFhVlpIS0szWmlJS3hGTVpjK1lnR2lJMXJudURwdEVyU2JsQnRwb0hVY0YzWmt2Wkd0R2hxaUNrRUZkRXFBUzExeERuMFZYY1RXWVdTZjdpdVhSdUp6SjZtQ25YaUJXTkRxRGRyVGVvQVpWenFGSER2bU5hQytXNExMVDFFb1R2WkZvbEhEZjZsTFVWd2N3Yy9BMUwrTHpCdTR5N2xnOFhNazFPZU1wQ1V3eHpjV1hMbDIrSmNNbHNmRVdwY3NsNWl5L3pOa3Q0aTF2bVBKcVVzekwzeEZueEhaaHhDTU5zdU9jc3RMZDh6c2gwZjUrU0RVVm9JZ3p4Wmd5RlFBenVwWUN1ZHc1V1hqbUZ2UkJyTWQxS09PWU9GVG9uU0J4QlJLRjh5blBBUURrblJBYXhxWFZWbUtzVXYzQ1UwdWFZQXlqaFNMVkxQVEd4U3daVWRlWUVYVG43aHBRWFJMZ0Z2dVhiZDJjUVVpMDNLTGpSS3kxRUsyVkxLQUJlNEJ3WXJsZ010eGwyTE5oR0kwQ3U5c3BwWGpYbUJUQ2pBNVpWcmpCRXZ4Q0ZVaXhTNEtsWmx6NGlCS0N2ekxlU29Yb2pndVdTc2d2MFN0UUlsRkVPSTQ5L0pHUHdmQjhMKzVWRXlZTGV0VDlVR3BZa3pHdHRWQmVOUzdGWXNoVnU0S2laeFV6RDlTOVlqWWpjVEZhdU5CYmlzVGN6SmlXcVU3bnVMSEFlSmExUit6SHFZcWM1bFJLWTBzbzNIRzVhZVNNM2svRENScEpVb2c1WUlnYWh3VFNlRXd5NXRCaTRoZDI3K0VheE9JYXVPZFNybFY4T2J4RVRMaVlZQTl5eGpqYTJ5NWszS0pxQzNBZ1JQZ1lhZmg1UncwYm1Yd0daMGdobHhON0hUQXdBMm4rSUJvV3Ewa0FCYWltakZ3bzBBM3RqR2FSREpjVlVUWUdPb1JJN2c0YzRoSTQzbUNiTmtWYmxPcVlHaHZUc2lOdTd3eEZqbE9QTVN4TmZyTUROSmp1SWdWUlhFQWphWGY0bTR1d3JFd1hoRnVzUmJHbSthcUNyS0c4bll4QlNtYXh3SCs0RkZVS0Q2Z1JVdFBURlFxcS93QjRxb2hnTVFFTHUzZHhCbGJaYWhSaUdmMEl6bDFTbmlNbXJpcVhqeVRGUU03bHdWTmZxV1lZZUdLaW1sNHpxSlcxV1Vya3Y3aFlZR3ZNTDA0cUNPZUNYVUxlQzJhMFlYUkNGb05rUEh4eEhYY0hoaWZGem9TYnBnY08ydW1LYmxCclB3QzBqbk1WYWx5NWN1Y3h4SE0xZHpoT0lyY3NZZTRuZk1XMm90RDU0bE5zZEVLQWppS2xVd21JYTZIZlJ6Ti9EQ0xGRUZ3VjdoejVobzhRVVh0WWJZbzBCVmI4d0x2VTVYY3lSQ1U1WWF3Y1ZVcXQ4d014TmZ4Q3lrUTQ1MUJiaUtOOFFNLzRneGVQTXpkUVFYSW1LWldwa3ZpVUZWWTRUaGdnSll2VENGbExhUnBJMWNsbWJMdUF0MERkMk1TWXEvTlJRY1pHS3FqK3BnQ0plUkN2cUsyMnpxakVSVGl1SVdBQWNyV1lwUURiMU9jL1JGcHRkRUlDNTdzcW9ERjdZZ2dOSGxsQ0tMelRxQUhBcnk4UUJYTWRic2dLV3Vlb0s3SFBjVURkeEhiRmdRbFRmd2ZJNWY2TnNTVkdEODVOeTh4MlRVUmtlZW9NOFlJUFVxaTkxTldCYmZtRW5pWHlaaDBjOHg4UzdtZEtwT0k1RU4rWVBGeWpZMkJMQ214S1crNWd3YVRuNERFcTl3SDNLclJpSVhjMzhTMGNHUGhmYnFEVTBKcERVMCtMenFEbUdZRlN2amlYeE9ZdnplZmdNUVNoMUt4cVZER0hENFZHWE5MSmxjdk5LZytHYkJCREJUREIxQk5OOVFFQmRjZHkxU2dPWVlxMmw2bExkbHVibGJSVXpJRjZvZ1lHVzdERU11NWRqQzJhbHBpckg5UjFUZDd4TnFNSDhTMFU3N0lJTjVPT3BZWUdxamlPRHVvR1ZLS3o0aWdoUTArNmlvc0txVmFpWDVJNEwwWEVhTm5pTE9Hc2ZpWnhHM1BxSXZmMFFRUDBpdkx1QmlaWmJjNWx6TERVRlN5R0d0UmF3SjdnRG5aQ1lGN3FvWlp4ZW9GbGM5UnBhdXFsekt1dVlBaFJoTUV0THJXSXFqeDRnVVB3Umtqenc5ekFRTGJ4NWdIeEIrcCtYd1hKSENWR0NzSVV0UUFpMnNiaXcxaUFMVnZNZk1kYXIzQjRpNWhpSGMxN2xyaTBSTE9ZaTh4Y25FdXpNMFBGeFpMeExLS1FxaThCTVVhTXhQVURYbVY4Y3hZRnczVUdvQmNrRE5wcmlDM0hjcTNFT1FkRVBNN3hWZ1hyREFKck1SZkJBK25pRE1NdEdvMUJhcDFUbjREQVdsQWVhMUtWTHN2Y0NuQnFKZEhFQ3JneWRUSnh1Q0hMTFcxd2VhdUlxaXA1Z3FEWW81RTNNZ3dIcUlOdVJ6ZHhvTk5LVlNXVkFLeUN1MXFGU0tXZFF0QmxlOFNvNWJUanFLSUtnd1FOUUt1ak1CNVVuQ1FCdTF1Vld5VXJRYWgxdVdtZ3Z5UlZmUE15aXFldVlGdGpnN1lvVlg1aXRpK1lzdWFmRU9QZ2ZCaVB5b3NQdzgxTVBqMUFqcUVaWG5tQ2xXU0t2UEVjbW80NjNPdk1OYUtkeGJiTTdpUnkzeEJpaWxaZ1dYcTVud1duOFJDOEdzUDJaeEdtcXZjN0ZXOExLYm10ekVXV0xMeEhNYk5sUjJESmliZ1lTSm1Bak9JTElMaHVsaVZFUk1qUDNNZUNha1ZFVmhDR3ZnS2J1SHpjc25yNDQrSDM4YmNUM2lWaUpOZ05TdVlNU2wyYmlVeGdKWVNuM05NUlpoc2grR2tQUDlITzRZTXdRVGFJMnE4Y01LTW52aU5nc0k4a0FXRlZtN2hBUlZiOHhDRmdQYkFPRXZVdXpxQ21SaUhkZVpidmgwekpkNTh4cHRvZkUxZFczNWwyTFZ1c1M3QkY2WmVoYld5b2xCV3F4N2dDbTcvbU5wUmR1NmdyUWE1alE0QndTZ296V2pVU0RrRHp6S2g5VmNlODdJWVd0UlhHa3laY3dzVEZhVGhERVVLZDhWQzREazhSUUI1cVd3dDRpYUFVUitvRzBPOCtJcHdYM01oTTB3QVlRcUlWYmQ1eExYYVVkY1MxSHArMkMwMWl2TU5URzhQY0l4c2Q5a3FLM0tmSi9FcEJxRk5TNTZtdC9CbnhEcU90ekRVRWZYaU9HRUZUeEhMZ3VXSVo4UWN6Y3VkNWF5dTVreEZuRUxXNEw4ZUlCakVWeXFpV3JtYUJLYnhqTUpoYk12Ti9EOGJZSUdvS004d1pxQ1huUkNxeHVBZU16UjhSY3F2dWFvSGlYbzZURXE3cUdnNGkwNnVKVUNubmNzVlUzVVJ4aUlmOFJ6eWtOSE9TVmp1cCtrU0RaVUFGYTl4UTVLZERGUm5BNjdqVkR4QUJ6OWxSTVZMN3VVQ0syT3czQUtTMXhlNGdVNWdnVmgyWG1aUzFWZzBYVzRsQlRFQWFNZHN5YVQzR3hkbTlCekxMWUo1bUJEN1lxM3RzdUZZZGNTNHZ3d0x6RHVCVXlJUStML29OeGVqR3B6cTV1RTlRamRnK0h1R3U0TmU0cTh3bGpLVUVYdWJLb2VHRGROWjVsRzdJbHdXUjZ5SXRNVXN1WXBVdHlNWGlvTFRReFVRUTVkUmpGUEVHRnFyK3BqR2FqbG1CNHhpTFJpSVZDNHhsWEhXSUJNeTdES01HSEQ3bEFSNmp3UllKZ1FXb1FMK0Q0cGhaTnJneGpINHV5WU9JK1kwSHd1R0RGRml4eDhsVTJnc2h0bUdJZmdjUS9FdzVnejhCRFpLaVJ3V1BIRVFNU2NrWmtBZXVJbHU5UkZhODdsTU1GOHdYREthR29YSy9UQlRUWHZ1QXBEVUhWaThYRUJLUThRRm80aU5YVDRJS3FaYW1EVlowend6K29xS1FMOHhpZ2JYTzRGcW1EZm1lckhNSXVuSGJPaUl0cmNhbU1BdW9DWnhBb0lJaDFCYmppQ3FQMndvVVlDSkNnWjdpM1REVUtOT0YzQ3hhWnZVRXdjUUZLUzF3U25icnd5OG9DOUxPQXhzdTRMNVRQWkNSclZQNGkwYitIdVBoWDB4YWRQSFRBRzdKZzNpRUh1Q3hjUzRnT3BubCtHRzVOSzZkUThKY3VPV1gxTGlyR3lMTXBhd290YzllSVVXTVIxaUxXNWRybVZkQVFHRDdqZjhBTVF4QVA4b0k5dS8vQUgzRU5zTWoyY01ZNmdnZzRncUdiWHhCZmk0TDQxTE9KaE13MkhpQmRWSzFpb1JYZHV1b1dmVTBVNHVCQ2g1OFJQY1MvdVdRS0h5eXRSckdKeTU4d2R0UlRlNGtONzRncGpSRlVoTUd6ZmNhRFdZS3E5UkwrNW9Ednp1REdMcjlRS00yUFVlbWh2Z3E3Z3dwQy9KREc2UHZjUys0Rm1RdnVLQ1UzRUZoVHBZcHhUWEJjWE9tWmx1cFdnTDhiaXVkT29Kb0tRd3kxM3lTNG9aUDZGZ0ZRYWp4QmpGK1hmd2xrZFM4VGNMc1lSSDhxVWZjckdJRkZUSm1MSjZsM3FjZU9vRjVFelV2YkN1SE12YXJuVHAxTURqam1hbFpoOS9jckkvMHpJcXI3ZVprd0Y4U29HcUp0ck54Uk1rWFRpb1ArOHYyblNPL1h6eE5FeUtoc1dXZE5aanFvOVI0SXNFMG1FRzJhaEx6Q0h3bU1RSXpueEdQVUpvbHhsa2MzT1lPWmNYdVdaWW81TlIvY1VXWnBpSnZFNWZEUDRpREU1UVovb2pLeEVqY1lLT01NSXE3UE1maFRGV01vZ29uZUdDUlFZQUdEQk1NU2xYWnlTdzVzaUNmNGdPOThWS0RoKzZtclJjWEYwZ0V5K2JJZ1lqMERKN2pCVmtBM2V2TVp1akVSMzhjUkk3eEtwYmtoRXpDQmt6QURYY01hUTZqelYwOHg3cTY2WXE1ZGZ1SlZXMWNORmpmaUF1Z3pDa0pveFZRUWdBcmtJamsxeW5FQXR1ZUpaUlVwN21BYnBURmRUQzFXTjFGQnlaNWk0SlR2cVhZR3h6QnNwMXd3WC91SXFkMUM4SHpCKzR2VUh4TWNmTE5TOFJaYWVZYjdncTZJbEV0ekV1cWdCWVcrWWpvZ1IxTHlxeGNSenJNM1J1RnlqbGJsY01CdTVPSW1FcmZNdmsxTFBHU01kd3dadURJaEhCaXFDazFOcUlLWHpMREVBSnc1akZJb05RTEJyV0lGTlNxaU4wL1V3VDFFdk5hbGxrbzB4TTRNUXdaeGN5d0Z6Yk1CZXJsV0oxUHJxWDFpcHRReERNSHFDbkxlWWxDMzFIT09YZ21ibmNVT0ZxWUZ1NEc2MTlTemFOM3RnMmh5dTVidlV1akMyN2lGV0srNVRkYmkydzZ4TStnK1dGcFh3Q2lDSVE1YXorWXFXWWw4M0hjQXUrb1ZSakdLd3VhK2VmNk9abzl4eHZFM0tqVXZtTGlrV01BbG9QRUZSM1E4U3E2MTVSSEdJNTNtYzlTdkFxSjB2bkVPclVHOUpneGlLdkh1RGRJNWhuZk1vbE5pNXhOMUxlNEl3WTZodmlaY3B2dUNmVGlLV2FrRERvZjRxS2Rvcmh2RTNIeHpMK1NXb2JMeEtxUGMxUjRJOEVIQkJjUXhMeERNeVBjdHpENENKRUpWY2JpUHhjNCthejhmY1dLeUxGekZSZ2kzaVVWcHVvbmpjVi9VMitMejhSQlRYd01HWnovQUtFYUlrU1B5eEtDR1pVVG1BV3lWZmNyYkVjbHhyTmp6T0xYbE13VmxIc2cyaDk0anZmbmx6VGk4eTdJVTl3WFA0VHNtdFRYQW0xWDFGbjM4QktxS1IzS2dkT0lyRE1SUmR3VzhFWWJUQjFBdDBJYnNjNnBpRkZzd2JxMGdOWUx0NGdBRXgzNGl2ZldiTnNSdXBwV1MrREZ5ekFMclVMMHI2SlZOWHZiV1phWUdrMVZTeGRuN2lQU0VTYkhCd2NNM0wxdUttTm41aFRUNWdxV1hVRUJaQjZsMzRncDUrTGd5ODZ4OEwyUjJjL0dyUkl0dE1RbURVWHRtSU5iaXBIeTZpWThzRlZtNE9mNElVS3ZQaUN0dHhxclNCWDNCU1hrSTZVdW9xUmRqRmZiYitKeEF5UVY3Z3lRWmdGS3hPVnNlZzVoVEhVMzMrWUswYmc5eXY1Z0pUS0RQM0VCYU1FR0RzNGhoQml3MGlmaVVyblVTMS94RThZbHptam0ySnZPYjNFcjJ4VTVKZGxjeXkrNHNHOVFvT2ZVRFRlRjNHdHFZM2VmTVRpbHZtSmQ4MURacUFybUw2Z3JoYWN3VTBwQjdYQjdRaUZtZTJJS0FJVEFEaGlzS2k0NGlRdDRqQmNDRUtxQmEyeXJFb2NOUmpLdGhrbFZIWHljUStQVURpMi8ybU9zeHVHRzZKZUliNWlWRTYvM0U3NGh1SzJ4TVExNjhQREdmb0E3ZkNkVDNGaXA1YmxIRU1jMHp4ejJsOTVqeFo4akxXV3Zjd2JBUE1hcXRIc2czeUw1am9jOTlSMCtlNWNxM3ZTcGJubVlWK29IWWp1b1l1RXF1Zmk4UnhNSlo1UmlwM014SGdpeEZDT1lPSXM1aWxRaHgzQWlUWk9wVVlTbUMzYzhSeExvOXkxWTZqWGMrNHFsRnhFenVhUlJxOFl1S21Qd3loejhtMEVIOVR0VVlrU01Wb1hIYi9VYlJpVmcwRzN1Y0JpT1pDRlhacUt5RU9jZ0V6TlI2RW9JQ2lGQVVKL0VXUkliSjVRTE53WFVwbDNjRkJTSU5NclIyWWxJejVsSmx5NWpXMVNWRnFydzdDTld2UkxLWGpxR2J0cFlFQU5hdUFGTXFsVzN4VzRXd3U2NDVsMDZNOGRSUHBYbURGMTFxWkFNVThTMjFYQnA3Z2JFdXRWZUlLRXZNVmxYcHJXNDlCb1lRMHBkOE1IbUZHOVdOcXAxM3hMT1R5VEJuSktEaGhmVUw0akFwNUlOK0pScGwxb2dsem1KdnhGenVJRFU0YjVtVG5YbVVIbzZJNVh4RnpuVWViMUVvU1VySlREV2NRTHl3ckxpWFIzRlNuTXI0RjFMbWJiVmYxTklNektVQXFDb2l2YkRSZFFRNHVITk1IbWFhekNQQkQ5d0xUR1c0TVk0am1yNmdjb2pSamZVVTVLNXp6QUJ3YmpsRlRBczVsRVZYMUt3U2xmVXplRnRnMXVDMkFSeG1BVWxOek5qVXoxRVJZNWpXa25LVGJ4R3dnNGNSTTUxQXJVQ01ONXFMcm05eXhwcXVZbGdwWis0aE1ReDJvaWlCYTZsbHFDenpHbmN0ZTRLVWVKVUdZVDNHWE5UaUg0bFF6cDM0akE1U3RUWnU0aG9IejFLbDRQNWdPRzRFNWR5M1diZ05XTmN6cE9NelF0NmxtUTh5aE5mM0tWM0k0bVo3aW1IVVlKU1ZVZG1ENmpuK0kyektwWDZsZmR6RFZLd0V3dCtJOERkeWppdWFHaDFIV01zTWx1NHR4enFQeTduY1hHSXQrU2JmVU5ON21pWEJIaUxFV0NKdk15aXBTUjR1RDFNb1Y4WHdnckhQeFVTQ240V3hwK0RFdkxpTFRGNkl2eGNBYXN6RnVOM0ZteUt2eUhERm1hVHROSm13ZjBaaHhqS3pFUUZtWWk5dlJCRkJSQ05hZ0J1dVlBZjNpbkg1aXN6Q2NibEtTREg2Z3E0WTFxWUZjeEVNYmdyRHVVTzR2S3JKMmZVWnFvNTJJdExucjRWZ3Q4L0ZjUFREUWJ3a3ZTdU9lcGdqZjNFQW96VUtEblg3aVJRYkt5U3MwOVMyN3VnNWdsNXk3aW5Ea3o5d1MzWVNtMU5Fc0F1dmNXbXA5UnJYdm1VQUhKZUdBV2prT1NKckRUSEFwemVmSHVVR2ptdFJVc2J2SHFQQWxtanhBck5sOXppVjZZUFRUMHd4SEpNblgxTGZEQ2puSkxLdURmK0dKVzhrUnJVVUpkNlB1QmFaOXhLWGtpaE8xMUtLM0FKUk15bVgyK0ZqVUdmTXEzcW9ndUREQUxxbnhOVEtBWkdJWU9MdmN1UzJOMTBaam1ZUjB3YmhZTmJtV1Z3UkNURWo4MEhFR1RpRGxsbUJFV2M1YWhBWGF3YWdtMUlwUUNITEFOTWhXM21PV3FzWDFjZHNxQkhDcVp1Tk5pQmdheEVOMXFVbGhYbUJLcHRsYllBUnVGYzl5aXN1NERPWm8zaGxOWHpOektwUE80bGJyb2dmZkpFMTZoanpFczgzR3NoZEZzeVZ4dVVmalVGMXNoWEhNQzFwWGNRM2xVMVRBcVdubUk3UU5FdGNNT2VvYzl3ZnFaMzZsVE80a0dZYnVFUGlpNTBSb1ptZHdxdWhFa045UnladjFFSnRmeEFsUmdYbWdsNDJhMWZFeENkTFlvMWQxQUFIOFFaVXAvbVdkR1pNSlZ5alFwcWJZS2w0NmkzTzFWTWFZaCtJQzBqdHpjdVVzUUZUbUhqRlZ6RnVrSEdwbjNDN3hGWGw4UmwxaU1kbnVEVFh3TTZ1TEZ4TG9xSzJCYm1XN3pORXdFd0VXTnhacGd3bForQXhWQitQU3Y2SDR2OFJBMFRtS0JIdU92TTBSU0lDTGllbHh4aUpxbmNma3psQjhSTmZpUGpyOEdhWXlqWXplTGxLcmhnQUxsbGVJQ3hYbTRPUTNFV21zUWIxRnNoNm1Cdkw0bHRCWWN3a3JUZkUycWIza0lsSFlRRjFWcnpCU1VaN2dySTVpWHY2alNOb2tUcVlOdzh6UnRQVERnbnpwT3pFTkdkTU5DbW00aWh4NGl3cTcwUk9hZ1ZBeTczTExhV1NzYk01ZzAveGlXWGIvN0ZRdFVCQVZtcXFhQWw4UzBYVFdpVlRJSE80dE00OEVGTlZRNmU0Z1FUYkdvaTQ4ZHdzUDVaVE5GYzA1eExhYXR3d2RRWDRjUW5DNmRPSURoejl3eHJadzNGZU5QY0s0d2tEWEpCc3puekJIWnFMZUtZSFl4VTBWREd6UFpNSG00b2JTTDZRQndYRlRCUkNOM0xTaXNkd003TUZlaVp3cEh6bjNVQ2cwMXRKbnJCRnVORHhFSlRZeWhjTExBdXE1ZFRQR2pVTXNOemEvaU1XSmtXUjRBZ3VxaXljRUFvbWV5WnRtS2xucFp0aGxTMWV6bUlZSFBIZ3VVcW9qamZxQ0twTU5Ha2lEeXF1NVFWMUJLRXNuME5EN1lWRUsxMXhFb3AzS3p1STNVTkIzTjZMV1pOUlk3NmxBWUxjNklkOXhGeEVxeFJpRDdpVUpyM0FyZWVtV0doYWlYTEZCYTVxV0ZPSUVjY1JWR3diaUdVR1VsbEVzbDhRTW5NcXVLbkVYTU5LTUdERStDRU1FTmZGelpoL21CWTVlWm51TXZjZGlqVmhDME9BN1EzUjE3alBjNThFU05PcUZsVDBZOVREenhjYS92SzBnbkIxS1lsdjlUc2ljUUtpbzNOVWxWL0tMVHFPTnVJczJmRnhxQnVjeFV3TE1RYWlZREx6RjExOEMzMW1OQmgzTnNRVlp4N2h4RmptT0xaWkdGOFluRXdMbWErcFd6MUhTU3dJOEF4NUljTXVvT0lKcURtRDNCeEZMbHdmbWlMWkZuRXVYbVpUbU5Bb2x0WmpxT2JyY3JFeEVidU9kYml4ZjZCNWZPWnZPWHpiUjNNQjZqNXpDQUFCUVNpT0Z2MUtHbWJIaVhUM0gvNURhdHhIN2lwZ0pScUlyYmZpRE9Gcjl4QzlRRmxHM2ppVTRxMmJhckdyckVBNE1STTVJdE1iT0lpY3cvZlVUdkVxeDRDSWIxRVN2NGdHVmZobHpjaDhVdGR4amVvaXk2eEw1cFduRndLTDI4d3FyYWxRYnNOa1ZpNzUzcURXTG9lSmtvVEc2aThySlpnTFVvcGxyenpIWW9WUnh4RTJMVkVhQ3B2VVZiYVpZZ1dlNEVqalZzVkF0eDBRYktMb01RVmEzblRkWWlwU0o0clVhcThDbTZqU3dPK0plaFdzMC81Z1dGSEdTY1lXNnBpc3h1S3R0UFRBYWMrOVFEYU1MNjNMcjdsbmNjY1dWRmJsSWcxZFRKUWZtV0JrcDdKbXd4VnBZVnpBTWwzQVZXWmhhTytJQzFLeFRsWHNFR01mcUs3UWlBNXpHcS9kTkZZZEhmbjROemlMaVpiaGlFQ3lybUlFVlg0aXRFY3hVT2N3bzBHK0dXbWlDbkZYQjMzS2FNUXErVDVXb1NsMjdxSUNCWmNBV1pJZzdpREVUaC92aU5veDl3ODdpdHptVlpmL0VCYlhFb0JzUjRPSms1WmJIbU1OT1dDMkd0RzRpNDMvRVUrb2xEVUxPdnVYS0g5dzBsNGxLcWZtQTNkL2lKRER6bVVYZlBFY21DRFJYY0JpSnNnRlRCRXpxWmVVTmd3VVB3UXpENDlSeHY0elpaRmF2M0tCb3B6S0FaNXhOcUsvbWJCTThRRzF4eGlVRmxjRjdqYm5OcGpQNzVnWDl5ejFVWUFyZzV1ZFQvSkZ2cHpQTVZweGNTcHJHWnlETHpFdGJrL2lVTjh4eHhLMGxkUXhyNFlPTlJCbEpZK0pRTUZlOFMxNndEdkVRY1VXNXpGcGxpL2N2RXUyUHFINGpWYmwzdmlYYmlMVnlydGh2c0dLbVlETXhFZUlzUzhRY1JaZ3NFK29zd1pjR1lWTDdpNGl4ZFM3YU5SZk11b3NVdGkyUllPSXJGM0hPWmRSQnFMbUxFZmdweXI0YzV2ODZqREtSdDhCekRORlJYUk1IcU50UkwzREM4dzF6dUZNZnhBTk5YTXFZMWQ1NnFDamI5U3hZL2NVVjIwa1YrY1FOblUwcHlOc3QybFZ1SUhWekNxS1JpVlJRZERDQS9wbFdVSW5EQTFrTElndUhNd2xjbjZnWHNDNWFPQnlWRllqbVp3eEtna29nd2c3dTh3c0NzcFRGbDVsbGw0NGlGVzBzR25IUGZNeVRPWG54TUtaNHpOOE9uQkNnM21MYWphTXRvSzl4bUt4NGlWakVyUTFXbGlvVXRHQUdETmVvdkdoMVhNVzZTSU1oV01GYWppcnkxeEF1MkNaTlhoam9OR090VGtVOVp1RUYvUzgxQktWZTRrd1M5TXptUmV5SUJabnNtUzFwTzQzOTExQXJCUkxsYXFKNVZtVFZoMGN5bGJmcm1WcnF2TERPVitpNHB6cHdPSTNnQ0xGRG1YRk5FYlN1dThzdGJYeXhsUWRPU0Z3Zm9TcnplYUxsc1plV2I5UHFJcUNQcXBYQ2NRM1BDQzRGV1gxQlRScVZWWm1KR3pYaUxGa2F5NWtKQnFvV0laekhnQ3h1TlZkWmpHQ0V5VXdvVXE5c3dGbHZOUjlrVGtYVVEyQ3pLOHg3YjFxQXpZOGFsZ1Zrc2xsVGNIemh4UTl6SEJ3OHdVWjB1R29zNENQck1DMkp5VnZnaHFxMlJPbzhVQUIwRUZDaWlacm1MOWRTcURHWlYyN2dZOGRSS01haTBsa1hoQmJ3a3ByeEM5MUFCcGxObW9OTnpKc2hMZW9lY0ZXNytNcGZ4aVhXaUsxL2VZY1FYdUlGVjhzQkdPUEdyZ2FEMGphcXAxM0JRQUt2TUNnb0ZWSEpSZXVacXZ6WExLOE9qaUN6UzRVVnZHQW1YNnhjZlhPWlg1SmVOM0g1U0xsclh6bzNEOVM4VnhLeGlhOHphdFFybk1XbUlMZnc2eEM3MUhESEJPNVJ1WGNXcmhtTCtab244SllWVEsvcU9tYVlyQ1BVV0lPSWhqQnhGYmlMRXVDM21KQzFGOFMycDJ6TXVLTDNNRVVsNGx4cW8xVnJnbWJ4cVpXWUlxWXNianFjeFJZb3JpbmVjdjZQemlqM0ZLOEM0Tlp4QlRiRjF6RzZ3eElKekJkb3RZcUpXdGU0czVwZUpZNFFjL3hNa3I2aUZ4Y1VHbHJPSUczR2VJTXQvOTdpaHc3aUswaVgvRXArdjdSeHh2aE13S1l3d0l0NXpWTXpRWDdsQnNjcm9PSUZSSDM0Z2J5K1ZxTk9WTmRSUXRPUDNGa294VzQzZVRIaUtqMys0WHMxS2RuOXB2R1NFR1Z0N2dicWptRmdFVnlrTG83OGtMdU1jTVNZVzJhTTljUlZjV1JjcWJpV2xxcFFRRldaVWRONmlvVzc5eEJVd2I0Z3FncTgzY01qeGx6cUpXTHhlUEVvVmRuOTR3cEhLWnVLcTdWN2lKWnpXaUs0T0VTMW5GUmdsUmVveVdGTVJpc0EwNTZjUXJYU2Q2V0VPQTltU0FCTDN3NGdXd3ZFRFVFOXJMTkpSRnJQMWN0TjJJMkZYeTVZcHR6M2lCbW96NUtuT0paVmZhTmtGOHpTVDhRSTZuQlBCaUM0d1hNTm1IY3kvOHFDbEpUeVhMeExIblQ4UnR3OERjZnBGMGtWWWd2N2pVQ09HTW8xT0RCV1pmZDlUWWpLZ3JpSEFYV296eW5tWGF3U3BGNmpQTENpQnoxTjFzcngxTjZIZlVMck4rWUJ0MnlnRFl2Y1FrZjlSYUcvdkJNTUpzU3NtczQxbUJ5Tmh4QnQvVUE4My9BREs0amFzUzc2aVNzcnVtQmVmSmJBdXl2N3pKYjMrWmd1a1dWV3VJcnpTc2JlNGpWc1FYTjFDSlRjT1BFbzE5eEEzbVYxTDRaaEZpYlQ3bDNubTBQalVxRXdoVXNMWEdjdzI0dSs0YkFzSDgrSmdGeWZVR3p0aTVac25GVi9hSVZZMXFzMUdLZTgwTWVCZmhMSisweXhxTWVKYnJodTlWS3B0VTJIK3NZLzdpVjBLMUdMZnVPSXk1UGhmejFMbDlUVE9KY281M0R4RnFYTHpVKzVjcGVJeHBsQ2sweDZuaHFid3k2d0V2bU8vY3RXS2xIWUV3WnFsMWZBb01MUTdTOHdRNWhCRndlNE9ZbmlDWXJKYkxpeFdiUzdpNzZnN2lveGU0c3haY0JSR04xOFJZb29zUllpeEYzSGlPS0xMSEhjelF5L3FXRU1tZFI1SlMxQVhXNWtZV1VqWmlvcm9URW9aQlhvbGxLM1oxQ3VobVF0RzR4c0lwV1NCdlN3QzU2Z0d0eXNVNHpxSVZ6ZFZpSUJhdDhPbzRYRmhrWURlekJ2di9BQk15c25CZXp4QUdDMWRYQXVRUjFmRkVUWVNtK2VJUldBWEhIa2YxTUE2NXFVMXNxQlBhNEtpM3N6eFVmTml3YkRKT2o0Vk00ZGtRT1lnWE1BTEcyV1RCRkxLSHRoYTh4T1FMdUNpbmZCQlRpTGtjbUxtVmlOdW9oV1lSZDk2bGxXWXY5eEMySWY1akJSVVFMYXp3UzF3YVBNdHlKK09HVXloN2dqWlExMUc4MkI4eE9iZlZTbTRNOHl4WFY1ekxFeUdPNVFKWVh1R3V4akpFQVZscVdXQmxXcWlGdEh1QURsZk1EYnhxVmhhT2Zkd0RvaDQvTHNVSUZQVUQxREtMMHlpWTNGQXB4NW0yV0ljVlUzRVBZUVRRbzlrY1ZLZXNrb2tLSEovaVdMLzZvS0toMmZ1WG4xKzQ0N2w3WFVycWREaGxUc3JtVjBOVnVXTVp2dUtGYnVaSUtHOXhyZFlxT1Jzczh3U2xiWGM2WDh5L3drR2hlUnlFT2c4N3ZVTmUydHJjdFN2SlQ1aVZvWDl4TTI3WlZhbEYzYVRYM0tBME53WXNnYzRnS0xLVGNCZUQrWllHcmZNZDhFb0ZERWdZaU1MbUlYdmVZK2VvSWx0WjZpdGExMUtvenVaVEZSdzFjc2xUcEZRT29MVlRPYWZnZFFITHVBYWx3YmUyb1Vla1VtMGdHYXRxVTR5Y1lsK1pCQjlMY2JYZEIrWTVQUDhBMjRLSnF0UnIzVXA5bWppS3NsU3N6alBXNEpKekFPNWNKZko3bVZVZHYwQ09WV0NvT1orcGdtNXQ4Yml3Vm1MM0xwcitoWEUwZkVjUEV5TVFhSmEzZ21HWU43bjZqdFV3dWNTOGRYSGNxRXdtWjVOeFl1Rmk0Tk11S3R5eW9OaExETUxRWUpMeTVneS96Rmx5OFIzSDlTekxjV2pjdUxGdW94WWt5UlJZdkVWTVZ4UlJ4eHh4WWozQXFncThFdHpBY1BMQURXQ0NtWUd0OHlsYlhHWWtsRG81Z0tLTGVZS3daZVlYVXlyUms1bUs2OCtwWWpYNmdGVnBEWG1OUWRLS3lsZUpRODB1a1EvRUd5aG1VVXBnYnpNRUV2Rkhjb2MvK3NiTFVybXZNdXBWQzRHdTRpVUZMcStLL3dBeE5xYjVjNFlsUmRPVzVTRnFjWWFsTkVxOU10WWFyR08rNFNxMG5tV0o1OXgyRGcxY0xISmQ4UE1DeWhDQm1qcU4xSFJxQkhkL0YydmdZbTRtM2lWRnVZdFl6QlpkZzlkd0FhRzViNmwyS3lId05yUXRtcGtLeFIrWXB5dW9tcmE4RHhFV3MzbjFCTXFQVlFSQ3RqaXVwV2h4RXFtN2VZVlpjUGNGQ3pkUUFJcGJ1SzZNZm1FK0ZIVVJiR3ZYRVN5Z3VuTEJ5aU91WXJRWUx6ekZWcFZYcUpacDVOd2hLUGJBbTFmVXk5RUxheVI1QkthMU1Tem5NdDQwZWR4UndROUZpdENRd1JOeEkrTGw4VU53cXRJRFZKQVcxbGlISUZTaG9QVVRON202REMyRSsyWnFGMTFDVlNuc3d5K3cvd0JremhWVkYrWmV1bVdzS1lpcTNHbzI0VFVNcTRyRlFpeHRNd2FCM0Q4Sm15NG1iY0JiY0JkUkMwN2xtdUkxU0YzRHFXTktaNWhEUlM1ZngxTEZFaFdQRUZGUll4ZkVUL3lObFZxVmQzdUp2a09KV0dBRWR2U2JsckRpYk5USmtZcmNORVBWd3NkUVh3UkpWcXJnbEZZb2IzM0xLRFVDdWNNOXdhdHhFMjlRWHFBc0pWOEpqZzdpMGltYkpsSWNFRlJhMStZNEN0VDJMRXVGTW5pZVR4ZmN1M205OVFMK2lISXl6QkZZS29ORW96bTh3ckpiNk9vblRjMnJWaVd1ZGRtYWM2amRsOHd0SW1NNGlQQXhadVpDdGJUbVdicnBGeFUyWWl4enFHc3hmaFlYZVlzUXZBcmExSDRNN2lpMUt2RHpFQUt4RnRiWTJvbWlIbG5BUzFxQUZYbVVVdVdVaXgwR1l5cGhKY1JWQmxrdUZDS3N4QzNGUkxyY3ZkOFF0Y0h1T1V1eUw2ZzJlWXVSdUt5eUxSY3lldmhZc1h1TEZsakZLY1BNVVZSUlpqekZGSEhIRXBvdDU2SVlYanVadkhVQ3NFc0ZLQVpPNDNDZUJmbG1BOWFsV3JtdVlIaUlHTnNrUnBsSUc4dkRBbFZXY3ZtRFRadzNLRVc2SGY2bEhZQzZ2aUtneGlzeG02UzN1QUVVeFdEY1ZSQ3IwamlFMUxTbVI0NmlDb1Y1dlJxRFVLQzd2T3ZVQ3FXbXJmOEFzd2hlZ3Y3R01OSTJxYmY5d0djTFEzS2QxQ1dWVzdTSGJWWjNDTWludDVpRHJPaUpnVFk3bGpWZDVXQWJHbDdkUm8wM0tES20rdTRabjRYUnhCcVVibVFyVUl3NVg5U3l0WEhZWGlXQ2hmRWJ3T3Y0aXBpMktwWm52bGdLNVFsRlRsaW5OdXRRZ0t4WDdsaUF2MTFBMXBnTmlWWW0yOHl6VkN5MUJUNjRpRzYyTVFSVmUwcVZVbzhrc2xDd0xZVUExOTNNQkc4dk1hNHErb1JRV3ZlaUdHTXU1cktoVjFMRUNVeHNmRUFya2ZoZXJORzV3NGExR2NDRFMwcUlGaXdONnhBdUNBRUVpQ2FxVkZwWld0U3hYTlFYeExBOXh3dDdpUVEvRXRLcmxQVXBXNGxsVU1QdHk3NWdxNE91WXFZY1ZIWklXK0MyUzVyZmNKMmFWRllYVVV1WE1ZSzh6dVliYmFzb1lOTXpsbE5idTl5L2FuUkc3L21VT2FtWERVRnUyQU5GWFcySmJ5RXJYY1RDdXp1RDBJRlhmNGpXamY2Z3FzY21TS2xXMTVqdk9JaXU3Z1c0bzZJanB3UXdKV0ZsYUIxQ29FeXgxOVRKcnVKeU9zUUtqQXFLMmF4T3hjUlJYRVhNc1k3Y1VPRUdvNzdOemVZTjZoK0xpb1hFUnlYTDZHbnVCeXZHb3RSaU1zL0RNb05QUVA4QUVSMGFUUVdTMUJWYzhSWDVXQm9vRTNYTTRnbzJuYzVxcnpjcFZmOEFFdVZ4VkRTeFlpWTRnckVUdVpBNmx3eXhGbUVpL0Y1bVVCTjFERDIxR0RwS0gzS0h1TjJZTTRpV3FNUWFJdFlQY2VNYlpsbGNFVytvclJMam1zWmdKWkJzekJpb2tHNE1HQzNtQk1SU3hnd281MUxPR1gyeTY1bDRpNXE3aTVFdnVYTGx5OFJwRnVMaUxjVVVpS2lpcCtKUlJSUnh4QlhMY1VhTlJkendiaXppQ3hFTTdJQWVhaFJseDNMc2JDdUo1dTYxWEVTcnQwN2lzYUMrV3Mrb0d1WG5xSnNjRHZ4RldGQU1QY0ZyZjJWS2cwWFhNVTRwWnljd0ZpbHlHcXJxSW9jMFcwZWRQbVZOYzFaLzM0ak9naldEWGorOENta2VMMnVBcTgwVnZGRXZVUUhnWGlBcTBLMHdDS2FOQkJ5SXU5Vm1PNnF0NWhJdXg0amlsMDZwSWdJbGRYMU5uamw0Z2ltanF5VVEzWm9yY1QvY1JXWUh0aVp4S2F1WFJFaEZtRDVnd0t1S2hWa3RUbW9sRFAyd1dGdCtaalJoNnJjQzJqa2daRjRNTVN2S2NzU0NqZHRSTmdwYjFBbHEzVmtHbWcvTVV0REJsU0lRdEI5WmlseFY5YmlobE9ZVUpkbDlRdHRPTlZLRnhaWDRsWkkvN2pJdGc5N2duR1hNQU1ndm1ZNEcyK0lHY1dUeWl1dDdsbVZlaWZ1Y1dmY0F0ZkVNb3QveEEwRkZHWWduQjZsNWQzNmdtQWlKckVFbEh1R0RGUW5aYThWS1ZnejNDU2dJSmVDL3pDR0dvbEk1TUJlSWVjUkh4QzJqOFIveEdvMk9HRUxLcGRIdm1Xa1NObUk3SmJtSHZHSEdQVXBDOTVDVmkyV1l2QkFRaDI2bGlaMWJjdTdPNEo0QktDRnZCdUtWRmd1OEVGWUhVcTlXcHFVcGJ0dlVLYnU3anA4UXAxTEgzekFtVG1Gamh6TUhkeXlWM0VwUmFTUDVFYXhjaWtJelVML0VCM2I1Z3lhY1pxQ2dsdkR2TXRMcUliclUxbUkzdTRyZnVMT0lsUk5vYXhHaTkyNnFPcjRKYnhsd0swc1BEaGZDeHNpWThJeEhlNWpDMzY1aDVQM003Z2NUMmp4MUF1S0JNRDQzNmkzZkhjcXd2bU13WVdXRU9PYTVsUjRUVmxRVlVYTndXdmppS0ZpNGl6VE1XaUVOQ0ZpSzRDdmlLTjlYRzB0SlJZckJiaWJjUWJta3BtQmZ0Z2MrSTZwS2lYT1hGVDRtdVl5YU15d2lnakZVdURMeDhEaUQzTHhETmp6TlVLS0lMUkx6RmlybHk0bTRzWHpGaXhITVdLUFNMSHppL0llU0w4Q3hIS0pxTzJDaUdncUtGNVlCc3IzSG1pb3VMdUlyTkJBSzJ0ODlFQmREbU9FeWxIQmlBMGpSeVlZQkF2RFYxV2Y4eDBMYXMyLzRsZ2paVlk0aWJXamU1WmlzbkpNSlFPZG01ZFVWZlJlRC9NU3l2QzFMMEFwYmF0Q0t1Q3hXeTgwU3FSQW9hcDEwUW9EUVd2UEhaNmo1dGdGcndFTXMwcGpmRUZLcmlFNHBkNWVvWUFwczV1Y3JCYTVqUzZLclRxVUZ1MUNmOXFGdUYycXh2UDhBbUV0RUZWeHdRS2RZNEwvaVBRL1c0SVVRNFhFRnBkSm4zR2t6aDZKeEdDSjhEVUpzOEVMSmY2Z3JRVlhjS0p5cmpNU21VSzVsZ3NDeEJ0dUt1clFxUGJYUEVvV3RVNDhUSlFZT2U0bDBaNk54QUJiMnN2VkMvTXVLVXhCVk4zRkxyYkxvcEc0amdDcmlnbE5FUEE0SUFDbW9BT01GU2pyYzdDK29GVlpWeWdNUWN3Ykt4bVVySmIzRUc2Z3FDQVZtcFVkWjRZRFBjRXV1SUxNYWhoV29OcDFGNFdXVmo5d2JyTVZYV1lKekxCc3pLclcyQ3R3WGlpQWpkMjdpbzVIcWVFSFpkUWlOVitZL3VHeXlMekVObS9xSTNLdGY1UlU3dUxjV29LTTgvQTFMRVZSQ3FUSm1WTzl3UkJ6eXp1Y1FFVUdPZTRlajh5elRjMkZQYkJhM2NxTk4wNW81WXNSVVVNSE1XM0dXSGVwUXgzQ0pscVdZR2p2dWMwOWJqMFhjcWpPZmNGSEJmcU9SV0YyckZwN20zRnY4UURtN20zeHVwU09NREVIQmRueHM0WmdSSVppdEpxSzArWnROaGNSYk5CTnM2WTQxT1ZRS3BxKzRoMEh3SFJQTVdSTFhjRXF0K0lncmZvYkpmUVF2TDRpV3lsbTRuQnROM05CVzRyaTVmcEcwbUswREEydHM0bUFYOWNTcE1kWWdxVitwVWZKeGV6Z2x4aExoVFc5ZkJzbDF1TVpSRXU0aUl2SE11aWptWFFHb29lNHI2VEJ6eEc4cGNNQlhxWmYzaTNreEZXRGJBSDN1T2hpdCtmanpOY3dGVEJNRUlITVVIekxxWGlwY3VEYys1Zm1MeEx4WHdXWDhPZEYrbzMxRWhnWDZtZkQrSnlGK0ltNllBU2p6UEpjd2ZBWVZRTzJlVEh5Q3p2NGxNSHdaWGVKaEVIT0l0NEpaYURFRjF1Wk9JcjlIY0ViYXV2MUt0dTBzNmhMRldqTkhFc01QSm8zRURDclhQL2RRcEdueFhIaUN6YnR1dGVJSzFSYS9pSzBvWHk4K0lBUk5hdzVQcUNtWE83V3YxRnVoWUVhSEQ3Z3RxNkVFblc0V0F0cWxReFJFeGFXR3p1dHdNbUxEUnFyaXdsRWFTNjl5OEZpR1ByKzh1OEM2eHZFYWV4dnZtWkZ2VmZhK0pyU2pxK0lpZ0NsWFJ4QmhDcnk2cmpKQUlDYUNrQys0NVpLNnJXKzRnMGlJWi8xRzFmakJVUVpxbHRlVmY3UlFvWjVCbTFWSlZDWmZUSERTNXJtQWdpZkJjSWo3aXhXb1lWYVNoUitucUdoVi93QXhWb05CbVVMeG1DdUx4dHZjQWFKUTZsYktxOFV3RXRSNWVJZ1hSYVpYbUFzcVVtZ3VXUUJvbllZUE0wQXVEQkVGVzdTSzZObW9YSlcyVjUvRUZBU2g1V0lEVGRjekI3aEROWG1JZ2dUbnVPSHVZZkgxcUFMQkpZby92VUVlQnFBdFJhYWk1RFVBM2U0NzNaT3RUTHZuVXV0M1I1amQzRlZOMHBGTEtuVXRTM0dZYTFka0FWZnhMbSsrcHQ5UkFNbHdRYzFxSWd6Mm9tYzVpU2tmVUZMZEp3OHh4a3MweGhtZjZtbU53VndrU2xPdUlxRVl4Y01jTU1tNWRNcTNEcCsxdzZzeE85Uk1hbGdMd3l3VTBidGh1bHcrZWU0NWx1dW1YM1hFeWZCKzRqUW9sTHNmRXNGc2NyaTRLc05YQXBkNTdqUTV3RUR5S1Z0N2piWEhVU21sdjFNQXVLMWJXSXVWVGNIcGZVWFk5UUZWMFF1Z3hiN2l3NWhYaCtpRnRoTWNsVGxodU5CMlFzZjJsWTlRMDc5VGp5bHFwTWs0S21LeWNFaEMwdG1PNExsZ2hVdEdZWGJWMVQxQXJXLzdTMFhrOE9ZcGdvNG1udmNjaHpCekNtb3JQRjlTcmkyVnJmSkxLNCtVTFlzWUZIZndpdmdNYzRzZFM2dTI0dWVJSGFXc1Z5SXJkdkViT0l0NjFCNU9ZckxFenVLY1I5bnFZdHUyT3I3WlREbjVveTB6RVMwMzhnc1FwQjh5NWZ4Y3U2dmlEV29kaUxuM0JYUkMvVUFxMVpZT1NqbVdLaVBHSmF1SlJDdGN4RG5OMUwwSzF6RWI2OXlqam1FYVJYcWJiRjF5RVhNajFVV0NsWGdwWTFXdWVBbDZvUkhKWjkxeEZRaHBiWWYzbE8xVjBnNVBxUGwvUkFvNHR5bm1ZTXhMV1dEQzdUR2FpS0NqOHhXbWNtNmxvNEhEVjVQTVZDbE9zOHhFd0s3emVJR0VaeVhwdkVhc05nMS91RFNGcno1alFyUGFwY1VzUkc5dE4reVdUaEw0MWlJcGRDQ29WOVJacW1ndHRxK2lDU2xkWTFVV3d3dDdHNzlFdDJxVWI5UUxVNDB3Zmg5UW9CelNtZTRoUUk1WVdLaUk0cHhzL3dCUURPS0txNnVObWhFUXBOK0pSUVRiZWVJQkJVM2xHSkZiSEJqL0FOaUxhczlqcjJQSHFNcWFyTGVqMUZiQUs1THUvd0Mwb0tYWVV2bm1OWWxLY3JHSUJaZ1Uvd0N4T0pZUlFLUzYwZjVndFd1TGN3WmI0amNZdzB3WU1FNWlCdTk4VENFRVhtNEFMRERpTENjOE1FRzhySGdyV05NRW9MZCtJV1pjR3lObG8wQkZCUitZSlc2OXdCaWh2bmNvYkZXc3dFQUtZSWVzVnRtQWFmY3hSaHVKTWJPbUJiYVVkUURoZHhMY1pLZ3RwcjdnY2FXQmJWYzVpV21od1N5OWxSQ2J6RGt6N2xKWVlpeGVMbkpNSlc4WEhIVG1OQU50ZUpaVHovTTBEZkpETzErb3c4dGVZSTA3NGxDT3lXTFh1SzErNVl0TitJQThwM0tOSDNEVVV0SWtvQUI5d0NYZVIwd25UbDRsRHFYbkJIQytaYldXT3lZOGJQNGliaXNZeDhRdHhLWmxZUDRsTTREQjFDNVlZRk5STHFLWU5UUnVMcXRTMVBFTjRwWEV2VTBidGlveDl4V3hZVFdOVHJxVmJpQzNMQVFNdHkxUzd4QnB5MUVKZ2lGMFg1ampGVXhLdHdhdVd0VE51c1lDSjRNd1ZXdlpodGdmVTZnL0VTMTNsZ3hFTEhWSUVLbXIxYjZsRFdmRVp6dUNibVYwN2xNdnhIaHNFQWxzV3F6S2U5TCtDbjVpWS96Q0lqNklMb0tlMklWdWVMbHNnWldXWmpJakpYUVFLNHU0dHZjYmxvUnRGWWhNb3NjSVN2TjdsRzh4cEdoTXJpbHh4RW83RGNNMGdtQWhRNnVOaW9DTnN1bVc3ZzV6R3JScVVuM0MyMlV6ZkJpS3ZicWJzNy9vdWFyNG1pWUtnOWZCZGxNVllneS9nS3VaY3VBV1lPMllsMmUzTUE0VnhwLzFCdFlydTVwV1k0ZjNUS29yM0ZDYkpXSllBTlBQVVdtbWoxRjMrWlZMN2dPVER5MUJsdjhBRXNXNEZhMWNjN1JqT1NieEdWdHJVc0ZmVHd4QXdBd2h0aW9HakVCb0QxY0ZWUHJrL0VzVUE3ZHo2aVN4S1RZOFJSWWltNk9tRnFxZUNYM1dZSWVOd3AxR3U4ZUlzQTZlKzViVldYNzNLQUxxd3NiL0FMUlVrRk9iMitiZ0NBcWdBYzRsbStoSVpSUnpzdnJtSVN3b1BHS3pFNWNyTitKbWJRN1VhaWtEaXg1d25tQzgzU2FySmlHUkJBRXJYcW9paFNBNmVMOVNpWFZGTG11YytvQUVEQzhycjNHclFMV0J2TDVtWnU4Y0czaWFVY21ocW1vNFlvcmxicndIY0dhdHR3cnhMV2lnNHljUWJ5R3h4MEhPSlFXQmhxcXFWRk9WMHB5d3dOZlp5UnNnRmNpVXYzRUM3VGRBOG5pV0MrWllFSzVyRUFPOExhZHlyVGNXeW1udzlRSFhobXEzNmpGQ294akJUQnpNTUs0aUJqckJFQUF0WWpuamlJU2lqM0tWTlYzQ3pEanBDSlF2cjh3dytBbWFVVTNWd0pCUTd3aHpYM3VMSlEyNEE1aTJac3o0T29DQ3dQUE1CU3FDZUl3Q0hqYktNSStSMUFFaUY2TzRBdUd1Y3kyNnNHQkkxT3lVRVJidk1wVkMzbW9LUXdqQTVETFdvcUJOd1ZOSTg3aFN0M0tBTVhxNDdhc2VvbHF6MHhWM3N2VVRSckhxTERkQmw3UU5kY1NtMFFkekpzU3FPWWxvTHM1alNqNllqRGRMMjhSVnlJZVNYUXJ5WEFxaFZlSTdSU3JIQmRXKzlRTGJROFMyUnB1SXZKVVVMR3ozRlRXckNZQWliN2k1TXJUMTRsTEFpak1Jc3k0UDE4WU5xbmNsL04xeDNLQUxUbHJjTHJvTVRGMlRxSlMzRjh6RG5NWVc2ZHNGTlpIWkQvcWxLRzh4Q043aUJsWDEzTG9hM0ZlTVN1RmlaYWZ0aTN6YkRTOHk0RnVlSURhZTVtemw2NGxXWGpRU3k2eDNBdHdGRUFBVm4xTXNoVW9IVEhHMUVKS00wZHpPWTl1RWdLTXcrcFZLKy9nTXdWL0VQYzlMTDRqME9hNWxoam5oNWhlenVKblViRFV1MzFPUURGV3g5N3dnaXllbzVYekxXNWpiZndjZDFEeWo1a2Q2aWZtZHNCUEVMTlBFYlJVSUR2aURXNEE1M0FyTUM4RzRwaTgydUpaeEJMVVM2enI0S3lvSCs1ZGkxdWFXOHMzUFJpWGYwNjdxV0JtWXR4V1JRWWRvTUl1RENMY08yQkNuc215dGVEL01GUlY1M0Q0WTh3RDRZZHBYOHhPaXpXWWdadXN5cGcvQkJETkxyTU9XTno5ZVBNWERyVEtacHgrNFZHaGZNWWwxZURsZ0FRVzh0eWx0bUYzZUluUU9oZVBxSXVFYS9STG1McGMxQWRmOHdKa1E4a1AzY01UL0FMaExnOW9aUFovYytESFVMTTdvWVMzTVd6UDFFL2p1SGRYeHVFcTNKM2NRM2dYQ25FU0t0UlM0ekZBVE40cFVTWGJpajFOVzBDYVVxNGd3SURyR2N4TklVRkIrUDd4b0ZIZUxvOXdsTUtYYUxWOVMxd0RiVnQwVjFCRU1xVlNtQmY4QXNTcVVvZ21CcXZjMlc3THNOZVlyRkFWOHVaVktWRG5mNi9tVXNiYkhkZjZndFhOT2k2Q0lEYWd2T0V2N2dheUZuYWZ4TFJ1dzBLM0xITjlpZFFxeFFPUk9mOFFGQkxwb0lwUUJ6Ymk2aFdqb2Jqa1V4ZDBHNEZWRnNBOGVDSmFpaU4xejdaWnV3dk5sZnVCZEdqeEtaUlJraWhhbzI4d0t6bnFHbU1ZTFBQd01IdVgxRW5PT1lKVmZpZURCVVBNR3E0cUZCRE55elFqamhZMktLQ1hTZWQ5U2lGVys0cWwxa2lvYlhRL3pLdHV0RVY0WGZFS29OTUJYTHZtNVNBZHlxMlZmVUJQTW9sT0hpK1lLTjQ0aXRhV1VlNGdxY2V0eE5SV29HRU5YRXRlQk9vUXl4ZXBvRmxYRHpUTUxxMVloZHk1QSthbGdUQjR1eVpiUW5KMFFXSURSd1JJQTBQbVlGQ2VWMk1UR0hQTUtIbUNvT1dHV3RPR0s1Y0VRaE1QY3NiTkdvRkF6alRNRGJBTHhDV3VLalZrcFdLOGtDS0p6RlRYNmxWQ1ZyNDhSZ1dLTXV3NmV5SlEwN2lRTXhqOG00a2JxQzRqYndzYnY3aXFBTitZaWxwY3FzYlppWVBXWXJRRlRpNGtYVFV2blVjNmwxT3lKVURxTFhGekRnM05iaGpqSGNPMWlIY1ZycUFlUE1FMFFVNmdFcXBZMFZDcjFNQ1djREdodUVhVFBjYXRCbUdkbFhNVmlxalJ4bU9jYVlmcHpBNFBXWmFib1l0OFZmTWNnV0tPYm1JVzVqdUpQeUVEdDc1ZzB5MzFLaWdlL2czLzVGZTVubS82YXpjenhLN015cFJFM2Vaa2pENGh4dm56S3ZyOXh0dE1TbDhSRHVBOHl3OHdDM3hFdk1Qd21FYXd0SzUvbU5NV1ltMTZpM1V1TWFQaVZyMy9WUTJtRW1QY01Jc2Jnd1pjWG9YNTZncTBzRzNSQld6UW1lQWxnVndiYXVMRUp0dXZFQW1rZWx1b0UyRlFLSlVTUEJ6RlZsWFhWekJid2p1dHNBbzJsYWY4QU1VWWErb01ZalQxeDVsTG5QbHhOSlJWMjBkUlZTS1hUWEhnaGJ0dENnZFJZQTNkU2kybzBjRzRtZ2FEQWN2bVhBS1gxdXlBN0JkQXdTRnF3Mjl4QURPWEZRSE5QaGNVRCtSZ0dMZjQrbjk0Z2I1LzV2NEJ6RjFCOHdRL3ZCTHNuSmlCMlZyVXhvQUh1TzdYcTJNU0xkWXlaUHVJU21OMVIvYU9oU0YwMXhEQ2tGMFU5eXhvTnRpczM2OHlnaWd2TjNXZFJzeVhnc3RQUGlDSmJwZEc3ZmZpV1RLWENLWThRS1VRWnByOTFDeGdCc0JwZkwvaVdJTHQxd0htREtOMFRHNnJ6MUhIR1NycnIvaURVc3UwQXZLMytvTVdTeXdRUTUrNHh1S0RsZFRLa0JVYlI1L3ZFRFlyZENKZDMvRU5DaEx5a29pQjBBeXdBb1JjWDJSTHNRQU9NeHF3MDVPNENvNVNxL3dBeStnQTN6ci92RXJRRGlydzVxWkxHaC9FU2xSQlRYSkVYSE8vVW9JNHJmdUdpSlJXUEVESnBPSUt4R293Y253TUdtWGZ3WXhCUnd5emVJSmQ3ZlV1M0lwTFhnMXhFam5ON3JpR0ZTanFvRFV4Y3ZmaUVJQVVVWWwyVnVCZThKdk13M3pBV1hlQ0llRE8vRXBIQUpLZk52Nmc3d1NBaFdVVGlGQTRjM0tsSEppSUZaaHdjMUtGbFZ6aUtuRmplaUM0dGRsc0EyMmVHQVFwZks4RVRrc3dvMlZaN2dJVFhjV28ySEkzUkdvU3NWZmNwUjJvU0pkYUJxRXNEWVlSNGdGdERFQ2JwQWN3VW9IZE54R29HZFBNekt4VDRnUlZsYWdrb01kRUF2OTFCVkwxY0tadlBaTmpscm00QU1PT1NBTGhvN2hiR0FRczFBYy94THJaWGlOU25QRk1GSzV5ZUh1S3hVam1NRHVQajRBQm40RnNFK29Wd3pGVFF5cXM3aGkwaFp0NGxKUWZXNWFyNDZ6SGhiclVBdThwck1XbnRqYmZucWRIR054YUt1UDVoZjBUODRzVzZpQURvN2lzSGVBMUdySURSTUdqNmg3aElGY2FnaWdtV0NqbGlFcTVrdU9Gd1hyTWV3dUtYVHRsQUlGVDl6R2VrbGNrckd2cURwaVBYRVZOMUZ4bGl1NGdJNXhianNxQnZINW1IcUcvSHlKOS9HL2paODM0bTR3S1IrMDNKVDNxYlYvaGpOWW5mRWIwWmhmTWNHY01HNVpLQzRxYjNObVpod1lJTmFhaXIxSEVPSXRPSWc1bFF0eFd0OC9HZjZFaUp4Q0JuUHdGSmczRHltMG9OSnhhbDk5UndCZ0hRNER6RkFLam1tai95V0NRVzhDMVVBUkhuQlRWUUNzaW1HOVN5NjRZeEswOFEwWXg4YmRSUHpMN2lscmJyMTZsRkZ1WGdzcnpFQ0xMc0h5UXFGYlFMcHE0RFphQjMzQm9HaXJwelhVc25ZMTExZHhyQW9Zd3FtS0l1dU5INlBjQUNBQUwzMUdBS2M1cmI3aUNpNkhKZjdsbDVxaDMvQU54QUVzbUcrNEJkSlNtdTRGNEhGYWpZNHR4aVdUQUh2SktVOWdtMTJNeTZYa3pDUWN4N2lHT0M0T1lBWGx1SXBBYi9BSEdxVmc5WmpEUzU0ZVpZTUZqUkVoWVhyV1lBNWhlQXVwZHFJV1lLeVNsQXF4VGUvRWJxbW04ZzhFckkxZks3dTRRN3RlQS9kU2twY0crayt5QnF5NkFBTmljUDVnUldpbUFHNHcyZ3AwYjk5UURpNG9vM0tNSXZsU25NY2tMSEZkbnFLMVdiYVREVVF0VUJseitpQzZBSGRsbEIvYVd3T3FFTXJ6S1Z3dGUyS2tTaTg1TS9uekNyUTBkM1YrZkpPR2FIRitvT0xVcndYUjNCaXpRM1ZmaUFic2V6UjNVRkxxeDV3MzQ4UUs0cTNYV0lnZDNpNmxhVnNyUVZDQnBVMmFndDBsMU9JdnUrNXpSK0VpVTUrUmJnd1piTFdyWUlKVXRDeFlrWVZXc054aUZxNDRobTliZk1TdUpjaXhyTDdsMjhaL1VMZnVDM0JBcXpqbUVXK1lVaVVyczZtZ0xRZW9OS21UUkZhVU5uVUd4b3pFNWJnOEMwNTNFNTJseFpDMGJwNHZtQ3RVQm92Y0NLZ0M1VzF2OEFpV3VIQ3J4TElWcHRDc0JZR3FMYzNBTGFxY1p4TEdDOEdldy92RUFvMHRGd2FFQ3J4cUk3WHhVTGwwZFBFU1ZsOFhMeDM0aVNsdkgrNVp3YytJVUFCY0c2SkxiOHM0R0szbW4zQlJWQWFzekVHekhaRGhUTURsMUxyM05GNWhyRTNNQ0dUZGNrck1Xd1BnWDRSejhZWm0zdUYzZ3VhY0VDOGtXc3pIVlplWWxvV0pZcURVR2pOcTh5eFA3eGE0alM5UUwrcHJVR2hIYkZRYXpjV1c4UWFkeTNuRGR6VXRjNjRKUjZFUUZoTGpNb1JBYnFEdEtCM0x0dmNKYTVpWXFDT0o5UzQ2bG1uYkFTTkdYRWNwbkVNeXZvZ3J3WDFCRnBjenRFeEFsUlB6QXhLT1pYVU1iSjlmQ01yUHdxVjB6SkdWOXhvM2lYTHVNRjhlb3dqMGpPN0krb3J6eEZIYkJEVXRFVzNGUllYVURHWTRWb2cyeEVPaVYyelc1LytGU3cwS1paQmlWQUxWb0RtQ0FDaSt6MDh4bXJMYWZGUUpsaFdxSGlDVEdGcXZFdUM4YzRpQ25IZldJVmEzVm1qY3BuYjlSNU0wZFJXRnlwekhIM01zY3dONDJEbTJobHJDT2JMeENxS3FhUzl6RWFzQmhTcWdhSlZzb215WGFlWGpqZjh3MGx0c3R6TUVDY25sbURJQkZLZVlPRmdobE9xaVUwZzJBWGlCbFRac3ZKZmlJaU8rR3RIcURFUlc4T01WQk0wdGh4eEdrdFA1WEZaUmp4VXB3dDN2dU0vd0JoRDJQRE82eTd5QkxPTDdsUXl2aVk3WTF2TTcxRVlWeDNVcGJGMmJnMDF1R1FLV1dXRlhpcklObVVVNy9jYkZJck41MTVpcFJrclgrNGdIQlpoeGZOMTZpQkJxejA2LzdpS2loVkhJYnFVb0swNzNVUzVMWFNqSWY0Z0JZS3BTanQ5OFJBRkFqeG8vMlN5MFZtME9mcVhlUURsMGVJVmJRclRlYmc0ZFpvR3IrK1lnRzBDUDNLS2kyRktCWTlRYWNOc1pGMzN6S0lpVmJsZjdSQlZXQzRicTZ4bVpJSlRxblpBb1J0TnA0aXprTE1BY1NncEtFMGpFcnpmUTVmOFFGdEtCbGY5eEVUU2xML0FLbENnT09VN2h1M2c4WFVDWnkzcGVZUkN3UExWV3hLMGxOWjErb0M3dS9jL0wrb2xmQXgvWG42Z080TlU0bDRvL01LelpkeXQ4UGpSS0YrTkR6QVZXNzVpM1FwNUlLdjl3cHR4bUZZL3dDWUVFcWg1aUlJSWw0Z2lpRmQrWXNXNkw4UTBvdmRYQm9CM01DeHRJaUlJV21KWVZzRytvcUZWWFo3aVlRRm1GMFRJU2lVRjFYbVVnS0ZoeWV2VWJEREF3ekRLdFV6UVN3dGNuVVNpZzBtamlVZ1Z1NkZ4QldOT0h6eEdVTktaektWWTV0Z0poUzhrUXRuMnpCWnR1Z3FEa01hNmlyY1FiK29GYkV2bUEyS3pnRExvdFBxQldGRHhCQnV5V3BLTDhSVXY5M0ZaMFFCS2RuSkZCUkVqTWdxOWtKZzNIVlBNY1JSVjh3TWU0cysvaHhCYm5mbU9ubUt6VEhpSEpoQUVGUGJtS0FjK0k5TXVwa3htb3ZBMTJRTWVJb1lHNWVaZGVRcnVZYnpjWGVvMVhGblV2cVhYRlgxRE11ZTJJUUdBL2NNdEVRS09kekVYSFdDTE5FcFdXRU5RSzRnQ1ppcHdSV1E3Zzl4ekJaQlpocG03SGlCaUlqakUwMXVKYngwU3Z2MUM2eVNubUhUbVZXL3pLclJBN1pYMVB6bWZYeDVmaUY2Q1V1NGtWNStPZmN1S05RMnlHUE5TcCtmM0tyalVaWjZpZjhBdHlqVytPdGR1blVjeUIzd3dhM0ZVbDRxRFQvbUxZdkUzdGlMS2lnVjV1WW1PM3g4MS9VanBjTXVCdUpVQVZXZ09ablFMTjlRMlJUWUdvQ0lWVTVUTUxWZVdzWXJ6TjJidkN4TnRJaHBkMmV0U2tGcFQwWWhxQ2xobDh4aVUyMlFBeGlwM04xQnZuNVRxR0NSc2dpWUVOdForb2dWS3ZJdXozQURZS0Z2U1FJaHVxQWY1amhwaGxQNTh3SkZFVndYWUo1aXFvTlQ4L1VJQU5GMllMbm1GMVdOTUJUYUZYNmp0U1hDTHRqTUM3cHJUMUZHa3UrWE1HN0dsMWp1SWdBRU9EaVdhelI0Nm5aK3lXTlVWdFR1WndscDVIaEk3dXBwNFRoSUZHZXBkWmwyVHNFN1ZxQld0THJPSUVRcHNYbURnNGdIRDFDMmpGaWRrc1F0TzF2Uk5WUWw0UExBRTIzeFhEQUFsMDJoN2d0Y2l2dXFoQXBBMHNNK0pTMDBkMUZTeWluZjk1YWxsM1lEcTRyTWpoM2YvWWlwa2FDK0pUUXppN2VuKzhFcUtJbFZ4SGRvVjNheElBRkZ0bzFpQlZaU0FtUURvcmxnREZsODFsZlBnakFxQm9yK1BFQVpBVGxic0R3OXk0WXFzUGR2Qkd2c3BhSGU0MkxReGh2ZmtnaFhGM1hjUUdXRGwxY3Rzb3VyVEJmTUFxK1Q3cU1YVlhpMitZQWFMV3QxVkVjS0E3R1hBaUtXNjQ4WE0xaVcxc3Fwa3JGM1RFRk9JRVl4M09JVEV4Q1hCbDI5UlZmeEtnNlpZSVh2KzBvdURJL3FLbUt1OCs0UkhtdVdZRmYxR2QwUFN5emxxbktTN1NGZDNHcHBwTjFHa0NZdk5jdzJuRXBDcXNIbWJOdVAzTW16anZpYkxnYytaUVBRNXpxRzBnVlpoVVVOQmZ4QldnSXcwUWRCcDVaZktyRk9keGNsQmptNVJHbFRoSlJRemlKQlJXeXlvdUcxTFZqVUFTKy84eXlxczg0bGtFQWRwaGhMTGQ1Zk1BT01oTjRFUzhGeHpJWE0zZ3g0bGppSzhNTkZPSTAzajdPWlM2SFhmRVJiWGpjWE44OVJVdGFnMDV6QXRydWZxaFU5a2Y4QWVKK29zQlF3TnRhRmxWQmJLcHVxSStOell1RzVmUzJaajl4Tkg4eFZrbGh4NWdvVXhiMlpuN3ZtT0QvZUxlSWx2VW91amNFb0dldW9ZN1htWGJSeE9kYmdEYitJWVlDSlJpRk14VTRnUWN4Q2pLTWhMeTViZ1pZYWlXTXNMYmMzRytNL0NNeTdINXdlL3dEMkQ2OFE4RXF2TXJ2SHhmRG1WUmJxQWNZV1ZXL3l6TFJjVHRxWGRWaVVIYUFMYmxaOFJybU5mK1RKNmlQVnkrOFF0SU5tUzUvMXdJVHhVTlp6Q0pWWEVtcFdZa1VMSGNVYy9iK3pMS1dFYVRxR1dtWGp4TFdYK0ozVXhWejhmZVpYeFVxVkUvb1lEdHRvcmxoRVhoNlFUQTNlYThkUUl5cTlHQ0tocFhOMUtJS2xaUWY1bHRCcm9lRHhBTThPUjEvdVlMdFhGekJTWUtieEFDbGxCZGtJV3J2eG1YZ0VzeWtONXpCeGlERE80NXVYRWJmTXQwNzhjK1lIZXdjM2k1Z3dCSFdLOXhPMmdTdEoxZmNBRXpwZTNxS2lrQjJjVEJ0WnJHZE1BSzJDNmI2aU5DTFd5UEV3cVdVYmNiKzRDVVF2ditabFlPUXUrR0lqSXJtNmlhcHkxN0lsNFNnNjNOdWY1bWgzRVBpQXdBeXJ0NjlNUlNLSTBqdy9GNmc1OHdXbWFGMnlsbVFPZ09ZZ1d1bEZtUXBvL2lGMk5sTHJ1ZWJXTHFvSnhTMFdzc1VIQ1h4eitJbExSdE1LYitpRG9kSzh1SUZ1TUFXRmN4UmhRM2JFYVhEVldRTmxJWXVrekxyUlZtcmhvcmx6cVVCTExlc3ltS050UGIvaUZ3WFp4WFYvNWxqSUZaVUwvd0RZbk5GbkNaczUvY3FvTnRxUDlwYUJZVWcxdkhGMy9FVGFXaFdjZTJCV3hWWFljUDhBbWZTdUZPUGI1aVFvMGNIUG1VY1hlTHp4TEZsMjhmOEFzc3RDbE5yZ1A4eFJDM2h0eUVGUUJveGZMWCtJSWxCN29BalVFd3ZiZ2hHMUc4VXY3dUdqaXE3TFdZR3h2WGlOTUZBNUc1dHNMT040bG4rSXE4RndWcytEK3BoS2lqdCt1Slk0QXpCTG9OdVlVQlRlcWx3Qmw0Z3Y1aFpEbGpVQ3RKVmJxT0JwUDhRUlEwSEVFS2pWNDl3QWJDMytJMmd0WjMxTUsyZW9vRlhtQ0Zrb2lSckVRSnR2V3lMd1VQR0VqeGFuRnJkd1J0VWFvc2xnQlJ2TlZEVmJaNWkyMFU3YTVoVlZhc2xURmVIU0lVK1pZU1M5TU5DY3REV1lBdGU5Sm1wZXM1R2ZjYkFxOGN6WlYzbmN5NW9TRFhHZmNlemc4UWVUZnVCVjFtR1NuOXk4cVdlR0FSbEMxbUJaNWlxelBpQ3hSeWNSOVJyajl3dXk0Q3NrdFE2WlkyWWY1aitFR1c5VE56bGFyeEtWYWd5ZTVndEt2VW9hNG1DQWF6S3FFcUlhVDh6RkNBeG4rWmZVTGN0K1lJbEVRWUc4ZFN5dk10eTFnbWt1Umc3WUx4UnQ3aklwcDFEUjdsOFRnbFlTSURhd2JEa2phVk1jd0NweVVSVWFURVFRY3R3Rnh3MUUrRmw3ZnVGaU9KdVhid1FadlVMOU03VzJWRE9XQm5yaUFOeEU5ZnVHYmFuYTRTc3dPVXFvTnNNTzQ2WTNIY09OVDFCZE01WWFxQjNEV1dwZkdMWUF3R21CajFIQjNBaWRSNHpxQ25TYm1WU2p3S2ZYbWM2SENhWmZjdEdtTFJSbFlxNHpIVitack9KVXFWSytLK0srR1UyZHpWcTgrLzRtWEpQSCtaV0F0c3kzcURZamh6YXdGRnREUjNMQ29DZ2FJUnRNSmZPUWdJQ1dPNVFSVFlWNE9tSWNOMzN6S3JZRlpIVnhFMm9YTmRTZ2JWbWxobG1hdkh3amNITXVQaVdYS2JBYTY3aWFJQUYxVVZqVjBkNGVwWUtGdUd0ckFYS3loUEhheFZ1bXNiOFFYaVVWaXNMMnNXbURWQzhRckFobHFsZ1MwVXlBeVVtLzlST2tBY29MaSsvY3MzaGFVNXdUQnRjYk9jU2lOT2Izd1FHMVQ4Y01SWlgxMUFKYlFKeEF6bWp4eGNGbWRjVGhMNEorbi9NWXNIVUtua21ORWc3cm4zTERDR0ttMis0Q1pMSlVvcThQSHVDd2F2SzNFQlZjM25rSUNOQ2dMendkdm1GTm9PS0xOMFFJb0IxVjQ5eEx0Qm9oU1pPSHg0anFWRm9CV2lNVUJhNEdVRzdUbGlKVHZzekFJYVhRVmN0RnFxYzFwaVVNQTREUmlXRkNtYnhpSUV1cXRwU2oxRzJYV00rYzh5aHBWeGtHei9FQnRvZW16cVkwRFhnZit1V2hhcWRYVVFLcTA2TitJcmtTM1JWblVSVVhYQnBlb0MwRm1yZFZCS0tSWmJySjlRVzJycGJheG56L0FHZ3RHRjJoV3VtSkJjbFkvd0RKb3Bvd1YvanVHNUhXc21mY3NLRDJUYWRRYUtXWEFZWVhQQzZERVJWMDcvY1F5b0lpS25tc2t2VTNYWDlGL054UkRjQWFBb0FoV2g3WlZjUlVGN05SUzJBWjRoYW1zdkVZTFRIOFEyRTE1Z2VVSndRQ3d2M1VRaXNsL1VFdXh2QmNDWXZXSzdnQ3VsYWxXMTI1alNJUGpNYU93ZXlEUlNIZU55NElVRzJ0U3hpRHhLUUxiT3JOK0liSzJXRnFkc0VVV0FvdUh5UnlONHU0VUdJNEYwTUlRb3kxbnZ4Q2FtU3l3Z1d6ZWNYVVVYTnVFd1JCVXlHV0tTTnRhcUlqVHZxQlN0UWE0Z1NCV2N3Slk1WE1Gell4TkZqTHRwektJMDFLQytXSUZ1U0lGTlZ1QVZUREdDSTNPSW14bUQzRVdoLzdCWXVxaGFhOXhEUm9PWUVMMWNDNFVBOGFnYXJjQmxYTHhMOVNqWVltWWJUMUFyRCtZUWF3Wml2QWZtV21rbDNwbDFuYkM2QXJFS2ZvUjJUUWlHTGdHbEltU3R1aUJRWGhZaTIySnNxSXQ3bUJUREp1S1dXWnJFUlZMbUJkaEZaUnVXck1mS1hIWTNLeEtiOFJvdGZtWkEvMitBcnBOTDRJRnRwWE1MOFZOWHhPdVl2SDZpL3J1R3Nzc0w1aXVHTXgzZW9mbm1adTU2K09aWGU1VjZZeGhWOFJQTlQwWXJaWCswc3pqR01zS2hoaVp4S3BNNStLZ0RmY09yU1lvMzJPSTd6SFJjWmp0M0tMRGJLbFNwVVQ0citpbXNaZzh2YjRKUU5BdWJUaUNCYkNaNEI0SXJiVUZLSHFWQkJwTmV2OFFDd2JhT2VKVXRnbXVyaU1CUlNqcUphVzlKUmxOM254Qk9ZN2lTaEtaTmFqcHBGUm9UY05icWpKRlhGNHpGQ3pYbUNrSDh5OUpGaTNBVTFnbUMxcW5NTktZRUttZEtEbTJVQllrckVSV3hETDl4TTJqZFZZMUZJQW9aSGNFaUJkY1BEN2dYZDNrUDdSVVJSRnRIY1F5TjF1OU1DeXpBVnZIMUNsRUFEaURpa1FOSGN3NjJtRklFY3JMcSs1Wll1YmdpV1ovd0FRaUlsbFNWaDhSbXJWbDluK3BjWFV1MWxNT0lDazBKK3lFcUxNMGVZeTUrMksxUm9QM0tBVmlzWDVlb1VpUExhTHYvVUVlZ2JNYi8wUkpWVmFXK1NMRnJXTVZ6ZW9uQldYZWFzOXh4Y1d3ZGhlZnhIRTIwWjh6TnBmTjdoV2pyTXdMZDF6QUtXd3d3RlZNcTRlQWpwWUZhdStTQ2xNamtzbG1NQ0J5WmZQcW9GMkIyWS9SR2JVVk05MUFGb0tkSmNGTnRwVnV2eksyc2pncUxzRkcvUG44eHFnbWFvNS93Q0lxT2htcng1ektzaWIyb0l3UkJlTU5yN2lXQkxZV3Nrb0cxSGk5ZGZjYk5LQTY2SmE4TFJsdktIWHBnRXdGQ3FMeCtZWWtJUEJ2NmdBbzBYVk8yQWhRQnpBV2xNc01BM3VjVFp2L3dDRmdGaGlVWG03YW9KUUFZZWE2Z0h1NEZiM0tqQnQxbVZKdzk5eFdpaEVyZThqTUhPU1VYVkhGVkJxMUMrSndGVnJFdkZwUjdnMHMybkRBVUJ0ZHdnc0ZPYmdNK1Z6blVGalI1aW9BWkwxQUdLTkkxL3hBcGJUTitIaUVTd3hUd2VQdUFRbEZZeFQ2aEdESVlaUVhTMGFUcy96R25Rb1JkTVFVVmlyR0hITXFDQnN1NVlOS1VIM0JkYkVvVkFWbGR4Mm5HQjVoUXpsaStQVXBFci9BREJaVGlEV29DWnhIRERpVzB3WVc2cVc3Q0tRU1U4bFFneDdocGRYaUFMUHNsNkQ0NDJuaXltWnZxWGU0YXZWM2lCU3pteUJ6R2ZWNGlNM1NNVk9KYlZ3S29nSnVvT2FoVzRwZzU4UkYyRHJsaURnRlFYZXY0aW9BUnJpRjFWYllKdEVBTnZjYXZpRE1XTVN5V2tiZUpYRGN1YllsV2tTQ3pNUnE0aHlRWTNlT29CSlJYaGdWNDRpMWZFUmZjZ0Vxc3B4ZVhpQmluY0liaUR2ZmlhMVBiTWM5NWw4UTNWWWdScjNMekxqM0Rka3VsUWN6UGFCV0pRZFExa3A2bHplU2JnV1ZKTGJ6Z21IS0RERldTR0xUTFUrNTVpNWJsZlVXWFpyTXc3Z1dCWThURmxQanBpVUJnSXNTbGRzcVZLaVIrVWxUbjVRaHo0UExNTVFCUUhGY0ZSRlpWVXZEaUtOcFREVUtnMlZmTjBlNWdiYVl0MEVRUWVXMThRSnlTODF2MWlYNGh5MFlZaDN3MFROalBZeTNEVlhuL0VBZ21EbURtSzZlVzVhVFZtRXJjb0xyUFVBR3NnbWJsSlgxRmlYWkdMcU5yS1V4N2RrSXU1TDdpeFdobHg4TXBLRFdLYlM5d0NvMDE0WTFhU3JHM2RSQzRXOEcvTXVqU0ptdk1JQzZwYm5qeEtHUlZ1Vi9YMUJwc0duTERwMjNmUE1Ta00wanU3Z3pKUnQxQUdicjN6QU00ZHAxNWlxRXRnQ1BQbU82Z1pYVC9oak1LV0NQY3ZYVXVPcFdFNGJtVlMxcys1b3RzSGNRdlRWNTVoUVl0ckZ0M0FHVElsWTNmUkhCY3FHYjZlWWpaY0kxZGE4ZFFCVXd2TWRBVXd0ZDFLT1VITjZoUlhSb1lDN0dtSlFwWS9pQzk1VHJqekUxdXR2aTVUTm9YTkdabTRhRnQxakg4d05JNHBWN2dSUVpCSHluOW9yMGI2WmlIMkxoVHFKVkJBVE94c1g5eEFHd1RPMW5GZWVJNEk1REIvdUU0b1BGUzRBUU1xTGR6ZTBhUlI1bGFnMDgwOHdXaEVGMnJ0OHdOTUpiZHJ4TUdiYkZ5MFYvYUxhRld2NVFFYUJ2aDMrNEt4Um5BR2E0YWxhbENpOHRyNjZpOXBWaGd4Z2hHTjcxTWkzUm5FQmE1aHRVR3NkTTlJNi9xM3FDSnZiN2h3djFCbW5VV0d5RzNHSzdscnpsZTRpQ05CRXBaYTVpT0ZGR3JpaDFjSVVGTjF1VzFiV2R3cGsvY2FpMmc4ekdCd1FSRVdjZTVkaFE3dUNNTmpjelZwUFBVTndYT3ZjdVIyRFpWNWwwUTBtS3ZVQUxsZDhSNmhRdG5ZeHRkSGVjeXNZWklITnhMYVVMK29CM1JEVm1NeW9BRm02SlFLc3N3SnAzMFFhN2QwNWdGeXloaHpFTHNMT1lDRjJWTXJxTHNncG5jUkN1SW05d0ZHc1RKZi9BREJIblhFSzhHNGt3NWIxQ2xjWVlSb280NWlvM0FjSmJUc2Irb0ZHcWRjMTFObVZWMzNGaUdaUVpOUlJweVNpWWR3czV2NEFvbVNyczhSVlVITjVJMjJEdUFtNTh3VTI3ZEV4YWQ4elNqYzFCZHpDQmQvQjQzQmx1V05RUzh3QlkzTVFXVEZaVHp5UkxxdC9tQ3JHWXJLZHhBUGdrTEZkRzRNekp1R2YrMVBEMnk2TVExRDhUak0vVVJqR29NY3cvaWUvZ2xYQmV2aDJUbURFS0dXaUNkVkZMaXM5ekJNKzRVRGhtd3lRZ1dZbFJtVWVibFdYREJpOVIzMzg1alBxR29ieHJ1Q0xYYXI1UGMxV2lCQWdTb2tTVktmZ0dMRkIyeG1kR1hhN1kxR29OQWNlMkFMQllEZkVzbEZyV09QdUtISjdQUG9pRUJMV3FKbDh3UUJiYVhkZ1JzQW9HK0wrNEk2SWRKZjVnQ1FNRG9JaFJKeHVJMFhiVnVhZ0VPVVhGNmlvNWJVdHpvNklCUmlucUlqaW5qeEZBL1BtNDBSVzY2amN3TDl4WWk1Y2xSVUZiclVkbGRzb1p3RXFUcklxdGxIRmNSdGdVTUN1L2NXa3Q0RXE0c3VBT1A4QWNRM1FvdzUvZjFFMnZHQzIvY3NFVUE2dmlhQW9kUlVLVXQvaW9nQUFMUm5FUWxYZHJaZ1RtRFFWdWpkR1lnb1haeEZWYkR5dk01R3hIc3d3Q0RXUXlTaURpcWFlL3VYQmlwTHpYRUF2R2ZjV3B4akgxQ04yaG1JV3V0M3lzZXdlTXRYYk1FVlZhcHdOL3ZFeEE5RnZuUE1OcFpRdk9ISEIxRWlGWFdEbU5Xd3g1TnhiSFBDOXpJcXdUenFCUnFpcWN5Nk0zZGJYVXRXc3YvRWJES1czV2Z5d1ZkalZYUmk3NGxnMElBYnlIajNBMjBnelRtMTFFS2dZQ2lzQjZqUkUyY3VLZ0JNQktxSzRDT0RwOXgxNFh6cEN1QTRtUm1sNzdsZ092NVlEeHJxVktBbVg2Z3BiQlRGWGYvZTRnSmZvUkM4QTVvMnhWVzF2RGhQckVzcW02TTNwL0VGVnBRQXJ4NExpb1lOZS93Qlh3UlVwbk9SUkNNcnhMdmJYbUJvQnN1NnVJM2tTOE40SlNXbU96VDlRS0N6b1IzQTh4OFdmMGVhVWhvQTlNQUdNSEVCd09VZ0xOTjRPNFhydXNFYllLOVRRTjU1aTVEWStaWlNQdXpVSVVLZGY1bU5OMjdYdUNBTC9BTVJLYTI5d3JMVTZndkZsY1FXSm9sU3hDOGl4cXFzbWlEQUQ2Z0FtM2xWVEJHZzVxNFYyTk9Rak1OcDA4UVd0Uk9ydUZiaStvaWpnYXd2ekd6U2hzUmQ1Z2tsWUxpL1JBM29HRjJ6TUtJU2xyTmR6SWVXQTZ6QzNScDNCYzNYVUNVMlE1b2hyRllneGd6UERFS2w1WVNQWktGMW1PV3NSczJrdmdnakZZMXFBMDNmRURtelV6RVpjV1hpR2g0NGw1aWxqek5vRlppU2d1OHhWa3lFeTVkelNnMUVsVFR4QzRDNXlnVTU0SUdhNTZKaFlGdk5SYmNmRXNWT1pVTytZcW90V0dZV0ZzYXJiaUhFTllnb3plWUJsamRzWXJBWWlVa1NOVmR4aHMxS3N0TXdWYzJ1OFRvWWhNbzB0cHNJR0MveEtuRHU1VlJ0TmVvWno4WWFuM0Z3Qm40M2tsM3pYeVQ3cG5NV3FvdVhqUE13cVVMT1krWEN4Y0JYbiswRjJjektLMU1zTVF2b0NvYTR3ekRSbWJFZzdxVjNXSVdTdEYrSDh3NGx1ZVpZa3ZQbUhwV0pTT29vUmxsZGtDVks4U3NSSWxTb2taVUxxN2haZEJ0KzlTMVU0Y1NvVXRJMm4rWmNLTjN4Z2lKVWFvb2Zlb0d4QVVJcTdlWWdoa1ZxMnZ1QktLcU5EaUlJQTBiN2doS0JjYndmY1VRRHBIVEVFRkk1ZTdoejM3T0lqUW9jVmZFUzVEV2krSmw1dk4zcUdMQnZ1SkVUVCtwZ0RQTi82Z01VMGNRUnp6Q3psczY4enlLWEVaYUQ3ajdUY0g1aVZDSThjWEtTcm9Xdk53UXRSck5SR3FTMHRFQnF6Q3JvaGRYTzZ4VVlDaFlkVkdGdWd1NnZVQlFvcHRyZjVpTkFsSG5VencwNEwzNWx4M2xGeC9tSVVpbE5HTHVFRVZXOEcyQWFRUTZnaEhRY2tGc2NoeVh6TW80VlhUMytZVmxLajhEQnVWNzA0ZzA5RzRxenYrRjh4Q2k3WEdPUEVRcTZheDU0WVltcVJ3QWU4eXphMmhhMXBtWkFxM0l1ZjFGc2pEenllWVhnODVibVl0bTcxRE5ZYWNaZ0hJZm5yaU96TGZMV1FnSU5OOEhSTHdiQVdnM3hGVkxSZURMNGFtUkprQ211UFVveU9YZzJmOXpBYUc4N2dLWkd0N21KYlk3WERVQzlEVy9NQlhGVzUzaVZyY3dQbmN1eW1XZjFNMUtzQ3orMFJFQXNjYndSdUhPSGZYcURZWThyaW4vcmxxQ3BGNFhiL0FOM0d4bFF1N1NpSU5naGxNNThUd2haZG03N3FJQkFhVENyVTV4eEJUb011T2Y4QVVzWERRODhRQ0tHYTNlZmNCSFY0Nm9ncG0rbnpMbXZmemN1Wlh3aHBPTVFpVzdLZ1lWRHFLeWpTV0M3TzRCVktFRzc2aktVV3haY1lmMUUyMlc4TUxQbURHYnVWYWpQOXBhaFYyTXdGSzN6RWhnS2wwVkJ2aW9vbGJaWlZLY0tNUVdGTnQ0QytJQ2dhT0lwUU9mRW9iQTlrQlZvQndzRHVvdmdKY0paWHpVRlF1OVpsS0RjQmJaOWFnbVEzd3hSMTlTalhjREdISjNFdGtJUktjVEJ4bUJRWHVHU0NoRlhNdFZmeEtISExFTE14ZDhzRmQ3T29odm1lUmk0YVZJN0c5bk1NdkVkUzVIbVBFZUpWTXAxY0c4TWM0aVp4QjV1S21GUHVWeWlMOXdtcXNjYUlOWU1TKzZpRUJsbUZmeXhYVHFZQzNNVXVPWVlaa01vR1lZSXN0ZFNuRURXWmEyUk5HTVMzY1R4TERSRXBaTHF1NGthZnpDdGNyUjNGTm1XSGU0SFdEdUJUQVh4TmVZTkdzUXFFNGo0K1JtL2xoS2Zmd3dTVVcrb3VGRzV0OGRRdkxFRzFtNTB3RFBFTDVpZ3V0elpOd3JnTDh4aUFCcTZnVUdHR25YdUlmREVpOXhnMDU2aVlMZ1lwM3U0K1dOakE1WFRHUjBqVXFWUFNEdUpFaVJEaks1OEhNVnNRd1UxamlLMklYVnU0QlNpOWk4eWd3QUNqbXI2OXpHY0dMdjhBZ2xrcndxVW40cUFYRGlpMXN2MUd3NEtEUDh3MmhNWnBkK0lDV0JEZThWMUxtZ0hEaTdnRm9Sc3JHSUFYYmVheG42MUhrVXVEbW9VQURBQnlwR1hPaXFxWFJRYmlMczN4THpUemFUVEdCbGxMM3hLU3kveEZXcjQ1bUxheXlYUXU0R1pwRXNpQTZwNWwxQUM2eEh0RXAzblVDcUx4Ym1vTUJxMXdsUmtpZzhLYWlWV2dtWHkvNGdyYll2SWM0aUNoZFcrdlBVc3VHVXJXdmNzV1dWSEQ2aTRSTHU4ZjRsUUVDZzVnckkzaTVRQzdLMDlrYUlPQWJndFVBSFo1bis0Uk5QOEEzWHh6Q3hnK29PREY0Nmo0elRIMmJNaFVBbEJrcDZJRXB3b29ETk4vekZvaHdSYmNySFNGR1RGSFB2dUl3bHJ4WnJ6RlJRTzYxVnlpMVFLdzhrdk9LWHZNczR0a3ZPSzh6WW1VYmNORVMycjdCTitvcmR0aUhEVDFLYnMxYWJkL3FCc0x5bGx4UTlRb0JFVXBOci80UkFVYkZvdkM5UUpWQ0p0ZW9BcWk1Uys1cENCWE9JVm9nSG1Yak4xeEV3VVVlZTRCVFRWRjdoaXJubkovQkFGSE44dXowUUlvSlJqUEgrNVNxM2Q1dmc2SlRKMVdMM0UzVkdkcndzV1Nrb3lhcTJLdEtiVlJrcnd4WGJrR3F6QUdnSjBiVDNFdVZBeFMzY0ZWemVPcWhMc1JlYjRpMnQrOU1zSS80L3BwVnl3RythL0VLNmdObzRlWlZhbWRlb20xY3kyVEl3OFpnUkc4T2JsYkM4OXhWemtOU2dVRFRmVW9CWDh5MVJXZ0YrZXBhMW1YY29NdHQ4eFBlVi9VU0FFR3JiVEhYSmcxTEJwR04yYksvRUJMemFXZEVwcEJZMndBYzJ5QUZNQ3NSTFVlOXhFWG4rOHNZTW5YTUttUmhZQnFpQVd6alZ5MWdQWkF2M0JLdUMzQkFubnhESnJFZTVmVXkzTHJHTXl3b1JhMGtHNkxxRnBacUpFb3p6R2VNUUN4eVZGdkVBKzRiSHN6Tkg5ejNBak5WNElKay9FUmlNWU16NFBpQWpNbjRQOEFMS0NnQ1lBYk8yYnpCL01XbUlTSTFpSWpYT3BRRUREZjRtTG9nWlRtWVZpRzZyekJtS0J4Y3NXdVlCaFFWTERjUzJRTFVBeTdjQk53SzVnSE5SZm9pYVhkUUtJWUwyZ0J2Y2RVYmg0aGZlNWtkeEwrUE1mZzlUOVEvUHhneWdMckJHRFBpTGpHWUF1RVhuY1dFYU0weXRROGNTN2xCeEFPSFhtZE9ac0UxNVJGak54QkdLQ0t0bURtbWNYRWZINGpzNUdCVmJialhiVU1IY1dpSmo2VW5qL1VQa0pFaVJJYWhsd1k2akxXTEcrbU1nR1JiVUFXaEljY2VwU2xDd292ajNMRENpYjRJMUMxcWxEZzhRMkt1a0p3K29DKzFWUU9DWU5ZYUZWd3dOb1pEU0gvQUdwamlXalNyWkNGaGI3NENDaFNqUWNydVdRUUJjdE9ZZ0dNM3h4QXN2dnVLR3NCVzQyNFYvaVdIenNxWmh1N1lyUk15eE1YWkVCbmNkRzU3cXppT1VjT21haVhmQkRxOVFpb0tyVnU1UWFMRjJYaVhTdGcyemlKUlpBcXIxeEJXSElIRzRtV29iS3ZQYzF0MHRybURRdUtORzJCQnNiTUVGRU01eDVtQTBLcW51UFFveGVPNVd3S3B2dU9nbDBHaGlTa2J2aVZQbFRIc3lUWGlvcGRrSXQvM1ltemFYYzNjaTU1dUVFRUM4VXpRbGc3VElmN2xWTko2U3dvcFdzNlliY1ZRdXRFT1FwUS9IcGlxalZlN1kxaTZjN3BIMFNod1ZZVlRzaTJvRktCL3VadTJoM1dvcWlVWHp3ZHloVjBNbVRMeEFGWm9hS2QxL3hFb1NsTW9aVC9BREFDTjRCKzczRUtTMTFyTXd1dlpZQVZ3bFpPb2tLUzByRlZNaFJMREJjV0tOaldXdnVwblpxbG9nZ0ZCV25saW1CYmFmV2VXQWFXeEhPZFFER1VLVkhOOVZBcm95NTh5dTBXeWd2bnpCWlNhMXhiS0ZMbzdNUlRBVzF6dDh4Q0NJV0N0N1lBbGhqT2EwKzVaeUtyWnY3bHd0UVZlR1dYZUx6WnI2bHhtM0pCVC9ScDJnY203bHlGWmliUTdpcU9YdVhXZ3lzQWdiVXlkUWd0NEpzemc3aVBvaXRBWHR1SzdPZTQ2RnRMalh2TTI1bFF1Z2NYTVdJSDhRVzB2N2lSdlllZFN4V0l2aUROTFhpQm9KaUtRclpwaWp6by9NeDBzZUxndFlTbXR5OXBkT0lKWWMrWUZxcWtCZXpqRVFLYnpLU2dsVERxMUhtVzBtK1lJalZRRXNxVWpVQkV2VVZMTmwzRnpVc01Sb1hNRE5URm1JSlozQUhHZTRQRi9VdHlTd1pqUmVTYlZIRytZTTJRZkVUc2prcDRnNmd4RmVZVWZnOWhPYkQ5SVB5KzRJTkdhNU5UT3FwWnNPVmlDR0NHbFdES3FkeHl4bGYxQUJXNGs1aDJZWmdLeHFVREtWTWlDdHpNTVJmTXNtdEVGRmtVNUhFeU13QzVsNmFqWERLSHdyU3cvTVBNTnlxMUNaNm51VkcwNCtIK2ptYllOc0hFR25NRnk2ZkVGZWNWRnVLbDBZSWxTNEdLc1ZHK0lYWW9sR0kySS9jaTJsUThFYXQ3UjJhcVlWejhSbHB4REc0NVJYRVJ1dlA0bUJ2aHo1bGRjQkhSVXEvSWdGWFZKU1N4Rm82bUVjUGtFZ2dBeXNWV0tBdXY0Z1JBZ3NVME1CRUt2aDJ4VkFiUmx2OEFpSm9VcWIxbm9QN3hvU29VNEdzUUFhV21ydW9yTURDMnlEUXJhelVLYVNtczVXQnRIRnZHOFNoQVVpVUVOR0NsMWJtTlUwcXFacThjd0FVREZIM0JOVlY5ZHdiQTE1bUxxdGJsWUs1TlJ6UzdxbUJUQnhadm1jRGNRYzh5OG9kdytVNVp6aWVFSlY2aGZiNGhXOEFhU3JsRlNhdzFpb0UwRGVTc1N5WkhMWnljUzUxUnM1YmpNNkJtbUJVTjV1aUxZTHRvOHdNWkcybS9xSUxxMFcxSWlnQjVIYXhBQU9OMURlUzkzdmMyVUJlVGdscFZCWnJFdFFuR3p4S0dNS3YzUFUrNFBFVlJIL3JFcmRxMWU2cVlVaHZlUDFGUW0xVXZFQlFGOU4rWUJXOEliNEdYQzFLcXlzeEpXUXU4RG5NU1dvS2REaTRMaTFHUE9lNWdEZDVhN1lyQUx5VlN3U2dvQUdnem1BdUZ6a3k0enZFVWdHd3R1NnhyRUNDMVdCeXJBRFFVTmpMNy9NSXF0dHh2clA0bEMwY21GM0VwRUFFODU5ZFFPRTNzTGhlekxWWFYzRkxjV1lML0FKbVFlalZmaURYR1RKYlJmTEhWVmRHYzFVcnRNdVVac1VMVjcrb1RtbTNmUHFvTXJTanJpb0tLNjZBM0hsQ21yTitvcTlWOVJUQXRlc1JuSUFmM2xBV2hIQVNuSWp3ZC9VeUtBQU1YbjZ1SmFHeE11Sm1MYThObW1YdjUrYWgyMUhWU3FBSXF5bUtxQXllR1UxQkxZZUlidlBGbVlseWxISG1Lb1Z4QlB0SHhkRE1pcURGVnhxS3RIaUxZVk9LM0VSclBtVUMzYkhHZ3BYOHdBUUFwRmNqZk1LZ0diNWlwYm94Y1pVTVBFb0NCdE1zVVdzam1Ha0hUbGloWGlpb2xhUGN3bURJOHk5THdSWkZGUUtFTUxCbkxUL01NMk15RjdJdVJOTUZhdW1hMzl3Y1FEM0UzY1ZtS2x5bHhGWlNZZ3JCeEFGUjFTRW9ZZzFTK29xRnZETm9GNHN5WGNHNExROGxRSk9sSU9maGp4QjRsZ3gzd2N2OEFxQ0lBQkY2WU9aUmtNY1hMcjdrRzdLd2hZQjFjSTNYRXMxZzZnUnZsaGlPWUdzUVVRVjVscmNTTkV0U05HRjF3UTFETWk0S2FNUktjUlVRUzVlbVl1STFnZ1hEZ0lJZm1jajhlb0g1aFIvOEFHcmgrSUZvZHl2UEpIaHhPdW9ndnFWNWVhbGlydU13WmxCYmRsa295bWVVU3NxaTV4a09aWWh6TEFTQkZxYTJGMUZ1TCtwZHZWeFcvcDhUOTN1WFJqWkI4U3lnZGJnbzlPUEU4elBQaU1zdndLRjZSTFF3dEJXS2poQWJOcjU3bFhTN0tyYXhieVF6Wng3bUVYV00zR3VDNkh4VUlBMWUydHNvS281S1NJQWk3eVYvZU93ZDlab2d0YjA3ZHpMQ1hSWThRYUZMVFNSRmdNYktxdlVwUVNoemNaYlIwUE1zQXJUZWZYY3lWc2U0WU1iZHdBRVNZTE9JdFJwNmhBNWxSczV6OVIwRG9oajNCK1pxN3pmRUlLWlpZZ09YblJFQ1VBYnJxSVVUWjFxaVVTeU9kdDNYVVcwVVNpcklxaTJpMmh3K0dWcEd5V0hpS0VDM0lYbXBhOHJNVWJTZy9jcWkwNUpTSVFUTjFlK3BiUTBmbGdBcTg4ZHhvTnRnN3JVb0JaQThjeEN0Tzk0bGdDa1ZmeWYzaDgzaW9OVlRIbmRjd3pJTFRabkZlb1doUnF0dWZ4TG1pVzd2L0FCQVhoYWQ4U3dSVVRkR0Fod05LQW95d01jR0d6T0NwZ1dOSFM1aWNsdWJ6Y0dpeHZCenJOeExOVFFaSzl4R2hIcFRWM0VyaHR1MTJBY3dDb3dqaENyT29Da1lLNEtXeUJYRmdGOGwvOXpLQ2JWdmY2bDJ5aHM2L3pBV1J3VWY5M0ZMQldydW5GeGdGcGZlaW9oME5OVmUwOEVxRXNTWUxxK0puRmgyQ2FEeEVBVUs3L3dDNWlwV1hyRjFSY1JZNHRNSDhabEJvMVhlWUVvS09LOGR4QlRiSEphUTZneUxTcUZNdjFHVkREc1NhNHlkUVFJdVBjUUJTWDQzRzBveDV2UDhBNUtHTEc4VmQvaUZyZGU1ZGh4dVZLbGI4eTRmekFvenJjVjF3NXFVbEdrSWlsZFZDTlhzelVRRjR6Z2lNQUFLdUgvRUVEVnNyS1VWaHpLQlI4d0tXNEg4c3F1SmhPb0lVRzRvbkR4TUJ4bTRiQ01jeGlOZnVhWGpFRFFERU1TaTgrNEZiV09vZ1BEeEVxcnA1am0zbTlURFlxMXFWZkZKejNEZ054aHNNVkxwUXpORm5acGxpMVZTdEV1aWd5UmJMWXBmOFJXNWlIbXFnMjExRzJtZkVMTnRRbzA2N2lWd3hMaGJxQ3ZEVHpGWE4zTHVKaUpRWTNOWUxqMjNNWFVvZHdqNC9FcEJzOGR5MmdOWS8xS043ZjFCQXZqOXhhMGNZZ3JvbFlPMHRWRFFRTVczWEVVdmlOQmlMaStvdG5tR3ZMREJtT29ObHdRbzFVRjYzR0V4dmlBRFdZMGxFc2xMU1VTcWxCWlJicU1jc3JQVlFnZkRyRU5RTzgvQnpMejgzOGtQek9SQnN4RTJnNUdiSDZsQUw1bDBlQ05Kak53R1FpamlBZFFzMW1MYVZXSS9KcGdhYmdwc3FVeGJsc2xLbVc1eURNYWJpelVjNnhVV1owYk14VnpZN2xEQTJzMXFJZ3NLcGtLSUYzamN5QjUzOGxsOFpZVlhRMWlYbUNneVBMTWpJWENWQXBWaTdWcS9GUmF0VjJYeEVjb05ZSGRhcUM4clZMS2N4TmtCck9Nc1NvcG1xY3hScWxMTWw4UlVDTGNTSXFWV01WY1FRQkx3WG0ySUY1UHhVTEJSYkYzMlFiQ29iK2lNb2NrL2lJV25xczhRQVUxUnBJQnlCY0ZwRE1PTE44c3hnV0YvTFV2ZnBORXR0aTd1d2xRbTlTd0krbzR0bzFtRXRpTTdKUytRZHI1NmpFM3hlZVgvTVNBV0F2RENPcDdYbjFNd0QzVjdsN29ieS93Q0dOU1dKZXF6OVFyWDd3T2Fna0FXZ29WaWNDbEFwMlNoS3NOSDRsNEhhMGNOeXRpV202eDZsQUFOY1htNHdzQ3BWUndpcTk4WENxV3F1NVhXYUtWNHovbUVOZkZzSHpFTllpRXFyOGFsQUJZWmJlWXh5SGRRS0ZsR044UUZCSzhML0FIVUFJVkZwQmc5ekt3Y1l6NTVZTFVyUmk4SHVKUUNoeUZHVDE0aVFxdEJhclZ4SzBnR3NjMUJORG0zeGJmN2dHMHJRTkVUV0tOVUtOM2VZQXFraTREQmQ4eEFoY3EybmpnZ3IzVHk1KzVUbFI4T0tmVW9VcWloWmhDQnZCYUdGMEg5NGlLV095dEpBempTN04vY3NFUWE3clgrY1JMd1dwdGY0bERZNDVYS1ppR2xvTjNlMldJV1hpaXNaNmx0MCtqR0lvcVFWd1dRUktXamtjNmdSU0Q0MUFScGt5WEhWUGJIRXVuZGNkeFVZd2R4YnJHRGw3akd4TXV3S3FCREFQZGRTaUlLbDU4eWx4cUVVZUNPMG96QXN6bzNMVnVibDhacUlxN3VBRk8ySkhIRXNhdkhtVndYZmNwTXJxSzdGWCtZRGF0VnU1YTg0Snl5K1NDWGJqZ2lXellSU3pyaUYyYWxSU25xV3RDMUhWMDJMTnJEQnhFalZsQmg2Z0RaTk9yY1JGWnh4QUMxQlJYVVA3UUJDbm1DMEoxVUtKd1JZUmlzcEtpaFdZVnMzRnN3MVVXNHNVUmFZMUhFU0l1MkxhTGlXclRMbVRVMmxHc3NyZGkrWmEyY3k2YU5iZ1crNVQrSU9LbXVZYkw2bEtkMmZCSHhpS1NtRy9NUHk5SEJDREpucUpSZUo5M2lCUmU0TG9qdW1pVmFJQ3R3SURpb0t3bUlBMWVXQ3JnQzNxSVdYS0hKbUNZZ0dtVnZCbU5VZWRRZ3RCZ0s1TjhTd2F5UlY2WVM0anU3SUMrSVlLR1lZbVh3SVlodk12SG41T2U1NitTUFVmNGo4TTE5N2h2TWVRbmNCWXhCQTVqdzhUVnpFZmFaTXVjL2lVR3U1VXZmWHh0SFVjbnFiak1Fc0R6QnROU2dDYlhseEtydUNyNmxOMmE3akJnYWd2WVJYV1lqWVBxQnplRWk3TG9OVGtjUWlWeVlZK0VaQUZkQmJFYkF1OHlxMVJQUElSRDJqRWV5NEt4Q0JyVlZqRnpFVzFkWWxvdEhOcDFMRkFwNjRnRk5yWGZOelFXTm5QTVhJanlyRkpsTEd1M3VDckFxYzFtSlFvRGtyaUtDVnZKVERhYTlzU2FHbTJ0UlpOV2JFMUVBcXU4NWxqTVhETDJYaUNpd3dHWTRLMWY1aXRqUjFCV00zS2VwYURKaDEyUjFuY1VMeDBOd2hqUU9CdmYxR0FSUnlBdS9NQWNHaXM0OWtTQ2dMdXdnbXBXK25mdUV3UlZsV3c5U2xvQjBON1loS3dGcW5IbUhtb1dVQng1OXhnaXhzM3dRV2k3WUNGVUpkQlR1NE5DeFhRbW9nb2lpWTFFS2tYT1FnMjVEWE95QnQ1RCthaW9JRnBuKzhNaHp5UEJFV0VzYkk2SE1RaDRtdUo5emF0eTR1WDNMbFZkNlArNGlhc0RCYWtWMHVXeDYvNTh5bFl5M1Y1L21LdExSeWMrNG13YkhyanpNSUNxcmJtOGVZcmFtd01uOEVLYUtpOEcwUDh3Q0prb1c0ci9tQ0lpZ2NxVnJxV1ZXK1IzVXFndjY2KzRpMTB3Z21Sdmp4Q0JRZ2VzSCtZQUxickdYWE80SEcyelJWVjVoR0d6cHJkeERTVjV6cVp0Q0ZacDVieEVlY1M3REo3UEUwbDdMVU10UzFoc1RnRzRGTFFWb2NCbys0Z3NTamd2T0pia3VWcHhLTHNjZjhFRmhhRHZmOXBTSTVwNzlSd1JLU3ZUNGdzUXllSXBzTW0vTUZPU2s2Z1djcWF4REYxeVVseWpHS05rYmRxS2ZnSlZXcTdpREtwcCttQXlHcmhxbDFxQ2xWbzY1STdTaW9aRnE4WmcvSnhEUFQ0Q0E0eTY4UkdxMWt1V3RzZFo1NFlGdkRPMkxueEtwQWZ1VUd4bUM4T2pNQTByQnFVQUx0M2NDV2NTcTMzM0ZHM0l6dHdYQlZwY3N0R1l0dEJrWURTdnNpdXJhZW9ncGJpYXhTSERQSkVMdHVvSlQ3c3VZYTVJVXNZc1hjT3pCTFVidmNXc1M3dW84TlI0V3lqZ2FtV1NIbUJvMFFDWHVDbHZKM01qa2l6YnFYbnhFQnR6eEVvemhybVlhMUJjR1VaU1BxVkxnRUx1QUFBWG9tYldlQm4zbGhxT1p2ZlBFTE11MlhxMlVXR1lBRUZnS1FBV2NkVFBpYWFJdVVVU20vcUZXNHpCY2JBVmhqbGlJWDZKazI2aWlYekhRTGlzdURhREZ4Rmp6Q25FQU53YnlnUW0wNWxSZW8wazFyNEUrT1kwZk9mcUxMb2x4VjNuVkZjQXk3WmdQRXd6aFFITXFzc1UxekRYcVhnWTdsNjNYbUp6MUJtOGs5d3hFaVZ1SXM5U3dlV08rb0xxbTdnZ28vdEtzRTVnMWswOVFTK1NtTzBUbUsvdUpoenBsSzFIUk9CWDNHRUNNVnVyUWhGc0F6VHVNVjFhZ2h1TEFMdFQwNGdBaVp3aXFCWEFQMUV1YnJHcnF1MkVXYTNZTzVnY2N3UzVlTjRpa0dtbk1NRm9tUU5SREJ2TjMzTEFnY1hHMUMwcHk4UkVOV1pmVTBNbzdnN3QySVhUR0lBMjRIVitaZGxDWjJ4TFF0bmNCdTRxckdXVkU0U0tBR2xFZXp1WEEybVBtN2RPWTVnQ3loeDBmaVY2THhsWTIxcW02R01mQUhOclVHY0FNK1h6RUVaNFgxRUFOMVZQOEFhRU9saHNOK1pTMU50RjZnSVJBZEIweTVRb2QwWXIrOFFpQlJ0OElRdGFXbEpjS1VRd2R6R01oZDV3UktBbFZSakJGVkMxRXhBQlpWZVhVc0F0KzJOSnNBMG4rSmdVdlRwbEkyVzNzbDFlT0xKYmVwL3dBL0VQazFLR1p0TmV6V0pVQXErSWwreXpSRWFpMWRYeGNXMXR1YXhoWVVCZGhhVitJVmRYWWJyR1A4c0ZBWEplaHB2cUNGcUhBcG5GOGU0eDFRbVJ1d1gzRVdXZ0tLc1BYNWlqUmlnWWRWbzh3VzZCVENQSWZYTUVnTlkxbzllNG1oWGF2YjNMVlFObFd1VDNMRGR1SEJWWjFFS2dDM1JiWC9BQktWQzAwdWE5a0Zwd0N2VVVvQlIwRzRoeFNaTERNTHlpTmRsVWY5eEJyR0FHbEtJaGNWVGRWdVg5MUx4YmJxQ3pRTHlNS0hnRjVUUC9rT3BTK1c4UVY0Vk9LbG5SVm05WEN4MWE1SFQ1aGxncWkvL1pkQ0ppTnJiUXpwYmo2aXcyTmJoS0UxNTdpMnAvYUxPZU14bGI1anFsNWp4VHFYYzl6QW9kN0p1RHFXVGNWQ3RYRXI3Z0dWeTRxS3pWMURUM0MrYnZpR0xIWkZzUE1iZFpZNFd5bnFJZU9LaUFOWjB5N3FLNlkxTEpNeFNJb0tmbUFCS093OVJ4dG4zQUlVTDZqbGVPWW1pc3kwR1VXWEVqbmJGUkc4U2p6Y283Szh3TkJrNkl3MGtRQzlPcG10TlBNVmpuSk1KZDRpNXQxNG5ZYTh3cFQvQUJFVVZraEJpSUw4d3kxeEdobGhzM0ZYS0Y3MHhVZGpObGh1L21KSHBNQlRMSzB0K29xQUdKVUs2bDFaeXM5Nm0yaVVsWEZWblVYQXhVQnpCdWFDQXVTQ3NzeG9jUTJzaDZQeEJabmNwc1F6aXBkRUJiVWdXc3hJc3pxNDZxSUhHNVhGdVltb09OeFB4TlFYUGIvTXVuTXpmaVA4eGFqTmtNU3UvajNCZUh3RHptYmwzaURoSnEwMklVbXNNenl3a280aUc4SjRjdzFUS3B0bUdLVmphU3JjNStNRnZtTzJHRlJwRTRnY2ZzbGxaM3VMblY4Ukg4ek5EMU1GOGFTZDM5UU1MMHpackhpQ2c2M2NBb2RNTk5PYWlUSTBqWkZXVFpjcFc1VVpxaFg3Z0lIUmU5NGhnRGdMSllCU3J6cy9FTWJUWTVWNTdtSkRoeEV3d0FGQnE0RVc4ZHY5b3JLQnMxWmlLaWczaFhFV25YUnhCVmQyVE5RUlhUUmk0cDIvVUJVVkhoa21tZ0FjYXpFYkZGTUFhZ1hob2NVeWxRWFBjQXAzekJtalYxS1BwM0VOekkvM0t0aHZEREJWR3JPZkVBMTVWb2FEVENxclQxR0hZQk5STlljcnhCUXB1akx1VldWbkNZdUxwV2xoaWp5eGdBYVJRM3pHS0FKVFpsaVVhcG9NWWlBSUxXNzVJZ05ZVFE1KzRMWVNsN0RjdWl3R25VbzJHMnc2bUt3dDNXNE5hbE5IVXpxM2VGcUJrNE1mY1VDbHR3aGV5V2FDbk95TVNuMnhaak5hSXN1UU40ZCtJRmx5UDdmN2cvQ0ZPeDVsUzN1TkpMMDNDMEhDWVNCTTllWmNveDJUQUgxTUtXNzN4WFVVb3U5WmVJbEc2QlNxNGdsdUN6R1dqMURJVVZ2RGNLT0t4cDM3WVpITm1UNm1hYUxWWC9rQW9yQjNtTFYwVlg3NW1GQnhuOFJJdGlxWWVhLzhsSVZZM1o5dVBNd2FvRHhWUHVDa0JBTVU0KzRya3V3YUd2MUJSYUVYZDV4TEtTbkdhSGNvdFRhc0RObk1WVk5ObW5ZYngrSlpWQVFLNnhCYVVYYlltTWY3aWhTVUk2MlJGaUs5Z2NmM2lIRnVzRUdvTHhZZVBNWk5HRXNQN1JDbk5sOWZxQmdhYnJ6R0cwcSsrNDZvdXorWTZCMzVpc3dGZFZNeXh0MG1vcWZQd1NnYkxnekRpbzBxbk1DeXVMdUhFUEVLQmVaZEFFTFo2anZISFVzcXk3bGtwY2RTaFkzTmJjUW5xelV0Yjh6SkEzQm5tczFGYTQzQXFBQncrWWtwZHhCc2NRb2ptNVkzVnMxY0RJK3BRcTFUbU1MNnZIbVdJSVVFNGI1R0pibTFpRGx4S0FEY1R0MmtWRXQxcGxvbk10NGRhbHFZTWJpSlEweFdSM0JVcTlTMDVtRkZwSXExcG5GL3FYVXZNdW5VQnlCcVdKWE1DaHRwSlZsOHhIbWZwTEVxZnltMnU0ZGZNU1YxbDF1Q0dOeGJmb1RBcnhtWG95dkt3THZtS2xTaFJ1TjNMRjNneEFNcHFGTW1XV0ZoamJUcURhOGtva09ZbzVpdVNDaTNFbktDbVlpWkpUSTRqdXkxTEl1Nll3M0VJbHdydTRTV1FwaUttalVHSFh4cU9NN2xudTRQcjRkNmwzdU1jUzQ1bFZENDVpbkVoQzZuQlU5UWN5eHVrS2FjVEYxbUFYY2JKczRtbU9zeE1ZTWRRSjZpM3JjMU42aGlreVRyRXEzTW5EU3VETG9qeDRsMDRuUGlKWmxxT0tUUEVGYmh5T3F1WGNWTUYwZVNwWm95Ni92OERDYVFQcmNWcGdGeDRqVVdyclhtS2lJN2NIMzVnVnB5bWI3WUwwb0VXdHNJdDRNcGY4UUlGMjAzZW4xTW9zcHNKV0NGZXpxWFZHMTY4UWkwcmNJQVhyVVZGRFVSVzNZK3Bha01PY2N4eUtoZFJXTVoySkFMVzhES0c4NU1uSXhlMDV1WjRIRHpLUnI2TVZGc2NlSloxc2NMSDF4NFZzUFVVR2NIY1pzT0I1NjhRUUFGWFN2TXBjWU5DekpLQWxuT2ZFUnNkV2xtL3dBeDlzRzNkZVpWalhPKzlOY3NXa3AxWW1MalVVV0tiY0Z3eVJDZ3RKU0ZLTExQTUJ0eUYvYUc5QXQ1dmdnS0JCT2FJTFFXT3lwU2k3Q3J3MkV5Y2dpS0pCa1Z2SmpKL3VXTGt0M2J4M0VvR2h2M0xGYndZUDhBdkV2WmY3NW1BL2EyWTF4UDV1RUpkNzBTcGhtWERDVVhxMkNnTG5ueXdCVmxtMEl3MjdyN1lxcnRuTkJqcURTcmk3bzZnb05HZE0wRzRXZ29ieTN6TUVobHErS3hjc0JTL3dDaUt5cnlickJNa3dZeGNWVzdXdU9KYTBzN2RGWmlZUXRCcTNtQXFOV1o2Z0tKVnRQMy9pSVdOT2NqVjFLUnZMM1diZ1NoWUYraDdsVmVTQlpicUlVNFVyWFN4R3M3MnZpVms1ZWNmdUtnYUNzQjcvbUlkYmJUUVFXdVZNTjJFVmVRVnlNR3ROSEJ4VXRkVVd1QzdYN2hjdThyMVZ2VENhNUxjWHhmRVRGVGRQTUxkdXVBZVBjRVZMcE1IanRseFJHK0JnTFFLNVkrN2NGd2Jlb1JZYkJrMVhueVFWcHFMWFVzWHVLMTdkRUZsK0lyd2JkZUk3bDRjQkxZaFVhdjl6Tzh4ZE1HY3Nzb3FDbUZaUnU4dlVkdW1EVXBMSTFlNG1tQWd4NWh5WE1GWWJPNWpJMUtoZFNudE54QXBNWjFCNEdvcmFFcnVPZ0x6V1pSU0lwdTlSV3FkUXVpdGxRQWx0NGlwczNBanV5T0d5NmRSSmppYldGRVhNRnNnbWM4ekJlSUZtSVpIeEJ1N2FpTXV0OHhiS2ovQUJCZzJsdFZMcGFqVWJpVXhGM0Y1ano4L0hMOXN3UUdYS0ZkSXRVRzUxUWRSclZ3TG96QkRLVkMyWEV3bGJpVGtobkNXTCtZUmF0aW5yTVZoS053REtvYWNRV01RTzRCQXJQY0hDQzN6TDFVRkRMR3VVVnkyYUlYY3ZHb1ZPWnNteWNZbnVhbHp6RDRMTUh4KzR0R1kvelBjWDhmRHFIWmdscm5FUVRIRU4yUndsMUhkSlV1M2VPcWl1SCtJMkFtQzJOK2dSSW1ZWm5PSDR2TVY2eU12a3pMVlF6Q29tb20raVZvTzRXb3RjUlRON01CRWxsUllqczhFMjBIbUFzdnFBcDlSVTlHaDVKV2ZVVGI3VGYzRmJRYUlxRkJUQmNLQzhsY0R0aEN1UzQ3bENzQXFxMDVscGtXT01hZ2tzS09Za2FvVmc5eW9ySjBiM0VwdGJjWHpBamlnMFNwMVZtSUFBQXN6ZGZ6RndXbmRWY2NkdzhmeExabGp4RVN0QjNFQnBCeEVaQnh6ZUY5UlluREt4aFBKcUxmOW9MRnRPNFpTYm1od0dvc0FiZUlOajQxWkFyeTdySHFJQ2hWT0t6Y0VTbkZmakVJQURhNHZnOVNsQmtvM2xJZ3VsaTZlZW9zSnRCSzl3d0NEdXVJTkMwTGRzUmxxekFuY0JkWU1XMXRpT3gyNHN5VkVsbFc2Q3RRMWdjbWpqN2owUXV1YmlVQXEyQ2VKYm5GSys4U3dDODJYMU5HbHJwcmlCYUYxOTRsUnN4V2JnaTZ0RnlubU9qakFPUERDVkRId1RJbzB3T2JsRFlRcFBLMTRpMWlyYnFXOE90WHhHYzQ3WUZWVmVQRXhYZUtxM2YvQUpBRzlhUlM5Z1hNbHlCTHJsNllYWWUrZVlLQlJHaTI0ZzBBYmFlZW9iSzdpRGV0R1htRDRJWG5UaUtGQlZRdmlBQkZvY1dGMnc0S0d4UnVycVlGVlZQMHppckExWGFSRkRTcFRSS1dzcU9jRzRpV0FYcisrWTF1OFYyUVptd3ZpNWNCV2d0UjNFQXVnenNTOHlpeXZhMXpNaW14bW9GRjJweUdtWFVGVmNpYjhRVUlBVjEwUDhRS0FRb29ETndLWVFXMTVTRjNUWnlXYSsvN1FLd1oyUUtIdDRnb09TcTFGcWpnY0Rxbmk0ZzBXOVgweHlSMWRGakdseExCWmo3aHhGdUtqQlU5UXdCNHVQbVVXK1lEQnV6RDlrQUFXSnpHd202aVN4WVpQM01sREVVS0pGbWtidlpMMFVhN2lhdEtxRk9ONGJ1Vk42bDdhbk5ReTlRbXFBb3BybVdTTnBicUMyMW1vOEhHNDI4N0lDUEVwU1ZudVhUWlNSTFpuRGlWY2pkeFBBWmJZRlIzWkJkWEc5elQ0WUQ4WkdvN3hMaTAxM0Z2K0dMeE40NFk4L0VOZmlmK1VBUVMxbXY3SUg5MHNwNWdhby9NcXh6REx6Q0cySUpBMVJMVURQeGowNWgrYUk1TndqaGxsSUNXUXMwN2lERnhDc1FVUXdhaEJheTNKcUVXeE5tNE9tQVR6QTZpTHNpTHVvTjZqcytPWnFHcCs1bUh3L1U5VERUT2JZQ2JqQTlvamc0Z1JaL0U1a3VqdVgzeGhmRzVsVFV1bnE0blRjNzZDV3QyUlplNWpSaUE3Z2ZhZW84Uk9ReTBkUzdFSUtZSWlSWHdRWGQ0cU9ISEV5Y1lpM3ZaTkhtSmZwTVNyQmVJTGxJNnZVSStMR3Q2TUZlbkVkcHdtL3FkdnVWWGFiL1VFWE9ubnFNU1Z4bkVXWlFNaHVvaFFKeVhnNkl0QlJad3VQeENGbktaMSs1WEZGclQzR0lCb2JJVmFVRlpXMVhvaWpWYjVMb0NMVEJSTUc0Z3cwVmZSRkNMYkNEcUFxRjcxQWdpamp6Q2xvMXo1Z2dZVjdsNGM4YjZsRy9UUkVEWCs1WlYzaUlyakRHRzM5eEFPZjhBTVYyeXByMUJCVWJXZ1dVVWFDODkzR3dwcHBIcUlxdkkyRHNpUld6ZkovREFLQVNoVXZucStvVVd3dkFOVjRsVFhnc09mL0l3UkNoWUhMRkFsS1pZMXE0WFBxV2xjVzlQRXBXYnlxbVVHZDdWL21DcFlEV0dZVFFaUmp3S1VPcTJ4R0tWWlh2TUZ6WWk4TGlCZi9SSUN3WUIwd2xxWlBQRURRR3ppNkdXZEJVSHFFTG5GbW9UYjNIU1ZxNGdnZ2Q2bVJhUDNCYVd4UmtIWmg1aWNVRlA1bUxzM1JueERkMlVtdW5QT1lpZ29BT0F5Ni94S05XRlcwOFBVcWhGQzJIVEdZTTNtOXYxM0NIM05uVEFUQmxiMUxXMjU0bVVMUyt6OXdSUldzNWVqWDVnckFVbUszcWJXWFIrL2NCQmFxdDg1bGdvQmUyODFEQXRRYXQ1L3dEWUFRRExUWkxFYk1PVXVGTkcyY1JNTFJyWEVTM2ZIakZRd04veHhMb3EvTnNhTWlwZlV3M2RHN1ArekJTeWxKYUdINmVQVWE3THE2b3F5V1dMQ2xvbVVPWWpRcnN1cTM0L2lVWWRHamYrb1dnNjBzVGFzV1RnRm5naGxBSWxJOHhIeVZsZGs4SENNd043L01wekRVRithZ1p5aXg5U205NGhsZ2FuSnZVeDZlb0VWcHJpQ0d3WGF4RnJ6VXhrUzRickRIYXc5a0FDelhNYTZsRE1GZzRxSzl1bUZKdk1SemJYVW90TlgzS0JjNmc1M3pxVzNpR01wQkxjaUpZcnJ6TCtFQlZDYmkxcUxqTXZKRnBucURDeU9pNDc4UnhkY1RkZE1vQlRtWDlYTHVid3NTeDl5bHhQMGtHUGNiWjYxTENkeHV4ZlJPM2lMUHVJSG1hamlEY1NyTEdJTGJxQTlRS1ZndHNZVzhSSGR6TEsxY3l5bHJYY2F5TndvOXpKVVVxb2tMMlJBWmdKam1LOWJscjh4S0ZtRXl6QnA1Z0p6QnBtMlhCaHI1dUxPSmVZWnhLaHVudjU0eG1adkRTUlYzbGxzSE5WR3FMSHdZTlNoVE5yeExJektIQmlEV2RKUlZaZ01xMUVYcTVUZFpac01vN0lhRFhtWkg0SVk2NWc0NmFqUnBOeXZ0RkZYTEx1NVMzR0hHRXlwOFJZR0ZXWDhRVzBhcUtxZFptVDdsbDFoTXk0VzJ5WHN3eTlSYm9IQkFadVU0akdtVnhVdUNuaFhxVVJwY3VBMHZjUXE1QXcxV0pRS04yVlpCR2kwcW5raGdWRnhqekNnSXEyZFJoaTdkMm03Z0twcGUrSmFhaW1rMW1CVmhXOWpsT294d0NuVlExR3owY1RoR3k5ZVlRWktZQUQ4cDVITjRZbVJDbnVMNm1QbE5SbjN4TEV1TWJnRmhpOGpNMVZzdjNFcVVGVmFYaUUzRUx2RGNGcU1ObGhkK1NVSlUwM1RveExBYURzYzNDcHZCMDl5aFVOcW91d2hVR0NYYlhQVVpsR3gvTUtwZzRLdHpCQkdoRkxNd1VIbGF5WFRDV3ZOWnZoaVJMemUranpLQ2daMWpjUWh3ckJVTFVVc0huKzBzeU5nVjRJcUlzSzNuY0ZMQzdUZk1lRnJXWWhCekZUWGtWMzhFQzlPWldZZHhKeEdTbEppMDM3Z3N6L0FCQkVBY212RURibkhLYnFWZGlCZUJnY2dMR2pkOFNscVdnMGVMZ3BBR0RQai9FQllITG5MTGdjTlk4UWdLREJhUm9Bc01rdUJER3pydUFSUXd0Vi9JUUZJNDdWeXpRUk1qbHpnLzdjcHNyRmxEazkrWUhGNHJWOGY4UUtPRnNwSXFOWDlqKy9jS21GOStJaEl0K1lLZUhtQnM1T29SWFo2MUVScXNuWnFvQUFpSU05aEVScFNnMTFOcUZveTA2WmRwZFhpMDZnckVCMXZmOEE1RUpiUnpWWGZqSDk0aWJRY2lqWXZFTFlCdHpreDdqR0RGT1ViSUZOZ0p3dW96RWVLLzNDSlNadmZjdXh2TS94TnBjRHUzM3FEWlR1QWpTYUxoaGJ6RVVZM05yNG5lQy9valNtTTh4REtSVTRab3NsNmVHeUpjc1A4d0N3ME01Y3Y1WU1RMW02NENVNWxCcVlEMzFGRmwwbjRpd2xYMUNpOTNCem1PaWI0bDJseGF1bk1Sb1NKRERFc0lVa3BTemlMZ3VYdURIV0lQREh4bUFwWVlpOXdkVVN5bGl0bDNSM09jNmlpUmJ3UmE5em1QS3l4U29QREJkMzNFbVUzbUsyM2cvY3Nxa05QYkV0ekZxZ0pwSUc4d0xWR0pSVmdsdjFMclJpZTJZSzRoeDFHRG1VclpVTGFvTXJzaXlzUFFpQnd5aHFBbExtSUlIRUNNUzlRa3FBR0JCbjVaK0djWGZ4ek1WQ01FbDZJWWI2bmp2VXkzZ1IzNVRXbzZPK3BiekJ1Q3VNSkZRWHhIRHFWY0x2TUFRRXBZMWF6QlFDamlDclNkVWpjWTh4d09FcElnOGVJdWQvcVZxMkNHUXFYbmwxZUprWFE1bGRWaWFaY3c1SWNMTXAzSElkRXRSSFJERi9xS1hEUWVYY0l2czNFMnd2d3B1WGljR1pkMS9MQkdMd21pT0E1cTdlcGFGb0xkTmFsZ0t1eXhUSWtVUW1DV0xFQ3QxaXFJaWc5L1pNeWxGR2IvN2NwSXFFdFUzQWdvV3VEaXBiT0FWZEhOTUJNZzg4UkpLT01xbXNLdFhVVURCWnUrWXF4eDFMQlVMT3VJaVhlQ1BTV0IxRTQvMnpLMjVOK0poQXZMR0kyZzFYaUxNbGFRRWltQUFNWXg5a0ZBZzA1N2phMExMQS9tV1FoaFEzdUFCMjVWNThSS1cwbDJEbHFMQWxaY25jUUczQTdPS21BS1haYWR4QVJXRFJ1V1VSdSszaUlvMkNjU3FDeTNndjl4RmhMVXlCdUNGQUtHd0dhZ1VVdXF4S0JuSjNvaWhia3VBR2lOVWdVdlVKQW1kbmlDclEzM0tUWUR6QU02V2YzK1htRm1wVFgvRUhVU044UTBPYTBRYXgzREtPcmdBekhBRnNxb0V0cS9NQXFZRnladzNDamFYa001dnpCeGVUT0xlSlc3dm5yVW9WUVRxNGp0STFuaFpmV2dFTkhENGcwSzVGTHpFc1FMc3pXYjh3Q0l1NlZEYjdqV0MyNmVnNWcxT1VjRm1IL2NBV0swbjY4eGVneTFmNmpCRklybzVQRnl3b05WVHRJMWtjVFFQekZUUldLekdxUkxEWkZLWFpUZmN3THVseGcvaUp6YXUxT09QdVZWVTJEcGEvNzFCd3VUa3ZCQXRRN3UvM0tRVXJzdjhBbjFGcGpCVGQ1WUFMbThVMUZXbHVNS1VCclA4QU1LSTF6ZFBNRjRzZjdtTUhJVEQzdERRdXBzcHRNUWNVM0xPdXBvOS9xS3NSTlFXSzRRL00wVUlyWlpTcXhEbTd6SE5uSHFJREdSMHpWblVMVzZnS1RxQVpjV0k2UU1BUm1RenpCYk1hWlZkNmppeHBaY1Y1WlN4YWNhaXpHMzZpMjVpNDFNV3ZjMnFJRnlIWnpNbmlYYkZ5a3p4S0EyVzl6d1lnVUtITVdWWTFjRnhYblUybDlTKytQaFF4V3JMb3pNYi9BQkxDZmNHQUlLQURNRlVHV29ZcnhsaGc3WVVxN1lDcjRpYllZK1pTN2VQZ0p4ZUpjQ1hDNU9PNW1zWEZ0UUtxNEFNUzExeEVyVzVTSlppS1J6OW9VYkdOZFFGM2lDZ0kwYXVLakVScnpMbmNNYm04V3l6NC9keGg4bVkvaWN4UVNnck1UeEFmTXBON251SkNKWGNTVUZyaUxVYW1YUGN2NFZ2RlRvWW5ySkV0S0htRnltZUJBWTJqbVY5aUJaTkFiWllNMTRsdEhFTVpRWGg5eXlnTUVWY3NxamNWTmt5bDhUQktoZ1RseVRzMUZ5eGNhMlZNajFSRGF0cXBSbXIrTDNoKzYrQlljZzJWY3lyY1NrMXcwRUEza1ZMclFRYVFNVjFVU3FiRElmOEFjUUNyd3BlNDh3empGOFFLd1U0ekdRRmhzNkloQXFpVWFpb0xXYnJtNHRVVEJxLyszRHNOSUs3WXlxaStROXdFVHJMVlV4RkVCQXA5a3p1L3hGS0RqeEtvL1VYSzQ4UVJvKzBleEFkdTdpS04zT2J4aVdxb0VvaFJZYllBVTJ0WEZFRmFOd0RhZ1VHZGZVYmh3T3FkUVVkcUdVLzFGVmhsNUpZQWx5THptSVFiTGNWWEVvWXFneXFTMTZJaGxQTUtnTWhubXBTSFpWdWRSYURWcmtMNWlJUVhPVmdUaGRVTHpFWFhRVlR3ZHdLUXVycnVKYXB1dERFRXhWU2hNK2pwbUFZWHlzcFJzYk5WRTBYbEF4M0JUVVVQRENDeitZTEE2Yll0Rnh3a1VjWWRZUDNCeFZGOE10eFNMNWw1c1d1ZmNWMDdCcGd6WXVjSGx1QkxMUmtTampGV1pxVTJ1NjZDRFhLbjFLWGZKeERhaXp4RWdPR20vVEtKU3VEblJFZ3BRQUFwQ3dFUlJ0OHMyZ3RvMlBMemNGbUd3YUc5dlVkWnZONTZaUkJGUndqcVphRFFyWlhqcUJLQzVQOEFFQVZRKzFpSEVWRkFlY1o4UlVYQ2VZYnlZYWc5M2cvTVdSbWRubVlSYWJHam1BbHZJV3V2cUlMRFhiQVd3QWJVck1hcXFQRjNLSEdzRVlnaFFuZzVtUUtib3JpQkRJYkxTQmFHQy84QU1xVHptT21YWURLVFBFUldiaXQzRExpVlhwbkNuTUZEZUlaWmdVZUlEWmlCdmlPT05jTWFsVUpMcXZDYjh3elFkOHhBRVJhbG10dXJqZEZJY1JqdStzeWl6TG1MR0pWNDNFYnpGZWlvTlpQeEZUN2lSbDIxZUp5K0lzREZ2Y1hKQnNtU1c0bW5zamhPWVUwcUdLcklOd3dSV1lsRm5mTUhpVmJ2TTY3bDViTXcvd0NKcXFLbzdnbUtvcDUrQkhUYnVEMElaeWdhRGpVTm0zVWVqaUFBblV5WXNUZGlhUUZBOFFnSUVzNlJVVVJxbU1jeEZzU2FLOVJLcXd5amdpcmdzaGFySVJ4QmR5dzBSTFZ4RGJFSXVJVENRSkFYY09FREU1Y3dmMThWdnVHTnorOFlzTGpsdXFoaWR6TmdtQ1dXY0htVUZXR1VPNHZ3S0NmekJuTS9TVlZ1eU9TeVVick1NMUZIbTRucE0zcXZNdXhrekhVVE9HY3ljOTFCV1dabnRxVnljUVd4aVhDdXBZKzRtaXNFR1czV2lKUlltSTBtMWN5K0hiRzMzQXNmRU5OMWlZQi9pWkJXRmh2M0JpM0VOeXF6Yy9QRXhiNnpFQmNLNE53T0hCY3FjVkVFd3BNRlFLc1dzNWxpVk95OFFnUlZPTVFVdHF2QTRvaUJVTjlFRjJoV0x0elJBVEFEYnJjSVFCUmJkWWhJN09HS29GaXJUaXBlS0VUbll3cldvWFZZK29VUEg5NGh5dWVaV1dXT0tJd0RoTGdSODF5d1FER2VYVXhBdlp1aEpRQ0FWZm1FRjExWE1DV2JFcStwYkR0bXpnUDVpYmJlc3E3WURWRlFVZEV5cUpUa003aVpGVWFwRU5GT0tnMmxKWnluRURUWkhVb1RZbWJlZnFEUXFoZDAxVVphalpkMVg2bDJVKzBRbE9yQWZ6RUxuT1hacUZDQjhYeVN4bDNLQ3RaNFlnQlgzNmxYdHFERG56R1UyckhMekhlR3JiK28vQkRMT2wxY1dLWnU1bGY4ZVpab05waUxnZmZ1VUlCbmVEVWVtclVzSmRMbHR3WDU1aXZGUEZPdkVWMEFCdEdLbTlyZVhqdVdJdHVzK29tcjE3NmlqUnAxNWdheWxQUGNTY2VGdmZtRnd1N2F1c0JBc3NoVlYzRmhRNTNSai9tV09MMjE5NmhsZzFob3JCTEZ0dytZOVdxWEpqVUNsR3pHVEdvRlVCckhFRk1wWVlIdnhCRjBIci90eGxZdnBxTzJGNGF6eXhITjczdUp0QXVQTHpyUE0wME5Ed3dCWEFMciswUTVBYXp0cGwweTU0dnRpVm04R0NuY3NHcmFwemVTSXYzWnNpMmxLRjRXTFlCYVZnZUlGSG5HNXRzRi9xV0M3SlVUWnZJZm1MSm5Fd1hEWkZUaUFnZFppczZsamppR1FBMUhXbkhVVlNsRmR4U2had0xpNTliL0FERTE1MUZwYjJTcGpMV1NVQW90MndKVkkvY2FMdDNEWmRRV2F4UkFVeHdaak5KSEdYRVcrdmk1ektIT29KZWNrZlJpWGg0aTMwWmVLaGtiK29yS21kYmdwNGdqTk1LWTRoK1lxVEppVXg4bk12TnhiaWxHQ1VxSzd5dVlVQ3RzRlJXWGNEZE9XVXdOMXVaRHFOcWhsUkNzek1WMmdHb1YxdUxjeUtxTlIxMWNEbjNFM0hMREF3WXNhbGdXczBJNWNSd2dPYXpCbWdxQlJCbWh4Y1I5b1BERk9ZcHhDVjZuUHdlWStZWmNRanp3Y1JTNjN4T1VsTGo4eFRMTXBzdTRiNmltTHVIZFg1aGw3NmlWaDNIRUU5YVlPWTg5U3lrTVRYTXpxWGE0dEx6ajh4WGJpRG5pSU9TNExIcVcreUtwT1ZoQ2x4Y3RiclV3NG92b21rekZacWJ2eEhpK0ltYmVaYTNjUnBTYXNmaVpYalJGc3Y4QU1YSjZocS9DTUZyVXFwYy9CMVdYNjRnRkNVRERlWDNLcXg5am1BbWxBcDhIanpFS2dXR24zM0F3NVZrUE1kY2dIUkJTd1N4eFgrWmRDeUJoNUdHS3dYSDB5bTBCWUFtNFZCUURwcXVJc3dHMUtUVXBzNGdIUjRnTEFhQmJXcFNHNjZCaWlMcFBzUXR0aFBzSEhjcXB2bXZVSWtzMk43WmJqU0hOa1lCZ0RoM1hxT1FGcEtiWGNxV3NDUVdRVWJLY1FRSUc5MVlIY29zMG8ydmNzcU5GL2R3SzRhL2NzRFpqTkM0UE1JcG90WXJ1V1JoWmxwL21Gc3V4T0wvbVVRMmVMZ0Fhd25aQmFBRjNiWE10d1V2dUtoWldLSzNBcUN4V2FOc3pITjN2T3ZVYUF1MUJ1dXBpNzhVRUtRQy9NYzlaektWV0w1cVVwZWNKNUlzRThzZmdhYWRRbVh5MjUvRnhVbXJpY0lyak9JSWlxVmlpNGtRVStqOVFVYlZ2OTNBSUJndnE0SWpPSEt1YnVKcW5GN2VqdVhLSy93QklJcW1lcGRndS93Q0pRemdRN3NJVkRpeHErb0d3RjFuUDRoZGJ1cVJQV21Zc1h1emlVYkYzU2wyNTdqczBVWHQ0SXNOTk40cmNFSmJ3MS9FQ3dIRlYxTGxDRG92QVRLRlJ2Vk1XQXYxMnhkWXh0NGdHeDRWZVplNlhySjNLcFF5WGp6QU9SaVUxYURoOXhZQUhlaGlHWEk0NTRnc1ZYUlhNcXdxdUZyekZjVm9zdHJERlRndk9jd0cxTFJMdVd0TGR1RHI3Z0FzQmY1bGFIY2ZVNC91T3h6clVBN21ra1BNd3E1UklHTG1Fb29pRmZ1T2ZBaWxxM0FjcmlCSHU1bXRnOE1RQmVLNWlPejNHZ0ExTEMxeFVSZGhoSUprZDhSMnFmaVlEV0kxUm1MaHU0NXVQRExpZVlORzRyczRnNDFHQ1JieXpYM0JPZFJsNTFjcmJiSGNRbVl1NEhOMXFjNStNNGlBekJqbWNSV21vcU14OHpDay9zaDNlcFVqeTFMYllLVkxWYnRsZ3p1QmJ1QmR4c3hkRVdWNmx6VXBLTlFUNFFBenVZOGJnS1J4dEp2Y1d3SWpIQksxZ0pkeXJwaGhtS05WQlJFT2xNVHFLdVdURUNyZ3pNNmhMeEJGeE9hbkZFVGR0bG9EL0FNbWRGczBZRUcySkRKNWdoVE1Lb0pjU0U2amdHN2R4QmNLdE9ZdFRNa0VWcG1ITUl0d3N5YmppWFc1dHJtUEJQTFpEaTlMOFNpZUsvd0JweXMrSmhycUxWSUsvMmlHbThSRDZSYnpBMitrVzY4YWczYzBWZm1HcjZpK2lRYzgrSTR0MDNOR3RRTnJncVM2eFBQM0xDVWhjQVhYR2J1R1J0WEVvREVUUjB5Z3BTdGhXNGhGRGFLNTNCYWpnSFJ6NGphR1V1amlab05BQ2VKWmdpb1ZkWWlVemZhK09tS3FqZzVheEdxd1VHSzBQY2JWWlMyNDBRR0pSZG5FU1RLS3gzTFZ0MkhMS2dqZDQ2cVZvcXR5a0Fic21EYkdpZ0l1enE1akxhM0JkL21hRUZ2RUFMUWlsdDVJRVFKVjNxc0VLcWpRUE9DSlN5Z3FqaGxTRGRxMVlSQUpZTlhrZ3l0cW0zWDVoUmd5MEhFdlRnRlc1KzRyQ05IRmJZMjJHQkdLQ3RoenhFWUxTWkZZcUFXOFgyOXdCc3NGcTdjWDdnb0MvcHgvbU1BUVgwdFIyTFdLcXVvb09Dc2E1bTF1QnpCYXpGemtPb1FEV2JBOXk5QVhqQ1N6L0FJS3hJekRoaXN6QWxMcGkvRUY1SWJvY3gyVmRkdmNTVm1qVXdGZ2RZL2NTdFVyZXFpd21RTVpnbEtKZFY2aUV1czFhVkN5SmE1WW9aOU9kUFVGdXhxb280UnZmaUkzUzN3dnFES295Nks1OHdiQUZiem1HRjhEM3h3U2dLY2M3bXNWbXhlQ1dBcFpXUGZOd0tieXVjek92RXVNdWVZQUx3OCs0UmhhcjFnUEVXM216Z0lsNG9jK29sbUMyOEIxQUtKb0REZTJMRUE0OGI4eXFrM1dvbGw3RGVjd29vOVpkWmxsaU9hMkhFY3RMVHhFMldwbG1FQ0d6UEIvZU5MYnc0dnFBQ2tWeTR4UkJHbk9pemNOSHBKc2RxdnFLbHZtS3J6aElvRkdhUytvcVNFSER4TFZ0bU5RZk1RaDRtQlE3Z3hSMUhhMjRaVGFFYWhBdHhDN0NWQnhxM3VJRkRpYkF3c3R1bnFMNTlrR2lyNWxsbkpGbXBkY1JiY3hEZ0d0UmJnNFdDMWlLbk11OHhhWmU2d3dScUs0WXJPWXRsMTl3eHFEZXR3ZUdiMW9pbHpEeExPWXRrVlRGQXB0MXI0eEtrMmgyd0NhMFRPc1FpWE1vb01SUXhjUnFLNGlBWWdwdGdzd3h5enFVUW04UnlocUZjSUtNdXdJNDR6Y3hVc3RMR0tXTVVTb0NxWEpHRzQ2ekZ0bUdNR3FHT0dTQ090eXd4RUdWbWErRFdQVXdIY01HZ2h1QWhiL3FIc1BVdXBsVWVmN2hJdWUyOHdtS29oZW42alNNUjNkV1F5Z25pRXVvKzBJQTdpanhNVFUzQ0RPQ0NHNEZyZW9RNXVOUGFWVWJNUiswdjRTaHhCejNGNE9JYVBITE10c0UydHR6WlJVZTZ1WGVKV2N1b3VjUnpXSEVyT1dEYTFzaXBzM012RlM5Sk5RT3FqSVdxZnVVWXFHR0RSbllSZ2dyVzJaYmFBV3RiOXhXaTBBMHVNUzBJMkdxNmpWSUFhRXJmdGc1alZBcFpWc3F3QWhxeDNjSlZnS0xLZnhFQVdzM2J2bUlBMlhkWSs1a0NqeTR1UElEQ211SlZEVTV3WkdOQThvT0UyeWpvUWQ0eEJGa3Z1Q29vdll5eTdldGY1aXFLTkFuMVVCaGRkb3dDeDAydDN1UENnUVZRUDd5cFhRemdxQ3RCamxsQXFzTTBsWEtTMnE3ekFsQXRPZTROMlVOYjZpamVTblp5d0cyMzdEeEFwS3V6eHg3bUhaczcvbVVLaVc0ZHNDOEFSZVJMVXFoSURVTk9wWXFwbGFyKzhFMWdPSE1GcUxTN2VUeE1Dc3J5ZUlLTnBsZnhFeVowdzlSZmJ5U3hwVmZjYkxiaHdIVVZsZDFSK29sL09vcnh6Tm9MTlpKcmsxeEFMZmN3VEszeEJXaTV2R054YVJxcmE1bDFtMHJZT3Y4eTdFZWUrUHFYUjA2RnhjMmF0QjEyVFIyRjNORUxMMDlUS3JQOVJ5bzZyY1YzWElZT0pZdWx4TFE3QnVyZ0hieHFYUzFXalhtSW9Ha2ZPMkxRQ1VXTHo5dzdLemVIdVZFRjQzTVBrMWNDa3VqQkNLYlFUamlXYVdrU2pjdG9Vd2NNS2pPYXdIRXBZTGdPc0grbzByMnBmeHFLZ0c2T3Rja1JwU3U3aXdJRzRFdXM1MUs4aFdacW02VExMS1Mxd1psTG9MNjVpRkx3Yzh5dzBOWHc3aERYVTlmaDl3UUpIWlhNcXlSYnZpRlJwMU5NR3M5UmI1ZHdlMlhtR1I3bDBlcGt4VEJTZFRYR0dLMlhNcXR5SnFvTlVQM01XaXM4eW1yV1c3ZnFGa1dJcFhLY1NyZ0V0NElXdCtHM0FWRkhNRzMyUnNMZzd1TFpmTTd4ZFN0UkY1MHlqRVlxWTRtMjRhTGkxRUJPR0RtWFkzRm9ydURReGJXOVJaYWxKUXdHenhEWHBMRThRMkx6RkZka3lNTUdwWSs0TFR6T1RFY2JpMVVjM3hGVUVqeG5jRmtxc3NTaVFJN2pVUmdsb1pndE15N0xJMGVveGxCdW1vQ0M3R3BYUE1zVEJMQTFBVlg3akJoZ1ZidUFxcEFoRytKWGVmaTV6cUc4ek55amxtWXpqK0lBS3pjdlBMM1B1WmNVcUpYd3hNZE1xTDVxWU9CaWFqVE9LK0hVM0RCdk1NeDNPTXl4eFZSTlFsbGJ1aUdmTEI0TXk2NVpoeVJjeG9KeDl5ckxXVUR1NFFsamxZTjM0bWI5d09odnVHVjNGd2R6YkNoZkpLMmRRcmZCeGNlaUU1OHhTekN4N0VTSjNLdnhtRGFXMXd6TXBkc1BVVzRBMGN4bEEyclRZYWc0QnVzQldHRFJERFYxQmNITFVBQ05EU3ZMN2xrRlZZRU1zdEtEWXV6L3VZMkZGRXk3WnNSREZaN2lvYWFlU2lxaVVFb1BSQlUxQ0c3eXhXQVEweW9CYTZ4WGN0bFVLZmVZZ2kwaHhXS21aUXJxa2hNNHdYdmNMVVZmYnFQcDVGd2MzRkFMSGxxS0tvTWw1NGVwZ0tzVFBVc0ZRZXUyRUxaRm1tSUNLYVd3ZHhwRk1MUU84ekFzWFdDdGozRkpaaDR2bnpBTXFGQ3J2TVFiTTFtekNSUkU2ZjNBVzZiWnZxSzBHbkppQW9DMEZ1WWdKVnBxdVpZanBlTHo1aWVXZ2ExdUt4V3Y4eXlpdWVXTGJ2Y1dzdU9vSlZ0N3dUQnNaNWpkbW40U1ZLbXN3YnB3eGxCYTh4RDVDYTh3UTVIR29DbFRYRUY1S3ZVMVlOWGpQRXZLZlpZaGRlYXQzQnltTlY2aUxGTU5ZOVFVSGJ4NWptbGJUN3VBVUYxMXl4eFM0VjE0Z3BUaTVhNGUvdUxsNmkrdkUyUGRiZzJwTUdFbTEyRzRLNzRhdmlOcjYwU3d0T0t4TE52KzVScFpoaTdoYmZBc1pNNVhWT1ZnNU0wcno5UUZLajY0bGhWS0x2ZXlWRkJHOG5xV2piM2lvM1djZHMwWUF3dWNSeUtYYkxBUjN6Y0FRdnBOLzhBa1VMV2xlVC9BQkdBR2xkRlZIbkxkNnVCYTJ1RWNieEtCTmFtWXB3a0Vvekw0Z0NSbDBhaWhWWmk5UVVpM0F2SGN3YWNSYW5Rek1oUjdpaFFjUXBRVUI1bFJBMkhNRFN5TWM4YWhxakdsVXhvM0xmUkEwaXhzK0lrenFYZFhLV3h3RWI3aXFxb0ozSElpM0YxVU1aR0xYVXBRcmlWZWltQTJRaGE5eDFjTVM3ekx6M0ZVb0h1TnEyV0tIcVVId1N0VjBRNFYxSFFIM053eXI1ZzA5TUlTemxEaFVGaElHRjNMUkJvVnhEV3p1WHVDekc0aGwvY291WWdZaVVhaVI1alF0bVRKQkg2d095QUticUlPTlJMaGdLdTQxMUhERVNtMVNJVmFZREpLMU5RaCtvVDlJclVVSDZJOG1wVnJPNWpobWIxeDFLRjUvTUlWcEZLZUNLMnlmQU5BT3B0TFVzVWMrL2tHRE1XcHJPNGZpY1IxbkV2cURtV0dwcEdLNWZDOTZpMjU0aUpWdmlZY0lsdDZpR2N4VUtsbFN5cTdqUlV6VnVvcFlJWUcyNGNwaWxSVWFyVWNyKzhWSDNCejNLRjdtOUhlUzVXUnlHT0hNd2JlT0lMVGhpaGpMVkFiaXpMRUN4WDdsb3VGVmk5K1pTOEtIdmNBaFpnb1ZxNENqUXUxdmR4SXJiYXRjUUxRS3B0VG54Q2xZM2VNMWNJZ0NsZDhTMWFxbmJFaUhDMnpYcUFYVGJNRC9Nc3BaUW9yZjVnVUNsTHRER3VZeUxUSEhMQU8xcExMbEUyTm1LdVdLQVJzZGZWUk1VdHpmTURpc0J5UlFkYTEvdUs1Qm5vM0VzR3ZqY0JySURkdWlBNkF1cjhlSVNRdGlaNFloYkR2ZHdqUXV2eFVhallPYkdHekxXc2JqcFEyeUpGVllhTUVTbXl6VVJUU2lza1JVeFdnRGI3Z1UwNFhKbk1BRml0VzRVdDZOWjAzRXFYVlp2RUdzNHZVL0E0aHV4anV5N1hIY1dHTWx1ZTRpTHRxaDl4UGl2aEpVcU0reU1KcTY3andKK2VvaHlPSlZPTUhNRE51STBEb3hiN2dSd2ZxT0Z1N3R4RXJhSFZ0c29pUlJWQktJRnI3Q0xWZVhpb2hrRDJTbGFyOEVlSVU5a1c1QjJrczM5VnhZL3RzYUwyUE1iVm80Y29mampPU0lFYjV6TEVCMzFMVEF3UnpCNjM1bTI1bXRhaFpIWGRadDdnTnRLVlhaQzFsMktWamlJZzIwTkhxQ09ET2N1NWhWajZyVXF5M0tuTVRmUGdsV09BMDMxRzZwS2V6aUlDMVVHUEVZT1ArNmxpdFMxbWVQY0tpOVhZUEVzQ1c2dTZtUU1WRk12T2VvYkhHWXFsM2RQbUNoVUdYR0NyWGo4Ukt5aHVaWVJ4YzVtQVhEZTQxdkV0ZmMxcTlUR3MzTU55eDMrSm9FSzRqN2VvNG1aZHVKbFpmd0ZxNExUWUp4SExWUVUxOGFJTGFaUks1T1pSbmZpT1ZTSk1NWFU0cVhqRVZNeFZVZVd0U3NZOXlZSXhSNkNQQXJNYUd0TVRVbURQY3dES1VKcmNFcnhFdWFCSFRxVVpYR3U0RkNRcU5sc29jUmF4RU12d1hPUWlxMWJpTHlRb1RyaTNtTVMwTXd0aERSaVV0d1Z1SU1UTU1vRlM3Nm4vMmdBTUF3RUFBZ0FEQUFBQUVNVURzY0tNSU1keEtIWlVmeDBheTgrMndXSVVZdTFDZU4xVmZWRHBJZ3dwWmhBTUN2T25ObFlQdVZmU0tYeFcwWldkK2UzWXZMMnpjQm4ydW5kWHR6c2tITWw3elJhK0dkcGY2S2dMZEtZdEhubjNlNDY4Qk1HSjA1YmJESkFQSjlYdC9VbG5jOTNZNHpUWjV6TzhxN1dralRkTlVyTTd3dFdMK1FFTEp1UEhMbWxPeXZEcWJZaW96ZCs4YXdkMTZYN04xcEFRL1V2UHBMTUdGa0hqcGdwVDRiNWIyelYxanFldVNFZ3czVzhaY2ZsQUptWU15cXNHYkZWakZKNUpMQ3VjVzdpVndmZDQ3M241azE3NHFCV1ppNmhLdGppVEE1cVlvaEs2VkZFRzIvMFNsSy9SVGVQb0VKV3NGZjBiemcrOElzTS9kVzJ1Sm1oVTR2aW1qaWMwZysvUURDY0hGb3NLcmV6YjVOZG5ZZ0E0RzM1bFVleXNsbUNDc0RHVVg0bElNakxmTjVGeVdOa2lzbGlscWVTTTE0K3NEazNjSGdtS1ZYWnhVZHlJMzVqZ3Y5VWVTLzZHMmE5VmJrQ1VjOGZwYTdwc0VVbGdMSXFZWmdrc3RNbWJGMUFDaGpBOENlTGhmTlhlVU1vdTVwNE9Kc3B0dWlFWnlwT29LbnRCSG1UNmlmTlNOSlMvaVMzSDV0SFFjNWZzQ2pEcG5HT0ZIaGtiU1FPbHFIdm9uNDZ0KytLd1E1RGo4N3cxcmJsVDJ3LzNLc1FHbFowNVB1blA2RmpiVzhyZldjaE4zNjZBR0NFRGpxRVpBdnFEUXJ4c0FBelVmR3VabkVNNEZ2dHZlVERwZ0JCS3NPbGMzSngvYVNQQ1RHbk1EdlBIMEZURTBzMHAxMDVYZHpJaVo4aHFwR1puWmtPSTFZYmJ6bEdOUEt5Q0daaXM5YmFFbS82YTJPUmpSR09BNnNtZ2wvT2JTRm1EV3BtbU5WZlNTUlErM2poRjVWS2pMNUkvL3dBMVk2YTdKWUFadU0yRXVIUGpITk9KeGFBaWM3N29JN0ovWnpIb0dVWUxnUWd3Tld2VXM0bjhkMklHeFNCTkg0blh2L2RoTUxWSkpIRG9uSW9oMkZZS0w2dGdZU1lraHJUdmFkR3dtV1hOdkdVUDlDRXpacSs0S1pBVFBQTFBPSG80TmR4eFVYMzBDTjZvTm9CUW4zOGh1dnRKYUViNDJKMlZYK2tKMDgvRTBLOEFUNnhIaEtKTm5pOE5FSExENWQyYnptR3hSTW5HUDhLWXNLWjl0UVR2MkZPNlVpYXBIRUhWa3ZmUG5XRW5tYm5HMFlzaGI4OEdyZjZqWWl1c21QcVNQTFliVlpxb2Z6bGJ5TGJoNXAwVGs1Tk1ZcGZHRUVBNllUaDFBcm8vUmpUVE8yMEdiY0hsL3dDTDZnTWg0SEFKZHBtS0FQdWpqa3NVdXFSejRvZUFuQkpmREQ3QlRaZE53Z3lLZ2UwK1o2LzAwekwrYnZSRExVb09aTUcvNTc4V21XQ2d1cVVvZWVJR1ZFQTl4Njd6TGphQ0NRMEJTT2EvbnhsdzR4S09FZXVOYmFpeU1OSnBwc1l4Wk1DVzIycXJEZ0JVZTBXSytTTlFCVk5wS2FuMXBuMTRaaTdKcFYwMFV1Qk1CdldOTTZncTRoSmYrRFpmaW93Q29rdWUwR1NpeU1nS1dRNGwydXZ0cEZXOHVJd2NtM0NVMXp6cXlBVitlVUtlUVNqQWNldFlLNU5VOUIyQy9DWW5QeFJRSGlzMWRlbkM4VXF0M01YMkhmVGF4NnhFT1hKWlNUSTFDOEtsMTRYM2RHOHB4cDA4THd6emVRZWdjODZ3RXVzNE1FRUFzeGJ0QkRCNFdWbEY1QlQ5MUpmMEp6Y2NZSVlrZzVNektBUGRSRTVZdnZtaTdXbmhQYUFsMlBFbTlvQ1l3dFkyVzYxNk9LRURpTEJYQVZqRFpJRUNHZEJib21kdWFvSkN6ek5WTEtIL0FJYkFBc0FKc1duSHBKTHJpQmpUNlhRenhFblE2NEQzUzNNZ1VTVWdrcEZMcFRzc2Y0NjQwcWZjVWZJdGpnUTNHbC9ISEdBU0xKZm1MemZSSjB6VlBNSkFrM3lUZi9kL0Z1cmVGYzA5MjNKWHpmVE1CNnlHUlIzdGxFNm1uaUh0Rk1sb0dyZ0FEQXBTNStSd2ZpVG8wQUlOYlc0OS9TWVRjVStVYlNUZTlaM2VieFlUU0dMTDJqVDNFL3JHVERiam1LRHU1MklsdkNFN1VGc29KN2ZvTUw1VVAxVXpkSW5KT2RrMm1yR0pnY29QcldIcWJwN3d6VjdRL0NFbExnRUxPbEFnc1lhMDlWcHJReDVYazh3a1c5N3hZYnhYdms4cXVjWjQvbmRRQUNEZnhrN3BnMC9lTzRJZWdoa1ArT09HazAyQmpmOEFWZFJTR3ViVmlZOWpncnBsSTlIWi9YRHlUOGlMNDBlUEVxdSs2WVBsR0RQTmJrTlNkaTd3UktlcGpUenBRWTlEald3bVM0ZGVrUHZTS0Y2ajVDVHltNi8zRENKOTMwNU1zMGZYQStNMFlvZ3ZMOGp0U2tJNlA0Zm5aRzZobVd0dlJJUW1ONXFXQytCSWlhbm5oUVg4aFNaTjZhSFh2SVUwV3dyTHcrUUt6TTE0ZG5FR0U4cER4YWFhSEtyTEdrRmV0bGVvSjQxRzJkL2c2djdTUTU5S0Q2OWFvaUxtMUdBT1gvWkNKUXMxWEd2T2hTVDg1UzNwT0k0bFpsSjFCdDVxUVpzNjBXMXpCQ2Y5REJhZE11TVhHcUVDUTB6aHdvK3RIODlmdU1QT2tOUGNnNUJwejJGTXhaZ0F0ekNOL21YTS9zMmxBQmcybm1rUTBMdlB2L05DVXovS3VyeGQwM1BZdDJxcHl5Vk14aXJiY0lCR25EWFpOR3lEd01hc1BGdlk3aUUyNlgxMUJLZEloY0d3Q2lvZ0J0TWYvT0dITjgwY1UxT09qUWJBVXNXUGNrbUJlR1lkUHZuVVU3Sk5UMVdtM1ZEUlAyWHp2THFBQUpXN0l0eFFrQlh0RUFDdmF1R0JVVzIrc0U1bG5WNzBaNWwvMWtPbDBXTGVpdGRUM0VRQ0ZEdzJWNVBnQnBoM3QwMG45N0poaVJWVUxkRmhXV1ArOWJVT0lNdFhNVzZrK3VpeTlqNTFBNHptWnY4QTd3RS8wWTJnOHRCWmFtNzJ6SHdJMFBYa2R4aG5Cd3QvdnRVcnh1cTd5QUwvQUpYZ0oxSFNlSUlTOUY5bFI1L0V2TEpEQk4xbEM3Yys2Z1hPTHBnejJ6MjRvRUpqamtvS0Jtbm50ZjhBWEdKTkZPNitLbzJST0RKQ3I4VUJrdWhZQ1RuU2k4OHZaNmdwbnZwMUVqNE10dkNyUEw1NzZacXp1QzJHaWRTQlE2YnFyTXhiYmVDM0JlNDYxa1RhSitqY2J4MndSSGc2RFFKRHk0cFNMREFacklveWlKdWprMFE4dG9SNVFqRHhQb0xSZGJ1SERpRjBSdWt0dHZqVHMwNzV6a0Y3ODZHVFZsU3dGeVArT1BPNjRJK2RvRXdUck15Q3RrVHI2eWlTRFRnbkJFS3FpUkpPM0R2THZYRE5TYVMzbU9Fbno1cExLWTViWktoN1QzL1pWNDR1ZHN5bTB2STR2UWJxTkRNN0taYXROV2MrK0RHSjdUaHhuanIrTWtaUmplL09qT0ZRSm95ZjhPQXZtdlozTldQZFBWVmhVckpHb0RIL0FCZ21Kc3JmNngzTXNnYUQrODhSRm4zRlIvS3IxQjEzZGtlamVaMTJXeFBQODNKSk1KcktudjZBQ0NqMjIvOEFGNmZhMVY2NHB1VmRXK09sY1RjOXpLWDQxZkxlT3NMS3lhYzMrb1FHNnQ1NTY5ZGQvWmlnV1JQSVBRSE5WeEdYdnFjRDVDSkhzSG0zeFcxZU8rUlJWeWt1czFrLzAxbzB2T216bWMvd0VIbHMyZW1QalhJSUN2SFBEUzY1U1Uxcnd5disrNGpXYlJYQTJuK0MwV2xrZStQdzdiZHJJMDBXbWpyY1hVUmV5WVp4b3pYRFRRSWFwSm42aStvSXZLRmxpamhheTd5MVg4ZVdrcDA4UnBmZGM1NytJNG8zMDVIMDh6bzdqUENKSnBrNmRkY2JYVnhUNUJCeS9rbGZReVRNa1NiMTBNbjVQS0F0dHJJUGQwajRNUzM2ZkhiMWMyYmJiZjdGUWV6OURsOE02bnloNXpUVHpDS2ZxQWdocXE3dUd2SEtrUEFYYnBydDRBQ3MwZWhLYTlaMzg2NlpWVWttVnBwTHVyWVJUUmV1S0RBdnU5UXpaWllvQjBaVzN3U1dZVVRHbUhZMVZJdDlTYlh2aXY4QVY4dFdXdDRJVnJaU25yQjAwa0lJTUR2ZVpNOXpXQ0ZvTkpjUnVyeHMxTlBZMEtMWWdDanFuZlcwUGJVc3Y4TXU1ek43eE5lakpJRFJ6eU80ZnVGcnIvU3hQK3VUc0s5UkhFMXVMd3ZyN3lWR00wamQxZUR4cmpmOUdINld3bnRlK0NzSXRlNjNxSWNOSWtnbjhWZEJxNXBZMmZqeXpURGVGVmVqMTRSSXpCN0w5ciswVWlCSkF0WUtiZG5oaVRTMTVxbElXV0R1SFBYRmI1dzhlRWhnQzlVV0R0VVNhU1BpWnk5czBWTGZqV3lIREV4RHZDSUpZQkdUZ2dDbTN6TUtvZzVkcFd1anhKY2lsVFYrUGZNOGFqR2xkRkdhb1REUjRIaTMzendRekdRWHpqY0dHWXh6VXQ2Z29TWGtIajc4SHp5eDFLU205OUwvQUhBcGNNbjByNWtjQUE2SC9wZGthbWNWd3lyQzFRcVd5SXo0SWlmamluazArSy9vS3BZSDhpNzNVQ3RCM1JkMW9ZNkQ5TkxoNldwUXA1QTBZaTh1NnVFUzNhSGs2cUdMV0UxR0xJd21Jd2tBRUkzVGNiVUFuaWZoN2xGM2I1SnVQTzlEeWlicXZ2cENzN2pjQVpoOUFoalAzV2lQZEVQQ3F6WXhpeGdVVkRWTDNhS0NvV1ZmL0V2M1VBMkxEOVBTd3pReU9EV0xtUTAvWGVQaVB0WmZYblNjNEtKa3AxOWlCcmJ4eGVCVWIzVkszc1JpT2tiZzVPVGFQbytNZ3IvNWcxbTBXZmdFbG9KM3BRKzIrUGlzTnlkdElHdzB1V3FvMUR6TndXZ0swaHNLOWlXNTFtUyszanA0MHYzdGxNb281ZDFHVzNIV0tOVkxPWDFQNnFCNWhZMnovakREWktEMjdhSEtNckdONXdnN0NqemtTWkVBNi9YRzRkVlE3Z0g1RlJLK3U5cWhtQVFSWjcvQ2pTNEdHaWkxRExUbEx6TExUY29BVU45M3NqVFVGR091QXVpTFdCdVAxaERwV0RJcFU4enppc2xMSmhMckE5UnBQMkRDL0NHMkh6VXZYclJmUnp4U0g5VFAvVWhrR25uMU50eXNGTVdMSjN2Q0NyMnVvZ2Q3K0NKRnBxZm9TaXFYMi9kUW1WNmJVb2diY01xUHE1YUxUekVab3ozTmdZb1hkT01IQzZLN3NjNU9zL0NXTHp6Tkd6TEJXdnE1c21pbHpQYjVEd0h6UEhkakJuamozcXFEZERhY3hVTXQyR2VTNm12Q1B6TU84ZDVPeHR0RE9UN1R6bk9TZGNBMzdEZkRRWWgwQmxTNTdZS25uQUprSWdEZ0FUeldyS3NrTENYbFBaL0UxUU1hdUVScGRZejhmQ3hNbzBXa0FFREVtMGkvSExqWnRoRndlMFg3ZG9rNlA1ejlRcWZHaVgvT3ZYQ2RJaE5MdEJIZTdLK1hFM0hDaVFPalRENnFLOWdsRVRKQnJzMHVjZldZT3VPQXB6VVoxOEJscnJ5WGJiSWhKSnBXNzhWbGNaNWNBVjBNdFMyVTVTUTdScTBSaVB6aGxXZGx1cUdmTSt0eHhPTGZVdWV1T1MvQmIwTTlOY1ZSc2FxV2N1U2p2cm5KdUJpQ1hxSHFMRWlTOVdwWmJmOEErV3ZaUm9NTW5Ed1owc0ZycmhzMzA1djE1Sjl1WjV3S2JLVGxocENkREt3bGpvMERuczMwR1VWUDBWVFJOeGdwWEVvWVdTL3JNak5Ed2wvNnExQzJPYmJNc1VqMWpvZzF1dXo2aVpaTE9YdnROOHBJSHBQYkZ3OCtHWUNVRzJESlZFNHlCa0FDUE9GL2tlL3RrRUJqZnpZR1VIOTIzb3lFQ1lsZTArU3Z4elErNndLSlhwSWFIaDMvQUYzOWNzWE13T2VzQUkyL29JRFQrSncxblBFNThhcXRiNG9DUXlBMVFpWCt0ZmMrUVZXVFhPQ3A5SzdRQ1Z2NDZSLy9BTjU3Zy9TZDA3NENPTHdrZUc3ZTBzNGovU0RXZC9lcjcvaTFWU1B6RGdycDRHQUlqS3JwdkErQUpidEVZVEhiZWV0alMyK2RUdjhBY25QVCtPaWwvd0QvQUp3NWhRb0l0TlEvajJJM25vaEVVd3VHNmlPYnlrWlBUc0JJUkZqbE52MTJPSExKZlJOOXNVVVFFVUl5bmVtTzFULy9BSC80NFZoUVNjUjRlNElCVlkwMEtCVHR2VC9EcDJjanduNGVVMkxIVnViN2VRNU80SEh6d2xGQVFMUVJFQ1BXWDVnSjEyL1dvMWlOU1JReHVnZWlxV3dsUFZOcWxFanFxMjA1TVlKVlVaWWJjSEhMV0FreWp3SXNFd2Y2cFJqU2VzMUpKL2NNZ2dvR1BZRWRjaXEwOEQxbFRnczhGaDB1QXN5cmpNK0tyWGZJb0llQWNtUkFGSVdIWXA3eDQ3eFRHd0hQVlUyenhueWgvd0NSakZCUmc2VG9qempQc0kyd0RFOVRTd1MxV200dmJNOXFKSUxGeWg3TjBHMFU2RldmN05BZnhiZVFYZzRnNjVPSk5SdVBtWTZUSUJ2M2prY1JPMVhXMkhYaWlmSjJQZktPdFh1ellOYk9sNlpnaUY5dU53K3NtY0ZyemorNWdVdlI3NmxKZTluQkdtQlNTNTBrU2tmdi93RDI3UjhvRFB0dENTV093SEZFaU5aZmc4Y3VqaThlTlpRVGNHNEcrYVN1TWZaNFN1RHkzZW9oVklCOXVCMHNqRGVqTG1oRFY5cERLYjlpTE1FYmlSTGVEOGlOeGRWanV0L2dhaUdlYmEySTRsTUlxUW94d0VBdHJlUFhwTjRVWWd5Rk8xZE1NT21zeGxKMllUOTk5OTlwVUtqQzJWays3N21YRkpaNkJXRWNsNXRTbUhNeEJHdUkrbnprTnM5MWIzNkdEV2JSQVN0VnBaanFxWU5nUDhaaDh5aW1JMjh1ektyb1Z0RWtvSXA4QTl4Vit1UENGL1dDZUJCYzd0MjZUUmVZVXZyQUxoMjk5OXZBa05pS2MwcnBseGUyQU8vT0gxVkE5SkozMmx0eVBaV24ycUtMTWFNUnNaTk91ZlRKeHpIOVNEdUNvdnBtTHBzK2ljODhnNnEzODZRRXNzbENNdDVrdEZWRnZpNlAraUJQeWM4MWw3ajluZEp6OUVwUHdPcnQ5OXkrOFU2ZzJLcjVqTkRSOGl0MEw5bnErM0JvT3RVOFdObmh0K2pHZlhqWllKRU5BY0pHRXZsYVJoUFhnS0pVdFhhSnVHOHdXWERKc0cyN01zN09nVnRObEJWN2ZtbUVXY1htWjdOMGo3WHJJV0FYSENxZG5pb0l6akhRRHNDQ0NtbEZ6UnpnOEFsc2dNV0U2c3lBRkxjNXhtWUlLdEJ1ajRGMXFZOUFKSTRPc2c2NHNlUzZLZ0pidDVmL0FMbXJJbUJiNDVHbUlmV3R6U2ZNT0pSVHhpemhLSXI0bjVVOFFhZjAzNThOTWdUNjZHS3k0S3p5ZDdWREFBQ0FLSzdlOEhKc01aYnNnOEpRYkVHZlRLRWhYYlVsT1pyMlpPQ1BUS3RBc2dJcklla2JMNjNZMVl6UmFLb0J4b2s5YXppcXJBV1FXcElNRUxNb3J5blBHMlluT2I0VFgrNTY2OVFRQ0gvdXBHa0tmalA2Wjk2b2tBR0FSVURBeVNlUnFmY3ZKY1gxRmhoMXRlYmU3V3kyeEVLNzhnSEFya0xqNUppS3JZQ0RMcEJjOXo4UWRNbGxYOUFLU2xzTTlCTG9lSnFaN1VXTjV1QzV1OVZ2K1JXeTBRcHA0M1hpWlJMYVljQVFnTzR0V2x3TGhpQUFPU1haNVpadmxSUmpxZGNubjhTQnVlQ2dPL28yQmthWUNaRGVJZzBRWGljZkNPd3NRVTZDVjFTMlJTTkxmeW5TeXdpTEdDbm5sbmF4YjBUR3BrSDR4Mm5yS2JqQitCTy80Wlk0dk5uZE90NEFBR3ZDRHJaK09DZHhrZVFqbUJzanVmZEVrMTZsbXNyMnduMllxMkc4aGdjSHAxU2N2eDUvVXViMDNXMkdXa2pVenZNd2txbnpjVEFkVkNHbXJCSUdTRmRoMk9idmlsK1RVNHNNMDMycjRRNFhTeXBtWWV0TStOSHdITG1tVnZReE1tV0p5NkZwbkxGcTQxUVJxbDdxZnNhMEZWd3Roc0NSd2plREJFYUJXRDlPQmZFdlcreGhnSDhQckxMTHRKUDZiVjZPS1BPcGRwZ3VQNFNGWmtsdkZieFVkVnRYNDgvbjJOejc5ZDNOcXBMQ0pnaVlaNXo3YlpJYXJNbTBHanBzR2tTYndWVWZvbXJJaFZ5dXA5OWI5dzVGTFZQOGNoRWRkRTg4Y1RmWXZ4YUREd2xFYkdpcHBEZ0FWeWVac1JHcUVDcXVqVm1icTdtcU80ZVNYY3BLcXNiYi9RdG9pV29OZ29tcUlRVFFSM2FEZ3dxUjErQm5rbU11Z0Y2eGVjVDBhL0swNDdKRzF6RnY2MjR0OXBPQXprSElJd05BNE56L0FCS2VLMEJLQ3VVZHM4NUNxeC9QRm56UWc5SzQ2ck9udEp5aTNzKzAyMnRlcVErTTRpUURFaVFJSitwaTB2dFU4V2VVc05HaUxsTWszeUJQZCsvY0MvVysvVm1VeExrTHRwS2h5dzYxY3F2UEcvUnVkT3g2QkQ5TDQvZ1VmbVo5dllhYnJMeG11WHhsQjcwNkhoN09TNit0MC9PL3drQUhsSENvWTYyQlNrN0R5RFNLNnZQaGpwTFRqVjM4NHBkZ2FBRUdlLzJ0VWxYY3VYTkVsVzBoZDZEbURLa2l4Rk9pTzg1L2tIQzcvSkliOHBtQUFBd2tTL3hSYlJKend5eVFBb0g2VTRibmdJdENoZGEvTzNXWGRGUUJ1YmFOT2tqTzh2OEFhOGxoM05RMHNhNlFjeURMdFA4QUd1REF2aS9VUlZwdm45OUNBdFRhYURGUy9nZUVSVENDUlA2eTYrRTdxWFo5OXozNjFuY28zSCs2UUttSU1UM1RYUXdIR2Q5NTdzblBvVnlOK296UldhMVpYTm1oL3I4OGZWczk1c3BoNFdNMDg3YnR1bE1LYWYzL0FEdkFLcXdCcVh2OGh6Z3pQT21rOHF3U2pkMWt0SVBGSlVJb0psbWRvYUlDV2JkaTdlSlpPL0hHa1RKTk8wdXNHUDhBUGxVOGI3UUtLb2VlQklQdFpwUmo5UEgweHRSbkxaL3hYTHBpaEY0Y0lJQVcxWFZTZ0NEYmtmOEFQRE1JTUtpN3lFSFM2M213a0F6QlczNGw0TmZtc214WXBtTU9IVldXVTVqS0xVVG1pa2xCYmhMREVnWFNhL0QyYllWQ2doMWI4bWlKTHROWE0yUjNTNWpRTm9tRk1wQU9PM3hkeEZPam1rTjcwZHoyQkZrZXlmdk5QTG9NZ0dXd1hDVU9pY295dk8zZjllTHZoRHJzbGo1Z0JRUmNUc3NQK0dvazFJUVZmL3E0TWhPc3NJV2ZtNDcrNWRYOHJqa1V4MXRwR0NHOTFRWGJXdlFhaklvaEtwcFFWcXpOQzIyUmNET0xzRTlRNmtQZUtnQUFVY2NtUHQ1UWRYQkJCbXJ1S1pEODE4UjIzWGMrcWdGemNYWldlZVNSVzRGK3pKUVFRUytWMXNuQU9DTlZEcVc2eHkvZ2ttbDFWYnJyMEtNLzlhVTNmaHZtT0R0S2dPbmFJR0xBWjNDb3l1OENNWnlaV3lkUnFjY2NUUVpsK3F6SGx4Wnd0SXc1YllDT3FNeGtkOG1yeWpxS09OY2NSeFFoWVhUZnJuU1VVUlVycXJxbnRLbTBTOTFJTW9xSGlEcFoyNzc3aUpPTjY4MGFDK2hqTU1odXRQcm9kcXQvKzNUMGdWbzdMeGlpaUR4elc3WFpTU0w2aGdtMWRiZ1hrajNxQUsxVkU5Slc0RG8rb3BCR0ROZFFOT0xRb1dVUG0wdHpaTFBnRmtsQkdnbXVnTUFvWjZNSmx0Q1B5M1N2ZEs5Z2VXRklPMktOamdxaHVpaWNsbTI4YzN2aDFwSEw1VU5BK20vN3RPVlVYcnIyMTJrMkFYSXp1SlFVZUw2eW5FTERwN0xwbzVLQjFZRGQvVERBV1dybHAyemNiMGJoaEFvTm9MdE5MSmlublJiVmhuZ29yVXgvR3AvelZGaERmS2FBSTBGb091cnNMdjNLemFVZ1pPZjF4dDZIcGtnOHFPNVV3NXA1dWZmWkJIWEtrakJhVmtwYmJDblZqVTJRdTRKZlh5N3dnRWlmVURzZDUwMjhiRU93L2dpcGp2QklBTGMwYVhtZ3FIQkJQNy9Za1Z4aDdzRllITUNETWl2TWtjNWwrZjhBbkRZcEtxdGZIZjhBN3JBdGF1VW9tUnBzSHFZT201RkNWQXdDNzJtZWdKQTNuNWFkS2ZWWnIxM24ydSsrTzVNeDBXZjNQN2lnMjMwd2c0NFlxK0lmQkRoNU5GS0FXbzRTelh2VFRjMG5MdjVnVytPc1NhMjQ4T0lBKzNNaUo2Y2xlTkJnWmsrOVVRQzBXeVZLWGZhYXJUbDNnd2V1dG41ZlR4OWVaRG5LcmZRd1cydFJvT24vQUVUZE9KVkdCQnYyTUlqMUNIak1oRHByaVFhK2IxeVpzcXVMRU9VZDMxZ1NoNS85QXR0S0dybmhsS1NtbDBoaWhrQTZySVVhUysxRFlhQWlIRnNpY29vNHhDdkFMdUZOVzZsNkVqOFo4TzFaWVkrVUhOV2paVTN0TllmQ09PRHF3OE9wcDNvOW52RElOZ01OSkJJb1pSYVlqTW9CbVlRV1UwbkZmZHliUWxvSktoaHRyOXBSZ293N2trK2pBamxIalBqamJhN3VQREdnYTRoRUZtN1FiUGdpOTFMdDN1WUd6NyticFhvSFpkSUZUUExFQ0NFU1NXZWI4dHBCY0FnUzJTTGtqS2pxZ2psci9lL0xVZUhPTFRXMzNhc0NjeC94M3RZOHZJRmdudmNuejRJREsxUE1SM1dEdDVYY2pOakJPSUlIa0NFSFhSVkxzSlVkSFJkdzhETE1haWszdTFpL0pJNERERTQ0UkhXU05rdEdTejNsaXpvUVZkOXFGcURsbXRnSkJCSGg3bGpxanZYR3JmbGtPVFExclR2ZWxIb09DZ3UrZmNESXBKQXdIWkhsM2ZYM2VGNENMQmtEMVpMZVdiWkJGSXBpYkF4bk1TcnNKVlNTd2FxdldVR2ZST283OHVsbkp2aGRNZ3FreGN0STc3UnlnRERtQXJtcHZJSzVGRG9taytNZ0c2TXNLNVhmOWZEZEFsSkx0Q1JVL3dCYUpDcmtubTkvTjg4TEI3VE1KN1RSYVIrd1BKWU5tUVdzY29ibmp3elpKNUxyV2NuYTdPZ3pRQUR4amNKQXhidmc2R1o2YVdXVnlGay9tRUVjT2ZKbW1wcWh6SUpUZ1hWczU1RXo1SzhVSElabnI3QzVJZ1lXTkhIRk5NVW8xVmt2cUFLNHRybWxEd0pKQjV0WFh1cXc3U2NMNXFpQ0d6VHdpSUc0K2V3akw3RTB4UUFJK3BwRTRxRmZvQkFNTktCeTFzRW45Y1YwRVBiWXdrZHRycTRyczUva2E5WVpObEYrY1BIMkxQbEFxYjcveEFBaUVRQUNBZ01BQXdFQkFRRUJBQUFBQUFBQUFSQVJJQ0V4TUVGUllYRkFnVkQvMmdBSUFRTUJBVDhRaGJ4VlJkaGFlNFVjSENTQ2dYNWtBckMwYVlaS0FRTllwQlNSbFFWREZEZ2RYck1Dc2x6czhsdkVOaURsTlJ4cFlOL0lDZW1ON2kyZ1pDVWpac2NRNWE5aVFhZ01JdWpjYjRWRGdpeEZEVUtIVkRRVmtQQ0FTb0o4NHlEUkZDQ3NwUWExbTRJUnhGWXRtREwxSlJZT1ZRckFLaDRGUTFJanpCcUhoVWZBamZSdFlnb1VYNmpWRC9JSUhDNFdleHBQUTNzU0dwcUV0RERSWVFqU3hHdmdOc1p6VW5rQk1UcUwwUjhrTXVabnZqVUVmd1h0WGlHVlFYd0J1SmtlWVVJdndqTGV6SXdidk53Q2xiUFNYL0l2WjFJUTNWbStDMUtIZVNrdW9XM1pReHpBREMzQklIaUJ1S3lDckNxU3BlUXdYZ24yTEEyUnRvSDVHVnhZM1dGNndHeDdtN0ZpS05ZdktvU0NwaUlvL0dUY0w4UUhJS3lYSVhMRmtObzFCOXovQUJLRW5zU0tsYUs5akxWQ2RGc3BTUGFaV2plRVJuSlFmd1JmZmlaY2x5Uk1SRmFCZ2ZTUk5yRkhFNUdnZVFCUDFGb29LRXhpcHFOV1g5RFpKV3FoNExzc09TaW92UlFMTDh5V3BIQnVDM0Uvd1A2S2pGNkxuSVVqY0Y2RWZ1amJOaUEvY2oySlI2TG5MRmdmM1phQmNVYmc0RitFZlZrZ0JObHpBSzRiMkhpQ0JaTEhzMUR4Q1pGaDRBVWNjQ1hoQW1UdFFQRUZ6QlNhQldQN0lwU0lWSHZIYVBXVytUcDdVUDhBUTBQaEhCZEZIRzljbTRmYU1idWlSUkRCSVhJVjVBQlE2akh5bnREb1VHVmlGWUJSZ1c0V1dWQ2dvU0NLWndDc2grQUh2eW1acEVYbzJKMWNxbGMwVkMxdFJXMkwraEdxS3FORUtHd25vUVhJVmlCOVNGbENvTDFzU3dqWVhZdEg2Tm5JdkxXTmV3WXFDNFVWd2xES2kwbk1iQm4xRkRMeFFoajFDd1VJU3dBYVN4NndyYmovQUVWdHNwa0pEVTE0UXVHYXF4TFpkdmxpSWcycFBtc0Vod3g3a3lXejBDU2NkamtrZzJ4aVZGOE5RNFA0aWVnTkdGTGxVRis0dkZlUnRqd1dLRGE0U1lIdktGalVoTjUrQTNTME9JY0htL253Z0N5cUNsaGNKalpZbUhnQ3Noc0xpRktDL29PV25SWFN3VVY5eEZEVUIrS0dJL1JXZ3RTNUZobVVlUVFNNC9lWlFFYXdGZzhZM3l1eVY3SGhIb1hpQnBRMWFCbFNOZVVuNGd1SWdGVHVmNEJ4eE5mRUJXQXB0USt5ZEdYTkJyMEMrQU5GUWhVVkZTME0xSWRNYmovUklqMk1XTEgxQWxEMlN3dU5ETGcyeDFQY3RGSVFXWW1vYnhZK3RDNXdxTG5jRiswQ2dWN0lOdTRhbElreUd2OEF5cU9HOFdWWXN1Vzl3cndkT1ErNldwWHFDcTVCVWxLV0FlNFYyTmhRemdwVWNEMWtoWXNhUllJaTFRRnhlSEYyd1RVQml3MEZjSHFGdG5HTWtLb3JBQ2xoVUZSMG9wU01xTG5Sa041eXNMekZ6ZUpoZDVoM0oxMWpZZzA3V0E0YVVEckxoV0pvRHJZYjZRYTJPY2tVVGRTcE1WVDVJYkJwUi84QUdTRXBKSzRGTE5pb1g0QmlyQnZFQnR4Q3MyZG4yRUR3enNiaHhYT1RCZDR4UTVhS3dLUllLRkJIUTRhWVFjaVZtVVZpUXd3WU4wRzFVR2dweW1JaUY2T2gwRGNNaXU0aVNQMlZaM3FIVW5Zb3dSZllyd3E1alZRZ0RldzZERjdPdzMxamN5NXEwVUM1Tk5CMVpNVVZpOHhZNGxCTXkxNHdDaWlpc09qU0hjY1hBNWJtMVNwRVBXaFlQeVhBWFJXMlBCVUt3UVErQlhvWVdBTncwaW9kRVZGbExxSENFMThMRUhZTlZmUnU0T2FHd2FhUTdpeXhnS3VCUjMzRFdJVFhHMEdoTElISlJjL3NmOVA2ZzBmb2ZzVURZdUxGZ0ZqR1JSUlVrVjRRVWsxNEFscm1DVVRTREFwSnRrSlFaeU11SlhnQ3Fndm8zVkRxT2plSTJEdXRGYlRYUVFWaGhPam9jRWxEa2NmQ3FIa05Kd0dEY1o0b0tHQm9NaUtBVnk2RkZHOFJBVGdNQmsyQU9td3NWWTBWaUI2Z09CNEEyRFdwaFF1WXd3Z2ZCVi9vZkFQc1VFcFdYR2NTUXFEU2NWQlNhczJhRTlqUjBpemFIM2I5bFo4SDM2bGU1dlZqWWNFb0p1RStnaTF3dHp3RzE2a0NTZjhBb0ZJQUVVaXVDNFdaSkZDZ3JBVm5RWGdDdEc2YnVLVUZvZUdrcUxFYStnL1ZvZjhBVWJGWmdMZFFoYmNIRWF0L3cyTVhkaVhBdDZGZ0tDNlFxTm9td3NXeFdMeDBoZEVJNURSQ2pZTnVCd2tMWkl0NUpVTlNvckJXRHp2RmFDa0hPSWRRck1GRkRrNjhRTjJKYUlGOUZsb2FRMmVqY1ZNRjFGUmRORy9ZWVZKVVZ0eHk0QmVOSUcvOWxMcVYrUmNOV2ppR3NhRW9mWVhJYjdSNzhCRExvbkt5SllNVXFFOE5mNEFBOXdCeXNoekpIVUd4c3NjSDBvcWhnNmhOQkRiTXV6NmNVVVBJVGtWdy9uU25BMklrUGZRbHJzYzI4SXowR3FqMWc3cmtWSmNLUXFsMnJodFExN1BrSmNGM2lEZnJNc1JZb2ZwSXMzR29IWFo2U1A1UDVQMG9TUXJ6QVNqazVjeFlFUU80NTJXTnd1SElPa0hoQW80RkNJMnhSV1FNdERheDBNTEVHRTZVRnZyTFF4cXljRU9CQWV3TjNCWUtnSUdHcGxlNUVYdENkeHRoWkFmcmw4R2pNcWZ5Sng1d0NVS0tLaFdLVVR4Wi9TUS9nc0xMOUVNVjVySzhDUHdWeTlsRllzZFlvSEVMRXJGWmFHdlpzb1RQV2ZoL0lTeEtPZEtNSVhPYjVEd1oxUTNpM2ljV1BIOWt1UGJ3ZnlONFVGZVFYZ29VUmNEMmg5QU9sUWtpb1Z4Q3ZHaTdOWG1Bbmhpb1J3cUc2NlVkVUdLSzBWRy85TGg2Q21PTHdjYnpEVWgwb1lhaWx0RDNxUjBmY0RndFNlNGxSMUVZK0hFMmJqajlscjFoSzg0S1pZc1ZBaHhEcE0vS0NmVUdCRkMrWXZxRitBSGNKOEd6ZndHVWxFcDRUTkI3RUZCS3pzZXhkVGdudEhzb1NjKzVCK0NGaWg1amcwV0JMb0dINGRjMjlCLzFRc0lWTlJVVVY1Z0swSUZJZk9JUnBuMExsSVAyS2xRcVA2R0NobDNKaVVXa3M5bjlqRGhlSGRsaDdLQ0RCS2RGVXRsT0VMSFkwZUtwTFpyQ3NIc1lkTHdPRDVSTnBGY2MxY3c4M2duQ3dzQlM2d0RGaTZPQzVRMUE0R0VJaU5MYVNGcEJZVmdsVFk1UDJhRldGZUNxaUhoeHJCWmR6NmtVaXBaNjJhc29HV05sVUVxUUlSdEJ1bUI5TVBMOExCdW5Da3BKZUhSUEVDeURRNzJQajA3R054WThDbDNBYnJCTm9MNEJtNUhFZ2tIVUhVZTFoTTFEMUNzb0MwVnZZZjQyVU9zWllLRnBoNGZvaW9IMEszU0ZCdUE0MExnTDlVZGNRWVAwTFJGT0NjRWxlTHdIRUwvSmtGdUR5OTRid0ZiZ3VZZ1Q5UDhBRU1Rb0tDNDdRcUV4QUtFamdubkN4WVRRdzREbHFDUWc5SG9XSlFtTEJ4czdoc0ErVGZkQ0dGZEFXZ0ZBS0NGS2hyWjhEVFphRGltRXVJU0NFWDQwckVpVWNaNXIxdUVQdVl5SVlJNnVlTDhnQ0FDVWdvQVVMOWxoZkVRSWYweWtVOUMyVjRCUXMydzJBMTVqQWNod0MwRndTNUZRelFVRnhITVdYUUp3T0RvVGdDQkE2QjlFdXRvRmIwUHNmZ2JJdHdLUXRTWWFnNERVWVpUT2owd3lnbGJjR2o3RXdxR1AyWUhWOWRESitrRVhPb3Q1RDZROFJCYmpaYmdyeEh1U0VHUVBaQU9xaEN0RGtnb0JJVVBhaEJxc01nUUsvUTFkUWplUmJEaHdGaFhZTHRHOXMyMFBpcEdvdlp1QmdVR2dvSUVCSVRjZTh5S3l5NEtRWm83ZzJ4d1J3TlVqNUZDamhzZFFvTmFFM29TRi9BUkhEMnY4cGt5M0UzY0lYWnFOUldMb2RZNndoanVEWnEwVWNpbEd2eEU5RUQwdkhUYlkrNGU2c2RNSmZCL0piL2daK0VCQWtLb0lrSTdMRmdhUllQQUVoV29JUlF5VXQ2Z05EczRiZmh2eWRIU1MyWWlKeWtLUitHQkZZci9BTlI1ZERHM1JheFUwZXpoQzNqV1ZTci9CcWZnYU5DTVpQd09pMWlFeXpad1FSdXNNY1dpallJSHJTeGJIcWJMUDJLcUVxWTVGMlhDUFFqa0xBVURJSzVJa25SRmhhanc3TkZEV0NvelU0aVREUVpWUVdCb3EvdUE4QUVuMGZ5ZndQMUJ2NE5rVmd2QUVvb0dGOHdXcFVMUXVoSUoxRDJFL1dDZUY0c1dOSUh3SHpMclE3RkxLcmVRVVF3SmpqbXBNdXRld3RvVTBVeHZxV3V3b0JtcTF0bGEvQitBTEQzalc4dzhMVVBJQlhZb2g5QzRvR0ZhSElrNVdNS213MFRjUmR3K2hsb3BBbXhSUUtvYnhFRXpRTWJqRmpLUkdvOXlLUlAySE1EQys4QWtYanM1Q2lhSG9LakpRMVl0V09PSXJXTHFqZXlvNTBCa0g3RGZyWm9oU0J2bWJCZHFGMGNIVGtLM05hRklQMlRUUTVHVUpnbjhHby9ndEJYUlNLaTJIM2NGZllnem1tRGZoUVY4SzFDc0EyWE52MGJpdHdkd2RoTHNXM0pRcjcyVnJJK21GQnRRRkVYRHRIQk9qZ21HMkM4VlRnRkhXQW1wRHdnVmJHRUhKMFFFWTJQdTBLbG9Gdk5sa1YvZ0kwa2lqZ29RU0FJN0g3Q2g0Q2hRRWt2QzlvdUltZ0p4S1VGQTluNmJqU2hwdHhieE95M3ZSdmhiWXVqMWxsQU5hNWlCSjZIZGJIZGhORENGUVlyV1NvQjFhSEJEZDZGZXdsVWtVY1BVT2NNUXBFQnlEWVZ3eU5nb1ZYbklIL0NrUVMweGo3QVJ3WWlzYkRabXpqZ2pGYUxEUlVLZ1FOMmNXVVh1VHdPRndhQ3NwV0wrbGs0ZW9QY2FSb05EMFA3Z0RSK0tBU0tJbzlGWWlhQTdlQkowZTFIdW5WU1Y0aDhBT3hleXlVY0NpMEs0aGN1SWFUM2xFU2lxS0FrY1c4Wmp3Q1VkcmpoY0dzUUZJK0R3RVVjQ2lYMHRncjJTR3RBdFdJY1BWaFJLb3RiUXZZZFEyekhCOXFTZ3JzVUhNVFFvZlFlZlZEVFlZV3pYcUUyeExjaG9Idm9seEJ4Q1dKVkNpRngyeVVHbVZLODAzcEFpOWJGQWNRZ1ZKQkk0RmlEVmpweDRPcGZTbEF4alF4a3NDcUtwU285Q0VVaFZCWWlvMmN2RTVTZ1ZLWTBVQjdxWWNCYURqVlFSVmpCSlNiV3NYa1AwWDZoWDZHK2o3ZytpZ1JVUHpVbWhvWE1rUVFMSEl4d0pnZytoYlFTd3RHQWJCRGxRTVQvRWZ2QTFDVURnNE9wYlRFVnlzTkZEaENTOUZRUVVLNk05eTBKZ29PQzVIRGhHcWhkaWJIY3hiM0VjaFZPaTFhRytFT3d3Y2V3SDJHeUpuZEl0eEIwNkpJWWE5aml6OUUxQm53V0FhR1BVbUJqK0I3eEJGb3VrRVN3T0tOZ2VwRW5kb25OQlJIdUJtNkhpQzRNUElYd0FhU0F5MUYySUlOYkUyVVVIRkZYb29UV0J1RjdYQWhTRERsSUpRSjhuTCtIUllzSTJ5Mm5HN1FpUWNUdW51aHgySHFPenFIb292Y2tEcDcwY0MxMFRiUS9vaEdoRzNCd1BlWWlTMW8wUUdEN0hNYVRSamdCUHNleXlIbzBCdWhZREdiTWcvQmlTU1JzdVFvOUNSUlc0VTVMd0NaK1JhRnZzUnVBTmxqRERZUnNMZ29Hc0lLSFF1ZzRoK2g2b0Y3a2hsRDNZZ2phZzRYQSs0ZWkwdGw0NGhYeERhdXpVY1d5d2tMOUhCSEJ0cU9UWVNuNlBnRkZZaUZnZ1p4QVBvUEFySUZZQk5oWStUT2phRUZ2WWt2Q0N2SXlCc25CRHVNdkNtaHNWbU9CajN2RGtRUEc2MUM5akMxb0kyTHB6RndtakJRWVNYSWJhUVBVYXFKV0gyd3RCcUhENGJleEdYWS84QXNZT0E3cUxCaitJMWdvWEE3b1kxZjNpVVZGK0tDb1VNelZqQUFWb3NLY25GckVGWnBMSUdKUTBRZkl4amxJVUFxSU45cFVvNVR0Q1NLeVdLV0xWY2J4RWRrRldyZzY0aXlwR3h2OUJzZGhzdU41UVpiVEdoaEZPR2hoNkZqV3hUVkdIVGdxQ3dZZFJUOXd1anUyY2VNSGFHV05rVURjaFpFTndPaCt6b2FFRE5yUXQzQ3hrOG9hSEdpVVFEbjFpMFJVV3hhUGFrUEh6d0FFQnlWWmVjdldLajZJV1NYR3hXOUZyUWxvRUltNVF3N0ZKT2xRajVEUVZzSVNwQ1NhdUJLa0JINkg2R3ZjYm1IVXFZUzlsSW9GdFFxRGtXeGVCVVMwMGF3QUdEb2VoL0E1QjZRMG1NdmZGR2FEZTlRdUc1b0xJWFZ0TTN3UGdPUUxqQnpCN21JdU96WXdvVVZoRDd5TUVUUmh1TWhORzNSL0pRN2piWldvWU9NUUxHZ3A0bXArQzloUGgwVUpOR3pYQkRyQUtCTjBLbDZoMzJFcERGbVB6NG9Ha0pVMENwWGFLellWSUNPemtINUI0QVhvV0F1YkxFNHZBYU9ncysvaFEyaGppMEg0eGtDd2Z2TlV6MGhFR2FjRzRIOUZ0Nk9TaVpvZWdzTkk0VFdSTk1DaHJXbjB1MWhWdElCdFNGUy9BNENuSThHbVlzZFZqWnNYMkdDdGlub1dEV2tNQ2ZwSkMyUEFDRGUramtibHkzSk8vUWlYeUtCNkhrRUZ1UDRnQTNURU1lb1hvOUtRMXlFWERSRDlGSWJ1VVl0RE0yQVhnYlExSlRnOVFxZ1k2QklhS05rRHNvMnBIT1JlQjhHWWtwWDAzRFhvMlBoQXFrT2lvS29GQllGc1ZvUWtMRmxsNU93OUJld1QraGx0L1F3TEFBZnhuZ2pZL0NEZ2NyQUVkWmZ1V0tFOUdnSDRMc3VzRzNHbUVOWnc4MmlpaXZrZ09xcUVLckpJMFdMNG9XSVU4Qmk3eE9UNXc0S0Q0MGg5RzdnVUwxWThVVXZ2QXczbjdoVUQwSG9hWUtxME5Hb3dCRFV5S1BCQ2NvWGlZdURoYVI0alVNWENaYUJZeFBEYlZCZFpBVUt5RXB1R2NFT3lDOXhEYUtDeERrRjdDTEVzVGlndElNTEV3cElyY2cyR0w4RDJmckUydUJyWjZyRXhhSU5wZ0F1SDdkNHdBTHdRRjRHT0czSVFFR0x3QzV5eW9Pd0EyT3pBVkdoVmNGQUZzcUJDcFdaTmlDWUxHOWtndnNmVVJhVU9UV1JJcEh3UVlZZVh1UGRGQi9ZSFhZOWlMOWwwbEc0ZWxZRnV2OGJJVW1NU2NpU3hVRllvVkZmQWNBSVhnckFOVkRnT0F1ZUZiY3hlSVI2TExRNDI0emdNdTdQaEE1aUprc2JIa3NSNkl2ZEhRbzZNMmJZZE9HNFZnWUx4NERrL09YaktsTlNIWWJBVHc0YkFuNFFaUW82VkJIZ1IrSEFsckU5emJzcVJqdmNaeEZ2Y0dMZTVGaDNjRGVGQmNyS2tEUzRQcEZIOUhZOWcxZ3JKUWUyQmVzV2ptaGZqQ3hIa2krNkp6RCs0NHJEbGVKeUtTYndTdk1Cc2psNVRaWGpBQW5JUEFZNUMrNkxGaDdvdjBZZ1YxaFI4SHVLZFNLSFkzYUZBVEUwWUluQkNvVDg0aXg0Z2dpUmc0aTFZbERpNHEyZnd1Wm5zWjhUa1ZtWGdXYWNCeFFuaEc0TjVHbVkraHYzRkNkK3hkV3MraFMvQm9zelRiQVhSOUg3RkJOWUZZYmh4bUFQL0JBc0lzd1VJTEJLTWNLbERjT0Y0d0hEcWo0NUZpVUJYNE4va1NrdEIrY0JLRjRuRGNFSlRlUVJVTTNEYnNZK2o5RzdRdEIrdy82RVBjRjFaMHJBVWZESjNHR09HVkNpc2l2Q0sxQTBpVVZnVmlVakxzRlNnY3d1VERoamtUQnc4T3ZBUENKeGZrU1JmaENpL1JhMFhwaGlmUTZvcDJNNExtMEpMRGU1d0ZKSVZ0eFRJc0lIZ1YvakFsazZSMUNsSldPdkFCc3NXdE0ybzlqREU3eGtaQTA3Y3c4ZzZXaWtKK3lhMFBoWVFVMTVVQUJQQm9zTWJJTldTNmYwQjdpSWFWQmFBMkRLS0QzQlJmZ2pTS3g1UjdlQlJSWGtGZzJ4bEZ3YkdWUUlUa0JGQzAzamRydzIwV1B4RjRYTjRBM0Fzc2hRY1NiekE1RjZ4UFRqMFd4N0JVRWxpc0lyd1FOQlJVOEpZUUZwRjRRS1NzTlNKSXBKZjJOUlkvWmlTRkN5OEJtWEhXaHlYNGl3RkloV0c3SnJDVDhDREZvTmdSREIwTnV4VUNpMG5FYkRYRWkxQVFOQ2tQSjRFMWVFUnBKUjJMNDZUK3dFN21LYm9PUXZFSEJvRmlndGRGSzhTNEF1Y01NYnlMTDhvSkRiQzJBZVRURUJTUVNXb2F6ZUtBbGhjSGdRMTVHZUJIRm0vWTBFQ0xzdGlOSDVnZkFyR1Jma0NHUDR4M0FNblJma1hrTWF5ZHcrQXVUSUNlTGtwUGdyOFVCd2FlS1lZYksyUUYxaUVzazl5VEJkRFFPRlFHTHhnRi82UXJSQUxDdjdQbkFDdFJScU55WmVDS3lUaHpsV0Jsb1drT3hNVEY5QzVzczBZRGFQd0I3M09DUmNxTmpTSkJJRW1XZUFNQm9MalljS3dxd0Y0aEJIcHpWcndqRnlPQzhRT0RnNFVoYzI5OEtsUTFGV3FHTTZLa1B3cVVkRnMzMUdKMmhmc1VsZ3BVOGhxVWNBdkNVeDZCQnNNMTRERkpmeWZhVGhaK28xT0JyeVZMejhDV296b2tTOFI4d0hGalBDUWFoYUZWQWVBbHFYTm1KQzNxS3IyY2RHMWp0M3dEeTRSTnlOa0ZrUTk0VXFkNExvc1hqSURnc2VGdVJhTUFiUXV3SzduK0FBTjhZZXNvZmdZcUhnajJqR0c4MW5FY1F6NEh5aFhBcTRWT0NYcGNrYmdvNXgremVMVUlvZ3cwaHdYSTlEcjNnRkZHMWl1SVBFR0x3eVRLaVZDN2tvZmdmbU9OelFSTDNKN3pzYXh2UFlaY0VmczIzQ1o3MklhOUNYQldoZVdqY2xxTjBLVUJrTlkxRndQR090SHlLQ0ZhaXU4Ujg1WERZY2hZS3hDTkVMektoZm5NNWxMeGlZRGVCblJRTXpIOEdLaDZqbWphU3k5RFNJVlV4bHdZU3FSSndBYXNienVJUlUxRllkRVZDU1ZMQXc0dzN1V2lwY05xZ2NmVXRCLzdRYUNqaVZrVUg0QnZmaFY3RXZoNkY5STBYQ3E5bHZacHc0a28vcXloaDQyY2d4emlFT3d2U2RhUHhnTlEwWk1EY2p6Q2hhQjR5QVVYL0FKNEFCV1ZrdEQzcUNyVVhTdUs2V3pZTE4zdEZCV0t4K0liUTB4am9UVzAxckM4aWFMTm1aQ09aSXRBWElpa3ZBM2draUVjbC93Q2R5THhCZVFvRzdrUjlIMmZxRjlEb1RkajJVdW5nTExFT2o0ajBDaW5HbzJGS0c0SktwYVBWd2NuRzdnQ21Ea3R3VkZ4YmNNTVZrRUt5Q2l2OER2OEFoQUxZVkQ1UUlnVFVOZ2tVN0ZZWFFTZ3cwaXpwVml6M2tTNk41M3hFd29OQjdTZllNVlBvWWtXSFNHNkxDby9EaGlvckVIRjRzdmVzbCtGeUxJNVFUZ3ZGUThpaWhqSXZzTTNzQ0NtaHlOK2o0SDRId0hYUTNHcURqQXNLU1Y1d2NEWmxIN0VMQlVWSGd6NUxzVkJ1TzhMT2tXaWtHWEZkc2pFMlo2T2F3Vi9sQUtrL1VpWGlEdUI3ZUNrQjZBZE43UW4wb0JSQXJxRnFSTVg0Qlc0cU9zQW85R3dZUkJORCtqOUMvd0NZUXhIRmNrYmc0eW1JQVdSVVVQRXFLOEwzZ2F5RHZoTEFxaUpXeVlEaExGc0Q3Wkd5bmlIVEFpRGkrSVNySTU3aHZtSjRpWE13cHdUNUFyeGFWNEFZRFBSdng3OG9GZUlQTUF4d2RROVpuLy9FQUNnUkFBTUFBZ01BQXdFQUFRVUJBUUVBQUFBQkVSQWhJREZCTUZGaGNZR1JvYkhCOEVEUjhmL2FBQWdCQWdFQlB4RDRJZ3cvb1RhWnQzZzF5SUp3VlE2OHFHOFhoK3NhQ2hUNzNEVUpEOUVNUHNPeHpWZ3BURWUrSWJRMUk1WXlvM2RuWUtnU1BCZkRweEI2d2RSb2hNMGV5R3ZSWHMrcVlnODJQWmh1aDdRYkZEcTVaSU5oaGE4b2pUQlhra1J2Q1QxUXlhSlNNWE1QRUh3NVFoS0VhUk1uQU9NVFpTbGJrVFlQcTZ3YldmOEFNQkZhTkRMZlNURWFPcEk3MkxkTkkydG8xRHBnRTZKZ1RmRUZvVzJZWU53SU5iSndrejcyd3d1ajNGSm1POW9uaDNOUkRvWjNKQWhHNkVmVUl1dkIvVS9taWVITVNqYWRIVTl6SGFqVCtDcllOWUVFQXNWMWo4MGYzRHlYWTJ5OEdacVBZYVVKcVljM0IyL3BpcWozRFRNQysvTytsaDMvQURqdEE4WWJIYml3bW9odUJMQzJHN2dqdklTd1RpTU5uK3ZrTitDZmdsUktySkJhdWpFaCtEOU4rekF1d210OVRkRHNERTQ3RXdnbkF5Tk9RQjhFeURMNG1KQ0NIU0Z6WlAyT3hoMWhWMm1PdHM4UmVObm5QUWJUamFqcFF1QnloTlN6dnhxWHI3SFV3VTB4Q1NnMGlSNGlkRWo3RDBnc29UNEJIckZWbzdvYm16ZzRqSDZOWnZPcEFPUHRGU2wzazd6WUJMTVY3eDNnMGtqaGRoc2JXeVFUcE93Z0k2TVUvc2JSNEtZSFpoS29NNjZ4R04rWjkvaEpnck40TTlZNVUxRTZ2WlRyb1BVZWh2WU12NldIMUpSUGlJTjRRMlpMeHNzc0xUY2IyaGRqb1hCeXFDRTZBakJoM1FRUEVyYWhsdVBHRWljZnlSL3Myam5ndG9heXloblNKMnpUTUV4NUJYLytFUHNINHdZM1dFcW4wS0dzdUdHakN2TDN0RzRIUXRINklmaW4yQkpDNlBTRUwwYXVobEpqV01OMWpjWTlYaWhhQitGalhzUDVFSVcraGQ3bWtsS2VVMDlIWGFHUDRMYkJKUGh5YnNSMEdRM1FvOW82cVFST1E2WlRhWWEwMVhSdkphSkxkb1JKaXByaUR3NXdndXg1TEc0eTlUdVN2by80VkVSMVZiR25ZKzVzL0IyMU5EZDlSSFdRYkg3SWQxSDM1bVd3UVYwZDR4Mng3VUh0K1NCT3NhOUZ0Z3Vrai9ENko1WWxVT3AzRUgwR0NXNEZkQmZyRmhjQUozZzFDakJXeDU0Q1JJaDRpZ3E3RjFEbjdEWkNSbUkyc2ZjbXhpYVJqdnhhZzY0UzdCMkNtZXhDWVZrdEJ1KzQ5ejZqM3VTUlVpRXRHdHZvMkxQb1E3TTBKMnNidU5EZktOVHNTZlJEOENlNGVUWlppTVBxSDhBZzhEckF1dUw5c29oZVoybk94TENBa24vUng5VWE0T2lHRHVBRFhYQ29qYVhiS3cvU1haWGd4N0UvZU9sOVpKaWdUY0RTdGVaQ21pN1dCYktLSU1NVy9BTTFvTmlQMXhSTHh3WmlDQlU2RVExaFFyRk1UMWpjc0lKdENFYkxVeGpiYmNFTFlkN0VrYkExQ082eUpCb1JlbXRVVHBUWFNLTE1iclJHN0gxaHBwR1QwMkgyUHMwWXU2UHNYNEpYMkNwT3cvaVlKckh1Zkk5RzhnYWJnb1RwaE1ncmJqTkowcjBOenBoVEo3c0cyS1JpTlc4R0hQUkk5bXFGUnU4d2diYkJMY2VUUVJySWJiQllGVFFMNEZJVXRnL0E5c1pxeldZV2V1YWIwdUNmSFFEM3dJS0F1bXorMW1wQnkzZGg1aWIvQUlQcTdFaFJZUHlvMzZ1WUFsS2pkRHc4S3RDMXMyamJLME12YTJqYlYwYW5HNTJCOWJaMFQ5a21QVDRkcUZnM0JMaUEyekFuMWh2c01kWVZKQkUvb0tJOTY4Qi9tbjI0bEx1TWcyNXNXa0Z3VFcyVzY0eHB2SUtZS2Z2aTduQVNpV2hMMmQ3aW5vWC9BQllSbk5tTGtIK1ZocTJKMXhnUW5GOHRXY1hZcFZwNEhzYit4RFRFL2pBYXVocVB1RUdqRWZQWVJ5Q0RNZnZ5SThLUlhiZ1pVL1l5U1Q4ZisySkVtZ1FJaWY4QXVPZnNTRnV2ZVB1ek5YZ2JUdmZZbGhYNG1WRCtnbHhOdmpYQStJMmQyR3BLRTUzWWxsdXlvT3NFcEFpKytuaGJUc2UwYTJSRWVuRGFEbkJMRTF4U0E1dWhUTmJhekh1UUNEdFlzSWpWRHVtZnBpWEFmM3d0bmNjSG9IVVRZZGlpWHBUc0IwOUcyQnpWMEt4cWtKZ3FnOEtYSXBCYzBlbWhkVFJVaXUzNmY2ZkN6b1dJVEVtc0ZRUDRhc1I4U3c3aER3RUtuZzg5Q3pyWjlBbFRvZ3JIb09UV2hLL1Q2UUJjWTZab2lOTklIaWJzVysrTXVnem9adDRLL1FUUUpIY2Faa2RDR2c3b0t3NzRkME9tQ3NiYkFzbzhRM0JyZ0ZJaXpoZ0hIN2hPZzRyMFVwVVdGeGtOb2xTUVRFU0ZReFB2Z3pid2FHVERkRHNaWGxGOUgvY3BOMzlHMjRtSmljRmFMRTczbGNialNHeXNKaE1WOTRFdENpTkEyWVNmZENkTm5va21qREZLc2MraUdkc3FSM0ZyUG9XMkdTbXA0UlBZbXdhQlhUUXAyZTRlRXdCOEpOTDhDMHhNdXhoNU1OeXQ0bFFEbUdOWVZZbXBrd2pjTVloRGNoWHZZZ1VHQS9mak45WTB3TklwM1VXMFVNbHBGYnBESU5RZmo0RjlncGQ0MHQyemZBWEdZNm4vQU1CbEJZS2pHU2ZBTlZFTXVMdXJ0a0dOK2dxMk5VUUxpZENrMjVBcEVYRGZaa2pESHZNZ3pnL1BDajRJaVJtekxKcjNnc1JncEllaDEwVVlsVFpyZ0VXM29TRGlRSkxiSXBod3U5anRSckZ6TVB4cDNER3NzYlF4NFY2UXZNNlVuRkV6UGtPODQvQ283QUk4RHFJSWhyNk93Tk8xQkxoSnBpSUhSVFk3SFlrRW5nMTRoK1REUXNlOVAzZzcwUEJJcndsWEc2T0lKYWZNQUNMR25qSVJHb1ZySEhpa25DMHU2RmVCemhMaG9SQnh0dkhydVI0TFJPT1RqV0NEN1JEVkRSNEV6UzJWdnNtWm1DRXdSQmZFV20zSW5FenV5NkdHaTRHbUNvWDJhU1hmby9vYTNEb1lzRm91bEh2aGk1QkMyNGc3Smd0NkdpSUd3VElNUUVWU21OY1Q0QXZBd2ZJVEQrakpEeGs0bXcwR0RSRFRZWGNQZG5zTm5vOWozRkhjR05Zc0pweUs3WWJ6VHduQ0xtaVltVXhDWkpoTXhTK01zb1M0N2hNZnM5NVFtZzhxSWYxR21aYTY3SjlpWWdzT3VCSVpUN0d4dHMvNUlmVDBSSFI5d0VSeGtQUXE5MzBiQ1kycnQ1cTFDY1MwNWcyaWdjYlFabzdRZ3ozbHR5N3U0eEJ6MkNIK3A5N1B0Q2FyVHVCYTRMbXJQRFJCMm9yalluQ0V4TUpsZHNSQi9BeEM4UGZrQ1Z4a0JzUWFwYjB5aGdpayt1QXYzbGcwaGpaak50RnBCYTl4U1hRZi92WXFjS0ZVMzlTbmJDcWxST0hUNGcxMmFoQW1BbkpJdGJHb3hpY3dqYUJaVkRIOUgyaGQ2UjRGSDVGKzJOeXhxUFBDck5ld3dIMjhmaklkQ0pNYmt5WVRpa0xCMkhMcW0wdnhMd3NIa1RpRXlzUWFENEVWM3JnUFJpOE84Vm4xQ0NCZlRWZ092U0VwcDFwSFlMc2RSWnBiRXYyRjlsT3hGL2YwZjVoTlo2QzVDNE1xQjVrTE1YOEJvenNDMEYrRHRnZFhCTTdZVVduTWlsSS92Q0NLTUZtS094Ump3cGo3d3ZnU0lJSVFSQmNOK0U1L05zSHhCTG1ITkQ3WlZocGtLNlBjMjdZU3RVUEdqR3daam9KWjBISGNhSU52VEU2UHVpQ3NHK0kvay84QTFISTBqTlFtVGNlTmJDZk1QZ0pNMmQ4VTRDcW9hakZwMDRya3VPRUdHZFI4QTYwTDdaY1g0R3hXU3o2MFFadVk4eXk1d0VJTEt1TlM1b1RFZ1djWnBsMTJucmpZR21BL2tOZkJCQ3pEQ1lIdkptUVVQRHVJWG9TdUhVbzhIWGhMMmlZVTZOUi9UYk9PbXI2RHM3M25yNVp5RlRJWEFkU3JIUlJyVjVWaFZpaUZHeEtpY0ZaN0cveUxhd2Q1Z21LRUdEcmtKcDJnNVJORFZIdGgyd2FwR1VMUkRqU0xCNHlkRWdtYVhpUEVZM2NBRFdOVlkrOGRCalFzcGJvWDJZd3ZZTVNoWjRRcXFOWUgxYndFeEZFaER3VGc0bHMxV2hyMXFLWCsrUklVWGdHVVhnWEJZUWVDWmZBWlJLazBHRzhNMTFrdGFVT2huNkNLMk45SCtwSSt0SDRDZnFPbldJTFkycWpqQWdoSXgyaW5nbTlpbTJSUG9tRndtUmRhSWgrSVgwai9BQXpoRDZZZ3FKeUlkWnplRlN3Z1o0bUlFbnJwSGtoL2NXMmtPdUdvTzRGU3JzUUgzcFhRSjMyQ2gzb1dDMmlNNGlsczl2d01oZDJXYmd6YVZFVkZodXZHWXVSbTRJR3NsSmtKdGlmM2VEd29PQ1hZNnVMdUdjaFdXTEFyRythMGV1QVprdFJhT0UyUzVSaFk5VFlTSWhpWm1aVmc2THNobHNvN0RIODhJcHRoM3A1V25TUi9TdDlFaFlCN1lWc2ZzYXJaSkUrbmpFYTJKOGdFTW8wWDREdkJINk5XUkxvUWhRKzQxaHBrdVQwV0J1SW1IL2hGMEc2SlhUeEZUd2pqQnNONHVWeWhDRXdRU0prc2c4RUVvSDRFc20zaFJ2a2RWWk14QnRCendId09TelZ1a2hQaHVuWTNjT2FJOFB5d3ZUL1FiejRPdkFTK2hvTHpCbHNYWERKOXhDeEtJUEhUTnRZV0QrQ0Qwb0xTZzE4RUtVMVdSWklIY1AwQTNDL2lKM0YzQ2VVaVlKRENFd21HaWpYWlVMRUppYkEyQWc0MlRlRXlKaWJnTEw3ZUFlTDRMZ3h1aHRuRmVOYVJPR1BvZlk5UHdIVmp6VFRHaVltTmliZXlieVcxRnE0RTBKbjQ0V0lRaE1lbkV3bndIaWNFaERQTWZ2MkZDOUUzL3dBUlc5ZVRPQ1pOVmdnaW0xc2NhTDlqOHdXcTdPMVdqZnN1c0xhR3ZZNlE2b3RpWHljcUNid2ZnTDhuMm8raGd0bGZNcUpoQm8zbGpQU2NPcWhIb2l3VVlKL3NRZDNYMktlOUQxZ2pBa0FWZmNNVXlMajNqelNVVXBjRFExanBuMlpoQ0RNakNYd0ZpRUlQQ1FrUWt4Q2RaN2xHK0lqc2VBM3dmOHJvNkxoUVhOWDJKWU9jNjJodWp2SlJoLzczRVRSd1lYMmpiVEJUT3ZPbXhub3dKUXVWVWtTeThsZkFYdHNLYmxsTzJOTEtSK1Zod1NkblRGUFJCUW5OQVhlT0xvcU1XdEhhWDJmbUpDcW9FRTdoQ21nbFhFR3VadTVoTUg4OEFBa1RoTVBoS3RRNlpCclF5UmlOZG0wOEdzVk5vUVQxZ1ZFb2ZnbkJpaWlUNkdnQ1lDN3RDaUgxbzk2RjVNQTJ5Q3hEUVhHQzEwZmJrQ0I4a2ZxVGtPdThOVVBLRzRrcFRnK3lYaVRweHYzWlF6bXQ5amNhV3hndit1YjlzdEJkeDJKc2REbTUwRks3SzJEZmJCQ1p1Zm1TNEkrRHhpWW1YOENnVTZFSVRDRUlUTDZMbWd4ZzJvVUgxRkI1b1FUUTZHSEExR3NvSTVnQ1BSc1RjQkxRVXU2UW42UlpoTWVualpvNFBLdkc3eWpXQisrU0I3TGdoengrTm9sRzk3d20zMGIvQU5HdkdIcUdyOUIzaDNTRW5mUTM2aDBJZzJhMkhTYlEwZmFObFFrNW9JZTEwbzBrOWpONWhaUnNMQ3hYNFU0Qlg3SGhuZ1lJQ2NTaVp6ODNJQXB0Z1V1ajdScDlsUVpuODRpWVRmUnNrR0JveGZTTEdDK3pqU0V3YUhQK0VVbUJpNGdYaWxKc2FGMHBvSTdzVHdTNW1MTHdLd1gwZUtTMFpXdG9ZMVUyMk1TRFJ6L3NVeExyc1RuV2dsMTEvZ1c3YlA4QTNveVdpbDAvdHc2WGYzQnZRN0hSWFJhbWtxWnZ3UXRaT0tFaEZLVXAzeHYzUEZoNlhpdUJZM2kwK3dKSDRXR0JZTlp6VFl2WWJTN3l4Q0V3V3hCRVJFUVErQ1hJR1lWQk1Ld3B6QTB0d09rSlNEVmc5aHV3WEJVL2VZc0pDTE5RZ1VHb1BOMk5WRVV0YTE5SDlLdzArN0syYWhhS0ZqOC83SHJmdmY4QXNLRnBVdHZNWDJEckhtTldMOFZrZUdhVXBjSURzS1Zpd3NHeEJENEZHbU5wTVFRdUJTTEJ2eEo2bzRSNUNDRUV4TUVzUVJPSms2VDRBTHJpSHlpQ0xBb2ZCSGR2VFZCSEVoNHJDNHAxOUtGc2JGMkxvWE5INmFHM3VrZVl2cjYvaEVuYm5Zak5ML2ZZbTlKVHFlNE5kRHNydkRmYkg5NEZrM1pxNW1MaENHaTRobnZnUzRvTEM1a0Z3WjM2T25xRTNzTmZVU0FTTVJwOEpYR3hDWkdodVlST3pnTDZjT2gzNEZ5ZUg5SHhHWHdsQ1kyek5Cb21CNFlxbXRrMytSckJiTHJGYWR4R3JzRW0wNjZHSis2My9nUi82WVNXdjYvUkNLT2hZbzJwb2JQdkM0NWdhZUZoOEV5L09BTzhOaE1GeEVMRkYvaXpHcm9aMUg1NFFwN3o0TUw2Ti9STDFrUVdOMFc2SGd0dGtPaHd3ckIzQU83Y0YzeUl5UVJqTDM0Z0ZXR2dIOVVJTWVMVk5yc3VqV0ZJN3dWSFJ3NS95SXI2eitDKytsTCtpdDQweXRkK0gwYUV2aExGQ3VVV0htOFFubHVZMlJLRUV1RHZnWDNFWDkxOUpvYVlkTjVlR3h0MmlhbmhCbGlFRUNLY1FsZ1N2c2F4NENSOE92MTZpMGNDV2hkbGcrRG9JSWJCZmdBWThsd1k4eThJWEc4SGwxSFJYcUVSSWJxQ1VaVGR5SkJsVzZFbjBQci9BSU5Ra043SnVoSzhDWm5BRnBVYjd3UGtmRDVpcHhtQ2N3aC9XYnVGWDROMnVpRHhSTG9pbXdrby93RGsvZGt0bUFMcVEzSFE3L3dCZHVHcUdYSkc3UXpzTyt6WG9aMk5pOWNBNkRFeVF2QUc4MGVDQ0VJRXZtVFdPbHdQbVdRZWFiWTkvd0JGQ3lYbzFlMFk5anlEa3paUWEzN0NHdUJPQ1lrV3dUWHh0QnNieGNoQ0VGZ1Rtb3pTcGZZcERYQTJvUE1YUkZiRnRxSUxMVXJYcC8wUEFwZXlsdjBkaFlwM1p0K3NSNUVqMGRRdHRpNkVpWmZRMFg0SUlXNEZGQllYd21TRDN5MDREOHgvakJ3TnlKaURWVHQwb21KdzAyLzdqT3p1Q2I4Sk94blIyeFZDY1FtSk9MSjhJOGhvZDRMQWtiUDRROHZkSENlRWFIVzlDKy9ZdzNHMGZZdG5GczNkUnB0T3laMU9qam9vVWRsUXV0M2pIYURyNHdOaUd4MGFGYUNQdzdhRU5URnJFSHZCY0Q1aVF1V1ZCSnhmTVBrVnU0ZVd0aWdTZlFmcDJlQlJ3YzFRMmF2aE1pWDNnc2lhK0ZqR1d3YTBkQ2lRalluQThqZUxrNHhqOGZRODBZcVEwcnJvVzBpMUJML1hwZHhDYWhuMG92WGdSTUh5ajNSUWs4UU56L29aY1FOR1lTUlNOa3JnSllpOFVIZ1R5QTRuY2pKOGdGaFVJdytzSGtlRWhxZVJqZ3piclA3aEU0aFFXQ1Fsd0pZK0EzczBjQkJaTFRMc1lZaGVGeDNQeEptWitrN0t0MGZHc05aOWp6SWhFZThyVzF0SWlwRFRndXFLL3RQcWpZajB2WVlaZnBUMFBZMTdGNXltdndBOFM0T2JNUmgvQURGd2VGZ2x3bkdkT0NEeEMrWWdnaERzSllFd1NFc3BtNGZDTnNraDhrV1YxOGdObC9nODZMLytFUkRUeENmMDlZUEZTRWFSNVI2KzVRZHZzNlZVVlZMb2V1OGRHMmV6b3BpeXVIYlk2NkdtbkROUWExd3ZQN1lqeDc4WUh3c2VFUWZ1TUREeVFSNkpZSkhtQ2VFRWhZV0dIZUlTWW5HWTdCc0NXSThFdnNXSGlEdzhyanRDNDdmOFlhN0U1MWh1UFF2M29lWTBOUE5rTnc2dHdpakRmY1FzYUZhUWpiSkJvL3cvRHZUN09aTWlPeWYwdUc4WThoRFdLeGVjQ1dHdmpMOENMNDFrd2hDd1dDQjVrSUlUQ0ppRXdRb1VZa3hFaW1ZTGcrcGNidTg5T0VHQzVkWmJIZUFpNHVFSnUvd1k4cWIwME5EVjZnL3BQWDhKejNQQkpsMEx2WkJqU29YcW82b2xUbzFJbnBqMTdNN2t6NmJMc1F5UFlUc3NDVHlRaE9BL21SUGpYeE96N3dPM1doaGw4QXZnckdOaTZ4YmNQQndKRVBUaU5Yc2R1Sml6QWkySUM1Uk1id3BjazRoUTBqeC9UYkc2SzlXcU5UWHYwYnNQUDZTZXZ6LzlGdCt2VVBSNHg5YTZON2RMb2JuY2JPMGIyZEduZnM5d1RBN1I0SWR2MkxvRzhJUVRDekwza1gveGdEUkhURDhLZnZra2gweHZkaHMrQWdvSjhKUW1tQ0xwWUZXRXJ4Q1VhQm1qRDBMcUFRVjBOTldDSW1RM1dQSTJFTGtFTjk5QzdJUWZleHR5RTBpRlg0aHNhZldwK2oxZUdkdUdSbytFY3NrRzdpK29ZMU9wOUhZcEtKSTZyb1lVZEN0cE9tMklKZmdFR0lXQk9RYjRuZy9uRUw1MkhmZkpSUWdza0g5UWJqYzZSeSs4RFdFK3p4Zzl4aWNCMG84YzZGaXQxd2g5d3l3M2pzQjNvNEZsTVZHc01UNEFoT3ZVVDFrazVSTnNlRzZQcVpycC9oZW5ibTlGL25CSU94SXYwMkt4Q2E3SHNNcnNjMGFHcVg0UUlOS2ZzUlp6ZEdOQkJJV0pNRmg2d3N2NUFOankyaTRQM21TOEU4Rnd2dFEvUnhyNldQQ3M5SHBZTXI5QjdoVEdCdkhXQVdIU0hpR1RkUUl5T3pJSWt2STNmRjFoTDRnTlo5TWs4U2tHY2JZM3Azc1NqMTEvN1JBZlpzMUdFb1FWeDA3UmJFdGFTZGpIMGE1SGhGcVF4cCtzMkpDS25kd1V1aC83UXc4eXVBcXVGeWZKRjhxZzd3WGl2QzhSMFRyUGxZOVp3SDBtc01rYnNJb0NIQWZ0eG1tUnNOdDVtSDZOZzBJTjhoeXlJakJTQ1dGd1RDeTAvdkRheE5VV2xHMVQ3Q0RIWEpIUG1tK3hJT2hVazlub2tmOEEybEg5SkcreFBUNkk3SDNFMC9zUVdiempaRTRFRytZSDhCZmdwSU5PV05mUHMwNFhaV0VLdG12c2YzRStpbHQ1R2ZNQnJuU3hPWGVCZHFPNGVDM0c0SEhqMkdtc3FnMSt6dGd2RVI1aGcyOFZmR0ZZcWZoaWl5OTZacXVCOWwwS1V4UVd4cjlvcStIME1qckpDUzBMOUd0c2YwVk5lQ3Eyc0lwdklrQ2E0d0tqd3NMQmorY3FhSHZPbU04THk2WDRLMGFaZXh2Umg5b3ZEbnZvaWNBNkJWL2hCd0tvSU5LRWhxRlFJSXQzd2dZMmR3WWU4R2tpTEdIaFFMS05wWEc1cDlodkg3U0hNd2JSQ2sreUxUNGRpUm5XalMvRGR2cDlqR3VpRXFJMTRKVnhIUzVMTHJQOStJZEV6WTQ0TStSZkFFbTd3M3dHYVRFOCtoMjBYL2lVdUIrL3N0dDZDMit3MmRMdEhXQlllakZ1TlJ4SGZYRWhPajNkRjlDTldEUHVVUTliRFBjamdvM0FWeWpFTXBHRGZoZHVTV0k4RWZhWjJnbUpqdGpmMmZqaStEUzA2T2xOTjkwU3BvZjV3REFzUGErTE15OUk4ZTR4c05CTy9NUFlEZUh4UjlSRTc2TkEzcEtVOU5xRzNrTmRneEx3MmZZblVOcDhCL2ZTRzRWQjZLaGJzZkdERlZnaFhFa25WaW40UmtGSFFlNFJXbURVYjBJTEVuaFdMaXh2d0VFc1VHV0NZZmV4QnRyWSs2U01udUlJSkN3cG16QW40Q2lTc1BEY2JEZm9sOENFd253Q3hzZUpjZVlUOHgwQ0pVM2xQKzBDa0phcUtoMDYwZFFTYjYwYXdpZG9uZ2hKSFZjUk5BNngxaWpoQkZvSUV3U09HY1lZWVpSaTdzaCs3ZzFnemhaNzRaNTJFNXJ3Sk91RExmQnk2TzhMaWtlZ3ZCRzVpZmZJUjJtb3pHaktoUHdMSU55V1JiQXZnQ3UwZSt5aE5xbjJDUHJGa1F4cG8yWnNTcnNLeGJjd2hidW5lTmRIbGg2L3cyWWRlQUxUTTRtbnhrZmw0TFhaWGVMSi9yRkdFcGtVSVdQZkZvRVBCNHVVUkRDWlpzSVNuUW1Fd2FZS2lmM3N6ajhDR1ZHZkhQNmxzcVppeUZDQTNRY25JRGZCekE1T2gwazliSUlXeDNQVVBnSjBFVUM5aFlqckord1JIWElhRWFiN0VsNitQUmZEZ3dNRHNvS05PWm80Wnh1Sjl6TVB2RDVJckxUQzZ2RVo0TU1iTjMyR3NUQ3hEeFRIUWdtVFkyTkdId0hnUHZBdytPbEtDQ3dXc084WG1WUjRBc1liY05zL25CNU90TGQ0TFVubjZQdGRpSjNraDFwZmg0TU5ydlJPNFNEUktwaVpzMFgzZWhPWUpwb2R5RHN3dGttVUpQSnlpU05XV0pDMExlTW93MjhHM21JMzV2bmxnNndhRy9DWENzU2pVUTNNUzRydzdDMkI2RmpFeHZJbUNlWnk4VVdKY0xkY2xHTndXQXVOczhvczZxTVhVOEdFOCtXSDV5NTZHc3lhM0ZqRXBUeTYxaUYwb3RxdFJrNncvZHExL3dBR2lyL0gvYUZUMU9paStwZWgwb2ttdXhMb3hlUW82UVNudVVpNnlna1FTNkZnWVpCZkxhcHd0ZkxwVDFDWE41V3dZNXZJbDhlZ1plU0xNR3VJdGcyWjhVYVVmaGgrb1o2UmYwZVFvSVgxazJTOEVXODNVVVMxQzJGbmtKcmgrYUgxTUxlOUdEMm9ieFp3ZUdWNGpjWWJ4RmVJM2hNNlNiS3RrNHJ1YmJZVFRBa3YyTnJhZE02TDB1bGRIWDBEZnRodmdqM0QrRUlKQ2FQZ3FJSHZQL2M0am5Jc0RkR3ZCQlJjRkUxaWpjY240akVCUEtYTUprWVNIa2QySHZqQzllNU1UbU93V2RoZ3U2SDAwV3kySzJKN3hpTHRpWjBhSFUzYk9xRnN5SVhpRms4TE9haE5EN2Z3a1RPajc2ci9BSEdkcitEVFQrbHNJdytrSTEvNlgrRFJvOC9TS3llNFN3R2hRUTBJSUxOaHN4TU4wSnRuMm02SFhFTkpUZVBYaFlGZmhZZ3pCcWg5NGZka0VXOGhMZ0ErUU1Ua0JGc2JqdGhsVFE3NDNXWFRCNDd1Mk5NSy9EUlIxTzJHMU0yWERFeDI1OVlVdUNGZ2ttVHpCTm1xTnJDVjZGMEtSeVU4VXZza3UwS1RiSjVpczdhTFBjOWxXaC8yNXNEZm9oTU5SWkZKRXBNWHVMVWJlT0tIUXliSGpjRzM4UXEvK3h2R1BabGE4aTROeEtYZ0M1SHpBYTJENEtlNkZzZE1YV1FSR3M3Y0IyR3ZmWWtReDIwbXh2RGFPM3ZuK1EydUJDNUUySU80L0RvWGk2TmFpUnZyZit4UjJSaSt5LzhBdjRLMjQvNzl4RVd2Q1FXTHBpUWpndDd5MFRDQmpxdFBvbUJpUDFJK3h2MmVNYnY2UnpiUXlmSHdxeVVYS1pXaVdCN1pHK0lCOWJqOEc4Q1BKQ1VKeUNJRldoZEk4d1NJa3NEUUtVMEV4QzZJbzlIeXY3eWVVZmduWW5vTDJGN290UWRndTlJVkhWQ3A5aXlxVm1vNlJIY1pPTU5DQ1FwWWZ4bUpndlJHYitVOHJ5dnFTUFhHTENpZ25OamhmT0FQVVU0SkdFWTB4VEkzOE1CYXdKalg0UnZ5VXRtaGF4bWYwanpHL2VQR2NlQXYrZUxUb1lzaytoTm00UW9naDRkWWlPaEhjV2pKd0xONjRyOVlvMmdjdzZRMmpzTzlsVnJSY2duTVV1RXlMZzc3R21QZU5RaEtTVUpZUktMUGt6cnVEM0JqNGFIdG5SNXBqNFJINkxNbWRvd1FmeTRBWHdIM0k4QTd3WG9QOUd6eVRxQkJnY29RbERyR0VPOWhPa3A5N0Irek8yTWJBU2I1WTFnYnJqZThvUVVTM0VJdzlBbDY1aEVveGp2b2Y0SFhtS2JmRll2bkFQV2gyNG1FaERkZURVUW9IeUpwZ3ZOUWtibUpoQ0h5RWNENENZWE1JTGtuSVBldzNnNGtKVkZaUkhSWUdaTVdWbUQxQ1VDcHBnelltRjRnMnhvYlYweFpIc1FXZHhJVEJFVHNUVVJCbSt4YUNJVExCR0lKY1creDdMWTVDWlE0a3d5VERTdllqVVpkUTkyZXhaaGhpbXk1SUM0a0FobkFETE82eUU1TUF4b2c1NFRRNlg1aUJGTHdDNUk4ZjdYQkFjRVRpTk0ySTNZNGtOUmxSaUJScVBoRFBWaWZ3NlVRRUoxeTFVRmZUSGJzV3crQlJJOCtkTTRESkw3UE5pTkVJRlJJbERPejNBUW82aTdHTjFqZlo0MTlLMndSZURRbmJva2V4WVdCbCtNUkMvWm9zVEd4KzdMSlBDRHdwazJWVEJya1JkQllveHNkc1BnQS9nRExUeGNXUkhNSk9iVkcwR1JzZDRIbU5hblRCcHhpRU4zUjZ2T0lpVFEzYlBObWtGd3A2eGxGKytIajlnMjZHeTZ3bHJnNjBWRHFZQ0FmdW5BbUtObm83dzdSM0pWUHNieFlFajBmeWpxQS93QUdZUDJkQ2owZkVIb0dNaXpCcE9nYTA1QWF1QXljQmMxOFlBQzB6cHR3Y3JJUVRIaWxJSHBxYndJOVo2bU5vMU85eFBhaSt2Qy9zejdENjVGRzJuZ3k0c1lxSFFHajBQdkRGRWUwU1REUkJubklvOFhpMFVjRnJnaUpWV2FHS1Bib2JWc2QydnNlOWtPdWJDM3o0UGdaZmhjQUIzWnhjRDNrQVRrQ2NrOEQ0bEZNYXI3ejB4VjJISVc3NEpjNTBrY1ByN1BBcTZsMEtSRDFSWVZnbGdXUG93Q2JDdFdhN0pJZnBpdXh5c2FzTzJZc095RVpKUzZMZzJOODFKMWpkcVZKRVkvdU5XRDlpaG83UWo2WlpXWDRZZHNQdlJaZkVYQjV5WW0zQ2FzRHNHUGlRVC8vQUpRQUtESVlOT1FRSVRpTlJkc1J0d0pKREgyeENLSWV4TEdvZEdEVHNoZzBZV2lZQ3RIWTcrUStkQStvMkZyQnZzZWFGSmhkRWRqdDhPTHNWVXkrM1ExcG1vWDhnZFFTMUhnbGRCTks0Tk93U0s2SzdnMllVcE1DNEd4TGg1eUJzVFhzaE1udUlXQ0lRK3NlQnBjcGtMSzVYRVEySmhIeENHd251UlcyZ1RRbWhJS2x3aDB3azBWekxZYkpMZkM1Y0pLc2FkZG5xTzVZM2dYUW9oL1kxTEt4NXdISkE0V0pOaTIyTnVoNWN4Q3VRU2hUUWYzUDBQVG1DdUJBTlZSdkUxd2E0eFlhNWl5a3pQYU5aSnJGc1VKd1BCaUdaNVQ0UmN0NUFoaXhIc01hdzFKcloySG9reG03N0RhdnBOZGpVRGF4WnZDVVZIUThDYTQ2MGVpWVFhQTVVdnNPOURUTmc1a1lnUklla09Ed05SOUE5WUh3YWhSd2E2WTg0dXlxbmdxTjNXNEl0c2lJbENtMGEzaTJzcmdTMHd3ekFlS013U2hHRkpaRTFnclhSY08zZ1lpMFhoYjVBQk9CYWJJVk4wTHNiTVl4N2xDRkpETFJXUjJvSllnNEcxazhST2hEUjA5WW9zSVFtVWhJUU5JTnNqSFF3VGlFelhoUU1vZUJRZzJPY0c2STZ4alUvUzZndkFlNTFONmJabDZlTWtudkhOV3o2THdZdUVEMHNmQVBDazBkOFlYNEJGNFhpelE2RXlPakxMa3hoZHdyZ0lFY1RUQi9ISW1MR3REUGNKNzRZUmk4VVZNVUxIZXkwU0h2SkNDUTBJSWJZN3M3NFF4QnBCNkxCTzgwNFZ4YkgzRDNHRVltSGl5QlFzN3VOMVRVRW9HM2ovTEczWXBvTG9iRkFkYjdGa0RhUDlLbG9YQnRqd3dlRElRbkRSYlJyTm5NQmhabTc0MDhMOEFjSHFUZ1E2TGdRMnZ6TWVURWdYalhKZ0xOT0N3UVE3ZVhRaTl4TVZJT2pIa1hZaTdnSWI0TlFVS1ZqMEVka3FJd09MSzJJNVVlcHVJdC9Zam5jUTNvZ3A2d211aFNmUXROaWI2SlpTRktTdHBzUVRjZGF3NzdFS1pmWmJnSWI0R3dKc3hzcVBRdzRORzRkdmtvTkZ6WDhTQUIvWll3dE1nb3g1YmJKY0N0UEY5M2lJSkNRbGdrTVFoQkltZFlDTnVtaDVQZ0Jac2UzckdDMFBhd0VFSkdoQXlLTzZrT3V5bmJHSnVYVU4weFltazBLWlh0ZUVoTVYvckcybFM3TlUxWktFZFNsTWs0Sm9ib3NvNzVqK0FKYkVKbWd3OEp3RStVd1llR3c4Q1ZMaGVEUWRWN2lheUlSaVRROWw1eUNyUWxFRmpSUW1Ka3NqSnhOQnZrTk5uMUd2QnIwWGhob0IyZ2Ezc1F1UzFDczIyRkYxaFZYRXlQcEdpd2FYd1R3cjVqckRIZWpiN0c4NUVkeURIcC9DTkNaTmNId0NUWThOQjhLRnE5TGVsTXlQdVdETGNKOFJRZThMdHh1RVFZV2dzZlVWRERoY2RRMnhaSlpkM2tYWTMwTjJEVHRFZGNCR2xSeHJZMncwRjk4Qi8veEFBcUVBQUNBZ0lDQWdJQ0FnSURBUUVBQUFBQUFSRWhFREZCVVNCaE1IR0JrVUNoc2NGUTBlSHc4Zi9hQUFnQkFRQUJQeEQrT21EZ2NacFFBalFGc2NLZ0JFZ1JrVWdzTURTTk11QUkwUS9na2lCQlZDY0hLd3o0a2dOdGVBNHZ5ZDBRVUlPaU9EMFVVbDhpVnF4a3NTWWpXMFY4WEREWUpBaFkzaE94bmZ2RTAxQWpKQWF5cnNVNWdxWGlWRkYvRUdBMlJVZ2lNZ1FNck1JeUpjQWlSbWlZbVlOb1lTMmJ6RUpJcU9FU0ZZaC9ua0phQ1NDQ0JDcjNuNlB5RWdPQjFRZzRsZ3dhK0s4Sm9BOW93Q0MyT29ZbXE3Zys2Z0s4Q0lXSzRMQUVDUmFFTldZWXpvTENsU3loSUt1ZktFZ3FJd1JBTm8rSnFRYU1WTjZ4SWt3bGtodnVJTTlyaGlkWkNmQXF6NG9RRUlRNkFNTElOVU5nUVhsQWo2R29TT2d6UUl1RWU4Smw1Z1M4QXA2RUZhTkNBY2NDYmxuQVc1a0pBT2UraWFQSjliS2NGN2twcHpEbWNqZ1hTOEJ4N0FsNWc1d1NXSUQ2WVR5ZTB4Z1VILzhBaFFnSUpMd01vcFI0REFOVytjY0ttZ1JTaEhBOElBMkxDSHZkNHROWldjRDRBSUFNdHMvVXBMSUNQQ0V3SFFEcEpjVU9wdlpOUVY1ZVVybHB5aGM4cVdJa1ZoTGdNeGdVbDJVNmlOb2pKanJvalVGcGdPOEpmSlVnQUVEQUJSZ01IVDdmSFFZQVBnQ3RHZ3ZmWmhwQk1MWENqd0NBZ2JmQ0lFQUY2VGFMcHJRaVB3RWlNQUphM3FUS3JQREM3bHU2OWlCSDRsOUdGbnBoZ1BKTUQxT3VSTmVRTTVVNEM3SFBFTEFIVGxVMlhlSVluYVFTZ2ZpTTR3YjRDRUJvTFRWdkZKd0MyQWM0UWtQQ0hHTWZNU0dFc3hFUUtUZ3JabVRSSk5DczJLNmpHajV3SWtMeVNYQnlNR1U4b0E1S3F6QXRNR0lFUUp1Y0VEWXRTVFk2a3hvWTFUYnlXeVdOUXNJNWx0K3hvS0ExRG0yVFRXdVJ5UTlFTTVvMjV3c0JTeHpocUkyRlQ3RVdJNkRWaG9FTEFkVUhJWDhJRUV5akJKQUJVSGdRV0dvZEQ4cGhZS0J3a2xVQ2taVWxYTWRNaW5Ta2JIRDRrQlpOY3dqZUtTQ0x4RFd0d0c0S2NGVldBbFFoeFFweVc0ZzNkQmRHWTFEWTlZTzlCc21KcGE3SFNKTzJtS1VSWUhzZmt5SmpBM0VkTDhvaFJBREg0bEFBUllCM0tFc1NneWtDT0VpRGFmd1FBWVFRQUJBTXVBSXdUSUNISVdRSVNWOEFRYTNDVFJBUWFTUXRGR3NyWGhid01SWHc4TEZRUlR3bE1YQkNQZ0dGR1VnQkFZQXhFRWZnWUpSVzhpaDFxbi8xa0U0elNDV1NmeUVkVmdCSWJ3eUFDMEJOdmhFZElSUFdId04zckR3dC93QWdpQUdJWWdxRmtSblVBTElid0wvQUM0UU1nNHFGdE9EeE5ZQ2N2Q2JvZHlqd2thNVdPNTJoc1dWRnNnb3ZFSSsrNkVLbnlONFE3V0F6cVVyUkhPc2pRQzJtU1VSd1FiK2g2RUZuQU4vQUFFQzQ0YUFBWktIcmpUNFN4c0QwRVVpSEdIQWo0eWlUV3BZWXJQRUdLaE9DN0FyNGdCTUFDTElzeHd4RVdONFM0b2RwSnZBL3RIb09ES0lLZmVKRXNCTGVPSEtDUWx5SkV5TTAyYkRHazhDdUNTWlNBaUI1UmcvNFVnWUJNZ0lBeGNQZmdBcGlRRW5jQXh6czRqb2lyd0FtQVJHM2l3QXdDbTlmVUdQTU1CRUNEeWh0QWhCTEJhNG9NOEFhYTRiVEVRZ3JGQTZFbGQ0TFV6aEpFejgrSUNBQ1p0Q3M0MkVFVExQQ2dZQWlzc0NSRGpEVWhoSWUwN0hnaFZKN0hya2draHpnb0JrQXpWdE1BdkJvL3BoQmxLdnlyU1VmbzBzQk1tNFNZUTlpUDRGTURlRklSUk1BdWlEQ2RFc2llVTRpVU0zMVluQ2RoN2NDQmtnUzI0SlNSdVRXV3pWa3JFNVBNcXJqZ0l4TnQzRFFqZ3c3OHh4YkNKOUxBZkREY0VvYjRZbk9zQmlNZnNQK0pBRVltZ2lGdUFId0VIZ29DcnpnS2hRMDRTQk1CRUZ3RlNSeSsvbWxVTkJWZzBxOGtKYVJzQlZGRUd5QkswQjVRZ3BSSDgwUGVqcWN1UEFKTVhHSnVKSk1ISUU3UFFtajJkNU5GTy9JTVpPbm5pb0FoOWpCT3Y3TjJVYVFnRk1UR3dRWmlJeFhFVUZCdnovMTdlRVVnRFFUQ2djR1RmWXZ4aEpJWGtBRUJCSmlyQTRENlh0NXpNbVFvSUZWTEloa1M1eU1aQko0NHpsd2ZOZ0RHOGE0dGhUTkEva3JROVd4S0k1K1FNVTBNZWk4MHVNcGJOempJZ1NmSVpDRVJrZi9BQTdIUk9GYWhQUXRBbXJ1c1d2b0J6RnNpRHlsTEFsV3Q0aWhGa2UwMkJieFppUjdpaVZBL0h4QUQwMXdkeXhLSjRKSksvSTZWS1NQNmhuTU5iUlBiYXd5ZFZLQ1pKTExMUzhCVXlLUmlNYUlUd0FyOUZxM29nM1F5QmxWRkIzZi9nQU1lQVF0VFpROGNDbHc1b1R5dVRRY1dCZ3orSFhKQWFFRENVUmdrdm5WZmlnbG9RUGpJNlRUekdBVVZEQVFlcFBBTU42aVY1R0NhaWV4OFJzemtVYWttM0l4aHlCdTNpQ01EdER1L0RFZWp3Q05Ub2Q1Q0hJRWFYd1lRSkFtZ0IybnpzenVuZ1RtRzVtR0FRQ0pnZE1hT2ZCTEIzQzZKenFuNENDRERSQXdFM3dVU0FJbHE4QTVXR0NMS2lIREx5S2ZGbTVwd0NRcEh3QXlNQ0xNc2hGNUFLS1dnSjhFd2hLWUVnUkJCVUFmenNLSXZnc1FzUGdFU0FDSStIQUthUWlHRUpKeHBnU21RRE9vNGVzU0J5aHg0RmtyR1hpRGN1UkhWRytNZUFBNEVJQnNDTFVnNHZIbFJLNmdVWmV4Sm9WVHNsUVFEenNhdEc4SzhCOHV4cHBKOWxsN0lXVFd4VitaZVI3eFVsc0p2MGFBQW5zbkFTSHhHS1hDcWZzSkpCQ1lXaFZKelkrN1ZNYVZteWdsTVVuRGFFTFFTeVVOVStyL0FJRUZrT3cwQ3dEd2dJNjRGaGlHUm9vd0xIU01GSVFKQXpmeUlxbFlqNXlCZGNoR3loVUgzdkc2ZTJDa0ZCYjRGNER5d2lBSXZNUWdBRFRtUnorY2tJVFpRdEtTQklqNUlvbEVENFRrWWFZQmJ3YzRHRERud0ZPTXVNa1hRRUppYzZzaVhRWUE3SUl3UHJ3RWt5MFBRdjdEeStNcDNIZDRFQU9UNG9kTk1NVEhONXAzMk5PcnQ2eCtOeVA0Z0pLamhyUUpjNEJoZ25YaWJFV0pLQ0Vjd1RBRnBzSmxEaEJ3TnJEOVdqV2VFMDRpVGo5NGFFTHIvd0RJRmxVM2ZnQWhXS2ZnQUFCRWdHZ2hrNjhVWUtJVEJvVW5CUGdJbXc2RjRBK1VXbE9YWlNIQTBNeFdSMGdxRDRnUVRReWtEaXpnb0FMeG9LSmdWcEZDS0VTcVFhN2lWT0lWc0pjRGtxOWx2c3RKRGRpU0VZNEFaVDhCZTQ2WWtnbFFKdTlrbUU3SFR3dlhmVVJvSld3ZFZIK0pFd2xTWmZacElxU0owYlRGRTZnUzN0ZkVNQThLRUxYaXRJZVJzd0pMK0FJNlBBTUNia1dCaUtBd2svYjNnbFR3N211VXA4SlRsckJPSVJ4cFVESmR4aEVUK0VoaXd0alJobGFKR0FpaURCUUFKRXVBaHlabkFSSzhTQUVDdkFVUGlUQVFlUVZVQXd3RkxRTUZWTGVRTGd4Q2c2OHFSRmd3R0h1OFFHRWRKREFRSTh5dWw0U0FNNHdPRC9FQXNtOEdXSUpCSjBDNk1BU1FtWnlGYkFqd2JGQWpoQ0JHOFloZEEyOG9OY0NJSVZ0NFpzakxFMjNpNFJjUjRFeURjakRlWFFpaS9maHk1SXlYQ08zbDZnaHpHVXB2NE5JRUJQVEkyZkJJRUViQ1VtSmp3S1hnZ1d4d1psQ0g2ZkJGSkpLQmZ4aWNNZ3o0WUFrQUtpZm5oS1FCSnVKU2xxRk43SjZucHlLYnNUaWltbkxoOVliVWt1Q1Q3dzRra25JcWN5NGdXbTZQZ2J0M2J3Y1NPM1FXRVNiSWlqTEVoYlVreWZCTDJRNk5nbkEwamtwajdqYXBMUXc3T2JWSk9tR2haQmQrZC9GQmp4b1pKSWZoRnFHQS9PREV3dGhVQVI1ODdHekJDdEtFbzhFYk9WdVV6MmJDdDRKQ2FDT1lpcUFjUW4rQ1FBZ3VsNWhpS0lVQUJ4SGdBQUJJb0tab2tHVkVnYmlqTE0zeUhzWmJuREF4b0ZHZktZaUJRMEhqT21DSUVjSGVVQmdFa0VFY1JHVW9LaVJDdk01aFVJZzVVcVFEbDV5Q1dtQ0ZuMlBzZEdFUlZaa05rREVJZ1FRYStRUkk5d3pDVGpBb3VUL3o0enB4S2lBUmhDMmNPNDB6MEZzWGdJNFBCbmFRUnovRzJnZHBFQUFCeEdBbVFTVWhpN3hJRXB2QUVZT3JUaUUvamFVRkFBb0JRSXdGY0JYZ3B1WDF3TjFnTnFLalRZaWMzQmRxVUtiTlk2NEdvbXV4TndJRW91NjJqQ1ZKeHYyTlVkazZGK2g4cU9lU3MzT0FmMDNZeVd5UnV6SVZLSnVUWU85RmpjdUVLTTFnZzFQUkNvT2xpc3V4Y0FJeEMvQUZpbnVmZ0RDU1lRT2poNEh3NUJoVDUzR3hnZlRSWVFBR25CNWxIU0F2aGh2UncrQzBpanpDU1FOT2ZQd3JnZ2hKaHFpb3ZGckF1SFBOK0JCVklYL0FFRVFKME5DQ2doZ0NBQUNFUzQ5R1ljdkpTUkFTZmVnS1V1RUNnSEpNajRUZzRGVk5zTU5wQ1E5eEl4VWxsTG44WlA3TlI4RVlsZ2dmR0JyQU1vT0JBSWJMcVZnWStCemlHUlhPWklTQWkrY0lWK0IrSkppSjVCV0Fpc21ETHd2a1ZsMkVnWndYQmJFUjl3Skp6bnU4ZDR1aEhERTZFUFRSRmZnTEJPZ1BOK0FCUW53Z2dhZ1N3VDZZbGZHd0w3NTFvQ0ZBMkxQQkhEdG1CUFRCeFBhL2tLUWRoSnQ1TE9QRHl2dFlRaFVveVhSS2hOcWVDVEJNUFdpenVWRFM3TGdrdnFpdEEycExiWEFvdjZ4YjBJUm1HSFdxZ3BURVZ0dDZnVkJWOGt5ZzU1a2NEL2tUQWJHb2lMaFRya25jRE4zckVZeWxoc1NFbExRbmdrNU1sZEdnS3lpMTh3Q09nY0pNZnNFa0pzVkVtQ21JQ0lzOEg0M3crUTRCaXBnNGFGMFY4NEVzbzJqNFY4aTBMQ0N1bUpFazhsQ0FGbVNpQmhCUWw2bzRVYjRleGdFL3lnUUFnUUR3QnFJQUdNWVVJQWpVaEtXS3BTZjNnd2p6Q1FDck1XL3Bnbk5iZkVkQUZrZUJLOWljQ0FFUVQrYWVBd1VSd0lvL2lnVGpRU0FESmNlSkFNQkloZkVpRlJYRUFCSUtTUG5lTUg0aWc1UURleElIYVFqeGxNR0kxaHMyRDBzQUZqREhrTGlKbGZid1FzcHg1T0JUVUZGK2FDRXF3NlNYalMyUHh3ZVBBZ0kyQkYrSUNBUEJsZ0dCWTZpREtCQTM4SUJVVGdCQUVSRWFDWVlFQ0tZd1NUZUZrUGFiU3BGb3hzN09JSlM5TFF0ckplMk82YWJMT3Z1UVJJVnVsZGs2dlpaVWJDenluNkpUSUdLbi9aQ2RFWDNKUVFZcTVLa1QzZDhBbHkwaEtvYWpOTjFzUTFaV0pxSVhaTmIwSSt4RFNJcmt0ZEViR21NYXVOUDR1a2FBSTRXclNsenRnS0FubzBCVUVsSUVBVUVERkxIYU5Qa1FBaEJMOTV4a1c4RW1zaWdZUjBzT3lTaVR4M3dqc2VFVlNuakxBS3ZBSU1PWi9sU0pTTXRyY0lCNHV3a0dGcUZHQVJjc0EwTU9rRkdBTG91L05nSmREVFlRb3MyeFJnZFA1cFdja0lZSUZvUlF5d2hORWszSFc4aGNFb1d3QUx1d3J3SEU4Z0ZJa3BXRFpVVGlvRXVDQkNTTWNpZUFBb0c0MzRFTHdld1JGL0QrRmtnQ0lDQ0VDSENGdCt5Qy9OQllRRnA0Q1E1UWtMamdoQ2pZaWgzUEJBQ0VCY3g4R0NBQWs3K0xFRTAzZ2hBYTdONGNtNHNXRkZ4Qk12c0thV2V4cXVwUWtOc01tWStBYkVDcFU1citrRTI3Y1BWZWx2REMyL1FwOWh4d3NKcXBjdlF4dERwSEtMNUZWRitoUTNRNEtnSk50WUYrUWMxTE52b2hFVlgwUW1YSVBsSXVVdk5jY1JFSW9hQlNxU25rN2dCQU1hajJMemRCQ3dkbERkbVVKUWRQQnA0Z2d6ajZXeUlMWUowNFFJMk5wRUU0SVpScFprZVFGSVZGa0dBS3B6WGhSM0YzaGdTNUhCQWVoNEV5UlY4cEFnQnVqQkxEVUpDSlhRS0FVaUFCdGE0UVM5d0JDRmhPQUhOZ2k1RDM5M3c3ckdCWUlPTUR3SFNXSW5md01BTlFDc05HRFJwbi9IeklCaGNSZ3d0QUVVbUNFTlFOQ05zaEFNcE5ZQW54c2FzdWxqd0g2ZkFqUm4xRGhNYUVlUUJIa1diZ21HUzBxK0VDMlJMbVJ3UlBGbURrZU5ZcEFha1BHQ0Y0cUFxaUR3bkJxS0hnandjWWdmanhCbzFrNzRpQmtFUUtERXFnWlRoUXNoc2JCUlFKMm1zd2xlRm5xTjlEV3Nwc2tMQXYwTlNzTkNDUWFkdzNLQkpUbXdZUTAzMTRLQkppRWt6SjNaUkJDbmdyZ0UwdnNna3lPSW91Q09JUFRLRGNIRUpLVDlrUmVINVdqcUtCNjhEVVMrQU53THEzS3pSN0xCUDVEQ0tFbEZZdGtpRytVT3h4OEJqZ3BTSFh3cXhhQ0t5YkNrOXNLaWNCS0NlUVU2QllVQTZBdFBwQjJaalluSUJqUXY1UG51V29zTGVDRUlDQUNBQWZ3UkJNYlFBTlRJYk1CUmplM0tHeVFpWGVCZVB3d0VBMHNRQUJOdVkxOEFBQ2Nnb0FJU0VUQWhUbFM1bE1qaXZJUUJRQUpNNEkzd29zeHQ4SnBiSkJJdUFBeW03QXU0Unpvd1VFM3lZQ0hUWWlFMXdrTmREaGtlQVYvR0g1TlBIUWo4Z1lDaHFJd1ZQZ2lEa1pXTFh3SVF3c0JRQVhsRUpCMUlMQlFKbnhSV3VKUUFBYStDQVFKeW53UUVJSVNXNXlOTzRveDlkRFJNVldqY2l4UUZLUHRBK2xCaDVrV3piMk1rT0pvdDloclJQZ3V6VW8wZUVRMkpwS1IwbElvc1d3T3ZFb2hCd25vbVZvU2FlR1d0ejhuQVFvZ2NLTkUweHUwTlVFY2FlUmlsQVRDRVI4QW9hVURpQkhuSlJSd0VOVytRUENRZ0dzQzJSK0pRRElOeDRKQTBWR3dCVk1DVVBra0p2Q2VrcERDejF5U2M0YUhCZUMyRkFCekh3QUFnQVZQZ0FXVWh3d3JIekF4RGhDQkFkaFZBcXdBREtEc3dKcFFxb3hWWjZ2WUZNWHlTUnE0ZkVpRElnWTZLTlJSSXJ6RGlFVUdCZ2NuaXlCRHFCS0Z6ZkFVc1NBZ0FqNVRJeEE2Qkl0R0lFMjFqNUF2UlM2bE9JVE5YSW9Vd0kzanh5U01QQXVRaUtVQXhQSVNDK0FjRFBrYVJJZ0FoSHNvcHJMWERNa1R5TjhBRENBUUVsdVRMUnFNUXY0NGNXaVFBQ2VNNmhNVUFkRWNlQUR4djhBQm9nMFdXYjBUdHU3QTRvY1FtUmJhSkNSTHBqU0tCc3hFZ3BUb1JhOUJWQmtWd29KVkJHOUI4SmtZRWFnY25JZzZFYWdvcVVpd0p4c2hOdGltVTJjRGFYQ3lMVGdLVXNwZUF3UVdncEZ5QXo1a3F3TkJBV01JRU1ranhab0ZkSTJQa1FBSU1nSWRPQlZ0ajVtQ0tZQ0lFWGhMWWF5RmNpT0FzQW8wVEFGRUE4QnRFVk5TUVFnVVNaTHVDck1Gd0g0WVlHb0V6ZkxRK1JvRHlNb3JCbzRWQUVBVmdKUU9IUmptVnBmZUhMTXlGa21xV2hza1g0OFViSkF3blpCUUZSRWVNZ1k2S0FFMG9JZ29Jb1NWSEllWXBDQWdaUWtheUY4REJFWkFlRUFoSzhDRU0ra2hDOEtSd2ZpR0FVRFd0TWcwV21ubWlOd0NKRDdqSG1KakVaZkFsdndZWkc2RzdRdXdXNjNqcEVGeXBuSnNIQ3BiUDdDQVFSdmdrZ0JvbGt2QmtFU3NpR0NrZzArVWRBQ0FKTFk3Q0xGZlllQW1USkR1TzVOb0tQSWFVbGdqVi9lRmdsSUgxSFFFWXY4RWJLa1haRjdTUURlSDROTTdpTURCNldzQnlVYlVoUGFFdkFiZ2J1b3BEVDZrSUErZ09aUXo5dzdsSitnK3RFbkJ1aGxROEliaE9hOE5scklOU1BEekRJbUwwWkdNQ0l0Y0J4bUVBMjhIaVZUQUl4eXpCYlI1UUJpVndnNWFnTW9jQ0hJU0dzSkpqUXdOT0UyRVJCb2JHQ0VGWU1NZFZCek5GcUFuZmdRSDU2RWlVVUs1QlhNQUxpVytKbEhob09ZZ2N2Z2dnSFpLOElkRUhsYkFIa25Zc0FwZnVHNEdadm9mTVVFQkVBendlUUNBeEVSQlZtSHJQZ2dhRzJqeERPZ09lNUo3aHlBMFh5MFJBTUtBUXJqMGFrVE9DbW9DSEkwVkRGZ2NFSThQTWpjc3ZBVkllNFdmaWNCT3NEMkdOa2UyeFc1RjhQSkJ2cjRTZ1ljaEJETXdyakZ1bEJ6SkcvanZIaWpEQW9BQkZvdkdaY0JFREZmYUJRaitSRVFoQUVvUElPWUcvQXR5ZVlHQTJ3MEl0amFISTBDUGxSc25kOW85S2lHcHNFZlNLa1VySkprQlBZVklLcWhlSUVSYlVwUFFoenFpQUVTVzVaWkhBaUtZdVlnVm9KMEJEVTZKVEVHNkRmREVuTEZKT2lFTjdIYWE1RzVKa1BqOGlDZ01UR1dmamVHc21STHlqQTBVWU9nam1nZ1h3M3dQeGtZUzI4WW9WaGhVNGhZZTBEdzBrUzJCRmtFTDlsSUtNRDd3SktJcS91RWVFQS9MaGhGWWxsQlpnRUUrMW9jSGxVdEk1d2xwYmNPa0NJdjR6NEpSYXhjQVBRMlZDaURXQVpDb1hneUJzTS96RWJHeHJlS0JlWURnQTBsZ1dKWWZFenlBc0FFQ0NsZ0IvR1pwTDRJSXArdGpzT0VIK1FnMFh0OEFxeWQ5U1lTcTJSZEFJQnlZSkgyQ1FocUNvK0FvNXFtUS9qcjhEMGZDQ3hNSWdVaEFXVk40Z0FCV1hpZ1ppTzFCMVdoL3dBWWtSWUM0VUFlS0FsU2lHQ1NZQndZdHdyd2t4VGtVdmhvVUlqZnNINEpqQXprc3l6MjdIU3BRazF6MlQ0UVJ4ckNyM3BHS2FmUnd6Q1VkYTFTU01UMzBISGIyRkZyYjArZ2lGQ25saXA2Nk9RRWs1c1NRZmRDYU5KUkkwdVpQSEpMMUpJd0x1UmFobXJSSjd3SERDZjdEdHQvQkx0cmlmVDRPaFF3dUNCZFFvaUZvMWpJaElmTitaSUNKd0M3U0hhdkFVTVlITmptQmlValJLVWhPOENZOGFUQlFSZ05GVW5JSmRNRXFRTzR3Mkp3VWJUR0xUMk5MOENlc016YU9oYm55S2lKNmxLQ0pCR0FhTFUydzl1TVdpQWh2QXdLQ0NKdWhJdUNEV1pSaWMvckdDelJaRWJCSE1nUVE0eFNrQUdXUEFEYmdpMGpEQk9GdGVDQmdOK0FmY3dUZ2pnQUVIdHd0NEJDRmI2RmZ1UjhHbVdiTUQrKzRKUW4xTm9Sc0JkK21lR1dnRlk4V0VOdGhiOGVGUWx5Z2dsU2VRQWNnSWdSQ2ZaNEF4Q3RBcDVBZzVKaFJEL1hvZ0hnQUovZ09heU5vTUlGWGtESVUydDYrS1dRRkpBQ05NV2cyUmVORDRDVUVRNHlLRVFENUlZSmxGR2JKTUVXZUQyNnpHMk8yNWlkSEtRMVBraDBUTHQ2Wlp3eUpPK3dNOStRVENFRVVta3lMWkpzaE1FNm92aUIzYUp3SWZrNGtOcEpLaWhOcFdkbThJNjF3TFFhOHJFRG1FNndHWWQ4WTAyQUlDRFN4UnY1Q1FkMExDdkVYNUllTFExcFlJb1BrVFkxbVdoVTBLd2pXTzZCU0lnZVlYRzBMOW1EbkJBeTU0cVRua2pTQTdjbTRFd0xESTRQMUx3dUsyQUxlM2dHOFRmaW5YNGlFUTNZRHhjZzdpR2NBTkFqQU1BTEVKZjVIaGhJUll6WVVsMkdzNXo0a0ErRVlBSUhpV1JDajVoQUJBT0hpdmdpTWJoOTRGNkQvd0REaStGZ0VnZ0VxcEl4eTNXTlcwQmVZRnZ3ZkNRalhxa21IdlEvSVI1aktFUVlTSndnWGc1SDR0YlJsT0dMVU1rY05CVEN2bmhOY3Q4VFFBRHJYZ2dCWmxFWnk4VUFzSklobmtLUmsyN2ZNUmdpbUNBTW1BSmliK0JLWkU0UUlDZ2lrQklZa1BKZmlDdG5haTJoWElTdWlhd0RVYlNRQlZEcHB6L1dDelF0TkVxWFkwcGFEam14V1U5QzJBZlhSQXlXUnpXK1RYNmN3U0h6YjNBamxwalMwblpSUXhPQUlvYUFtOUVyOENVeGFrTk5JYWFkRnUyam9YUFE0Y2pqVWcwVExmZ2hia25wL0FkRWVuWWFUU3Jnb2ZFU0VOSUR0L2prWTB2TkdnZ1hpQXRZT2RJbmxzalMyTHRodHVIaWlCemlMQ0ZVTVJCdkFiUkZzdWdvNUJLQ21ZTnZMMlN2TndrSndDSUE1SDZHV3pudEJQOEFIRG5hcEYzSmdLU2NBZ3BpSDcwdnhEZUs4R2lGR0FJaHpRb1FXaXF2WXNCNkZSTWdCQTVIREZZTlBJR2c4SER6VDVVZ0V3Q0NBZ3dDQkNBRWxlYWhJZkpjU3hCbjJ5OFRCSlBnT09ta0I5aW5hUEFENkwyRzE4NUFLWUJLQUNLZ0FBQWdCeEFBSUFCZ3pZQ3ZObzhlV0VHS1IzbkVEaE1VZGp4d1lRUVJpRGZpQUFJbEdITkhDRjVoQ3NUYm52RjlFa1RlQURCZndwZ2pFZXlEakR0ZU1iUUdWNEZFbktyc1FEaVppRUJ6bUpFVDRTUVRzNUt1a3JlaXoweE1vVlRPYlEwMW9nbWpqc2txYjJLdnhtaG0waUNtOEJOWDJoelM4c1MxT21Bd3A0VzVwZ0Rjb2JWUjFqazVHSWNwSVJGTmNCSXU4VlFXV29UTlFKUGlKQ0Q2Nkp3RXI0WitKNEJrQjBRZEhBTjREUzhBYXljM3c0a0ZITnZPak5lY3hGU0dia0t3dDhpSUlNWnJEYklUSjVYWUhDY0FNM1NDZkRHQnM2YUhBTzhJNEZNV2dVcGRCVzVocXlvV0J3SDBxQmtVQWdHN2kwMkdDRGlJeEF0ZmdFUHVERGs3Z2xZQXRTcTBFSU44RFp2d0ZvQmlwRWlGZ1pyWVFwVzQ5bmppQUNmbG9SQUJnQUJDQUF6MGtoTmp3SXJwT0lwdmdqYUN2MlhnNHczaUZLVDRROG9MbVowQ20zcUxKaVI2MTJmMzhNOERyQ2dqZUFrQUFCVDVpQUNCakFRTHNKL21iekhia21ZV1NZTm9JSkd3ZmRtQVdXT2tlTkFBTFZuQmdzQUtEb2VyQUZUZUFURU1SdWJZM2V3K2R4OGE4RlkwQ0dFTWtBU1pTeFVnaGJZU2FKTjVWaGhJRWlzOHdMSU9NdE1DSDBWK1B6aGdndHNzVDlBdit5TjRTVUxFUTdINExJSnhlbHdLUnUwcGFMTmtFS21vWVpNVG9FU1EyZDBzaW5CTFJlcE5XSkdXcHlJbmJvM2s1T0J3b3pSa1IyaWdwQktWQXpiZ29yWmVDd0pKSitZcUR5SWZBZ2hDK0t3YlZrQWQ3TTlrSXFaQUFaVGdlTlBqYndSR2g3SW5KWW5CWTRhMGZ1R3dKb1B3Uy9BWGs2RDRMaEhBUW9CU0JQRTlXUUF3Njh5U1EyQWZMSXNFME9JL3hoN1EyZ3JwbFV5Z1NrMk5CYUU0bEJyYVJydUFySlU0QUFBakNnL0Fka2VXZUNBQnRpRElFb0lEU0JVQnlFdkFFb0Y4Q1pDeStNSVFrS0FCaHdJT2lCaEtNWm9TV21FYndRa0FUZ25BY3BnSjBzcGh6eG5BVnlEbkN1cGVqeEFBUVJnSHZGVHZPZ2RrS0w1Z0c4QWREQVFoRUNKdzNCRUt3d1B3c0xJQVNtb0lCRlNKRFpLS0UrVm9FQUlNSmdpSUlRNFM3RzhlRUhSbXVJSnlsbkdPUVFWRVRSOGl3a1NBaEFBTU1jTWFkZU5yMzNzRmJCeG12OEJNUndmVUVoakhqQXdFMkd3Y3BQM0s4SmhBZzJkTWFZSksrQmxzWnNpM1pLcGpOVUV2aXBja1U3MjBiRkkwaG1HWVh3UUdSeGhVbTVKVWo3SEVzYlYrQ3Z0SjRMbE9hRlA2RGhvbVpRbVhBcTJiWmd5bkZVdm5CR09VOENnUXNsY0RPNUYraE5hSzREWGp4Vk1Da2pTVEVFWVBTQ3A5NFZIZGhEa0YyTVYwUHNHTmprT21jNG5nTWlNZ3dBc2VpS3dBQ3RRSkhTU1FETU1jR3lCTFdCTkxRVGk5c0JKRlRuQTczbUcxSWVBeFUraDBFcTVVazN6RkIrWVVJN29QYThLZVVBRTZlT3dSTlNmQWNKNVRVVCtCOEJqaVdHcDVscUtaTUM1Nk1jUjhTS0JUMURTdjRDWk1DQm1JSmlZQUJZa1BYZ0xLTmNOOEVjRG9KM0ZFMGtqMWxpYndWZ2t1UUVFZ3VDR3Y3amdUeC9GRUFRZ2FZWUFRQkJJQW9JUUF4QlFNYUFBTW9BZldEa01nUnlMd1JIQUR0L25haDFWSkFBb1VBQUl2S2hoYVJnVStDcHh5bWlBZk1CQW9KVjFoaGdneE9GaVBJaGpLQUYvSnRxV2hTRUVab1RmZ05DdmdFZmZpbVlBZEE4T096VVJrcUlTUWJrWlU4Q2U0V1pvUUhYMDBTRzRERnlQaklsQnVzY1lCS3JmWnBLeG81dXlBUWl4MGloa3FnMlNMcnNkYzZLVkNLYVFodnZBbldDMGhlWG1zV1FSTjZodElZbU54TERMVElTQVVlbmpSNzR5U0l2eEdjQUZGWUpvd29CcGdtM3NRVnNIY25XUmgwczZVbTJnSnNDWGhqeERBSVdoY3hmQjdlQmcySEJlQzBPVUpTTkdCRG5hRDVlZ3c3MUNBU0dLb2NRSGh4UVpEYTJBNTBHbjJCZVE1MHdHUkMzR0FTRXRnZ2ZnSUlBVlFHN2VBTGdJbzJRVTRNd0FFaDg0K0NBSUN5Z0dJS0VyNGVZd1VBVmZvV0NPRWlTcjBKRkNuRGtuMWFFYnM4U0IxYkFIR0FuUUdTaURnaWtBamFKT3Z5L2pJQ3dBVUhZMEZRREl5Q0pnQUlBQVJRUUFnQVk2WWRFUnFaQWhDRVVnWFJrU0JrQTJqNTFRRUlBQUNoQUFJSWdRY1hDRWhQUHhnRm9ZTWc1Zk1TZ1drRTRMZ0drM2hRK01TVDhFT0NTRUpCamxiVEZ4SndWaDRBdTA3bkl4a3NJSmxvc05Ld0YzUXR4QXh2Uk5VNGZZb3F2dVNyTlVPU1JLSmNrWExkSG9PQWtleHNrN1lzR25NelJHUXZ5T1VVSnlvRGoraHBzV1JiN21RMFlBZFY1aDNKcEI0Vkhwb0dmbEg4Q2hnbzU0akg0WUNKelpxYkNiMlliRDRSaDdlSmlKNURsaFpKaENxZmhBT1J6ZEJaTW10L2NTMjg4SWp0RzNBQzZCQUlLU0RwdVBYa0RzTUVVRTRyREdBanNIMlF3Y1JFL1g3bUFTT2t0ZnpCbUZoREVVSEpXZ1F3MWNBQUFobE9BYmhKSkFQRmtRMmRDa1RZZ0tERXJDNmNnVTF4OENnUUFCc090RUdzSUhnUURDWVZlQWtJZ0VSQUtlVGpLSjJtT2RwVU1VdUd0RWIxcjdIbHhxZ1VPUW81MG5DOWlSMFo3SUI2eldrSDlIb1B0NUNBQWRBRUE2QXo1bkIwUVBBOEVERXhRR2dha2dBNFVUNENnZ0FHd2FuOEVZRWdTT05NRUJob1FCQUM3ek1VQkVrNEtvSGdtRFF2S2dsb0lmd0hBQ0lMRVl3MGZmS0JEODBtY0g2Q0dHRklaRUFnakhndEE4bUFuQ0o0N0FsZ0dVU2U2aWFqb2FGRHVTREpaUEpJMGpMYkc1UVpNTkRZUk56SkZpcWRtd2FzRTNvbEVOWkJVa2NpOUJxM3lJRTlSUjBnUmhDSUhCNEFEZ21CQnRXU1NCVEtCQ0g3THdqUDJKV0Fuc1E3cndKeHRtUkdLMDhRa3pzbUVBcUNhSm8zcGRKSHlqSEVoU0NNdHZNaElTUUxBaExnQWJwamVvd0o4NklkMitSemNCbUxCWmd5VEx0UnZJSkIzbk1QZ0VwRGFBZWtDK0F1NW5vUjRCU1J3Y0hQUVhpbmhsUUc0QUFEUU8wSzk1QXhDSVRnSVUvdk1IcHNMd0tBVWhkUmdTcjRiUlFBVloyczczMFFpL1RGcHJVR3REczZMUkRGaE1ZSmtQOXVOS0VtdjhBMGdwZUtCUUNCTi9WUGtBS0dBREJRbUJwQWtPQUE0V1lYMEFJam0xOGlnWWdsbmFpQm9CR2I5bGxUMllWWkJUbEFCUHdpWUFuRmtWRWhKOFlFTW1Kd2dwamdBNHhhRUpFVjc4MENDUVE3d2x5RmdUeUlGRmdLYVc4VCt3U1JJVnhlV3B0NDRieC9PWnBTakFEaXBmUWtuQ0lUN0ZFbEJ3YkNKWEpGekpIYWhZSEVoellkcFlXT1ZvU25MTmlwdHRrTFkwTG9JVkJMaE5XVjB5QmdBaDBCTUxZYm5Ba0hEaVNrUkZQd2NBREpKTEVGcEMweU93eUx2T29VaDVNQnBFaUdnalNHdFpTVWpzaEVHNDBhTlFyNUd5Z293VWt3SUlqcTlEZWdRM0dCUUhDNkQ3WUlzb05JZ05TVEJLaENySU16Q1VxbFRiSWdvSEVBK0JDa3Z4TXZBckNJT2dMYWdzQVYrYnl3aEhBQlNBT2tWR0p1RlNHSW9HcUhjaUZ1UmkrRGdjT0FBZUdOazRCeUVoMFUyS3dTSnd4b2lWQk1tMEd3WFVta1NHSDZNVVNTR0RMOHhjQUJxaEN6eUFaQUNoLyt6NFZFQmpCZ1RPWUZBSlNnQllBOTRabHFaR0lCcWZJQkFDQURkb0dnY0ducTFyNWtCaFFoMm13T0srWWdvQmdnQ0tsbEdUbWtRa0NISVRWYkNwaStBcVR4SnhGV0MxRFNzSlppdCtCQ2JZSkNKUWpuaHRRYkZmQk5md0JoZ0ZnMnZDQ0FSazdJZzVUb3BpMjRSSlV5dG4zR2dJcWtYOUJ3blN3Q1NZbUhGK2hObDNKQ1VzVm13ejhDQXJtUW1BYUdDQ2o4UlNpMEl5MndLQytDRVp4Z0JNUE5LSmdUUEloWkpyeW1vMUZKb1phVDBra0t0a0dyV0JpYXZraVRyWVl4NE1ZVVlnZ2tnSFdiSlNGQkpiZ2VqQXNTRFJZSUpUamtHQ1FKWlZsOEJUYWFjc0VBRUFWb0FXc3lyZ0FqU1dBRTJvU0RaZ0JnK0F6bVBwRzhLSENGQUp3TmtmRkRjYUdoUVEvTk02T1JtajUxZ0JZd0J2Q0JOYlZ3TUdKMG1RZ2trdm9hZ09WMFNiSEliWlg0YWs1UktyUkNWSS90S0c4SkpmYzVBeU9ETm9SMUVlQXpBZWxRSmNBQUp3a0U5TEFGNUFOWS9BNHhJU2pEaWhBQTdIbERNRWtpeXloeU1vby9HQUNKQU1Bd05ERVFRQmg2dndsOUw0MG1nZ0RJZ2dUSm53QVFpdzhVZEEyVlRFSTVFSEpRSm40d3pheHlSWUhZcE5PZmtsNkRRQUlSaFc1Ry94S0REcHRoNDE3eThRUEVmNXprS082WXhzdG9VTFcwU3VTRmlRUTU1RTZadWZSUmtJMEZ1alNoTkttV3ZRY0ZsbXNBMUJaSFJBa2NBY2w1QUdkZ0tVT0VSR0NUSmdxSHpqRWdZQUdJTkh3TldOeUlvNXdTUUlXTEkxRWZoQ21zQ2JnamRpQndMNHlFa3hqanlDZW54a0E3VUNuK3dBckFJaTBZWmFVWkFRUmhNZ2FRS2FHRitIVVpZS0NrdXlBQkFnMEVJQ0lUd0FYZ3lRRnlnYm9NNGx0azQ5OFRMSktveE9OYVFrMjloNFgrQWV1M3ZEcHNrdVJjaHBnalgrOGtFQnNONFRuWnRoWEw4d3BTbFFmWnZ4dUdHMUhMaS9JRHlFaWNJbDRTZG1CU2dKSlcrRVd6R1lVSUxzWlFjcitnUE8xeFB3UUNBQUFLb2RVMTJBNzBFZ21vNTlrL3dDQUFZYUNnQUJaQXNFaWI4UWh6c1loUWR0RTBFRk1ma1VqWnZoQ1NCQVlnTUFPQVlpSm9lRkFnY0N2Z0NIVURCS0FoYjRJSkw0QVJrd3hwd0NOWWZsekFuQVc2Y0ZvRjErUS9nUW9pT01NeGpnRU9GVU1ZZGd3Qm9pOXNCV0ZvdUhNV1NUNFZxdVRmSlF2S0ZpMHdERTRVeU5JNVJ6YUd0eWV4TmxxWElselF5b0doMGhtdENKVGFrZ3ZzVGEyZEFrMDR3R2xJbmVKaXNKVTZIR0FKNkVRRFY1QndBRXFFaFJSd0hBcUZhY3lJNGRGcnNjRVJBVzRMd1NIZ1JMOENZNER6MktCR3BETzJTYkhnUytYWHJETUNEWUJCRGcxZ1dFamRhOU1LQjFhM0RlQXV3RkNCS0lyQndiQXUwcGhOQ2VnZXF3ZEtCTmlBU2g2TVFzTTRBSnRNaVVRZTNCd2tqRDFhQktKT0lGcFFMSkJIYkR5MlhKWXlraVJuSXBKeXVSQW1kZ3JudDJRUk9WQ0FsVUd2R2FHSTN3Zzd0TWdpTExOUmpwcXA4OE1oSHY4WUw3R2x2UktNNzdvS05rdElSUWlDRkM3VnlNcWlLbFNRbHBtVjlzUGUreVlFcEN5SUZZbitOUWl4TEFCaEFTQUtlZW5OaWFmYlJQbndDQmlBQ0FFQmpSQWFoZ3lEWFdDN2ZyaUxsV2NGdVpxTkNZQzc0eklESU5RcURCTUNHZ0NVNm1IRXdrSXovTTRZVTRJRUo1aGhBRURjVUJTQXNBc0FJQ0FYQ0VaZ0FVRWtOS1FzZzNxT1dZSTFEQUdnWWlKbWs3Q0ZaSVVZeDFBUjdjTzQzWHNJU1ljaFQ0QUN2Y0dsVzJaQmFqbEJpc0IxYUUwcUNCdlF1UnNuc21kbjlCMW9iTDhFdVF3RTBmMk1PZ0ljQUJZaTBDUURkSTQ4N2d1SFFCcmdaTGVJS2xCTVlHS0NmbGhnYWRoS0J4bFJ6NER5eHpqQlFnNXBUNGhCWU43T0hESUpBejRPYzhUdWNYd25ZSUJxT0VvbThSeW1XTG1DQkJORGd4Rk1DRUNWZ0lBblg0RSs4QUEwcVNBMHdGcmMrMlFBQjlZSUFNbDRBQWR4YldRMEJWcVMzeFVXZ2xvT29pU2JJRk54N0NsU2xYb0xjSXFrWFJtaU1aMXpmMUZWTkVoa29UcEVJdDdrZ3VPSmUydTlpNUl6NjJrdXcycnFUT2FuYnNjdENSd0VSMFI4TnVMUlJCd0lVQ2VvZWo3SWw5QmRSM0NxMzVQZ0gwQXBBRUFwdXlVWWsrQ2FtL2lnMElRSkFKQWFRa0JZQlBYS2lKREtHU2NDd0lFeUVqVHdUQWJjQmlOZElRYWRmZ29TaHUxMXJ5d2pnUVVIQXZ3WXhndzN2OEFoNEpBd3dCSmtyZ0ljeUVHeU04Uk9nZjhNSVFIWVlJNlljMWtCSnIvQUJZSUd3WUd3UllLdmhZd0VPSmhFSStCSWdZaGM0SWtBMmdTMnM5cDR3VFprd3NsaXc4NEVQQ3dFUUxFaVpPeDRDSnBJZ3lWUWdveWNDSUxaaFJHVGZBcVpwUzEzNEFFQWxRRWJBZ0pLSnQ1Z0dTZzRJc01TU1FuRXBzaG9ZYWI0aTNHbW0xa2pLS3JHOFFGUnJvV2pkd1EwTDB2SFRrTjdHS3RVYVFaWVovTm9kNUFBTUNpdGpCQjRJYVN5QkJYSVBMV1FBSUxCY3dMYnNVd00vd0grS1l3S0JwWUlOd29OekQ2UVBlaHI2QzlzR2tQQVJQbGtnamdLeFNpUmcxQ3lUMFNSSWR3NmVRdlBKTFBzWWRTWjlleUVJVzRyMFNwTHdBb3N0RTFVSVk0ZEY3aHNGWTczSGxsUmJzYkVLZ1Y4RVNIQTRJWFV4WXR5MHd0QmxzVG1xNEVRVWp3bWtCVURCbWp2NUhmUldFV1gyVW1LbFJ2WFdBQ3Q4d2VBbEFNQTQwNmREb2NTQmFqUnMwQ0RleUc3Z0VnWTdNaDcvRHdvUVBxaklCM29JdnVITzVYd2xoQ0F3UkRBdzZ4UGpBQ3F2aDBvd0NxQXdDak1UbjJZL2dNK0N4RUhtRWpJUWdvb0FKeUNML2dYQUFBZ3FyQWg0SUlRa1laWDFZaG9CK0dJYVJiZUJ6c1VhMTRoeWpNV1VUTUIyNTRvQUNDVUpObStCN2hvcFlrcVFKWXZaMEppS0lZVkRXSkNrUHN5WnNTb3cwVytBU0dtSUdVRUNBTWYyUTViZUlUVHNSb2RRN0pHNThTUTRQQkplN0RRZVFUZUNJa1NoU3ppbVRYTVkyQWVqblpKOGlOQW9FNGdCc0d0UEhFS1RsSmtmMmhQRnYvQUttU1VSWUVpU3VFTFkyRWpDTUNhRzhoU1RnaVlGUklhNVNaVWdqSUlRL0pZWmtnd1VZU2RBOWd3YVExQkpWUHNPYlgwS1ZDTHp5V056bTd4TklraVdnZ3R2bjNHWEI5QlI2TlVuejBGdEovakNYVTVhUFo0QmM0UnA3VU9TTEtCVzJ0TDFBMmNxdUI4eDd4b040QW1ZMkZuUkFiTnlxL3ZBbjR4alJXN0t5c2Zpb0FLUUFZU0ZBTGdwUUlBbDJDYitSVzdDQVlOWWZsQUNBekFqN093aExmZ1NkdUM3VFFsQ2YyZkdBSUNDVFJVTTBCbFFLQlhuUW9VdHdUNEk3QzR6d21iaVkwdzZud0l3Q0FLUGdDaVBsQUFhSUxaWkZBSGdnb3BNVUFkVURoZGxBb0w4SkFDRW5BeFdBU3NZUWdBamtob0U0dE9oT25NMEllaE5NUU1DVXV3MGIyY1JDTHNwSHNzN0EyQTNZYXBhOEJJb05CcWRXQ0JKUWhZTVduTjlDZUZaemhrNUo4Z2JOaXNxWGs4bVE4aDFDU0VFeG5oRnlZVURPQWhaNmhIZzdlUGdCVkpTUm1WSE1DTmhaT2pKdWlWUnhaRXk0SVBkZmdndXc3ekFqN0FKMFRmeHdtSy9vSktoYlhFQWhnQ0lid2dUOFNDR3lSZCtJUVVHREIxZ2JrWmdDUlBBTGVTR2tkeHVTRXp6WkNudGFBdVFDZzFJMkhMVEhCMDFBaXRSQkVQMFBvVTFKVGxJWmNHNjBFRjE5Mld5YkRNaXJZZ1Mvb1NWUW1vWEo3TS8yaHQ1dHNqeHY4Q3FjOEV3NnhXMGFQUkJrM1EveU1DVEpJOUhyRDQ4ZkxiS0lGSkFuUHcxSElnZ1VrWUNORHBjYnFBb3prTjNvOXYvUTRYalZhUUJ1My9RZkl2L2VBUzBpVWZJd2dJQVVHUWlRRUlNTlB1SENTQWV5OEdmVUlNblNuZ2xzQlY4SW93T01FQUFnUUVWL2dVQVBVU2lnL2dvSUFBQy9pQUpaTWVHelZEWGtIQ0NRa2JPM2tnalFGSWpBc0E1QTFNRU1uVUNEU0hLbzBGdmlSak9SdE1JbytDR25zUUFSS1FyRVdDaTJjS2prQjlObEhPTXpaRzJ3clNhbEdubGVFbFpsVHhER212Z3d3cEJRSkIzNERFQUZVdkZxcEJNVWlTSUVzaHZKQVRhZjBvSTVvTjcrekYyR2swYUZmWW1ra0RZNWgvd0Jqei9CUkZwWDdENFRoUStrZTB4N3YzTzBqYmlCRkdTS2xPRm14NzBIK0xkd0NFV0Z3T2dPZ0lVN2VPS1NUWUZHQmdJSWVBaEJSYjhJS2RnZ0ZBdUJoMzFMOE1TMDRKTW95Y01GcUFuVlN4d2VLTXBld2ZkNFdKVXM1Q0ZiQk1KQ2JRTzZxQy9ORVhxT2lJNUp0WVZWenlrUU5VU0dDZGh2QWdWM2F4MjVDZ3Q4NnNnNlpaQTJOeFRTbXZMZ0tVb01rRGdXZndBOFQ2Q0pwRWgwWWdEMmlBQ2l6cE1nTnZmSlQ1SDZPbjgxU0FlUUVDQ01EMEZBQlJnR0FBVEl0R3hZUmdvQm9JVzhnTUJEQTdWQ05rZ21DbERZMCtNQUJRL2srUmtJU0FOZktBRzBSS3Nod2h6SVpmbEFDTEM4Q3JFR0kwa0Y3RVhIOWd2a0xXME1JMjBqRWNGc2hjVGd1eEFSUElTUlBFZ2lBUXV6bU1DQmdiSU53RllrbndlTVJLeUI1bnpKeVlpWVV3aTVBUjhLQW1NREFib3V3bG9jWmYvR2l0Qk9pWDdaWGt5T2R5RnY2Y2pjSTB5dHZzT2orU1c1endhSERicjNna1JVY3NMMGlDTWUwa1NmcUNxMmdteitoQ2hONFFOZERWcmNDRjk5aTlqMCtjbkNzb2xJNFdDVzJOeXVZSmJCSTJ6Z0pDY3FFNUFTN1BKeEdmWEpUWlloQk5CdUU5c2dsV1doSkltMHREaWlxY2laUlNqS05YeUNMNlI3NURFNGliZnhTTmtwNStjeHlKaUN1UitvbzZnU05uWEJBb3ZaeGp6b2hLRzlOTXNhMFgyZFUramc0RTRCU1Z3NkYzejg2eEp3QjdRQXBiQUpBTVJFTUFIOEdoOHZwb2VzQlF5VzlMQXVPVUh6RWlCNlVDZ0VHSUNDaGhpNEFyVHZ3U1MyQTltUllvSFFFbjU1ekFsaEFBQWdqRWorR0tha0FHRzNtQUVHbU1pY2hBc3FXYmF4UFJtRWZIVWVEbytFVVdhZ0VqbzZ3b2pFc0p3QVJ3TlRCcEhBYVFsZ1NLamNDRHNXeGdGdmd1TmdONG0xOENEZzRmblJqSk4rQUxvN2hFK1lBZ2tra1NoQy9sQUNTREJDcHBJQnR2M0RwSlM2WENwSFJlQlU5QWNZWktvWW5GU0NPVCs0L0RtNE1Fc3Q5SUt1enJBWk4reHdTTGVYN0RQVk9CT21rVitPaGliVUJSQ0ZBa0FYQ21EY3pQNlFJMHJXTTczRUJvTE5CcTd6Zi9TdmgrekdDZ2tkeHVFTlFXd2hPM0xHcnhJUkFzczRDbEhSQWRFNm43SWJwT2VJRXUzdENoVmJCa21kK1FVRmp1S09wdjNKV3Rka1NpcWlLTmtub1dtVlFQc2hVK05DT2s1dERNM0liWWMxUTFUcVZaTjhvc3A5aXBYdDg3Y0NlV1NnUEVDRUFJbUFrQ1I4RUJhQzJJK1FIWmMvN1lKQ3pJbnRIempDS0FvZ0lHVVpBZVFRaUlJSUliWHhWTU9tUVJnWkg1UVNkTHhDT01FdklJeUNUMEVQTVVQQnJNUnRoT0JxTXBpRjRBUWhRQ0dBc25Bc2liTXlBRFNza0FDWk12bUVxcUJEUG9Rd2FCNDRFQkdrdHdTekNSc2p5eEFGd2hJZzdKSXhTekNFYkFuQWhRUWhBNm1BVGVERElMVmhCb1g2SkovTnlCQ01rcDFndEx4alRLSnlLeTZma0JoRUJCRXltQnYxOVlNc3ZxRGU0WFJhTmgrSUpuTGJmWW50TkJGS1g1Uy9YUXRRMnFmY1I1VDlCZE1Senlyd002U2dhYVdDM20weEFseFhSekljd0tEYWFuME9VQ1NqYXJBSFRPaE51VXlIWUgxSDJJbTlFbEJoTWpxMGI2L1I2RGxnWmtRQndsNmF3YmI0MVlwZUJxV3gwZzhqMWw1dkNkaHZEak55U2xzbFFVaHpYSm9NenlSa3ZLYlgxWkpRcFVwYlBRREhQRnhJNE5OSTNvbUZhVkNVOHZCd0NhanlJa21UZEJXN3MraXVCckZnOGNUaVpTUFZiR2hIbUlDQUFZaG9NUVZBT1hBclFUU1htMEFUZ0FBd0ZBUWlBVVFUeVlRWVFnQlVBd3BFK1FEQXBnb0FNQWNBUVhZY0ZJdDhydkZ1Q0FZaUpKRDk3Qkh5Q2NTdXhUZ0RFUUVzdHhsaU5TYlhiRWZsV0M5V0NGOHBxR3BqL0FFL01yRW1BWGMyeFN4TUtQd0hvMkFqR3hoOGRBdG1hQlNENGh6M1JUbTJCeUVQaERBUzQxNVVDejhtUnQxK3hPVlFmNVBNVWJld0VqeEpKc1UvREFKdVFkWmlrNWw0QTJDUW1BUnc0QlFNOGc0SUlBb1BRaGdMMmljUjNQTVRRakpJMENianpRQUFnRUJnYXhzbkMvd0NGZ0N4TFp3aW1Jazk3RGFtMEROZHhRcTlNUW1wRVowcEZVZnhCdTJ6aUY4cWRnanArV2tTVEwvUVRRcERaZUU2UHVqbGpXT3hCWi9RaFdRbW5EQm1SdjhrSXFGMGZyT1JOdXg3NFEwbENaUHRqaE9wYmtrNlNjalQ1bVNFYy9SVGtXWU9iY0hSSmtMaldDRnp3YlVPaHNYUVRnRXorQUhhU1hJUklxd1AzOFVUOHVxT2NIUzdFNkUwWjZSaUdKSExhWWlTSEZ1QnRwcG9NTk43SUtOWGJFRUVYM1pQMmVjWStrbDBOaVYreEc0aGtFWDhsVU5zcHFoWlZJRjY0Ry9zbW1qZ2dRWHlCSVlyb0dwQVFJcCtjcEpFL29oT3V3UkNoejRKMC9OZkFzRUN6SkFDV0NBQVFuQkYvaENBb0h4ZVk0Z0NDTzBvRThVRy9qNHdFQVZuaXNVQ0FPNEI0ZVlnSWVJQWNxamdnYk1JTk14bUZDdjJpQ1lRQUNBRStnRmFRT1pjbllmcklFVTRBZThXcDRSSjAwc0RoOENBQmhVRU14V2c5NEV1WUY3UUVMSmFQZ1FKREZkZGlCN1dRQUV1QnA4UUVFd1NUN0dTUnE4ZVRBUTlERmtZSHFSNDVuMFJiRU1UY0hDdjRSUkZFb29VZGlMUlh3RkFGQUFFaVBFMjVoQjhRQkdPTGU1UW9qM0h2QWhLUVhHdEZvRXR0Y0gzWkZvWDJaUEllaU9HQkN3eGt1VTdOa1hVaUhRaTBNREtIL3BHN2N6OUNkQ2lHM0JaTWZvSW5mVUkwemJWc1RTSjBNYkFxVWhvbGE2MTBLNHlEVnVxOElmdUh2Z1l0VSt5NFVjY2h0Yi9XMWhDT3NiWUp1dDhrWGNPelNCazdvUlFhdFlBRTB1a3hQM2FQaG5TRzhFNFcvQWFINEJhd3NHNHRlVHhYc2pZeXEyU3A3ME00VWNoaWVvNmkxcHhRdno4cUVMVGdsdk5DcVpJZ3FkQkRLUnZKazdOZ3JsUkRyaUdGWGduaHhBN25MOGo0U0k0QWNNQUlBWEJJQmdMWElFVm9nOXFPQnNWRGpGQXRadFBrb0hhWFNJZXVFT0JXSFVvSUViYU8yRVZvVmlvaVJpbDhnQ0FzVGdDWElNOEFEYUNvOERjdGVSZUJRQllFdWhOaHliQUx6RWt4Ums1eCtaWkNXTG1zQU9NYy9DUUNLalFEVUVjdkFLTWhBcGxBZ0NhS0JwSXZCQUFBRUE1d253QWlFUjRTSmpBUUNPR1BXRWhNcUR3SkF4V0tQbkFNR0hlQVRnc0lFV1RFUmpENk1pOW1FRUVDRng0RXdZMkcrWUphVUxUK0tCaEFRQUlBekFBbWVNR0RBandnNEJGckp1QzRUU0Y3YmRmZ1NpZHd0QTVEaVVtU2FoRXRJK2hzRERnNUg2SVUwcm9FMHVmOUNCRGRiYjZKTFplemxOYktScitnbVlYNVlBWmMxeVhmeEd4eDJGdWxBdXpOOFJuam5DVWdVR1A2Q21IRzRFNEJmSjBDazNXNEpqemJSa0s5dmJvVWE0V1lqbld1WjJXbHN0dFZ5UUpPUUpBK0JjZ0lqU1RESUl3dkdqSVNoY040WnNpbGhEUy92SUowdERwVkNYa01WSVFleURGU0ZLdllDTGpPeE5sc1E5RC9BQ1JybWxmaEVPaEVsQzRJOWx0NkpxUk9nYjZnNkJZYUhsMExYRklRaUZDOFNvVzB5aTBBaFFSV3dCNGpaY0FKTFlrMk5hd09LSFRCVkR3RVlBRWtBUWY2d1JVUVNuN0JyaDBNL0NkRXAxdE1VQjhUcGdJNjU1Z0t4YUEzb1lWb0F0NDRBQUQvQUF3MmtDUC9BQVFJK0RockJSbXc0ZWJhaHZCNlpIcGtvZjRSa0lpeG9FYUdFZENqNkRHTmhnbkNZSGRrY3VNWGVrRFRBU3JJYmdiWW5lRGpJQ1hsUVl6UnJnSy9nUTFFbS9pVURDZ0FJTENvV0Npb2dGeFF4UWtDUjVncjlQakFDOGdVQlB3WW5BLzRsTm9UR1BlcUdoTWRrMVhnNTE5WVNFakpWdEY0VVgyZWlNamx2K2h2ditSZEFiVzB2cVNqV0NmNkVSeVZNZnNLMGJYWThRMEtFaDJpMHRGVXZZRTJucjdRbUZMN2ZnVHM5Z2lGSUpyZkpYUmNERSt2YWtiRlV6d2ltcytvUVNwd25GTHBEdjZyUHNiZXpTNkc2ZlRJbmgxN1BwL2dzbU5seFBTaWNvWGRhUTJXUHg1aG84UkU2M2pKcXdCc1VUTTN6Z0MyV0pJWW4wUGpYOEVUVWFDeGUyTWNKdUNKNGxweWRnay9xUlhKSklENWJCL1RCbEIyRWxoc083ajlBMkVsRmdBdnpjQWlCNERRQmhnTURnYW5BNjdHcVJwRkljTWhIWVBqdkFnQU9BR0FLNEZwbi9jdzl5NkZkV2lTZmx5TWx2WTZ4TXlzSUQvL0FFOEJEME1ibUExTWdvWHlpYmg4QWc4TElhQzYxYVRGa1B4UEpZckVzUXRCYmdpTUVxY2dDT0x3QUswUmJKNEFCckcyQUl3SFd3VmVBSGJFRStDQWJYZ0ZNNElmWnJ3SEJITGVwZ0ZNM1o1Nkx4VUh3SVFvZ1VBVTRqLzRPQkVBQ0NMQWxBd3hZd2dCYVBBMGU4cDJOWkEyZzBsYStPSXdHM0tqblRGQWdZcVNWaXltK0E5bkZRTlJVeFFuYjlDMmxLT2kwRHNFM2IzYUUwbk5YOTRCT2E5WjVFbkthRktYTGcrakFtS2ZIQkpldlE2WW52RlNRblZUeG9sTzRrSTFqTzZVcVdGN2Evb1RDUEtYWkFqYWV5YklCRTdkekd5Zjc0TmN0eTRmUTd3bHhkODU0ZEVuK1lJTFpMVDVHZVN1V2dYYVhvUUUxRG9tV1NiZG43RGdBdEV5VjRINXB0K2FLeENOUnZBMlVCYUZJSnNlL0U3VVNURktMSFNYQkJGYndPVGJ3TkY3aGphUnFXaVh5TDIySVNoQ05qN1dCV1NVQzk0TEtEMHhQRHVhQUhJK0FrQUFvQVNEaEhlem9MNVlqUk0ydU1iRU5zOVZnQStjTXdMT3h3TERWV3ZFd0FaQUE4a21randQL3dEcEJ3SDlrbGpBY3FKT0NoWUFiZUVCZ1lsTVhCTDREOUdHQkdPZ0NSQ0V2K1kwUEdMV282d0VjTURhSzhCNm5nSUdkQWREQUZTQksrRUFBQUFBMjhBT1BBUXZBWGJJemhFUEpTa1NFSUVrZU4rclpRbHdFajV5RGpBZ0ljQ0loSGFMMWpKSUxjUk5GUHlQU2s3VEtOcWZJQXpRSUJjOUhXRk9Fc1BBaThqblFwK1RSQ1NVZjFGR0RmV0U4WUdIZVNOeSs0NXB0K3hOSzBzSnFHcCt1aHI2SUY5dnowU1hSamIzeUxRaTVRcVFENEN1YmtqWnRzejlpUW5zbHg3S2xjQ0J1SEQ5a0k0a0E1WHlNREt3NXBqY0gxSWxHeHlBNkk3NjZKQXBCSEhBS3lJaGgxQWQreE9nMjBvN1pVSENSK0FTdlZUSFR1RHNyM0FyVGhxR3RqMklya2xLMFRiVTBCeGZ3KzFuazB6RzR5RzJUTCt3Z1lUZU9YUS9rZHBRbHRFRXdQSmVTZGFPUUlMRkVqN0RVbXJNM2JrbGlQOEFxQVJ3NURQekhTZ0p5aHFyVkkrRUFLb1lJb0FJRlNiMFltUHpnYTdZb0VrcjJPMEtLYUE0U1lBbDdpdDJQMC9BQW9BTm05Vmg1Q1NEZDNvYzlxMWgzTTFwYU9YaUUwZ0FHb3VBVytBaU9nQmFUckNGMElZbXZuRVlnSUFBQUpsZ1NCZ0c5NFFHYVFjZVFBRHN3S0JOeFg1WWNYZzlXTkorTENXaDZETVRna29DWEJKWUlraEtCSDF0b1JQbWFCcHc2QUFnRWdiUlFjQ05RakNRc0oxWSswZFlnMGFpa0lWcWNEYWprUDJLMDIvZ1FBQ3FQSUNCd0dVL0FBQnZBaXlMZktDMnZpdkRrNVJ0bFNVUCtSWkEweWJaS1hnVXQzd0kyN2FnbVZKd0xJNUlCc1lFNHR3Mkpha0xkREdjL2dwWEJOVmJFeTBNU3U0T0xicU9DTjhDZElPOFhGT0tJYnBJN2twRVluMmhxV05BamdOUHBTUVhtT3hhSElmUDdHQWxORjhnYWN1MkZjV3ZLWVYxU0E3a3VleCttTFBZVnAzdnNYT3NGTkNEQmd4ckoxWVN1R241Q2NNbVFid205akdVS3Rqd2ZvUmdXUVJ3eVF6bXo4bDF0SUZHSFJBU2pibDRleDBSOTJld2puYjBLd21Nb0xJbVhLU2prYytuNUpHaEFBR3JKaHhoSVZ0d09rVS9rU3BsK05SRHFBL3ZBSVpCWG5JV21iTGQzYXlIQnlJS0VGckRndlNaa2tNRTgzK0F3T0FORnExL0VBZkFsQU1Ba1JMYW5qQjBueEFBQUFiNUJwWklnRytUQmZpRExuQjJBV0Vtc2FBVWdDMkJuaUlpNGpLZ2dDQmhvODNlVW9ybUpNQTIrQVZNZ0lCd1dtQmhOVmh6L3FqWWhlRS9lRU9FOVFJWGlSZXdTWlRDTVFOQWhBNWEvb2JJZWFqWk5TN1pnQ0dnK0o1QU5tVCtKUmY3WHkzRnJVY3o5Q2tWY1BNbWxZc1dFZ1ExeXJFMVoyaUNhMSt5ZHFDNkpIQitXRUlub2FiTE5TYWJTSlJCQ1lla05TZEhaQ3pVMmIybllJTHRXeGVuYWZmQ2ZJbEUxZWd2NHlsYWZJNHVlNGIwV09TWkpzWUpEdjhBSW5ISVpOMWk3RzFTNDlFSE90OGpiSWx2d2t3Qml6T0xvUngzMlRrdnNtTTNFdWFOTGJBdG8rd053V3NRQitKOVlONEJJWDRaWUc4Q3NHS2FzaEZzd1Y3TmREa1RDSEdrTWhob1F5MklYWTZvRmNjWW1rYUV4TWw4QTUwRG9wL0lSTVNDd29PUWFBRlVEb0tEOVlIbHN1M0dJUm9LTlg0QlRtUnhUZkxrYmtuK1JldzBWWklDdkFwVFhKamtEM0VjQnFMc0ZRY2hvaG9DcE51Uk52TEM4QkM3ZExvZ2pJU2xJWkJ0ZzkrVkJwWkpHWTV3Q3l4czRZRDhUd1FCZ3dsSHF5eEJrQlJFNFFTaFQ1SU1RSWthbGdnRTlFRWkxTUJyaWZRRDNnSjQyU2FFYndIQUFBamRBNENvUUltaGxLUkJKUDd5ZEFCSUxaQ3g5MWlnRUo1Tm1qN3IzZ0xMWC9WaWRxVlpWckRUZElvRkdITUp0QlVxNVJHNi9CZHdWczNxOGtrQW56YjQvREFCb1J2OUJCbDlDaTdaSVE2anRTUVFEamZKd1JkYVByUkV0TmtUY0V0NFhKUmZlSHBvNXJSS0tFRzVpeTA1SVJTVEx0RXJBTERRNmhxYjRJYmFXTjBINUt3RHdMV0hkanNtN2JKQk41UDBXS3ZhNllBM3BwWklvWlFoenBpWTA1QkVFRmJkb3B3UWlTTzdDakpoeFN3OVNrR2h0T2oweWtPQmtyRnJQWmRUQWk4QUlQMjc5K1k0OFRFR1FWSjhMWkc4QVFsUTVvRGNFeWlTbVJQSkZRclpBSWJFUU1yMzRhTkJaazJJQzVYMkhKZFZIWTNsVEhIQ2NiQnNiekNBZ2cwRFdjYkdHTy9NU3dEQ3BLZFpMWWNBS3hZMGlVRWdEWGdndllJQkpzOFFFQ3d4UjRBYVpDWGl4R0lDVFF4Uk04akNDQUVqUjRtRVRBNEUrS0Z5N0RFSUFuOFU5Z2NpUllDOEFkSHpKRWdmQ0l2ay93QWhnRUNUQ2I3MDRtUW04d0lPbUNVQkFrVUNhRDNRUFJYYUNZUUgyZkJHVUNBRkpFekFVQ3Z3QmdzQU1Bc2hSZlkvYTJZRXA1YU9vOWxCWXFGRXlrSWVORklZUWwxcXlCa3NKL2hObEFCcXlJZFFqU1BiNFZIY3lOVXhFQU5TdGpqVTR6cjBlMmozZ1E0dGdDemNJWlplNGFnZ2dHcUVLT2lWWUU2aEc1RUl6RjZDcW5neU5PbXlqVlBZNEx4MEJycmZCN0ZxWlNqOUVuL0dYUExUOUVtMTl1eE11ZHRsODlrc1dDbXNpRk5LUUVhNlAxaFNsMEM0Q1Y3azZlb0MxaTVqT3V5WHNoQ25pVUpuczBFMk5BckY3RnEvUUxaWUpaNWFLbUFsUTBqRFpNcURMWUJXSGE1SitnVnlJQ3NqR3RET1VsQ05tY2NTZU94eWdFdTNnZmNpM3N2MWhKbzJ5bXpxVmtnYVRKTXo2R0xMR2JmSTJOalkzV1ViNlZmZUVlNE1tM2gzTFpnbmxnWEs3TDI4Y2ZPQ1ZZUUNTb2RjbUZZTUUrSUFBZjhBZE9aa0FKVU1Yd0EyZ0U4c29BU2RBSENIb0VMK0FpUmdSZWhGQTZENWg1Z2tLQmNxZlFaQitBSk04QTRRakpSZWFLd25rRVlBZ29MRjRBNWhYd2dhSEFBSTBNSWNTWmp6WWd2NFFZQVJvTmhndHA4YmZFTGw0TjlHQkFNZ003aGd4L2wyQUpVL3lVbUZTMzArUkhJZTd3UVlJRGhPREpOWktoOVNvVC9UaVgvYmdhL0YwSTFUNmhNMDV3NXNHMzhBU3FSUGlJZ0c3ZjBXanp5T2QxOURUMEpxSlh2Z2FwcUpISjIyd3hvbTA2aTlyUTVwVG9yVnErdUNpQkxpS0hFS0lUTHJ0bk9QaGJFb2ZRYUpEZnBEZzI1T0NzOW85Q1RzSW51bC9jNlB5UlpkREVkL1kxcTZCU1Y0STFvRnJxY29sdWMvc2c4MHJDVWNNYVY0QkZBU1ZMVWFFZEFlaHZKQVJac3NMRlJwK2hOUkRKcEZUeVF6eEdWZzhWcVozRnpFM01jRVhlQmU4WXQwTGNNSmM4Q2s1Qkl5amVJRDRQZ2ZDWTBBUXJ2S2FNeENROEFNRUoxUkJqMDBVUVE4bitDUkpmc0lrVHdBVGpGRDQ4UUNGZ2FuMEo0SkpKRm9BVjZLWE5uc3lUd0NiMkZweStBVUloa0o4UVFRZC9vQTYxZndEUVVBZ29DMEFnQ2pONExaZWdxdmZtM1Fla0pZT0dtSERSQ1lMNXVIQjRFYnhxajBGOER2aFRBSm1ERHlaUVBZQnI1YUlnRk9BSWdIcGdLaFVFRTVNQ2dxa092YkZtQUVIZ01NSm9LbGdOUStuLzJnbXMrY3dGbEt0K3p4WFFRUUlpVVJMSkVMUHF3ekhZZ2czd0hNeXNFSmFhM3dHYktCbUdzQTRzQ09WaUJ1YUl6Q2JnSmQvd0FDU0Y3eFNDVjBTTjJjRFRNZkNCNzNsZmw1Skk4WFNHaTVGU2FKSjQyUnpoeTBoMG5jOTVkU3hTZFNFdjdEb0hJSmJ6UDJUSTUxd0l0Zm9hMW1YL2pBeXNiSG9hcm0zdGRDbk11R3Y3TExvZXdyOGNpR0xYaGkxUE02WXlVT01BSGx2VlE2dHowQzJON0Z5TnFwU0hpRVoySHNIVGtHZjFHR1NBeURVL1FTbE51bjZHNys3RUhTZVJjR0pGbVczMEovOFZHd1BvRllhaEpVTzNDdlNnU25uU3dFb1RzdWE3d0xDaXhiY0laT1BNRnNoQmhYR0hmc1prWWhGQzJUNUpBRWhnV1lKekdBUitKd3JhR1dKeEVtbVNOMU9Ha0M3K1VCT0NmQVNQRitJRDE1TUEwUjQwbzlnWVlFa295STRJZ0hXWFJrSE5nU2t3aU9sZVNCUTRlUmdFVWdKUUNGUHhBRUZnTUNpNDBFZndFQ0FDTHBpc0Q0Q0pBMEFEaEljWlJ1RGtTQ2lDd2tGdVBDQ1FIbWdzNEtGQUxIZFBBTUlDTXM0TWZlUmtTYnk4UUFvZ0hGQk8wVWdpUHJ4Q3lET3JiQm5LdmQ1TVlIa0VnZ2d6bEVBQThTaGd6UUdVK1hpQU9BSXdKRTFNNE5yL0EwZ3QwL1VVSFRNb2dtVzkwU1JpK2Y0SUw4QUh0eU9NeUJLWExZUmZUTm5jak14TjJ5TkF1ckhsSE42UWhMMmpmUnBZTGZBby9QWXFnbm00YmRSME1wRFQ0ZFd4clVOMkhaUStlZTU3Qi9qa1FOREJTVzFSQ1VUS05udGYwTm5jQXArWHMwT3ZjOGlwenhETmhnS3RHZjdiRVZ1YXZSdWkvcU5BVlp0NkFoWmM2TTVXbXZScVNQTGtiOEo5RFVpNUNJVXRyZklsNlZoajV1Q05CbHdIRnFaazVxUkZxQ3JVU1M0dGlidGpsSnNPUlFNK0V3b0NYeUFMV0UzT0JYaGhEZkVnQWxQckE0TkRqeWdTU0lkY0xvV29ab0o4cWpSUnlPWHlnQUdUNERKbU05MGlqSnA0UVVBckJxNEVQS3pETURlRkVMOEFLanlQQjdoejV5NFNBTmdpUVlLQkFJQm9BRURXM21jSzFzVUJwTDhnUUxnR1pBY0t5TEFVeHRUNEZDOXhZQ0ZBSW1JTTJSY0lObUFJTEZXNTlCTFlYOEF4WklST254RUJNQUdJdm95QUhPWVpBSnZyUUNJaGliYlhMS0lMRTBCM2lSU3Q2OW9kSFh1bWIyQVpZQ0poTkFxNHR5bndSRUN0MVR6eUpXY0oyRy93RG9pWVZRbGRtN0kvekpnK3VodEg4Z0JrUEtURVh4emJGclF6bTdYOXZHa1p0d2tUUWUwSVFvMk9OUFkwZmFIT3BCSlVJUlpjTmNkRHN6TTd2Z2p2TWRYeGh4MmZWcGRFQnlsWWNzcWZZblVkSitnNUVuYVFrMlNUejB1UmhKUTF3V0s3T0lWNk5rN0hvMHdLdEdpZXcvVWFBamE0YWdKRU85aXBDUGZRbEZJYThNVEhMbzdYQ1RrSWVjUkdIYVN2T1FsTHBpTUpSZDBWWnhuNjZMOVBoaW00amxuTTFwUGtleU5RNHNpcGt5c2lkQS9odjZoUFdRVE55TzduSWZiQm9wd1FMQitGZ0FCUVlsNFZrRXJ3MlNmWHhBczBBTmtoRGdDSUwzRUF4cHEwTFl3a2tXeENTUkp6NUFiS2NqWlRIQmlQa0FLaU5lS2h3Z1lncURWMWtIL3dDYThXYmc2NzVLa0ZUUmdHZ0M1b3VXQ0lxdjRxUWN3Z0VFQUFVQmxGR0FGd0JHUVRGaEFUUzhJQUlFNEEwREVDZ2R5RDl0SmFIYk45QmZNaVNtV0lPWVpBVUhnTHNXWmtpNkQ0Y1FBallJSjlRQmdPYzMrK3dnT1gzc0loakJRRmpYdWhZU2xpK2dFblFHMWlRQThCRmI2elJoT1JQRDk5TFNKcFdodVhvTHhUSnNJcS8zam9TMnNFU0NqRTU2SWJmUEN1Q29LQUtpRnRpZVBUWW9WVDFvVzNiRlBDcFNTVWRQOGlyQlN5cWEyelZ2WllVQ2F0MGZyK3lFbEkvWVR4ejRqUTY1Q0xJVzkySk5yOUJxZ3B1NDRIZTlCU216Y3JnV3R6WXBSc2ZSSzJKamJTTnk1ZkpVSlp6Nk53NjBPcFIySmVLTVRQbThoTWt0VUtFY2FKLzdPSVRmcENha3YxNEVNbGlIa3JOcXpxTmJXYnNUNlBBcU02d0dxRHFrR3poTm5JdTRENVhvSW9haVE5bCtWSTJoTFNFcGtHUW1GQ2loblVDdHcrQzBzQ3BheUhNTU5rR3ZNSU40eHZBR1ZHc21LVUlCb0NWdkNvOGdEWkVndWdDMGZ5b1NnSm5TaW5rRks3RzhFNGtuSTAzaWZJeDQ4aE1uNlBFMEc1UUNFVnVnRmxFQXE0V20vZ0FYa29FU1FEUUVBRURFbElZQUNBMnloU1Y0Q1lKUjh4RWVBcXlCaWdvWUFNNElJclVBeklLWTlnVjRNYzNKN2VBQUVSaytJa28rL0VBb2V3a25QYjU4c1lXQ2dRRUpRUU9nT3hZRUFnQnlBV0VEMkp0c3JFKzZaQ0FnNG5pQUJDQlc0Q1BibnNLVWhaZ05qdStrZnBDYnY2Q3lJcFQ5Z1RqTy93QUlzcWJ4UUdHQWdTcmNoa0FFQTZaVEIybEJMUTlxb2xzYlNHNHZRaW85amsxcnp5eTNwMk85c1NXeURtcVhzZjNmU0lFcmZKR1pRbkFaNGZxVU5XKzJua2FZTVREV2VseVB6V1lzSHBPWDRhb0VFNGZ1SVNEd3BYL2hKRUFsVHVTME1TSWRlSUpWR3VpS1RQTkJ1emZwN0cxZlFNMGhkcmJET3ZMSTQyTzhIcXJxMGc1K1ArR2ZtUmZBOWJLdUF6b0Y3RnRBWDBCU0Zidm9MWm1pQzJta0pVQk1DRDIzZXFEWGY2UTFESmFQd3VpeGhLM3dqdXRrdEI4cm9wZlFWL1UxL2tQYTVmQUNMdFh5TllXK2ZBaG8xc3hCbVFQQnBsQk9EYy93bEtCZ0JDQitBQWtDR3NUd0RuVEpTZ2crZ2xDR1l0aW1Oc2xDYTVIZ25KTllTeHI4VzhJUnRyeXI4QUVDUnN5UzhiVVFCcUJBQUNyeUlrZVNEWU5FZXlmVS93QUFpR0NVUWdpQkFDVEFBQ0VKV2doN2dxcndZVWlBR1JCUGdndkdGK09nWVlnUGNDUk5nVFhJM2dtdXNscytnTXBBU3B3SVhSNmVZQmUyUWN3OEtNWlYxd3ZNR25vZWdBc0J3Z2YxRnpjRDBCUEFxeGgxUkVmc0NOUkg2QzNsUFF4N0tMNkhxRjNFZ2JPVVBnU2FsRko1M0RsUG1Va0FSd0FvcGMvVkRSaG1wRUlCL3dDQUpYR0pvTllSOFFsaEw0QkE0WWRFd0tsUEhETEI3QWMwTk1BSHUxankzWnZyOGt6Z29uSTRhUW5ZM3QraEh2bU5DSUdnT3B0MG9TUzRGNWtRNEVVUTN2dWZZblJrR3ZwWTl0Q1ExMTArQ0YyTkhaTy92QWEwSDJWaVJmclRFQXI2NENRVjB2cEM5YThDNUJ5dE1SSzdUMlNkZ2pZelVybE9TY1ZKQit0Q0xPT211QjAwRGppRTNyUGFONnZrQ1k4QkZ5TWx1d0xlaHJMY2xwWG9SRW9UU2tYTmYreEhPM1lXNTBQSTBNWGFHZFVhSVp6Qytna05saTdrbXlDREVIRWJRN3dpR2czc2VFRi9nUUNUWDVBQTRKS2hpZEU5UHdndFdNSmp2WVNrNGZNQkVCT2kyQzJDNStTQldBdENDWUFLWkFFQVVjTllYaElUS0M4V0V0QnhLRUFka0ovZjlvbjE0OGUvSmxVckw1OEk2Qk5aT0xNaUZCZmdPRmh2aVFVamxBRXZna1dVR0JoTklsY0Vka0RQemhCQTBBWERqZ2taaEFNaUdndGd5QUF6a0xhSDZWR0JBampDdmFiRURaMzRNemowZVFCL0FBQVVid0FUY2VxaXh2ZkRZVUF5QUh3UE1JUU9aYUZiZUFvS0ZJd0dBTDVKdldFTTdWN2ZBLzFxMHdDQTBsWUkzd3VBRmt3RElMZkJRZW9DSkJ3RHZEUUNhQkFBZGdIZzFzUGdJbndmc1ZYT05DZkRid2t3VlZYd2hBUVdoemd3cXlJWi9xRWFSeUdPVlEzRm9jdDZLR21UcmN4dEdua1NwMElGeURSQlVicXNLSHF0UE56TWp0WHA4ZURibXl5MEgvU0V0eGkzS2hySzlqbWlXam1GZExkQzFRdU9DU1J2bmVoRHRsK3dRNVRYWmFOVzM2UTI5Sng3WkJ3V0dxbDMyT05LS1J2M3hLaGpCYlNLeUxVbzJoUG9icWVEN0IxOGlBYTdva2lpTFNJSlZjeXUrNVp6blk0R25TV3hKdEFUcWhKemJHTDMwVzBEYVVva2VYcXp0MGtPOVZ5STVEMjBOdVJSMHdnZ0ErRHp6QURKWSthU0NQQVlGc204L3dBMmsvTWpvZ1ZnTExJMklUNjZiUUhRR21BeGtDVFJWUVY1K0ZCMUFEdXAxRlFHd1QxQ1hPQWEyam9ISU1XMG5kaGpkK0JGdklIb1l6cGplSWNvZUdnQ20vZ0FwbTMyUGdKRnRnSUhZQkJPQWxua0FBUGJ3QUJzU2c5d3hBcVY1QUJTWW5uZ1JsaS9CQ1paaWY2QUVtTW9ZTzh2d0FDMWw5WVZZWGZEZ0FoVWpzd213RmhUb0xXampodGhSU2VRS2tpV2pHd0ljK1hyQ0NRTVFCSGpBMVA2V3UvQVFRTUR1TUZQQktFWUtQd0NwRElNd2VKaXA4Ykx2ZmhJU2dNQUN5bEdRR2hBMEFUSVlRMTh3UUlBQ2d2WnY2dk5mK1BCZUhTNkVBSWpUbWtHd0R1T3FJRjZDeXBrTmRqaHFORjk2SFpqcHh0NEpUdFpUZlpmcGFrTDBXTVluWmRENjl0RFU3TnBrR3AwK0liTTNWK1JJaHBZUXFlcmJmTElYQThQWXpXcU52Y2hlS0t1QWZ3eGhoTlh0bGtwZi9ZMTF4ajJKYnJKY3FUaFp2eXJRMzJ6WG85ZTNDc3FXL3NSeEo0a1NsZUdONGF6MnNNVTY1RWNpTlY0ZzJMZFFDaFNQS1p5MmxXcVRrNEVyMHpmRkJ3S200SnEzMlJod0U0NEpIRTVrZldiRktUYi9CRnhPMkovc2FUZG1nZ1VwUEJSd0ZQQWxsQkdJSUVFcEdMUnh2NVlZbGlBSW8wQUFRRndFZUVaK0FIVkJWaUlEMURyb0N3cElZQUU2QUhhdm1XYjRocGtBQUFFbk1FUG9LcEdRWDRJR1pCTGdlb2l3WUhZTlA2c1JXWUk2UEd0Wk1HQWJ3ZytBQVFlSEUxUnpaalYyUUZaN1FBMC9BRWdXNXJ3Z1FqTVVlQ3lQSkFCcGhOa0ZtQ0JnRzRKeEp5UUpFTnJJRmk2SXJ5TVpkL0NTbUFDRVdBTGtLc3FzdGZ5VEFQYUsvZkRuL25oQ3daUlFERE41QVlwQVcxOHdvVXZhRnJVZnJEd3NWa1QrTXp6SGFnSHJzRWtJQ2NRTURZRWtIQWFPbjJlVWdFQUFCUDd3aE5LZ21oSFdWRWV4Q0V5ekFRWXRnTWV2TWxBUW1Rdi9BalJLcVFUTlBHOEV2MURHVFRwRU1VaVY5bHZZMnBDcWJ0UW52eUpwdHhUY0V3S2szYjZKRktYN0NSYVczQmdDNDNrTGpUclRNZ3NtUlV1Mkkyb1MyS25lSEVvZG14MjZCMDlsQ2NVMkt6N2JyK0I3UVh0dW9DOXlWN1FZQ2NHL1lTeEduVU9qVXV3Yk1PMHRqVmZpdU94ZXdVdGp6c2JtOE1iNlAzSktkZU1UZ2xXa2pTdUZzaFVpMWhBbFVUbVJCV2kzVFA1UGZTS1VzS0NVMmdpc2JFdnVJcGx5bVgreWJsOENwVzJ6WjBiZWp1RG9MbzR4UytRSndLM0FuQ3cwUmxCSGlKbGlYem42Q1pINEFFbUlDOENDREFiMk9NQXNneEVzQWpPd0Q0RmpBSlFPVEcwQUZtTHNBZE43WU1FN3JBbE1NeFN3ZGhxSWNtUU9zQkltVWdWQmhuZDVCQXZBSVlDNEFIQUVraEpGWktSQ0RyOFlBQk9zcnlvQmRzSmUyY1J0bE5IKzJaSVJWNUpBRnJrTlBoU1B3aFVKU3hNNTJPSHhBQzV5SGhZRXhSWllLUkE4WkFOS2tEbU0rOFpKZUNEV3lFQUN6c0FCQ1ZEWWRTNEhsNEd4SEdBNlFNTWVZeHBBNU80NHdOYyt1WU5aZkZOUUdRdGprVVY1YVQxc0FBRUdUSFI1QUM3UkFTQUV2Y08yNWZESFVCTzd0d3lORUY4Z0VUSGE4SFRLRVpVR213b0RqZ2lFUGlRQVdKQUdBRDgxWEJKWjlEYVNSd0dscy9xTW5CUFE3bkRoaXVCVUZGSmRpZWtuZEQ3SEphbDJ4RkZROEtPUjlrVW8yR0ZUYWJvVTJoTndSYWx3R3lIY3RvQ200MlJBMG90TkJqRzZNQXhlalJzYWpYL0FLYkl0RVU1ZjRHako3L0ZKQUVORndyTkMwN05wdFdhaW1sYWZRdHBZbndFL3dDMlhFaDF1bU5EYXEvUXdsQ1JvdnlPaWFCaXpPa3dKRU5STks4aHExYVlvVTYrYkowTnBhMk5ZamRTTjFIcy90RjBHYWNoNm5nNDRYZEJxRlRiSHFDalQ4RWtIa0JBdzBOWTBESDdDT3hQWXdORGZpQlFLYXlDUGdCNExBQXZ6MklKWkpnNUVsVDdnNUdwYWY1RXN0RjBhR0x1cFVxQ0NSek1HWWhSK2cxY1hLa0M3cWJVQ3N1bER0VUpIQTZSOTh5MHY3RDRuZEJBS0U4QWhvTlpnZzBTQWpZRG5nR2hTd29maEF5SHd6eGJJdkhKRk9JYjJja1VtaG9LZklDQ2xKVXlaUFNSUEdCZ25tSUFHeDRFU0d5REJMd0lCSXZRUkF2Z09NTXJ2aEEwZ01TOEVnQkFFWmdiSG9lTFlIQVJnRWFqYzJqSmdZUmxjU213aHpGTUk4SEFIZ0RJcjM4Q2VNNFViUUdEeTBHQjRnWUFUWm5oSG5FYmYxSmNyMW5rRmttWlIzeU8yaHdPSWpibjdmRHdoVUFnRzJIb0lITThNaGZHQURTUVV3RVlDcVFMTWV4OGZZMW14VENaWmNEVW5VU0xhbkFjbVVqdkp6MU1vRGFUUnRMZGJnUnBxMVRzdlo4S0RkUmttM3lpQ21rNmtabXBTK3hhbTBrR1JUNWdoVXRxYmV4WDRwellReWhVYjJHcVl2TmZvb1VmZnNWMUN0QnFkSFNySjY1Y1gweWNpVUZ0OURhbTNiZks0T1lVc01sVDdCVFNCbDlobkxVV1hMclEzY2tSb3JsQ0k5eFF5SjRNYUtTdjMyTWFVNldoY053NGJhS1JTMGRIRm9hdTJLbWNqS2tiUG9aMnNEaXhCMGtTVEFBbCtEQ21VZkVBczR5V1g1dkFBQUlDSHRBL05NRG42YUozaUZnajBBYWtMKys0RW1lZEZYRXhhazNLcUJtOUhvQ2g3VmhycGZzSWpPWFlFa3NvS0NMczRkbDRRWmtyU1RjSVBIa2FiQjVUUTFWWC9oQklvZU1ZQWtBQWdCZ0lBdUVFQ0F5RUFFcUpZY3ZPUnA3Y01jc3RRK2tqOEJJRWZEbHJpSVQ1WUtZZUFSRU1pc3drNTI1SlZiOGFsZUt1VEd2aU1rSUJEWXZEd0EzalFnSFhZa0NNS2JOOFg0S1BFK2drOGVBSElnaDVCRDVVRWUzeUFZQ0RBWUZOQnFreUJzQ0FLL2duREhLSUFnb2VGcU13amJ1QlgxLzFZZkV5ajJZcWtJaWNDWDJpQWxoQVJGd0prQXJWNjdZQVN3VEdTRkViei9vYjBmQ0VTQkFESkxEbUFGRVFCOWw4VUpBbndnUUFRcThURHBnTUpwSjlNMm1UajJPWTlkbTZmQkp0T1E1VTB0NERYbEZOUWhzalRYS0d4SWFNVE1PMGFydVQxS1doZnI3aEtPVGY5V1JSSlU0aUtGN2JFblZ6U1E1dDlyRHRKTUpka0ZmVkpNU05EcVp2TFpzam0rcHBzVjJlVEJxNTUyMXdOMjduVGFFUXNRYWJtT2pjV0Y2SWxDTlBKS3ZSeXlRZThSS0loMS9ZcFA4QXlRd29tVzdIMWtWRWk0bmdWdVpnSjdRdFBjL1pKSFk0ZVNaME5LcXA4a1lMb1VsRDNuWndrZnhJeVRZQ3gvQ1FBSFlnUlNOZzhJOHdBZzhLKzRvbVJYemN1Q0Rmb2hjRi9zTnkvQkNtdkhBUkVjalQ5d0tBaFBkNVVlaFE1dU9uSTJnMjB0T1F2Tm5FaldnSlNXa0lZMHJiOGpXVDh3bHVlQ3FXRitBZFdCd2JBRjZsTC82dy91T0M0dGdGTHZPSW1pT2hBbW9BeWhHb0VFUUlUYytGQU1XcDE2RC9BTmtKMS8zb3lUcEtXWFMvWUd1RVNKNk1mUVNTUjREOEtCcmQ5Z0FWeXZqOGlpU3AwSm5NbDhvS203NHdKQUFBS1cyS3dGZ0VRQ3JRNVZrYm5HRzJZNkpyM2dlWGlKYXFXc1ppRTRZT1FFc0JCM2Jzc0l3RmZid3V3d0xnRFFMTDA4VVFBa0p6RElLNEtNQVNTeU1IcGdjU1BzTWEzak5naSswTWF3NU1mb1RraXE0bU5BYWRKZ0tTRFFXSnNWNGFBS3EyTjRIZ1FraUU3VDRnSTRBQU9pd0JHZ0I2aUdnS3pDaldDVjV3ZEVJQUFjVVhGN0pjWVRRMndkRFl3RGFKeTdxVEhnT2NUZHNPaytuTjBNV2d1ejBjdFc2K2gwVEhFMFFTcFo2T1cvUTB3d1pDUU9vMTBoQU5pU2NpdFQxS05wSUMwNUlIMFI1S3pyWWZWbTRUZ0pPdTJodG1XNkdtZ3RFZXZCQkF6U2t0YkdKWTUxRmpwU0lOTVNQWWwwVERRbGRqQnovMkNXZC9ReXpsY0loR1orckhXViswVGVJd1NBa3FoVzBrTzdzZHhXaFEySERzL3Z4S1FBcjRnWUF3TEltU0FJRFExWGtBMEpoV1g2WHpCRjhYSWR3QVFBYnhNQk9BRE1GSjBXZ1RZQmtDMzJFaitHTHNSbTMwY1dqRXRoNmhNcEpnQVVNQnVNNC9zRks0b1gvcUQ5REFKYVRnWVVxZjJJY2R2NUQyUkIwZ0p1LzJBdGp0ZkVFZ1JJQit3QTZBQ3FEdUFPeUFCQmlBTEJRNW9rdVBNRG5pTmhTS1FMLy9BQWNsa0VSZC9qZ3dLa3pTazdvSldxcEVLclh0dEVOcEhsMGNjZTNBY2gxL1dDcGFjL3d3anI4dVRCSUEvZmZrZjlWbU53djNpM1lub2tPUEJRM3RGOTNrMVY0R25QSStwTVQ0QnlNUk8xQ3VNY3VGdTRJUUxWZUREQ0lBTXlXMlg3SUY1TlJHZ3lnRkVnQW12cnlHTnd3SWtBRUEzRElOc0RRS24yTU9VZzFWam93b2h6QWRnb21kdjBPYmc0VzBqUFlnOURiN1FaOXJRVkV3d1VORzBBU3dPdVJtQmFHbmdMT094OG0rRFlBR2Y1b3hkSCtJZ0NnUktJeDRBcC9ob0RVZ2dRSTBBR0JsbVJCU0RBSnlkRi91Sk0xT2hKcHV1RG1GT1lHYW55aHkzNXV5VHl4NUNTMk9reVJjOWthL0F0M1JlK29sL0VqRzNvN2xabklPZGlyL0FLQnlEdDNRblBIaWN0QzhMUTFmU1FUUHB4QnlCL2lTdjBKRjR6L3BBNWhDUkpWTzkxN1lhTXN6NVhKRllXL1JLRm1yWHNXMzl1aXRRQWpVL3dCd1BVb1hsSDNuQnlhWm9xUjdoaU9Udlk0ZFNiU0pOSWhoSE0yTlBMb1NwemY0SWptVWRrUEtHV3d5OWFLeU9vU1dRQ0FrQXFWejh4empRRWYweVBoaFBBZVdoQklaRGVrUlV5SEhnR3lBS1FmZWJNZ0dxZW9pUExjVUMrcG8yV2hra3Y3QkpaTDlEa0JDQmpodFFUQy9IaGF4M0lUMTlFWUdCTklIS293dHJ0QzMvVWM5UDFCSTZCSDRKQTlPSUpFcEZDL01zS2ROQlYvandBWEFCZ1dDaWdpUUFEdGpCWllGMGpnQVlBQzhGNlJFZUlSVG5YN0dqVFdmOUFJU0p3VEVocDh5T095OFVlMk5rdFF5RjlBSXIwaUhBazlrWjdQcU5xa21pQ0VkdFY5QTVVaEk2Rm9KL1o2VStqU0JwL3dJSTdCMjhnVWlxQVNBcHp3V2lCYzBCWEpCUVVKWVFMRUNlU0dUYkpsQUd6TEFDb0ZpUnlzY1JjMzRBbmNRaGRjNEYwUWcvVVhoTEgvbXhnTWhRRnNRYkFGd2tKNFIyMU5qdVlCUTl6aWxFeThHQWc2SnBVQnV6VmcyV1Jjc3AvbkdkK2tEczEyZ2gwQlI2d3huUFluc2hTVWJFODRpV1hPTkR1dFJlSHptTmdDZ1FIQ0hWWFVGVU5nQmdnSURXR0VVbERjUEhRZ09qbDdKRVhLSkFkM096WC9PQXVhSjZPanBGaGpFTnAxcmdlTFNMMzZQd05UZi9wTlM2ZGcxRGRiVnNVbGNwb1lwcWRwcVpBMklxQUVwTUlPTVNZbG9IZUJJVU1OUFlJVE9XY041TCtta0V1cGNtL3lKU1p0d2VGWGFndk1EUzljSW9USW8weGlRNU55UXhLdnB5VExVVkJQUWRhMmNvdmN1aTZrYmhRWVdNQnQ4QlhQK0N0MDQ3SWVoNnJCTlR2QU5EVUVGSElVcENUQzRMb0JieWdFZ01DMHFqNUFhaUVGekVFRUNZRnBLRU5PL3dJRGhJQ2lCQ2JCUEtQN2tRRjdUZzhEY05vZ205dWdPMFFiQ1JXVzJ1dnN4VXU5NTBJeGFyMktkUFphRTg1T0FOTGJuMERqT0FoYVMyYTZKenU3MDVPRFJCSCtBQWMwR3ZPUzdFKzNzaXR2ZDk1UUJZQk95b0Q2RUplQTFYNTlBSXBDbVpFUkFIREFJZEFVQTFCd1J3R0VQb1pjUHg0Q1BxRzBRdTNnSkRRblM0VVNmY3RVVDdCRDIwWEZKUU1TeUhGNENmczBra25vV0tWb2tkZ05TbThSQkx5MHpUZWkwK29wUkI3UGFZZElOOHdBQjBzK0VCUGVSUTR1MThDRGl1R0FCQWhSSDVWRXZpRUFDQVNBQkNBZ2Y4aWdReFd1NVVVekFhZmJGb2hiYWlZRDg1TUFKUUtNeWtCZ1F0c3RvSUtheEFNdlljYllFRFNkaFEyOE8xWmpBTFBrazJOd3JINEFnTmRXVTRPVFE5ZmhnWVRzaHBVanFtK0djejlzWUVxdndNODQ5Uit0R2twQU1BRVFOZXlOa0hnZ2toZ0FndHZCakNnWlFlQXczQ25BMm1UakxUT0duemdWZnBpSkkzYlRYSlJtS0dwZlk1WDBOZEZocFc2Q0FhbnFKQlU2VzlsWXNucDlEVElORUZlaHZwRmpROXV5dU5jTWFsQ0p5clRJRkNDR1Mya3VpN3FWQkIrYm9YeUxLVGNnWVkySFNHbU42OERrVmw2L0pBTkVuNlJTdHAyMEYyVWFVTTBvMSt6OEVzYWxyUVJSdkh1Q2R0T1NZb2hUcGtwVWs2UjBhR3RYY0NOYkVtMHV0TVdvS0pvc29WN1paUVFDeWRSSGw2RTJ6a3dOYkF6Y043b1NrNUxrSW41eEJvUEtCQU1WNWF5S1kxbStuTElEbGt0a0lLRFg5QmdwZ29zTko4bDlQUnpKZTBIT0JiSUc3SzNRS2xXNEFoeEQ2S1VZMWhrSTVHa2llVzc0QXNKRVU5MEFmbzk1c2ZkUVVBakQ5akQxL1hSMm9FVXBma0ZhRit4Tis2Rmw1U0hDZ0lLTm9ibUFpaER2NFFEQzRoNHdpZ0hNQlRCQmpndFFLSzlNLys0ckN2WlQrQ2pTUmFvdVNZOFEyVGxGYUEzdTRKT01JSzl3TnBpRzlXa01LMURoVW9sR3hPOWpUOUQ3RTdjRW1nTm1CYWxzWFphUTFFSmM2SU9XbENIdXhKaGhOejFCc3Vhc1BZZW5BNVBtQ013aFVqZ01JY2w0aTN1UXh2UkNIb0NGbTdBRmRBUWFVU1d5N1VPZFN4U0krb3FNQUR0QW5VQjNZUmREQklGMllwQWo3Q0t3ZGhOenduSlFNRWJoWGM0TG0yVVhaME5rUGlHLzNSQlpWS2FNYVdyVHdHaEFiazNlVlFBTDZzZkQ2QTNFWWdpRGMwTG1oQlVMUXMvOEFSRFJNemNGVW9Kb0MwNkhvc29MT1hJRW82VUc4RzNLUlRTRzlXTURkd1FtWjNJYnY1QW9pVUtNQlJBQWdnN2dISUpBRzVDR3NCTGg4Q1ZqREFhREN1RU1DMDF3UUZ5Mkpmb3lVbFQvQTYwRzQraUZCcVhCendES2dLWkhRNDVURzM3RkFnWjBrVWQxQkVzTTJYWlF3cnlEMlVKNk45Z0tRVi9LMFlxTFNwT0dmbmh5T0daOWtUWnVXdU1lcFI5NElOT2pLMkhHMFhPZlFwYkNYTFk2T3BjY2xXNVRFNWxqUktxQnlRcEF0N1lpMWN0a3FwaUt4TktMaE1zb1pRSjZzY2dsTk9DZExzcFRNa1MvZU5nVDRiN0VjVVJKcElnZ2lDZ0VnQnRZbC9GaThESEVFTUpKb0hneDRqeEMrQ0FRbko4QUpkL1VBaWxkZ0QybDBCZUc2Q0dVbjArQ29BVDV1MmRsc2tBNWZ0UG9KQ1pKeU0ycFJHNEEvKzFiRUU2NWFDdU5PSUc3SHNBbXdoRXhQZnRnUU0xbVpYb2R3QUd0UkdnR2prOUNBU2lRY3ZiMnZBRkJrRVFhK1hBQVdSQUd4ZHVBMndGbWdLcDN3aGJJQUlJSWtKREFCREs4Z3dFZENmL0EyS0MwaWM0S3BGY2c3VnVNaStpV2syTjhKTkVxOUkra2RFeEsvUlV4MEt3Z29weUpvcEd3a29kcHlVbFdSRG5hZUdkd0d0Vyt3MHZYNExWU1RHSE1vUnFLT2NpaGhmNDZEQTdJY1Qza3R2TUJKenQwUFhnQzVZWTlIUUJPd1JCS3ZVR0FNQ1l2Q1BnQWdVRHJRQWhQd0FKMmlURXlJSjR3SDJsQjJBa0NtUENKNHMvMGFtbUwxL1F3NEdEU2hnd01nd0hsT1NQQ3lGTnNLazBESDBBOUx3Z0ZJQllBWGs3YUxoSTdDYy9aRXJibHNNWnlVSXBGWGJqd1ZVRjVTcE9Fd2NnUWpORmc5RURuRWJvNkkzSHk1RUFvSUFnRE1FbUQ4REtBQ1VKWEE5dlgyTjMyTU5qejlianJBQUNPK0FmYU5EV2piR2phdDdST3V5SmU1VEpONldLVW5SZHFSOUJMSFVLNG5WbTB4RWUraE9teXFrVUNVc3pqckNVYnBHZVJTMW5BSjIzQVpCdGZUME5LYkJXZVNkWDVsbyt2ekJtVjlnYUpwdWt5b2tUQkRhRERMUWczY2hJUTExYkcwbG9mUEc0T09aZ05HaERUSnphNE5Fa3BMOFJOMXdRMElvRmRRcFEycCtqYjdKN1VOSDJjSDdLSEFUR0M0SG9Hd3l3REptVFdBWjhNQ1FSQWdDaUlZUEF4K0xjWS8zZy9BQ2NNQXRBWXFCcmFTUkNIQUFBTTBMMWdSRUJCcWVJSkswOEFwUjZTRmF1KzJHbC9CYURwa3BQWGVoeU45TXZSekNhNkU4em9sQzREalBvcUFKdFVwVFM5U2NqMnVXUHU1YVRlaEZxN252UkpwMUFqSys1NGYxajdpYjVDUXdnNkFNQUloQWpBOEVBRWZnQ0tIRXd2eGhJa0MyaGFJRHlFQzVBb3hJd2dUUWtGbCs0cUVFZlYwS3J6QXRIMVJDWVRMS0pVY2tzVXY5QjkvMFhCUUVTRXI1U1ErSzBPdHdoelBRNFRra2xGdVI2bXBIUWxrSlZlRXQyMjJJaVRoUGFLM0JibWNhdnFTRkp0QmkyVVI5MmJhN01vUUsvYm4vd0J6Qm5ESVg4QUloejVCYkhLa1N1UUYyQWxOdnJFaFpDQVFMRTJqbEFwcHdMQW1wd0lHY1F2aFM0a3NZQjlCbHFiL0FQQ0E4QTNqU1FneEZaQUFlQ0U4SVdzamcrZyt1d0RzOUpxaGxQc01Ra2RLT1RUTzRnYVN5S0FraFVwd0dUQ2V1ZWh5Z25CNHBvRmtRbm1BN2NIV0VBbmFaQkxPQzMwUEFoN0pMOVlEYkhRaWkzZ0IwSkc1US9VVGhka0lic2EvSkZwa0VnTjR5TmdFQmFlV2ZBS0FNNEFBQ0k0VEttSkdWd3ZWUjNnK3JIZURRbkFPc3cxNElIdEdtYk8wZW9FcEo0QlJzSXBiNEo1UzJOTHlqNE5wcDFMOWtUSUJISWtPZ28wbk51RytTNjBYZnNWeWM2R08ySjNMMGFtdTA2RkVwbTVCYnBpUmpJMkUrRU9kZzgvUlBTNDNyTVd3aXp0UndJbEc0UzVObWVwcGtFRGtsdmdkbXhLWEhJaXJ2UzVScnRtdnJDWmlMMld0Y3dVb1B6SDZFY1V5aTBNam9LemNxdXhCY2ZSSnYyRGliNEtqMGlob3MyekRwQ20vd3lJVGtMaGVBQUF3QlNKQnZBOEx5ZlRnQVU0aWVORUtiZnFRV1JCWENWRHVvRmtQNUNqY2FqUTF6djJFRGdwbllHOGlKOWdpTWRocmovSVFCTFlnVmpkMGdIT294N2owNlFsUTg5QVM3YnBVa1ZraFVPMEZIK3dHNDdnY0J2SklpTVNyb3UrV0JjZHhCTlFCQVlnQ081bnhDRkFBd0FVQitJU3ZoZ0xFQTU4Uk1BUHlha0VOZ0FvZ3lBYmtUVDlsNXNBem5FcE5ocHovQUtLRDdGZllvRzJKRXNDWjhZSnRma21JNXZad0o2SXRQVDJJMlFrUi93QzR4Tnd4VmRzSTFEb1JUc2grOG5aRTI1ZGtFMlMvSmZKMG1VNkcxVSt6V095U29rVnRTb1MvVDFFaTUrRDZPQVV2SU1FWkdzTlFDeFlCQ0dOVVFaQ0NoQ05UZVI4QXFGQUlOQ0FSZ05NR0E1d0RjUWhRQ3hPVUFRSElGTk1CRm9XVUJPOUFwTENNbS9YQm9sT0dWak41WXFaL2dJdXNEWHhJTmdjK0NSZS83RDJONVR3T3N4Q1ZWMm5FaUZRb1JJVEpLbm9aRXlBdHRSUVBhendRRXBHRTJEcFM0V01vRGNXZWNZS0pna3NhYU1LOWlMT242TUdLbjhjWUdBaEFENkJBeXdKakFjb0Job2dWWVA4QTBBRlVIOUZhYU9jWXdyT0FoQk9XR2ZoTkw5Q20wK1JaVFdtc0NZSGFORWNqek9raFVUSWNzK2lTU3JRMXEzbC80RXFkZWFVaHFQMFB0Q1UxNDdUV3gxeVZmYkVqSjNvQnQ3WDZUeWV3aVNqcVFhWWEvd0JXMHVDQXBmU2RETmxhVUtoMW1uSTZpWFFPOXhjYklVMFlHNEQ4V3ZzUlFYYlJxWkt5bGJaRzFzVHBQOWt0R2d2SGdVa2gwUUhxNkdUYnRrM1lvaHRaU1hOSHUyUWJrRm55TEFKb0JlVklCQUFBZVNpTW9Jd3ZHSFh2SmxJQU5BRFNpYXpQN0FwVURLbTRDb0FmTllDZEQrZ0loVUp1dzN3WExRem41dFRJWXFmY1k0K2tRRjMyNGdKZFgzTHdLSytFa2hLRHhCNzlNZ3lJUzZla2h6aWJ1ZERVVUZGcnZFeTFPQkp5K0JrTVFCZ0VJNitSODBSQVBRUkFESVVVQUY0RTlFTWFBZlVBSURBR29FRTh3WFFBUkJpT1FSdFV0c1F0UzNhYUc5b2NXQzdjSFppRm9KQ2xpUHJJSVFrdmtJN0lUYmlsN0xLRE9BT3NHcWlVUnovQ1Z5L0JFbEZ5UVVzSU5yK2dtM2laclIvWm9PT2JmN0hzSWNCeVhyZ1UzZXpZUUtIL0FPU0c2YWZBbXJURithSnNtUWdCQXdBdnlVSi84MmxyWU5ZR3R4WFFDVlFTQlFmTU0vNFFDbkIwTFJLa1A4bGdnbkVJSVhpQVJEVUYyQlhpRW9VOStDZmdIWTNFTmRBNnRIeEJFWmtHOXhDbGxRa2RWN0NCdnlvMEtuSU94VUVRNjNvY3ZTUkowdHJFV2dhRU1pYXhJaHh5OWpFQ3F5TmFzd2VRNzBJeWFEbTk3RGU1SVVCUEdteWduVUJ5NEJrS3phd1ZBcjRNcUFobEFTb0NjVVZBREJERlFIb0syU1pEMjZHMjVkRUxMSkhhSmd4cGxDSmdOd2pTNzRJNDZqbE0xb1pxYWRNak5ta3haNENkVXJUYmFXaHJZVjAyVjIwU2N3ZTNjczVnb21YTFdSRUdiRHBCR2t5ZjBGTWhXbGtad3ZIcDBDS2FRVUxEZ0pJRTZlcDBoenRyY3JUSFNaNy9BSUM2ZE54YmZJMjVzTEN1aFNzRVcralM2RVg5QktyQmlsMXIwUVRrUkp5SVJMOUR6SFJJNjBNMHREb1FqYlNMYVZRblRvYlRodHF4MHVScmFSTFQ0R2tMTUxkbFBnRUIwUndlSUhKcDVQQ2NaWDRGRW5JWEFYRC9BRWdWTDFDQ1NudURhSnFVUFBhUGVKWW51djFFaDNxUTBFTjBRRm41N0lZa1hNV0JFelpZRGtnRFdNQWJkQ3d3VlVBZEVqY0pRRnZYeFVCVUtOc3BJQkZPSktCYTFISVhZUUJmWEVRWDhPeEFxQVFRRElBZWlBeVFJR1lrRWtGRDRKckNZRUFCaksrVUNiQWVvQU40VUFBbG8zNkNBa28xOWkwdklreWZPeDZFVnlUVU4vWWR0Z2JpUTE5czloM3VFUGhOdWsrTU0ybHVScHBwdlRFVEk2eDZScStCWEJxUGNRSHQ2UnR0TVJ2dW15NGhQd2ZScW1nS3VTRTlFNmszeXlEYm9NODRhUThMaGxOQmd0cnIvUkpobmFZMGlrT1JHQ0pXSXI5RVFWWWswQVh2eVhOWGd5SVhRbDhuRGFnRTJJMVVKdEVBNFFKYmlFcG1OUEk2aWowZ1RuRWFmMHlrY3FxV0FKekNiVnRYN0NVSmcwd0tSQ0pSc0lEVXVGZmVkQXNPcUFMZ1d2VGtLM0EvOWloNGtoNlRnZndSYkhnaElYazRrRXZUQjgwVUgwemFrM29kcm9DWnBUSkthNE53c09kc0tnMytBa3dhcVcwL1FnUjlJRXh5RlFvOW0xQ0xPQWhVL0ZOSUdETmdLYURFQ0lPZ0JnU0J1Vmg0YlNIMnhISTVTTnNZMDc4aUlGQ3BBUUk0WkNGZ0hWWG9xNWpsSUhFZzkrNDBKdkFJSmR6eEdoWldra2N5ZWhTY1Rwc2IwcGJrZHZkSm8yam1OdUJvaHZhalRzUmw1cVZKK0pjSjJNM2RyNWtpMmlDYWUvUlE1azRIR3FRMTYxdEhvb1psR1d1VVRPNG5yQXM5QTdvclpGQmloYjEwZXdpdExSOWtDMStlVGZHamFhRS9QNUpLUXlmckNTYit4Q09ObDJ4M2dnZUtMRUNscHpKWUJ0NCtOaEc1M0c0L2lRVUlORWRBRW1CUkJ0cXZBaFlHNVpLTW9BSUUyeHBCTzQyaEkwandUQU9XdXlVSEx5RUFsZFVVNnV6OTVDb1FMN2t0ckFhYnpCY0FBQUpTRVlVdFFHSWx0dDd3Z1BnUUVLQUFBWUVmVlVoRDU5Q1h5QVFDQk9xUWNDcHdJOTREY0lIQUJrZ0VTQUpvRzRtQ0d2bHlRQ3BBOXdBTTFDaGhrUU1yWHZjQzRUVnJZc0tlaVV3amJkaWpDSVNYWTF3Y21RdGxBbCtEYUVOdVpaTXVYdGx3M3doSVExazZRanZEWGhMak1pVTBQZ2wrUkRPbkx3eG4xMlA5NGpTUUp3dnluUkdvZXdYN21JWXFUY3Zyb2xhSkI1NkNmK3NNaVB3Tmx3cDZMbS9zOUphbzU1WEFCK0dvUWFVVW9QRXFKanBBZ1NnSGxxNUJCY2JGT2dpUXFJaGF3SU51d0plY0VCTjlMT0pvd0VkdUFMOEZWakFCQ0lpODVyb2lKdzdEQkVUclc2ZHJ3WHJZZGhwU1ZucnI0V1lZR2dFbkFHc1NZQ3YrMlIrR2tUVzJOcTl1eXNEQ1lTQW9pR3NCQTYzSjkvNEVZd3dYUTJseVgxeGd1YldNRU53ckVLbXpkQ0RpQkZmd0RoQ0NJb0NId1dFaSs3aTJjbFBpY0dCSUVCdUFjZ29HY0FMeEF0Q3JCL1lhdDFJalp0eVIvd0Rob2RlK0laUWFJbTN6QlhPRmdFaG1xamEvc2JUc2NYMVpkalk3QlJmNURtbkVTS2lqVlNXbWtFQ3JoY0IzTVdFaEtOWHdaTTAvdnJnS3NtanE0Mk1JblF5SjcwT21OZDhFenVKR2sraUhTZFVsRE51dGtjUVJtQ1ZOSzBjOFhGTFI5K1JFSHRuQlNRTWdRNkVJVU5Wd05zRXJGekRUQm9KQ3V3cVMvZkdSbmtpYk5XQ3RpZW5pK0xHWUJ3RTJBQUxKaklHc001NG5yd0VVaDJBMEF2T1FDcUkyZ1Bsb0UxYmlCQUdrYi9jQ2U5djJJWVBpeDdFcm1RYkNjYi9xR3VHa0FxUHF2a0JqR1NreDZKSUFtSWNJQS9KQWlabUtEUHUwQVcreVNCRXdGSUFGemF6QUVJbUI5b2F5Q0FQdlJ6d2hRZ3lnQUwwQTFpeXdsb0pVQUhGZm1ZRHFBYUlBOHVSenlhbUJqTkFzRUFXSDBNNnNBQXJaNnBJWDh4Nzh2SUZIazV3TDR4a0VRa25ZVnlXQXVDM0J6UmVVN0VuRnNHdEpFRUFIcGhPM29ET1c1a3FBSWFqVSt6Mm9uQmN1QVN5Unc1SllPc1VOZm9vcVg5b21FQzdlNkNrOTNvWXB3LzdMUkJLbGgxbUFJWGp3SnNNQm9qUUgwRjUwTmlDM2JCZEoxejVScXBOd2d1S0htQUlMUUt3THdIQUNIR0NBQ09DQy9GaHhoWFlQalFRNmJnZjVDdDdrcmlOM1lJNkxiVFkrdk1lQllJTmh3RVJsWWpFS3lHcEhuN0J6aXBqaWV5dURicWR4QUpzN0ZTbGYyT2Z2c1dSMTBOVE5ocUdnZ1U1aGFGL09HaTlCOGFjOWltQmRMSThnRXBYQXdOcXkrRXhSODF6NEVDOFU4QTUvaE1BMkFHZzFDRERBa0FYVmdHalNFK240TlRTT01HeTVGcmc4U0VTOWpWZzBHVjA5RFNyUHNhVG9MYjlvY3ZxaWxERzhiQ3JPTkhZZEo3U2ZwbXhKSTIxdUc5RXlCdHZPdXlhOWF3anRSdGdoTGpyZm9aTTRIcmFFYStoektTdFJhRkdvb2NGTUVJU2JhbEhwcERHOWEwV3JiUmNjZGpWdGlZbGMxdjdGV3hVdUNKVk5RK1haUlZ5R0pUb1FrN0NTRWk1RU5oTDFsR0J1eG9rQndBTEF3RTk0K1FJQW1pQUUrQUFacDhaM0hGVkV3QVdlaEJ2dUlWZC9XV3lEcEI0QTREMHdDSVpkakVod1NJYnNyUTdSaXQxQWpwYndDL3lRc0l0bVFqeXFvWFFKUHQ0Z1FUa0FoK3U4SVRCUUFhSUhPRWpMemtDRFJOdUNHalBLa3RBWW1BR1BBeGdFY0FrK1BxUVFKaEExU1ltQVNDSW9RWWhBTW9CM2dJRVdVUGtobUxpQ0VCMzVOZlFrQTAvL0FKb09Dd2l0V3lwTjR1UDhHMFZUTERuQVNpRTFaSHNraGxTZUJmbFEzTnRtZ29PdVJZSU9OZEc1S1EwdERuQkJMRVBISEJsWlhZeU01ZGpUZFB3TnVRT2JwQzRsMEJpQkE1d1phVnFGNVhJdHVibitpZDFWc21TbmFJYlVZbXhOSjM3Zk1FQTJ5U3NmQUNxaE9wS0JvQXZUTC9FaGJRbitXZmdobVVZbW9BQlFKWkJyaVJDUmVKb0xBQXdFUmcwNEFKeDFHQmFOQkN3NkJaRnArQUNDQU94UVJJVjRPb0FrSFVDUksvTVBxYlFvY0s5REtLaHpuTmg0RWZzSHNPV0tVb1JCZzZ5UFFoSC9BTUlIZ2tnNVBEdGlqa1NwVjNNWk1nS3dPWngvd1JCVWFTRXlhRUp5bUFBMEJRQURBSUNBTGtCVEVGTVZYa0djbkFsNFVvREhrcGI1TkQvaFVBTmxxdUdOVzVPS1BzZ2dUVm9IY2YyRTJRN2QzWVkxY0MzY0N1NFMxMkFtKy9Wc1RjZGdvcGFVajJQZllpUkVYMmRhb05KeHlKT3kyVVN0bDY1RkJUcEhhU1NvY29raTJBOUU0R1BvRHBUWlhMa2tnSjlSRVdNMG41eEJSN05qYVpaUmV5SHRFMDFKTGNpV0F3c0pZOHdDUkFGQVF2QUF4Tzd4RlVIbGFlT2lJVkhnQWNBaEZ2WDVDSzRRQS9ZbnNQZkprMEM5ZVo5Q0c4YjZMakdnQTRmMFNBdjZkK1pkalVxMERjSzNzRDlQZ0hCYVJFTUNCcEpLOElGS0R3b0h3c0hoOGc2d0YvNjhwQXZRQXNRaHBzSW9MZEFCd1JIbjVnQUFrQUtnZ3NZVnlRY2lBMGdNVDRkUVFOQk1aSUdFaUtJZ0ZtZ0NXSU1CUkJFQ2FrY3VTRWIreHhBY0lxUnFJRFJMc0pZYWhQa21tY0F2UWxzSk93dkJEVU01Zkk3YkJ1cDFERklsMnRMdklDd2M1Y2s2U1FLcXhPNnZDb3JYY0RjRkZQa1EwcWdOU3VzRXlSRCtiMEZONUlqRVgyRmkvc0lMZDdCSWU1WHk1Sk53cDhvbG9oMlJlclBWUFpEWmZUSWZVcGVEa0NDRzZrSHhtMVpBd1lGMFVZQVlSVEZKQzdmRnY4RnhVSFhJUkxxSVp5R0Evd0JsUW00QVc1RVZoZUV3emdSRFFpV3NkbWNKRlV3SHdBRzBEbUF5UXpCQVFKaUkwblhZcmNSeVptaEFGY1F4dE95NUhLNWRoYnNwc2NIc0ZGTGhhRnprSm9sOGRwSllJRWdDQVJDRGxaT1krS0RJSjJZQUFSZ0VBNFZJTmpXS0I2RG1pWE8raXpjSDJYRDNoc2Z1Y0lsZUNCWmFEOWFDTmxvUTNLMnhXdnZnaDNLUXl4NnRJU2Fqbi9KWkQzeVFFamdQSnVZSk5jWDZFVk8xbEtvWklPZ3puUkNvMk1JV1JPNGJheXREUW1BeDJrSTcwUnQ1SW5lRSt5aEJzaVZ6UzJkVnJnZHRwSWVpa2h1NEowOUh3SmIyK1JMTHMyMUlyOVJKSElrcnN0SkNOQlNnUWlnSGV3QkNPZ0U2WDRFbEJOTnk0R2FHbUl0T0JGZFdld0w0OTRuQ05aK1FuQ3k2Qk1BWGFDRnlyYll1UkFLdlcwNEczQnhITXFBQTNSSGFFaFZLS1JVWHlDWldVSDJpSWRBdHo4am9GVzhnbXBOMUFCTHZnb2dKRE42d1VTL0huREFBTVpnZFBBQ2kzQUpscjQ0eGY5QUdvSURHeUVLUWdhVytmb1Z3U0l3QzZNSllBZ2tqUVNMU0FOMVNBTHlBQUNDQk1nQVdLQWtKaFRjSTFqaUlBSVMwM2RtOFA2eXdsRnRuWmxQczdoVHZTUDBESjlFbFpLbk9CUFhZc3ZhSHNXUUpnbzIvNkp2Q1diUWRoTTI5aXNWUDdDWExBM1NRM3dEU0tkbjArSjVHV3NndTBoU0NpcTEwVHRJVkxmNUxwWDBLa3lab1RYSVRJa0Zrb0pTMS9abEVFNkVuN2tFSTREVHNBSVVTQ0hHS1QxUTFxVW9YYjBtUi9pSWRCQlVBd0JsUlVUaFFKcW1LQUxRQ1BBMGFQQUNFcmJMR0RUSnJnUkI2QVJBSFMvd1BKK0ppQ2dwaGw0Q0U0RWNZYUJGbFkyQUthODNXRVFnUkYyN1hJTFJWUElVV1p0Z3prd3RFT3JJQVFTc2dRelR3RUFRSUM2QTNHWG0xRkFpcVJtNUFHUkJqQVYvK0RBNURaSFd3ZWtFQVc4Y2wreCtJUFJwNWlLeW5pa2oxSU5mam9wVDJRK001bFdpYWhiV0Fpb0d0THNRWnJRemEyYmE5QktzNW9jM0E5eWg2bitEUk1zYld1MkpJYk9zY0RoNEpVVklhNWJJZGlMOERnUzJmS0hPa2RqSXk5Q09MbG1qeXl4R01wT1NQQ051UkpXbzVKczREcWREV2s3eUVEa2g5RjlrVmR3SW9xTVdFeHFlQ2FtaG9KR0cvZ1JUa0pRVDVJQUlCOEJLb1QxZ05RaW4rWVEycEJGTkJxbTNKMEFWRmgwQVRmbnFrRlpWaGlCUHFld1o3dlMvK1NPNWIwZUlpd0MwRkxpQWxFR2p4bUVCbVVjRFVSK0FDdC9BanlQbkRWcEFVWWdPWXdRN0FBRkZRVEw1ZHlqZ1FJUUpsQVBZQWFXQU9SQWZjRmhCQmdDRHFBWDFFQ01nMUFnM3BIa3pBQUNCQWJJVWtzTHRZREJDQ05CWExTMUNLUDFITmFpU2twRTZ4K1JiMnBvbVZZbXREaVpWTG9kSTRwaldmM0RCdFdDM0pPUnBFZWtFN2U0YUhBMHlBdWpWb2FnOXFrbTE4a3F1VmV5Q1JRNXVSTkMybEdobTRpclRQdjhNMjBOVHJXelR1NEkwb1MvRW1BcU1mTXBJNDFqMDFJYWZrMnhCSFJNUzB3WFlCYjNIRXN4K1JzV21xamNFQ0xrQUIrWVdBZEdjZndJS001ZlpMZnk0T1RqUVV1STNIWlIvWmlzS1NnZ2FyeDBNQUFJQnV6OVBKQlFHQWJBUUdtRUxJTlVuUUFzTTV4ZmpZbHdnZ0hHQ1Zpd05nL09CV0FGOThNQUdYUUJjQVRoaWFJSjRSUi9RZGpISjd6Mlh6ajZleGoyaXVqUThScVA0Q2dML3ZIQndIOU1nZ3A3WkRVTk5VeHErN1k3ZG80cWsxYXRjbElsSVRkUitTNDQrblp4amZZdEhlUVRVT2tyaGtsTWptU1NTRVNoSnVKc3JHSElrVXVCanBFc1lGYnhBemRGc282UHpqWVB5VlNja1lLNVlpUnB6ME1hSTBPR2wyTlNVTWxwNENIQVpBSFJDUmIwWUdTc1NpbkduTVlEYlo0YmVSNFI5Q0w4b09iQWxZUWVRVjJOR0dtZklzNWhNYlE2bHkwdUI1cmRldzNUbmFRUFR1L3dEWU4wYTlZYzRTUFBRSVhxMDhBbG1McUkvU29uVzl3OEQ2aE9aS2dtNGtPazR6K0VKY1JYaEFCWWdSOGtBU1NBMlJFRzhVUVBvb1VrM0pBQnpRQWRFRy9OQVFEeEFDQUUzZ3E0UWJBallFaGRjYnhBQzRNVElBWGJBWTBZd0UxLzhBVlE0ckw1ZkpOUmdQSTlmUlVvcGg5RWw5NFVUVnNMbGlqWU1FT0ZCYkZhY0ZiWk0vWUQ2aDdDQWt5bnhJMU9HOGhPZXgzYVhZeFJEV0hlQXptRUZtRmVndGswM0RRQUpYZ04yTllJVXVZdjhBUkRtaGNpemR1eWFrcmFFWkN2a1UyVTdjR1VjQUtFK2VjMElxNDlpaEE4d2FZeUVqWVFCKzd4VTZKNm1FMDlOT2JDSU9BQkFBMWtBY2NnbzBqd0JJeEhhd0NVaTNnOTBHS2ZmOFR6aHd0a2NCb2dEWUpkZ2gybDd2akVKRkRKTi9wWExFU1NLL1FoOXBDWktFQWdKU1EwVlpJS0NQaEhCS1FReUd3RXZMQUJ3WUk0TUg0QWt5VGdBNXR2NllIWnhzbUhKWmpZUlFtbk1yRXlLMkUyV0ROTVhQd0FCdU51QWJKT0wwVUhUK3hiZlFRVzNhRWIyRjZtUTNUV2hNcGg3RjZoTWYyaXJrTG9RVzRsRFpKUXFlV0s2T3hBM0wwTFBLSFMxR0dDOS9vZ25UWlBVa3RMZlpLT1VYUHNVaW4raHA1K3hYV0lKMjJPdGE3SVhLc2wyNEs2WDBOdHJaTzdkQ2tPbE1CUVFQTVlBR2tnRUtCQjRBSFMyaytDYVBzbVBFUkZ1YXdRZUV6MzVaNElBeUFCTXI5d2UyUlFkQlZpYWsrN28rODQ2SWJ2cUF2Rkd3TkhtSTdncGx3VUJYR3U0MmRreU9SRklEZ0M1RTZja2h5RC9BUk53QUs3bjVyd0RySVRiZ0JKa29BZXQ0QVBlaEF6VTBsbk1EbjhwQVlNSm54a0I3V1l3bnVDQWdRQkNVODZBTkVKQ0FCQ0VWOUVnb0RqYndNVG9oczFQT1pKZ1B1Z0tBUVB4Z0xBRFRIcm1TQ3k2WmdjRHl2VG9pMDFYQTdhSHBydEVXT3NRRmJ5cDhCclRyV2tUZ1M5akVsa2ZVb2NleHJSRXVSbTBEeS84QXBKQ1pkQTdvTmhwQ2Yvb2xRb21lU0RUdFVKVW5mMGJmcmJJTm1qVW9HeTVlaENpWnRGRFNRVFdlOEtDbStXTUwvY2RQRFZDYnNybE9CM0dzdEU0UGNBVktCZDlwZFNYVmRpRHhVdE1Id0FYbTRmMndmM3dSc2dTeWNoN25CWDBRZGRzQVRZeHN5NlJoRWdKNGdsd2IzSGdCSlFYQXFhSGc1V0ZpR3FJV3ZXU3o2d2xjOFRRTUpBSS9BT0FUVlB3QUFEQzZJQWw3d2xBY0Fob0JXZGZ3UThHRGdCWUVOVWdZRkFBQWZEQkFQaUVDRk5MWkFRYytKVTZ2dlFvSWY2RURLZDdWSkpPNE42c2tlbytoTWxsVkFHVXh0eDRFajBONUEwTko3TWJUZ0xzamZMOWlZdUpST2xvUWxsenA4anBxZWVTbDhNZHZhTjVPdlpLb2kreUdyL3lGd0kzV3BKS1F4bUVIY3pORUthYllqZGtleGIzbHZSK2F4Q1VoUksvc1YxQzJkTU1vMkpLbWgxMDRYSS9hV0xjRkw3SER4YkNhbXpnYUtiVEdXamFaVEdDQ0tXQkV2d2dCSUNGTEFHOGdaMDcvQU5LSnk0ODZUNEJ2NW13SG9BbWI5QWRzQzNWWlBnSE5lT0VqL3dBemdRNVcyd3lQbWgwRGI0Q2ZidFV3UnMvTU45aUFENjFSTTJCZk5tVW11SVlEdkVDRkdqT1FBcUtRYWRGSmdnUUxzOElJUENqQWZ3QWJ2Q0hyZzJGQWEyRUhucUFBblBaRURUM0NuQUJZZDhNSjhMS1FFcWdHT2dldDJBR244THNBMEJBR1VCV0FCSUVLa3kvQmhJQTZCRDMvQUhnNVQ5Q0U5SkZ0NEVTaThxTUJEZ0ZuOUQzdnRtLzJSWkloV0t5L0JEMklkdGV4N0paSjRGQ1RQY2xmQk5oQmI5cHdkUFVSNENWVzlEdEE0WG9ZNnVGUDBoMDJaTTNBYVNsTDJleUhRWU91VTIyeEhiYkgvWG9ha2htb1RiMUlVTUdzMWJDQlNzSWE1T1RkeVdwSUlrMjNXTFdoRGVGV0FBMkt3a2FnRzhJRUlRZnQ1R0x6QUFFaUdnaEloQUNtSElpR2dRekFwVENnOW5nRFFLSFgwZXNtNEFDUUlOZGVCU2F6d0YzNDBPQ3dORkFYNFg4Z2hCU01nb0tJQ01RRU9GNEEwWUFBOElBQUNBYWdUQXdCOEZuQXN2bUVORE1TTjFUc2F0eDlrSVNoRFNLSlVjLzBma2NQb1lsaEpWZUVuNE5RUGFZTHNJc1FleEQ3YTlFRC93Q2hMdmtVbkQwYlJ0Mlg1V0RSUUU5YkRhbFpKeWsyYVhCR3BXYXpvYkNJOGJERXY2RDdiMXdMWjBOMEhMc2dueUc3bStEWCtwMjlpMXBYeXlGMS93Q0FVVFNZZXVxNUVmTFM5a2FtWlFyaW9hS0FSQUozeEJDaXgrY0lRQUZyWTBjTVFUcy9yOFIvbStYYVYrVGxDa0gvQUdXUDlEUEV3ZjhBN2hlY2pJa29mWVR5WURQUUc0RUlnK3dKUkVHOGk0UVh5eUFkdWMxR0NuaElsSkJJb0xodG9JVTVKQ0MxQ2YyREVxOEdvSkw0SkJQRFhjWUlBb0FBTHU1bzRFNUNYb1VnSnh6cEFBWGdBRTJ5aUUxMytPTER3cHdBaVlHQkhBQlNGMTlNNDh5d3dOUmdCMlcySUFHMUhYeXhCcWphSUpoa002ZzJRR0NZQ0F1NEhIUUJycUlVZ3ZRWlBFVFk5SDV1QkZSRGZ2MHhYTFpNa2l6aGNENzBxaWlTZXpFcXpLelZTMlZKOG5vdFFsMk5sT3k0a09sbUc0UmZFazBUYkRuV0lpVHl0b1lpbTZOWmo2SVpsTDFwbTJRZjIraXV2M0NzWjNaS3FpcC9zZlFrTWEzMkVkVE9RTWVDSkJSTG9xcTBkNWZSTGluSEFWRWQzMHlST1k1QzF3THRxWjF5UDhNRFlucVJFcnIwYUd3bCtuQUFENUhnS0JCMXAwWmc0UFJkV2dFdGVnUklSZ0gyM2dJYlB3TW1SSXRLWXBOK2FPellRL0JPNTJWOGNwL1dYZ0FnRmtTU0hBZDZHL3lCQkFESUFDQUlCNENBREFSY1R3aTYrTW9BQUNGQUFGS0VnSUUvRjhCQUlBTUdnWkE3QzJCalV5NDc1bE1zQlR0THFwR3pPMlE1SlVXaENTZWg2SEgyd1l4NGFvekRaVmVZQjJ3eGRrNFlmd0NCZ0ppV3JYSXVteDlSSTFhR2ZhUjY0czJBVEUxSmEyTFU3WWw4L1FnV1JHMjRYMGVoSXpuYWlGcDdGeUJtOUlrUjdkRVVYazFQL0pDeVEzbWY5QzAwNFR5ZHhYNkxvWHorZ2tqSWhaL3N0cFFiVThCQ0pLaUg5TUNiaWVER1kzOUtYeEtjRWhSRElBQWNpa1g0RW1KSkZCZlo5MkY0RHp2ZVFuQ1NRR0g3QUI4aFd2b1FhbjJpUGIzMERwZTZ4eTRrV0lHdmtwVWNyMENoZmxOTmgyODA5UUxDckpBY3BzLy9BQmRaL0NBWTBnVnhWeGdZVkFGOWR6QU5YNkduMUJGMkJZSFJ5UUFGSTdhRWd2aVFBQXh0dUVUeHRUd0FOWGxRQUphNXB3QW5zNk1BeGNRQXNGb1FnUUFpMFFZL1pzUWNHQWNaUElnZTRNRUp5QVV6OHVNZlFJQURsTVNUQW1SK2dBZFVBdllpQ1hQc2RTbVJXL0dCWjBiRkN3VTl4V2xwZmJ4RVVzNXFRL3J3MkV0aFN4SnRXaGVEa0RiRnVSTExjd2ZzUU5rcEVtbWhrbk00OVZ4STFSZ2Mwd2sraTdDc0FtWXdsTTh6L2dVeXhCTjJEcFRMQWdUYkVpcEtVNldrTkY0ZHNUS2xjQmxOVG9temU3dXlUVXpSMEtTU0VhS05rbFJCVm53Zm04TENNQU1XaFJra1hzTUhnaUd0aVZzaTRZREJQR0FBQWdFQUx4Wko5T0lNT2cwZHVsQWRONDZHQndoUUVENnRONEZFVHpQc3BpT0Q5azY3aDN6YUlLSEF3QndBUklTVUIwSUdCUUdVSmZ4Ykk2S2NEQUVRd0NCSXFoVVFzci93SUMwNWg0UWkzbHBOR1lHY0d4ZDR3aGZBQS95SXdMRWErQXNCM0VjaHllaVRkQ1lIU1VweWhMVzVFckVoV2dVVUJNNjBGQjI2UlY1WnlJcTRVaU94SjVmWVBFcEVmL0VzTGc0Q0Iyd2E5eGdPSjRSVUduSTZmL1lwSFBCQllzV1FFNUtqQVdqcDBIVElEMURGZ0RjMklyV254ckdnSUFJalI0U093U1Jlc1lObm4zZ2tiUHhEUHJ3VVFld0Y2RWJWOWdsWFBBZUFmb0hJb0pRUkx3YUlFblZudGljelRWQU5pQmI4Q2xhL21KTWxxa1lsdnpsWlVnd0MwRDlWMTRnZjBRM1VFRHlDQVVyT0FXZjBRQUpySlRENEdDZ1NOY0lRSzFLWGdPbnNUQUdSa1Bkd2hZeWRiMVVBRkRaWWdjV3ZBMkdHUGNqWUdaSkJGcklISlkzd0FHUUFEcTFKQWdkUklSWUhxQWlCS0dEWlpWL3RvZlUvN0NLcXlFZXlBRDFIYmQ5NEUyN0w5RnBQYjVKemV4cURURVBZaVJmSWlWRUFWSWZDSTNhT3NnZTFBbXlPQXRTYWNqMWdVclB1dWhBVVdoSUZPVEJEZENhNlJtZ1o1ejBwUlh2b2FpaFVuS1JRcG9xWnN4RWtQMFFxVm5QQVFDTzVqYUo0VWpqOFZpNDNTa040TXZhRjZod05IT0hUMXlpeXRJU0szcERDRTJpUURXcnhnbHlEQjlNa3dDUHN3aGg2eWowSUhKU01Gc05jb0FoUWt1UHpRQVlCUXFJaUluMzhBQ0RVa0pEeEFxQjg0QUFBRFFJQmdSa1VQa0pDZ0pCMEFBd2hBQmdBamhGYmdSSnZTRS96aDBnemxnY2VpbllUNnZHa3lzczB4MGZNSGNZWkZHRVZ0Y1lBbEdnN1phYVByVzRMNkQ2WjJ2eVJSVTZab1N2SVhwdlpCMC8zZ3JTSDJIUS84U0N6ZGtxbFRmUTVXLzZGVEluY3haQnA4RkZxTnVuQVgwbnZsZ2QwY0puS2NCWXpwc1JKeEdDRWtCRTlRTzB6RXRBU29MZ0pyTExqUktHakNGNUlLVHlTRW9JOGdxaEZnQjltMGhKUGZYaFBpT01pRkJJVkVCMkRSSFkxS1FNdFhXNlBxeU52UWxxQmlreHo3QkFzS2FXL1Vna21vdTFDQUtDUUMwcEZJQkJLY21BN25PRVdxQWZDVUU3VWloaUw4a0lBbE95WmtXUHFFQXJoYTRtT29UY3V5MGdjeXhRQU4ra0dCSFVHZ0F6ZGJRQUUwNlRBaVNraStjSC9BR1lENWtEVDBRQjJpVmdTTS9ETG8rSm5PNEJrb2dUdUVIUnpDd2pwOUNGa2pXNGNKRTNJcExTL29mOEFaZ0hMU1Rlc0l1empBYjlrTG5MME10M3Bwd0pIT0hZMWI3ZVJaZlROcThnWWNFSUtCb1drUlRrbFpRdVU5TVNrZmFlallRbWxPUkNVaTk5blZNRFNsR2tNZHhBMWdqbWI2THJKSEg0RTJpTjh5bmxrNEQyZG15T3BEODJKVUZFOEluUWxhRjl4c2pwVDBNWk9wWFVDWnVmT3hMMXZpT2NORU5HcUVqTTRHMkhHSjNHRVdKY0FIY3dkUU41VHN0SkY1Z0dkaktEYkExaVZocnpDa3BROHBDWUlCTG5HK2NkVDZDV2dBb1BNRDFUQjJoSDE4MXhJUVNCRFRnL0EwQUVDQkZnY0tYU1MvQmtSS0Z3UGlGZ0VrZ1JwQUFBaEVtNFpvZzVjUTB4cVZtQitDSFBnb0l6dDRJRElUb0tJY2xUQ1MxRDRvSkZSNTVES0NIK3VEWlM5QUlHYWQ2MnNlVmozeElicU1CS3NiSVk2NjlkaUxsTEVaeXZzVFVLSDJJa2lua0p4U3RQUkJRaXJKTGwwTmNMOWtJeHdhYk5oME5hTXFnQkF3QWVnNUErcDRob0V4U3Z5SWR1N3dkcitmSkpGdXRqS3VoUEdDbTNhNWNmVlYyU0lyL29lSkFRUzBobkFLMTFzZll3Z2U1NmdKbHlpYkhyVmdIUDVRQnNxb3FjWldnRlh6QVJ3TWNBc2U4MEFncSt4TEFiQU1PTkFFNzBtQk1OQTFoMGl5Q2VpQVhIVjBwL29NUHBnaEwwbUFBem1DM3RRQVZxaUdJSXJDcEYzaVJDWlhDMndPVFJnSm1mSGdGYjBCWTFReUlGY3lBNGljRFcwQjF3NE12QURUQ0ZXZ3NITnF0Qi9oQnhNUitndFBUa2Y5Mk1MWkJvWEJRbWxDbXgzQndOelZYcENBanNpYzVTYkhKbzZJdU9ZMXVZNGoyd3J5NnRpYWVFazdSME1kVTNDdW83SlVDRXVkYlpUNjBCODBtcXpnWXR2WTEySkxpbEZvMzBJSTBxSjBMVnNIc25QQ1JPdG9tR3d4RU43ZENTcWF2SWpKM0Qxay9vMExSd1F1aWoxZWloYnVua2E2Z3JWR1RIMnNudVBRb05RWmVRb0J3QTlCT1orSUVvQUJBUS9zS0p5a2pRcVE3cDkwejBMZ2l1cDRBN3ByM1Rtd01nZVBIZWJ2d0lpQUVaeWtpRVZ1aE1Ud3V4bzNmTUFBQ09JQURJWXdRRUJpZ2NKUGpNSmdBQ0FBd0FaQldqa21LMTNISnBBK1dGbng1RFdDR3NFMWluSVNBTWJ3UFFGSDB3SmVBNUJoTUNWd3owRTBQMHdnNUlqSXdEMkRpQmJMRnJZZ3ZKMUY1bmRLWDBJU2t2dVRsTmhwVFRrbTdRYXNLTFYyanZRa0tCdXlMTkVURnhiWk9wL3dKRzVZaSsyUE9oMUxZMWJXUUIxTXNCQVJxV0FKNWYwRDNUdmtUREd6K0VnelFISlJXQ0l4Mk52Z0V6REdGV0FWdzhrb0Y4c0ZyaTU1SjJEY1N3SGdUcGd4S0NIR1A4QUtCNjdESjFPK3NCZW52N0RvR05JSEZSd1lFYzcyWU56aUFmc3FBYjl1QWhNblhSQTV3L0RnQzhTeFhJQVNRV0ZWTUdpWVp3Z0JGeGlVa0MyVWwyS0FHenFseEdBZ054b0hIYytNRFJnZ0RJVm1FQVRVQVJLVWRLWUNGUURlSUFTSmdRRkFNdmkzZUE2d0dBbDZJUGhDZlVRbEs0LzZQd01PYTZqMG4vMkU5VDJOWDJYMEpSd3pnM0x3c2RoU0dCOVVWU2UvRDFzRGUraitOTEVxZjhBN0NReGZzSDB3SmtHbklFaWIwR20zVUlnSkVPWmhvMkhrNVVWZ0pjdTRoRzVQWmNXQ1BjT094SnlRYnJKRzB6WkNaUDJOTGhvS1NZcUk5cFFsWU5QS1d5Q0N1ZWJFTlRTRUtIWW9MS2FhM0krdkFsdWlmYUdTL29lL1dkZUlBUUJwaFpRc2hpRGtOQnRlSUZBSHRKWUhRUGQzVG9jZ1dVSmtFcDM5d0l5ZTk4Q1VBQUEwSUFEMVQzZUJCSkMyZXdScGZ5WUFxNDJnWXE0QUFBZ3ZDcElPaUZRRUZheUlBaGxEL2hnWVpTY1R4aDRVdkMySGtKa1FoSVNUSTNMQTJxMWlRS1JrVkVCUldWZ25iL281Y0FOTEFnNzV5d2FLTDFNSzlrYTluR05VanEwUFVwd2poU0ljRGVmOXpzbHlUaFFoemZCRk9rMnk2eW1GQ1hadlVmc1R6UDJKc0NXVkJVMGhuR1FjZ1FQSXgvWGR5Zmh3YzEyRVBDa3NUNExLb3JCdXZoR0FESDFmcGVKRStDNzQ1UTc2T0FGalBHWkFoR2dOclpBRk1BTUQ5SERnb3pacS9RSnRQNmdOK0VBSnd5Q1lEQ3FhZ1hzOUFrYnRobXpBTm9RQTB5UUF1R01KQnJWMWhBL015SXVuZml5M2dJNEh3VEJGY3NZTkMxS3hId0QwdEF3Z2ZHU0JhTDhPQWJVd0JvY0FnQk5WL0VGUUI5Rm9CbldVUWc0QUdQQUNtQVFQSmlBWVFJTGdBTnNDZmpCMXo2QVJ6c1BRaDdGa2cveVlxaGZiT0Q2S0dJN3JnMmdsU2ZXbzJmc1JhTlloV1Nua1M1VGhyc2VFSjIzMkV1VHl0MktScXdNQVVpUWZ2SEp0Q3NoeVVaTGw2RWFHRDVoY0M3Q280NkU3U2pnZDRnNkNrSVVTYkVLelhvVFE4aHFGN0swRTIxcWdidEZOd01ocm9aNDNQNkR0dVc5aU9TWUtlVitpMlFSejY5anBrVEV1dVNaVWNpdEI5bklCMzJRWUg1QW84aGdBSzN3QU5xVVlyK3JkT1NJcFdoeWp4ZUFlOUM1R1dBQkI5dFBlUkJVSHEwdGw4bndEQUFNQWdVQUVRR0VmdUZmTzRFQUdEQXdZa0FnaEFvRUJnRTFBMktHb1RrUm92UVNMQkpJWE1sSmZjNU9NQktXNGRwTFlWdkNLbFVTQ2kySVFPbVJWQ2s3QkQ0VUtaZ2gzQm9EUVNmWXpoQWFIUWtqVUNVc2RoMlpSdEVGVWlTbVVHR2tMOUVEcFhBVkFVNDZYaXhLalFzbUlKcmdmczdOa05tNG5EeEc1eWtGQy84QVFRNEZXUWRDcC8yNFZYbVRPbTVQREhFRFVEckVDTElTd0pYeW9CQURYVlQ4SmduTEFhWTlrWkVOa2oxQUFWUmdpOHA1RVZnU3RpR3Vwd0J5c0FFZVhCQUczT1lNZ0V5K0UyY3pNcFVlZ2ZMQUpmS2pBQzJKd1grZEVCQVVUR0FVcjY0cU1CWWdCbnRRVWdrbkNURTF5WVdnWnJhQmVrbi9BT01CQS96S0JESmhDQVFBQktBSTNpQThhQWFNcWhrblFsdFluOFhFeW5JSVRiQTJRb01rQ1JZSkFLU3Z3QUFRNXYwK3VmNkhZT05WdXBMbWlpR2ZrbW1BSmVrNVhaWUpPNnJwZGt1Q2d1VnVyOUZjeTBJV3h5c1ZRN0tTZlJPa3cyN1B4bG5aVzFTVlNKcU5ScjJpQVFDRkR2MlFNeTQvb2dxc1dXTm9HSEc1akptNlZpSHhnYldOaHFBMDMyS2V4S1JjcGVPUlZXYUNvM01HcUVKS2JyYWdoQ1ZEL3ZzNUZnRHJZaGFJL2VCTXEwd21XL3lIUC9xcUdBMldCQkZ2NUFBQUlBQ2ZZTUd1QnptZG9hMTFoT2VtME1FT1BxUEZIZmdvRElCcEN0WStZTEFQQTRjQUFoRWM0QmFJQXBCQ3Y0SXFBZ0EwZ0FJZ0pBRUdTS21ZeHVUb1dMbXcvd0FuVkVjaVM2SGJGd2pXelNQMkVRRG03THZiam82QndSSkJSU3EvWVROLzlDZWhKcHlTN09lU2pRdlhnT2dxTGJyWmZCS2gvUVlZSjBoeGhKUUk3QUJKT0NOUWtpU3JCaUpBUVJyWU1sb0JxRU9obVFwUlNFcDBUQW1GaVRvVURiSlhRdlEvRVNVQjFRdndDZ2szcUZaSzB3bXdhRE5mNUJJZ0EyTGVVVG1ud3BSYy9nNUlBQVRZTWNVL2doUUJXSUhoQUJBQmNoTUFBWkExQjJPYkxNaG9nUkFqRXZDSVFsQjRCWUdGVDJJQmpSVVFydUthQUljaGtrK2Q0SUF2VUNTNDZJQVRHMEVSc2M1T3dMbDRGRGtQM1I4RDExQVFZSkVJRlJQdy93QUJRQUpoRUFBV3dCUzJBSmtRSGtNSUF5UVVTLzJBSFVMMndlejhCSTV3OUVkQVlJQ0E1L1E3c1dCWWd2RjIvb1JnYjBGOEVWRnpLdjBNamN4bDVITzFDM1kzMXdSUi9VRkFKS1dXSnl0SUhNamdJV1dkMEkwK1lraklCU1BSRTBsRHFLU24zd0kzUEU2Z2xSdUpMc0xpMzlFSnR2UENnYTBiclkrMnlWTmtYbkpIWHU0dGJpMi8wRzNKZm9NUktYWk1tWVZvUVJCV2tpV2d5Q1N4enkvcmVCRUJHY0NJYXdJV0FCUGtBWVVFYW10RFNwTFJrYU1xZGlFM3EwUy9JS1FPQW9CWUFZNWZJT0ZYeGhhUXFzQ29BaWhBUU5nMHdqeEFQQTFwQjJ2bEZoSkpBU0tRRkJFQUl3ZG9NUURVMm5BMGE3OEFBRU1hNHN1VndVa1BRSnhDaVpaUUJrMmdYekpkc1JxV0lsUXIyZUZCYm85RG50RVZwL2cyc2c3V3hTbkRVb1crTWd6YWZ2bkJqckN1UURsMGtuRUI4eWxaQW5ScU1FNW93VVM1cG45RDRYUjdndGo5a1FRdURkdGhzK1NjWEJTdUJ3TDhCY1FJS0pEYjV3RUVDRUlDQUFEV1pYRXdCckt5bWt6c0UvQmhLaEdqTUFNRUkwdUI3VFMvUUVhU3RyMFJNRThZRkhwRFMrYmp3SXpDOXdITVlNbWVHQVZ5Z002Z0RaOEF5dWZJZ0Z2RENKcndJVkN0Z1NlWVlCZ0REQXU3OCtHQUVlb0NXaENQVmg0YVBJRnlraHRPWUJ3cXcxUWxnODRTZ0hhSVFaSVFiRUFVT1FIclJBZGlaQXhBTjhHUUhvQUp6YXVJMjVJSEJwaWY0bjgvKzBYQkl4TVBWaEkxOW5DSGtYT0toVTJscGdEWUt0N1lSZGdsSVpKZFZObWlpYVhSZjhraHBXdGxUZ1ZDOEVtVEhvWk93SGVFRmgxMnlSb0Vac2trQ01icTVLRk9rbE9qS056UEhReTRHOExraUpDTUpSN0VyMzlzVEtaQjRhYWZjVndNa1NFa2tFd3BLNEorOE45YUx4WklJcU5xQkZyOWwxeE5ESml0Mk5FUGF4bkpZQ0RZVncrWkFnSjhBQUdxYXhlSWV2WkJQaFBSWUlLbmVkSUFFc2dPSVQrS05Fd2dnVXdLUVFBQ2dnbm1Fd3JqNWhvUThXSThnREE0REFoZ0lOK0REQkFSOEhvSUEyMUpOZjhBVHlBQUZnMHlPZUJIVXlHSW13bklZSDZWay9rYUVwdnNqeXlWTlFUSzlEN1NrVGsyMnhPbnNvNUZhQ2dhTm9qc2gxUDlUMllDRTB4elFFaUR6YnlNQzMvZ043QVR3QkxHaENIOGppVjU5UkQ3Vlo4dURKa2JlSUZsdnlJWEFpQ0hnY3I4Q1VJTmlqSUFReUVBM2FRdmhUWmhaTUVSNGJJVnZ0ZGpRWis2L0liWjZwSmJOMnlnVXp2SkhpbEJRQndoK1lnZWdBcTJna0ZuT2NCQ00rS2lIRUJ0V0JzK0tKQTAwUWE0TWIrWko0QUxKRmtJVXl5RkNOVGNoZ2RhQnFOQkJ6RUVtVE9BQysrSEE3akFJNzRCUWJhQVBZQjVDb1J3QTAyQmVCaUtKckd6ZkRna0UvbUozczBYbm9raGUvSTF3aEJjT0V4eUpLSW1DYUdSN3dFb2hNSVN1VU5Kd25OMExVcjdFT3lyUVVaS0prWW4wd2hjamNRdC93Q2hLaDZSdDBzcnNUZWdUM1J4eUtxZzErR3dVaWord3hWcE95VTVNQVdhVHBYSW5GSVJ4RWtxWkNETlQwVGM3RXEzZlkrd1l0ai9BRWRZQ3RVOWtHd2tvMm85RTVBbFZDODdCS3RvSFJMNFFBSk1DSitBUEFwalZhUjFYQXR1NTk1a0JkQnRTNEhrNFE5eUJNMmx5UEFZVCt2d1dZUkFPcTVnRklGY09SU0pCTXYrRW5BSWdJQ0FCSUlTSUVOZllBRHZGWUtPUUFtdU1JdkFLYzhQVGhqNnVBVVlJUzlHQlJNazRrbSt4eHJBb3BZcGJzU1NKdWtTWlFrNU9nTk4reE9ORk9ySkRhYWhNU29kNG1BcFlvei9BR1N1RUg1eUgxeFVjWmlEL2FreVcwTWdmeFNJSGJraGVSSTRlQ0hKR1J2a0ovSkJnV09BNFRES0NwU2NJWDk0WU42TDhGWTRYelpJSWtzQXR1SVR6Z3doUlZYcUJCb1R5RkNMd0xVT3BnQmxqcFNnd1JhOEJER1FUYkpoazNEQkVPT0VtWllvZ2VFOEo5eDRZRzlCMC9vQUpVWnBJRkNBTEpBNEJSWkJBU0dwQ0lEUTBjQUxPQ0lhOGNnY2dJc0FBanBBSzRrbzN5U0Rvd0FEUW5NK0FrL1ptQVFBaEF1N2xvWjlpRDNPSGhOa1kvNzMzSVZoSUZ6Nk4xZlJPVDQyS1Mwc2lVb3V4cHBhYWNjb2hTVk1iUmNyQ2VrT25vQmpKN3B2czJRdjd5REVWdlRHNEtKUU1idHRCWGFTYWdTNWRhaERIZHlkajNEbmswSXV0WVVTTTJidXdUR1hWOWhUMDhIN0Qya242QmFsZ1EwM3BDS0lUM3lRSlMrREVOUFM1WlJmc3NrcWh5STNoR2pVRnZFakc5MEtsVnQ3azUxUDJoUS93WTRTK0FnZXVFTlBBSnlrbndKellEWWxJTXBCN0QxZ29sNENRQjVnZ3ppQU56YkpVeUJnQUxPNXdFQWtISkJEMDR6Skg4VUFBWkFrRUFPZ2tQVWdZb1pYY0FBcUJBQUFJQkp5NUJUY0tUQTlXTUNhYmRaTG9LbDBDYkV0ZnNJbnRqUnBXZmJJV2dwSkl1WWI4U1BBK2hDU0dsU1BZbmxLaFloQXROdjBTRkN6WVdpbU5pYWhrWVdPdzMvMUNJVFRSQnRkZ2hvNFk0YkM0TFhvVHpHSDFCTmUyTURrVENEVXJHcVBoUzRRcDd6R0NBQTdZS3ZEcmtJdlBpUUlRVENnQVFhRHVEOFBRdmdGVitNRUNFZ0pCL2lEM2V3RjlHK2lBWFVUMENUeE5hUWJRUi9vQnYyZ0YvaFlnZndaT2dZU2RnQ2NZcENxS29ETCtIZ0JJZnZzQUZ0U2dmanNpRHlDRUFjVkFWWWlFRVpVcklmUVRBQTBPRkk0VE83dERrZkN6SnB3QXJBUmEzd2cwTUFoVUNPQWxQc2tGTkJTTURRdm9FSFRKZ0tHL3dDek4zSFdDRVR4MERPNkcxME5qWDJDQVl2alBGSGNKM1NqM0o3ZUNrN0NFcWFYSXVJK0dpMjQyaFRKb3VlVDBucWhhWHd6c2V1VXdtM3Y3c2xkbUxZS3owUVpMZUIyNTl0bXprTHZCRnczMkhMVUxvdDRXWVUwY3dxdXJ3T1NWN1kzZGRqdEhZMm9YZUJMU0p2REdvYUpLS1FkcDZINElUWUd4eEFnNW53d0ZPbmdaZXJBaWdma1JpTWpBU2xXY3JvZFBsUDlZT1lDbVdsaWo0QmVMU0dJR1FWV0FFQUFpVVg4cU9ZYUFjRWdBQUFFSkJnb2NFRmFJUUlBRDVCYUdrUUxBQkM2d3FoRzQvcDF1V0VrZEMwTFFRUkFTNk5xM0JaQ0czb21BbjQwSkNsRmFNVjdHTjd5VnBrYUNCaU0xeUxQRC9DSTY3QUkwQm83aTZhQ2FVZTBSSWllN3NVOWdCSVdybUJ3NUc0c2F6eXN3eEt0MUlzYldCcitzUzdIMW5nQWhCQVB0OENmSS9aQTBCQ2FSOHFZOENNQkdORkRvSDBRRnkvSUtmQ0FBSVFYQytMcXcvRG40UUoxc0JvSUFtOTdBcGNTeURTMC9zSzg1RkN0YXdBYUIvZ1NDZm5ub1ZoRGcyaUxRUUZjTll4ZU1odXpBTG9zMHRqSTZ1VHpTQTA0RlFTZ3lCaFhUUVNjVzRDQ2N4RHpCMEQ3em83WndMdmdCZVJEZ0N4SUZHQkk4UU9acVFNb1FDV1BDbndTZlJGamdKL0VKRTlpVVROa2lyWkV3em1PQ0kwVkpwM2dPSHhGRWt0SWdDWkRRUkFPSmxranNiTGFvNmFHbGUvZGlMSFlnaW1KangwRGRzUTNoRUxaK0E2YzRsMGFOUXRwY1J4R3lZa2lWWUprL3NFODRVNElodmVpSDZ2c1J0UnBORTBWTjJXQTZiQzI3QXRNU0R2eUd6ZDA5bW9Ganl5Y2NDTkJ1WXNWNFAxRUlBdDdJQzU1WVFTa243QWRqYkNSVTZWaEUvVGFFcTFlV0lET3lMNndZUTFxNC9pZ0FEU0VCQWdCRVJCSmdBRVRBUWs0d0JBUUF3QVE4UUFHUStFUm9uMk1scVVaUzdBQW1PZnMvU2FWS1dXbDJLTkRFdlozRHpSR3BKY0VvZ1RxeVZFSWVoZlVqR3dFMUF1djF4a0ZpRGVHU2k3aUd0SlFMb3ZwQXhsTGZBYzIxclpzMS90MlBMSlZhNUNETHNiSGNreEZ0U3lQOStzVjFpM3l4anVocVY0QXZ3WWowQzR3SEVObzlHL0ttTnBZanhzQ01oejh3QUNBQmhQS0JZZDRvd2JnQWdZUVpIOElwQUFBRWd3b2JpUjhZd2doTEhCSWo0QWdRTVZBQUJoNE04T2tKSXhDSFBSZytZUlgxQ0Q3UGdDaVZWZ0twdFpUWTU2NE83U0hFQVVEeHExQkpQMlBsYmJoL2lIQ2hOcTlxUUE3OEFmRlIya0lFeUFMSVFnakVISzVJYUFOdGZKRktnOG1BNWx1WUNnRzhaQUFnSDAvQW1SV0NCRklGRXZDSmsvNmJINmJJQ2wrQlJ3emttMEpRZzJabmdkS1lwMXlPMWNNWmtKcFVOZDRMWWJmRHdFaFdYN09CNzBpdlRSTW5DRURzOWtieFViU3ZZeEI4RG9hMGJDQk1YQVdFRlRTbVRsa1hKcFVMczdOWkNLY2FDbTAyTjdrRStoclZpNEt6U0pQMW1KTzhLZC81WkUvSkNFY3FiRi9qakNSQkN2Sm5HSGhvc0NSRjRBMFpCaGRUWUY3UUI0R3dEbjd3OFpSUUI4SUVSUGdHUEg0WWRXTHlRWkNCRVNZQ0QwVGFQa0FOUUJNQXdJQXdFRUFsa0lmQkpRYTZOV1BMNnhReENyTkJJZGdoeUo1K281aXpkRU5jbEVJU2xmUktJM1EwdURXQ0wySVZZZnREYWlUcFNOT2dOUDNCMmJTNDBNbHBkbzV5RHBRMXNMV3ZzSkQ5akZmTXJ1U1RRaG9ZdmFGSHFEVXlobStTSHVBUU1BaWsxaDg0Q1FaWWh1ZXdmVUJmSmFDTnArUk1id2hmRzBBQUVtK1FUQjluQllZQktndEEzT2drdmlBQUFBQVF4QUNKOFJSRjVBZ2lJREtGbWswS0NkYzRDQVFIQWdHdWJOa2UvV3NIVEVGb1JBM0lUcWdNSHNoaFQ5N1FlN0JGcWsrS1M1c2FYSW1JSllBVTloTDVCOFJGbENITkRZd0VUUWdRcHFlR1FtdUFLRUJ3QmZDZFR3UUtCQU5QME1PRC9Pc0V4dzh3ZzVtQnluRUljZ2xEVUlGTWNONXdDUFlpRmpKTk1qS0YzRWk5cE9KMlNCMDNWZm9ocGNFVkVHc002U3MwS01iL29hUXkrQkIyQ1FoRllVQ29IUENJU0xMU3Fxdlk3akFPNFM5VWU3SGFvUzlJWEF2dlpHQWdhMmtzTktOUmdab1ZNaTJRa1dtVGUxZktNWVNPQUJDSUFPNkJ0eWRMdzJFSmFEMXJOUVY5aDRYQjlwaUVDSXhFQUlaNWtDaDF3ajFaWUtZT2JKNlhDTXlLVWw4UW9JSkFrQTZBaW1jSEVNTmovNGQwVTJnQkFBQUFzSXBBS2FpZ2lBNmpOc0RHSUZxQlVBRmNnSHljOVlzMmVoUnFrSUxiSThrWWdyZXlJSVNLRklRSDRIUjlDRzM2S2ZSRFpDZDRIaWhRa2hsZzZON1JyWjMrQks2Z2FxMThQUWxQUmQ5akprd2x3ZmFKaURCY0JDR2hPd0huTllTelRrVENTa3RodzF4S3NZZTVqeHdDSC9jYjVZQklKV1VDRFJGb0h2QWJFTERkK2JDSVB5WmdUL0NBQUNxaE1Gd0pDd2lpZGZhL3dBYzRpZ1JFQ0FobE1qWE5ocFNFVmdFUVlZQWxHejZ4cEl4aVFoRFN2YVo3aWFBNVVRYUNBSjFnQ1JVSm9BaXFnTlQyQmtiYnVCdkRlQUZqTklCZC9ZQ0hxekxBQWpBQktKNU1Tc29nWXlZSzlBTllMOEFEWHh3QUI0Q2dOWUFBRU1ZRU1SS1hoVmdGK1JDQUdHZ01JZkNZazlOQlpQSEkxc2dsRDB2OGxNNEJ6Tmh3Q2xPalNFc0hmOEFFRUQ5Q2hLWUxnVGZvQXNvWWxkaFdQMUUrajhCUXBTN1pDWndNSUYybEs5NFhibVNCaEQwbEphaDVtM0prd2lUb1FxQmJEbkVLbkp5VUJYZ0FBWmdWb3ZJQUxuRGxEckVHQUFOYkZBMkRuS2doSnA0TTBEQWlzNEVLUUxlaDhUK1J5QWloVHlpcEJoc0E2QVFZakNmWWdRK2dDUnRmNHdMSmJNQURCTWNoZUFFVnpFQWVtQUNjQUFBVE5RT1cycndzaUV2MGhObWllOTJjaU5aYnNrOW0zQTBuUlo2SXQwTk5FcFVrVTlrVmdvd2Vna2t2Rm9hMGxaY2xTNTllaE1taHdxUTAwbjl4dWpDNC9jQWpMUnB4RnVFTXExdjlvVmNLSlhzNWxzQ1pVYnRNSjd4c3huZnhLa0hZYkpOWmw5Q0JYQS9ITGtqWUFyMUpid2hhbUFvSHJCQnRJSmJoa2VCRk5CVS93REhrQUFBVEFJaGxQUkNxQzJKWmZIRExURUZBQUFoaDdEQnZuTDhvbTZwQUNEalFBY1VLWUhHR0dOQUhJVVE5aTZMdmtnQkpDSkFjTWFHZzdtV0dBQUk5aWdnUXN1MlJZWExBbGcrUVRNdzg4RDNReWtBVENWbEYvQTBFRkF0QVVBUDhRQXRab0pDOEs1OE1CSkpoaG5SQUJCN0NwR1FRQXJ4M1Z6czd5UmlOcVowTUhOd3puc2VoK2w2akxlMFJKZEhTRTE3MDRIU1lGQ3VCTjVjNFczME9uY1RFVU5PMkJaRUhzN2w2S1JGQXFsaWEwbzJUMlcreEUyUDIyRUZiMk1pUmtxc2NnV1JDZm9EM2lOUXdyVUdMWXNRbEJXNXEvN2VKRTdFeUU0dndTVWdud1FBTmthWTBRMlI1SFVVeVZRRnpBQ2RBYTQ4aUh1SHlvS0lDVGlFa1FFUmRacHdUWWZBd2M2Z0dGc0NDRGNMWkVIUHd3YmhxQXhRSUVEQnJBQlBNZy9pZjRwa1JBQUFOWWFEWVZOeFE0cWJiSUh4RCtvMkxrUkNUbHZaTWFWalJaZm1CY3hHRTFCY2pOTk5pVFJzUjBuS3lsd0w2VTBLM3BZWXZldlk1VXR3Sy9iaXhOMmxDYUlnWDVDTnIvTUlWdlBaN2tXaEwwd0o3RGtTL1FnaWhJQkhDQ1pWazltc3AzOWt5UDhBUUdHdHUraldIOEVIUFZsT0Jya1lOMlVGcFlqak1OY0VQeWtnQUFOL0dGR0lHR3BoQTBMNUJHQlFnSUVrQnpuOCtsN0NIYmJOT2dSNFIxQ3lObUc2TlViNlhJbURnQ0ZRQU9lMndNSnNEc1lzU3V4R2djaitBRWNBNVFBeEFTOVJrQU1hd09JRHdBN0lEb0FJQlFKZ0EwSmkvd0FMb2VOVDRHa0JnWUFVRElBQzdPU0kwaUhtZnJ2by9QSWRka0lnZzRJcXJGdWV4THZRNGpjS0VRbVN5Q0ZwaHgwckoyNS9waUtNUnhOOWo3aDA5bXcwVFRhVCt6Z0JoSlhMZXNFMk4vUTJuQWt1OUQyeFVzWGFLR0F5Y2hyaFI4Q2tEZ2ZNQ2RvVjRCanFBMi84aDkrSVBycytMdyswTWhJaTZ3Q2pEVDhJWXNpUGhXSVZOZ0VXWVRBaXErQUZJRmNBM2dVb0J3QVhKUUkvd0VUVEFLUUFkZ1RERE1CS3dVQUFnQWtnTUQvSUNCZ2dBVVhoQ29HdDRBNEZzdWw3WWdsTDZJVGhFbnNQVkUrUjMrQnNSZ0VTazJTQzVCNVhNOG55TzE2TnNuUnJuaXRITndMTnBVRXk0ZGR6b1ZIQ3daVzhKN0NQdkxubys4WVJwQlpsUGxZK053VHFpc2c5ME1CMDAzS0VVcmcwZ3hqN0ZiZERlRzY3OEFBTmVEQkJwRSt4NVBqU29mOEFGaFFBQUFBQW1taUFBZ3NpaWlXTHE1L2lMQ0wvQUpqb1FjQUJBQXNNQ0dBV3BEaHdpSDNpS0FBQUFBQU4rTVFnQVFRRXdESUJvQ0ZBRmdHaUJGQVI0ckFVQUFoRkNDYU9FdGY2Nithb1FZQm1KRTBEZ0F3UWpnRkFWbUFSWWhrV3Nmb1I3VFNTNS9CRTBlaEhCUklzalBZWE1wanZEUkwyTnV4VTZUWVBjUTVXYVR2N0RVdllnYzNzYWFqaUNreVVsWGJJUnN0eHhKczFYQjNNQVdPYmlHZkdpQUJBS0lIdUFFVGpld2pTUzhYaHJVSEQxaWNJVW1VQ3BzR1c3SHhXeEN3TkRvY0hIWWtKcGlNOElLbVA1Z0xBSENCNUJDalFDNEFJQUFrR1JvWU1DQWZRQWhBQ2N3UUJBN2c1Y0g4QjR3QlVZQ2hBaG82TFhKSnRVT1hxa2h6cGZrcS9lTmJHQndSYlk1b1NpUzNrTlZiT3dXSUp5a2phUlIweUlUek5vaDlTUkwxSk5OY2hlcHU0NW1WRk4vN0RjSFJHdHlURUZhbHgrSVNONlFhSmNKR3BjL1kwbmRnbHY5U3JKa3NSQVoxYis0MnlGem81eGtHN0FLTURGd1J0dXY4QXpXQXBBQUFBVUFyZmtRRXBadXpYRWVGSnpBYlQ1ZVVKQjJab0FaQjJCUHcwR2dDUU1BQ0NSY1h6aHdLQk1BQUVjQUFKZ1EwR1IwQmhEQkpmd0phY2ppQ3MrZGdRRUFZRGNFQ0FBT0FFQlVlRDQwMFZCekE0RGE3Q1BzVG9SUTlYdXRDMmNzbjJJMHBOb2lTZUFMVGR0Y3l0RVd4QkVFTENWWUpZUHNad0lPamhSU2thUnZPeEcxU1V0ajQ0SjhTYUloUVU1bEdGdGs1aEhheU1CS3dZUzdvRHJ5L3psNEVDOHhteUZHSEo0b0toVVFKYWZNUkVERlF2SWZwSnhWemtFRUVFTUZJT3dOUXorTmFBSmFBSWpJaEFBM0FCdWdEYVZ1QUlCemc2SWdpQlFRUUFTR2duQkFOZ2VKRUdMZFlKU2dkVFg1RVFuVURyakVKUndsYzlqd3EyTCt6UUtJTHVIVEpURkZHMWQ4bFZETE9aTFkxNUNVV3QyUFRvN0lyZ3lWUzBvZVo1ZWlVRzZNTlFFeCtUZ1Mvd1ZPWC9BTEZ1QzhnTk5CblpSclZJZ1FTOXF1OUEwWndJWkxVZ3h0ZGVuWkdIYjJQV0tFUXVQTkQ2WklKVGtsN1A2SmZsRGZpQUlocDhJQkhPVDEveFFBQUNRQUFnQkZoNVNEcURDNXNRUEFTU0VJQlVRaVVFRGx2Z0VBQWdDb01BRklBZ3N6NEFTajBHSUFBQUdGZ1R1cnNMc3QveElUQ0NBTElHQlFoRUFBQVNrSW94b0VnSUFSUkNEVUlpNlNDYVV5UlltZ2xONlpmS2lXblFibStUYlkwQzZDNnVoRk15d1pwUW9UVS9xU2NnT0Z1NFlIWXM5RzlpTFJFYWFaYkVEQUNaNlJOcElRS2RBdHBBN0k1NjloeDVoeERtRGNBWVNjL0FQRFZjanNpeE5Dc1V0aTZBbmdZY3dFYXYzaEFnSFlUbExCRzREUkxqSkNjQnMxb2JRL2pnalpGQUJCQWNPRUFubEtIR0FBaURBWkRnYmdDbFlLSU9RSndpdmlRYlJSSmtwSHlSYjFvNUNjeWpZVDZPUktYSEltd3R4Q2s0Q2FTdHg5VEE3ZENKTWxQa0laT3RKODRXRXBLSGVCQTBFdE1leU9IejRIdWNDWm4rbzlTWUEvZ3dsTGFUdE1hLzlhZjU4QkQyNFcybEszSitPSnRpS1lBUUl5RnZqUmo0KzF4S0wzWlRUTGw5SVZMRjJCbnRDeUR0cTFna2tsNUFBd25JVHlDRlJqYkFqNHdBRGEvbEFBQUFCQkVzdEl2aUlLQm56QmpxMkI4UkFMazhnT2pRSUFBb0NLSmZ3Z0lBQURBRlFBd0JEQU9yUHd5UXFBQ0RBUWN4OFFERWdHWStBaUNZUkFnWUFqNE9BQUVVQlFrRmtpUUFFeTJjZ2NBUitoQ3ZvbFVLc2dCUTNERWMwWDdPdW8rMTBOMEZ4NEk3UWxjd2hvbEhBbTA0V0NwSGM4QUFEUlpzRU1CQk9BckJDQWhaRlh4SGtyd1hQNFJXT2xaaUVwK2dnQ2NKamd3ZEVkcUl5QTRORHpKNkI4RUFZTmsxc2lVWUc3QjRCUUFVRU0rZUJBd0FFSUVCQ0FBR1dCQkFNTU1iRmdCRjVBOENCVEFsNEZORUNFdVVKU05WSEpUS1NrZWVjRVNTUDM1aGtZME96b21sb3h5WEtnVG0wclVpUUxDblhzdjh2MmUrR3hOVlNPTG5rRWNqMlV0U3I0UTVOYm9WOFpjaFQ0SFExTVNjTmlmWUY3bWhpaVJrdFRHZ3pSKytvWkxOSmlDNjNjQ1hvMnhTVjhMZllWQzVNVnB0K0RvSGZCeGVSOWhpRGtkaXl2OEFncWdnQXdEUWFlUUF2NWdxRUFDUU5UNEtVZTNpQWt6djBFN3I2eEVBeFFCNUVZSk9KRnZsSGdRRUVOQUFSU0ZvbFhEd1VpYjE4UURBRFNKQUIvd0FLRGdFRUFZRFFIb0FwanlBc0FJTUFJQkpKY1ltQVE1QUlWQ2dRRURWREY2c1l0MElVVXUyanJUeFh2Z2xwK2g1Ukc4a1IxRUFTcWsySDIwaFRmSXFiazdHTVNTQTRpMEZnQnhhR0NKa2UwWUY0QVNBSzFBcExjdis4aXZXWUFQQThDengzcFBERkVzQ3N3Z3l1YlE4QlBLQUJBZ0FnSW0zM2hPcWFIQVRTWmhrNERRQ2dGVGtJQVE2Z2ZlRUlYTjgzQUFEQUlJQUFSQ2g2eWk2R0pBWkFSTEZKNG1rQzZXVTBJaUladHlpRFRVZFkwTVZwc1FTV2JjRkpNblkxZEt6Q0ZrdFFtVEsvd0JQWS90cWNUMzlrNkcxUTRPSTk4R0taODMwS0VrSk0zWjJWWlc2N0VaVTFXYlU1SUhrYWlVaUVLdW5mSS83a0hhUDc1RXRadDgwTUJ3MVBUZDhpQm5Sa0tYUW1hMEJTazdsNmRHcEk1aGxleVlOYW94NjZIdGRTVzN5L0VBNXlrbjVKNE1rQUFFU0VZcDhBQklQWG1FK1JCU0VqNEVJZ2dxYmp5aHBMOFFnRjFmMzZLcnRCNGk0V29GQ1E0WEwvRlZqN0lpY1NsVUR0Zm94T085WVNiOHlBbVIvRkJRZ3lRQWFJQVlFREFSQkFDT0FSQW1JQWdBaE9EYmdtQVJvRGVzRXNNSFZVbTlkRUd1ZmJCTDNzYXhBdUl3RU8zUDR4RUxFRk04UWFGMnNyQ0FZQU40RnBOWnBTVzJCQ0tyNFlBREJBSUdnQVNRby9naXhIRjRHR0VRc0RlL2c2ZUFBMlR3QlJSSkVJQ29LcjRRRUFBSU1ZQUFBblVvSm9uMFlBRDJqd1lFa01lZ0dBbkwrS2E1aENKb1FCSUlBUktnUnZGRUJCcFRKYUpwVWpTV1B2QTlXUkR0eWJGc1h2Z2JVNWZCSTdnaGM4aWxDVHNZV29OTG9hYncwMHc1VXRoSkNpdm9ONXB2MGhhWmM3RVFsQlJwaEhaRFdtVWtpb2Jqa2NyMVhDSTJTb2UwVDdjT0EybGNnYjlEZm9IcndBRWp5a3lCZjlqc2JpSHpiRkRnaG1iNUIxMWJGRFJjMzNnUStBQUs2Z25CL0ltUUFBTmtlQk1vTDgzRGJsQWNlSWlDeitJQUFBUkFScTErQVFFK1llLzRpSEhFYjRZQTRRcFA5VWpvTE1BSnlvdStDK2liTnVJK3hFaXJ4SjRKc0xCRWdPY1FyK01RQWNNb0VDQUFFQkRnSElJaUFVRkFRUUNBSENjSDZJc0gwaUVEQkFDQ3IyRndERW95RzdJbCt5eVlKYklFV012Mk9MdCtBQVE1QVZKYUtBdUFHMUJZRGtDQURDQ2xBa1BCb1Fpd2lROENqUXdnVFRMUE9pSVBPcGlPeEJJRmZnakNnTms5ZytJVEJJMEFkR0F0REFOQ0FRQ3VTQklCTUhBeC9XOFpnQkl4d0NXVFNGL3c0R2d3TVlQdUlHQUJPQmtRSWVHNUFCTGlOSG9jVHB3T2czSldwNEVwYmd2WXpCaUVQbjBPOFBsTTRuQUdWeENRWUhEZHBETmxtL3dEUW01T3o1RGJUNVlOVWxuc0xzcnNvb2ZrUGFFMkUwbnhnYWo2d2tBYTluTEVqSC9xWTJnOXdOVzZIVnZCRzA1RU5INGVCMGtMc3B4dHlEdHRzeUJlek9JU0NzbC9vNUlJSHNnRzY2enlHL1RJUTB3LzVIZGhRQUFDQVhUemhKdW9mbnNJdzUvaUNBUUNFL0hrQURJSUc3NWFsOERhaW16endkeWpBd1FEaUFnRjd6QUFBQUVRQXRmSWRaTnFHOEw0bXd0R1AxWi94aEtGQWhPNWhBQUFBQ1lFd29JUkFJRDB3QVlBbU0wRmtGa0hKTVFnblBBVUFXOEVTYUJEc0czRURmRWhYTHhERURCSUJVS1F1VFNRTitxNUNRN3hPTnMzZ1l0TUNSRklSWUN6Wk9OaXVRUzFvNUJVeDRnQkFsMWlaU0FWM0NyQUhSY25kZVlIRkpDQ2NBcUFyd3hrNTRVQ1pRQ21nNy9Fa3FhQUlqQ3FzQ0M4RkhPWXdJZGJXUUlVNEFERlFSTWpBd0pjb0JBVFFFNzlPSWF3ZE5Ld3ZnSGdOamxyUXRTS25MU1lxeWwzYjZGZHpucHVTTFA3Q1FPOHVHeG10TzhhbG8vVmgwRXBUVHFORFZjUWh2RlJrM0NOU1ZmYUgxVTdrTVRLNldHR04wMS9zU2JEVG1NZHhGUEJ5d253VW8yeTBWM0Y4bXlvdm9tNnA5a0QvQUFFTWZsUTl6KzRhdC9SeU1tam5zUTZYMHlmNzlpNEtmMk81QnQzQ0U4ZGh1OHdrd2tORmh2a2FTZFFZemV4TWZrNERvSU1pUDBJZ0VOSFg1R3hJUUFCUk1hS2hzNTNRelEzK2NBQUFDQ0FBSDhoV3RtODhHd3hDall2Rm9FRUFuSmxIeENqZ01BUUNBWUlBQXNuR05vN1NGelRPcWtCV2VrUm44WkJnZ0NHWGlBQUNFQXdLTUNnT0RRa2dHQjhCcGk4QUNFR2pZQXVSV0lCK3JRNFFCYy9ZRGNnUjRVSGtBaGZBRUxUR1ZEeFdoRFVCY0lJWXpjRStlSVFZY0pvczRZQnhyNFJjQUJDQUNQQ1k0aWVCUllpZ2hYeW1SS0FGb09DeVRYc3Y0ZXl3bTRIVEQwUmRZRmNVMDJNcVRrcjBSVS9BQzBCZ051NU4wRmVRQVFBSXhrOGtBQzRBUnlZQklacFB2NGJ3TUVReURBUW1SUmtEaXg0TVZib29vTGZQUmV3cFVsdUpIWWc2bWNybzVqRklLcmx4N242S3ZNeTJFTTU0SmxjZ05Wd0g5VkhxaTZBMlVTamErRVIxYmp1Rm9LaUU0ZStSVytJTGdlN0R5WGZodWh5U1ZVME44RitoSTZnNFRNekZPQzhDWHcySnd2bzltUHVvUDBieVFwLzZEb0JodTVaeTBlaXhyZmd4UnQ2Rnp0TnJRaTRvYXBKTDNETFFjTndJQlFud0loUUc5eVNQNklBZXhSSDQ3NXlBalhHQVNKSnFURkRjamQvUXBLM2tFMStNR0ZFQUFoL0JBQTZ1S2ZhajhOa0JTWi9CTVJJQkVCUU1CZ2dBRUFnQXdQVkJJVldDWmlEUWNSNEFCQmtaalJxWFc4TmRLZzFqK1VMd0pBNFVBQUtBZ0pBVjhVeEtBRUEwSFRRQ3dBSU5JNEFFWUlBeXg5UUpFQzc0d0FOSUFwTVljSUFjclk5ckNoY1Fxd0grOXh0bklTUTNqS0hNQWN1Qy9BblNNaWkzU1NuQWl4QVFxc3ZiRmo1eEFBV2hzUVVCd0Y1QWFGOUNPVjZTRmU4SUJHKzVFVnY3VzFsQ1d4WWdrQ29zQ3hCZW1jb1M4a1JVcmNhN0lsb0xnQUt3QktBRDhlRUFVYlpaRFYrQUtBTERjUlFmOFFJQkFrRUJCQUZJRVZDU2VCd0NWN0ZjSFpEOExEVlkzWXNLWEdwS3R1UmRuUFY3R0d1T3pDRmkzblRFVHJHazJNVWlUWUpERld4WENPaGVJZjI2TDZEaGZhRFU5T3JSdTVLZzZOcDUwNkVwaVc5cVVHRHVnU1NrWnB0SW5hajRtTm4zZHJrYkN3YkVCb0hBSE5lRjJPQ0RmOXd0WVgyeGUxMlEzak5EZG1qVkdlRU5LSnc0SkFRYTBuMWNpTnBUdmtjMHlYYm92MjV3SXI2aXFwandJWUZZRjFDcFBuVU1DaE1JaEltSkNkUTdqcmZ3eFFBVUFBQUFBUDRLYitWZHY0RXhIWkV3QjZoclRpQ1o4NHdJQkFBcEdBQVFBSURCQURrQlZYd0hBQUFDQUNBR0FCeXo5RzFJa1NSRGorVW9vTEF3SnNCRVlJUUFDUUJHREhnQUVBbEFvR2JBQUFMQ3JBRHFGeDQ0WlRpQUVBQ0ZmZ2dMeHlEL0FDQ0RsaE1CY3dnWitwTUtKdU93QkdEODZTa2t5cDBQNjhXRWVFM2ZnV3huS3NsQWlHUkVYM2crL05CK0ZsU0R2RUlBTUVrY0MwTUdvRHFCSUdyaW1DQk1sa0I5Z1VGRjRCdENjQ1pRdUVOQTE2NEZWWUYzSVRvaDh5M3pDRmhKd0ZvQUc0Z0NIV0ZubGdzQzNDcFlmUXdvc0VzS2o0Q0NBRUJPQXRQRWdnTEVBOEJPVHV5SzduZ1hORTlwSlVvSDFYUWFWeVJISm85b2t6ZTRZenBSVUNVa290VWduZW43UVoyZXBzbnVsSkdVaXVTbnNqc0JVcmIyaGs3YUgvaVJWNGlmNlZSemIraEZ4VFpncHVaKzVrRzdYUUlVaEZVUDJUcWFFdzZKR0xzS3RrelJEaWRqMkZlL3dRb0lqZGhrUldGYnB4Z1B5VEM5Y1NQQW1qbXdFWDJJMGVpK0hpVk9CeDRMSXl3TFJ0SDh6SUFRRlJSQkZDQVFBQUFBRzhRQ1Y1bGZYQ3V3SFJZNThmYXZBU2crTXdCQXdKSkFnUUJpRVdnOEFFRUFGNFlFQUsxeWQ5L2l4d0xBZkFFSUFBREFBa2VGZ0dmL0FJMGM0ZkRTQVFnV3AvS0RRQUFKQ0FZU0FvSGdBRWVJQ0FjR0FCUUdBcUJ1TkxSd3NEQjdRWkFFY0RrblFlQUNnUmcyVGNnT0hYb2c2SVBSRmdYcGlsSUgxektiV0lKU2cxNUJhYVp5Q3RzbUxmbElVUXZvOEhEaEdObEFvMnlBWG9UZ2hlV1VRV3drdHdnRndrSXVBZXJBbDdxQlBoQWh1UUgxZkFHaU5RWlNpMXowT3UxUXJzamRRQkpkR0dOU0FVcXNNZDVoQVFDQVdaRG9lQUFBQ2dQa09CTUFBSUJZVFRuUXJmMFdJcjhtOWp6dFNoR2JiMzMwSzhneVd5SnlrdGJxVDBDa2R3ME4wcDEwMkpTM3h0eEJwcTN1QkM4bkFtUUphSE5CUDV5M1VmRlhDRlljaVo4Z05IUzhDSkdwcm94ZE9IcWVReWlVVVUvc2JjVFdoN3p0K2hsR3B0eXhXL2dZb1Z5TzJrR2xqZDBKMkJwSjA1K3hiMndOZldZYVNmcWgwbXBzZmFSYUp6eThRcnFZaGVWQUFHdnR6RS9XSTM4UHJrZ1dFaUpDUm1LZmdFZ0FJQ0VZSEI4aEpKQ2dIWU5wWlFWQTMrUGtJTERBWUJJQmdqRmRBa1JraENnRUFKQThBY0FQZ0tBQUpnK2dwZ09NOEJRQUJBcS9BTUlvN1dPMFQvSlRISHpVSUZBSVFDZ1lBTUFRY0tnSkVnb2hnSkJFVUFNRm53b0JWQUxFNGVnTkNFRUZRb3dEQ3pSOXhnT29UWmtITTIwZkFRSUFLaEJCWGs0WHpBZ3dhT3dKUnhZRTlIZ3czUUtWcElWSUY1NEZpRGhrZjlIdzJtQmdIcW9BWDZoZHhrY1lTUU1Qc0Fjbjdoa0hSQmZZaUNMK3cySGtFQU1RckZoYnZBQ3E1d1kyRlNTUFM4eUVDZ0FBaGJKQ0FpaW00WmNNRFBSdUUwaTQwRkpoS3hQSWt6SjBUc1owOXFSRXRUSjdFWjlGVm9ab093ZW9xTXZKTytDSmpYUnNqdE0wa2tJYUNhWFhZVHRyVDdJbzltMFhPdXdIdGhudG5LZ0VicVRmTC9BekVsRTg2RWtwNkNncDlKaVlFMmsydXh1QUV3NFc2UkV1QkxZNVA2R2h6UjZRdTlDSkpUa1NVSW9QNEhxVG9NYk1Uc0cxSWprTFJGcGJPZkt0djVTWWVGV0FUZ1UzUCtFUkNBQkVJQUFnQUFKbjZwSDREaEhmSUJDYVBrUFJIRVNBZ1p0SCtLT0VCdUFDSWdBa01nUTJBSEFHQXdDRUFPQWdhQTNnZnZTa0lzQ0lBQUFOQjZUSUFCQ3dGWUdoa0NkeHluRElQNXVRS0xNUUdJVUdBQUFJSDRKZ1VBc0FFU1lZQkFjZ0lESUdRQUFDQkVBRU45K0lBQXdDRUNQRUlZRTBRUDFIeWdBMERBZ0lMQ0JFUnlFV2pteUFoeG9maUZoTngzOUNnZmNIZUVOaUJMZ2hwUUJCZ00zZ2tvQkw2SEdjR0ZGRi93QWhzQlE1RXdNU2I4RzNXVUFMMWlKUkZ3QVU3QWEzaGdBNFpvZUFvQXF1dkFCQWdHSlFnbUhIa2d3RWtyT1FCWmcyV1RrSnk3UTRYaE1UcGlmZnNTQklFNmI0N0hjdkdKcUp1WDRqN1pzZzQyUnR0eE9JK3hzYjFNNGt2Y2JuQmJ2MHVBSzFjNnVXaUhUZTNTSE96Y0lxMFRTait4NlNPS0N2SWhWdUNIcFBNTGdiTkV4YkxwUTlCU1ZWSW9pTmVPeVBTTFVTYU5oR29yZVBTWE1sSjlNUUhSUlV3ZzViZm9ST1p4RDRJaGhEQk9FYUJFRWRPQ2VRTi9sSWdVd3VCcUFzRXBpUVNHRkVNaWZKQnZDWVZPc3hWOGZGcDFZdGhzTFdBTmZpMUVGaEJnQVNQZ01kRUdrQWc4Q3NCQUJBSlovRFFBQ0VFQWgyQXdZalVRSmtBQUNnMGlDWjJ3K1JGQmtBWUVBNVlPQUZDQjFSeXNTSlNobkE4aExUK1NTQUNoQUFBVklRUUJFd01nOEJ5QkFpZ1VBd0N0QjFERUJZQUFVeVNxbUNxSkxnRXFnSUVqZWRBaGpvNXZuRElRQUVvNHNRZ0JBQlF4QkVTSTZBSFlNQUVQZVlSWUFVZzJrV29URXlOTEZaOGt3b1RmRTJmZVFQZk1ub3pnSXFRTFlJSWNoUTJSV1FTbWdhQUtvSjZnczhnSEFTeUFBUUNYa0JBRTBEQUw1RGR2REJ3Q1llSkZFSmh4K21MdCt5azEwQktWUmxFd0lOSTFKeTQzL3pKcnZXenNWTmFOd0p5cDNmL1pIbFA4VWlaMldrTmMyTEhJSHRkaW9YVlpWYi9qa211ZFJTT3oyRXUxNE8rRDBMV3FlMktVamtDelB0YTlscGFKTkgyU0ZNTnF1TlRTeVJ4VE1hRndxT0E1ZGlqQWJRZEcyUnFPU010Q3VqaEQwb1h3ZkxoRWNKdldhaUoyWS9FQUNhTmVNY29SditLUUlBUklRRUlnQUdEbGtBQnA2OGs4b0x2NElBeEFnQWhFQWdBUkVSbENra0NCNkNJQlJBTksvQ0FDa0tUQUNCRmdRUVFjbzBJYWdOUjhRaUFBQkhBUUw4QURBSnE5NUFBRGN5S2tMVENiZnl4a0JBUlFDa1FDQUFBSUVBQVZEUUJVUXdHQUJtQ01JS0ZHQVdFVER1SUJFQUUrZ3lZT2NjUWM2WG1vNFFRUUFSQU5nUXZnQUFZQUFSQ3VRRjJpR0NacHhpR0JPd1JGTkVtRUlkVThDS0ZQSG1GQmprTy9maGdRd0I2QUlRMnVDWUNGaThETVFTaklhWUF3YytJT0VrTXZRYUNDelk2SGlBQUFJcGRneS8rRWpxQURCOGVCQUlCQUFRQ1JFRTJFSWdmMGhGMVJya1p0MVQ3eDFDV1U4b1Fzc25mMGR3eWRDK3FKMlRodUNaU3lsQzFmMGpabXNTNTNKTnpRbTJhQnR1NGlUU08vWWhmU01oMXg0U0lYYXZadVN1WjhwN044b3dmVXJoMGxpV2I2aUcreG1SMWozeDJXalZGY0RoQ2JBbVd0bzR5Z3FyWk45cDkwU0tZSE1mUXVkMktxcUgvcUowSitBQlFJUlRJME1Td2tlakdQMHZrdHBkWDhRaWlzcWY0S0FjRUFQRktpd29ONVlrYUh4THRyeGlqd0pyL3dBSWpBaGdJZ3dDQUFEZ0FBSUJRZ0VBUUJnWFEwQVpndUFBQ0dBVWdBUUVDd2lGb2hZTUFFQUFuU0JZQWFpQUZoQVdUd0t3RUNLWUk1K2hjdElyakVvbWEvaUlVR0JnQkFDU0FBQmNuVUdxSkJCZ3FCSWdVUkNjZ2lZZ3B3RUl4QUcvVURBeW9EUDl2RVlnS3dBQ3E4Z3dBQmdRVDhZZ0JoSkFFUXNCZ0VOSmh3WWNCUFdRSW5BWmp3UkFJUG5CNnZSS3NvTmJYaXBqOEhVb0NXQmxDRUNRYk9Ca0tOdE5kbHFHQjZIcklnQUVwdkF0Zmt4QWZsMDhBZ0FQd1VDbUFEZ3dpZnBQRUFnZ0FIWGdpUU55Z01IZjNHRUFFLzNna3JoVEVtU3pqbURzSmdwRHF6MklwV3ByYTJUdnZTSk1uVlo2K3lxdSt5R0cvT0FXemwvSGlaeHVORFpCNmxJNGZLN1NzTkppeVB2TTJ0TVNtSm5qRFA4QTZZRjBUblRSQ2pkYURSc3JvdENKaDhrdmtoSTBxQ2FiYkhvTGR0Vkxib2hsb2x6TXFTWXBZdVloT2lLV0wwdjZLWFlTL09NNkFHL1FURWVsWU5BaEZ4eGdNd0NDVmtoN2VSUXovZ0tVVHI4QVNnaVQ3SkVQYXJMRUdqWVpEYU1CYjRDM3VCTFh3RHArMHhUbXczeUFvWUUwQUFBSklBSUNCQVlCRC9rQUFRVXNKSWdOUUo0SUd5RUZrQUFCQTh3ZGdBOEFDQUFCQUVBUkFCcGdFWGdBOXlBTUFHUkp6Z0hnSjRXQUFBRVYvd0I1Q0srUGxBUWcwaElEVWt6QUF5SEFMNzRUQXFnRDVBSUJDQU1nMDByUWp5RXdBTUJtQnNTT2wvSUkvQ2tHQ3dDQ0NNd0lFQWdFa3BnUEI0QUJFTGoyZkVoQTVJS3RhWEF0QTJPVWdBRUlEYXNCd2NCWWtlaUVzeExTNnlDNk10eFBDUWlwaHdqbkE2eUJTSXdZTitZQ1NpUnNHUUlSQ0N3UElZQUVBZ1l1ZkNjQW9Ta0MrQUpzd0JUc3hjRllmVEEvYXhWalRJU2xjMTl6YXdMZXBhRzF5VkxYVHJaN2Q4a0tDZG1sV3d5WW50ZjBLTTVoU0E2TW4rUTdYNlZCRVh6ZE9ST25XMDFodWlUSXJjWTdhcE9JVUtoMHFPZ1FacGJhMGZzY1ExNWJLSlZ0L3dCRXA3Z3BOSUY3Z29UZDRScjJLY2pGR0RVQ2p3Q0lPZHNpNW9EQkRrQzVRcGVBRUJIRDlDQ00za2JlS0Q0Y2FrdWZPQkVRQlBnRWpJWVFpQVFJRHMvTTUweEVEYVlHSXdBajlZZUVDVmxFVUFRWi9maS83djhBd0dJZ0NHUUJBQmdBS0JJQ1NZQ2dnVUZzQklDRElEeEJCcWhBbDBIQUFXQ09vQmlBaG9EUUFDQUFBQXpCb0FEZW9odDVJNE4xQXhEQVFDQklBWlFBYzk0ZkFnRFlRQ0NHazEvRUFGQWpnR2c4QXdlQUlnZkFyQXZBR2dJQW0vdmhPKy9BTlFHNEFNSUNoekJpQTZIa0VqekJxa2dmNW9FRGd5RUlRSWZNUUlhQTJMQTFoeUZDRWtHWWdFZ1VMckNsTVI2d0FmaWdRa2t1OEd2YndBRWIwSUVsWnJaQ1BBRlc0RkEvWUVHMGdLZzVHQmdpTEFpdVgwT0JjZS9FQVlBRENEQllIZ0FMQlJ6TStmRUJoVHlPUjFFV0VTTnBvRUJ0Z2s4QzFoU1ViSWhUZzl2WnB6RDhNU0VvcjFCZGtrQ1V0MlZBc09FTklabkloTGQrQVNWcWMyY2lYc3NkYUpYWnRqdEd4eXVDRVBmWTltWk0vZ0lSV2xGc1JXNUYyaHR4R1hTbXhnNWQraFNiMFBiSElMWXIyQzh3NnBEVVRmSjlRSWVRZ0Vwakh3WWhUL1FaWFRHaERqbkpVQnlXRFM1UEZNdmpBaElFZEN1TWVNaFdNQU5hQTdBbFJTL0RYalFNSUFBSkJ4NEpMZ0FWeElqNEdBYVFrQ2VRSENBQURUN0E0TFJ3WWNmQUFCdzhRdGZuQ1JNQ0FCQXhBVEFBVGRtUUFCQU1nQ0lNUUJRQUhFLzQ3QTJRQWI5QUZBQUtrZ2hnQmdBNkFFSkFRQ0pRQThBTWdDcEFmZVFlb1JLQUNQQ29CQUlXSGlnNVVCT2I0SktobEUvNGdCQU1nRkVBQUdBa2hHSUpBVEJ3Q0J5QWhrS2lJR3hIOFVjQTFBRWdnS2tPUU9BQUFZaWlBQVRDa0hTeEJDQ2dBRlFPUVdINHhyYU1KeUJNdk1CRUlBSlFJQkFBRzFCQWQ0amNLNUNZSUNqeEFKbmFKN3BXU0xRWW9la2dJa0pzZzZJUW40dUh3WjRCYUNjemdRL0RnSXNBRVJnbGxnQUVNQXNHd1JFRER2Z0lCQ0F3RUdIbnJDQ25HTmFFbFFCV3cweVYwTm93NVRpc05qUWxMZWtTUXBTVFhZdG5QZWFhSVVvdUZOc2QyZEFSUytnUGFKV0dWZkl1UU5CVzVGNkZKUUVjcEVpQSttVjNYc3NPMVB0RGZFR05ZcFUvYkhML0FFQnFVSXRaUTJLVFJMOERiT2FsZmxoQkNyR2JFR3ZHQ20vWUtRaUNBVGp4UVc0T0FlQks4SnVKd0o5Q0N2OEFHZGZPQXpGU3k4eEZ1dzBEV2tSYUQvb0VUbEt3L1FBa29DMDc3Q3ZDSFNCdVhQTDZEY1lDbGZTd1ZCamZBSWRZRVFnd0FDQUFFQVFwM2hhWkFXRFQ0aEcvQy9rd0JHaEFBUUJpQUlnUGtvRUFrR2drRXp5TkNBbVNvUVNJQ0VHRnpFSW9ZU0FaZ3BrQVJDQUNCUFBtQVJRQUFJYUFLV0FXU1p5YnNBRE9BQktCQU9DTjFqY2I0UjcxOG9BQWhFQUFvRUFRREN5c0FDcFFDRld5QlFNR0Q0UUFBQUJBREJWQVp3QUJ2eUFHQkVQRlFBQUxZWGFBQkFpRzZBQUFUY0tpK0VFR1FNR0pieEpBZEpSWHhFWG53UVR5MlJiK3lud0xBQUE3Z3NpRTQ4ZUJGQVBFa3lxRWZEbVVTcWtZQ1d6R3A3WGlBQU9Yd2dBb28rSXdBODRJQ0VhQllTbERiU0VzbEUrNE1jNkNHejBFUUl6STNGMUVnQUlkUXJkbXg0NnJUU2RDOHlpK0RPMjdnc2tNbnlzaGExR3oySnFkbzEwU1RGL3VPVjc2UFpnSHNHdVQ4bEZOMGV4a0NIczZIUWpRSFVFM0xFS0xCM2loRkE2SWFZYmdZT0ZMWXV0QnUyTW14Qk1pQUVzWGtKMVBCTC9KY1AxODJZa1dsaGhRRUFEMEFlQUpBQ0lBU0RpSjF5SzBTR0o1Z0VRQUZGRVBBSVlIQUFBMm9LZkdGY2dFaE1nYXdBYVFFMEF2QVFCQUdBOXpiWkw5NEpNajhINmNrVndWNzh5UWhNQWdCZUh5REFpUWdBZ0FVS0trSUlBQUVvQUVRRUNBSTRZQUtBRUovaktzbWlBSWdISEFBOGtBQURBb0FBaGtBQUVSd1VFR0JzSWVCUUFhS0ZFQUNtSWtDSkF3QUFJeDJ4eUdoL3R2RUF2SUFjSjh4QWdBQVlDd0thaWpBT01LT1lBSUVDc0IrdjhBaWhBQTVEc0ZRRG9ORVl3RFFPQ0J4QUFzQkRDRWdCS0RRS0FBNlJ3QUNJQ1FFYmZ4Z1JRdGhnb0VDQTRBSU1aRXR0aGdmZHNCT3BnQjVNMTlrYXdPY0FHOEJZa2E4QW9BdUFFbGtBUnBrZTZtQ0dDOElCRFppY04vNEpHOEZaZ0h3QXBiSU1nRVRyNG05T3JnQUlrSnBLY1F6cFlKQW0xb0p3QUtEaVRqaDhrZ0lUMjlVeEZNRS92d0tYL1FKVmpnZ09pVE9nU1pmN2dsc0RRZlJnRTB6TUkwNmFJZG8rLzZrdWV5K0JMMDNnYXJKV0RZcS9zVnc0K3hKTGVzT0pIUVJrWUhHaFlRRVViQXRLMTQwQUFBaEFibm9TWWdGUmhJa0dSeDhhdzJOWXJNUUdlSG9BQkJZSWdBRUFCUGdRUXpRY2s0SEk4QUNQVDhuM0doZUltZ0tVbU9RQUNnT3MwRDVRMmdlcVFWd0FRNEVYZ0pvQUFKNGdvQ1lZRXdEWjBFaGgvOCtRQzMvS0VBRWdOQUVBd0EweFlBMkFJQlE0Z0NpTWdCTXNKSUJXaGlEa2dIaUJIT0lvQUlRRFlDUlY4SkljQUFjUUVVbWZLRUlRUkFLU3dCU0J5QUlBQkFnQUdvSndBd0FRZ1hCeUp4aVJReWkrUUFCQWd3Z3NHemhqUnZBYlVYeGZHaFBhQ1I0R0RCcEpDL3d3R1JPR0RBQVJJNUdDRGhBRWdPZ3dvWFExUWhVSUFnQUVBT0dCUUEwNUJnQ0FoZCtadzZhTUFDUWtvOElEY0FJemFZT1VRc3dVVC9BSVBBQThTdWJQUlZrQUs1US83UUV0QW1qR1U1Y0JBSXNCUTRqZUdBQUJ3WkVBRWdlRDFPTUNabVlGSUdCRDJQZ1E1b1JCemtnNWcwUWFBRVgraFIwd1ZQWEkyTFFYTGVpYm5PRTIxOUZGeFBSS2xIMFNUUzlFTnBGa0c1NnF3TXB0WC9BRWFXdjJNYUowZXpaM1ExaW1LYmhQNUhyYmdnK2liY1VIYlVOSGFQUThJUUpIUk5yN0pGNUgxYVpBVFlFRUpuZEZzZzZNQjJGajZUR0RDNVBnMHgzQVlHT2NXREtYa0FISUFuaUJoRURCZ3cxcFlCU0JYYVJid1lHRG9Kc0lTaDZFcDAvaVNBWEFIa0FBRUFoWUFmRWhSUmlRd0RpSVdhRVFHRWhKQUZDQUJnQkFnQ0FDNkFTVWVxSTlEOTVIQ1EwaithQUFBNEFCQWdCZ2hDQXNRUUFBV0dEU0lBcENFRUJEQUFGSkFKQUJoQUJBQ1VEV1FSQVVDUUFJYUlGQUFxb1FKRFkrTkFBQUJRQWpFTWdBUWdpQ2dEYUNHNERBVk16a1VzdXZqQUVReTRBQVNpdGtFb0ZrM25DQlY4Sk1BRUNBUUdBd0FDRUFLSXBYK0FES0EreVFLQTRjdlBCblNjUVVZalpRTm9BaUJvUllFZ0N4VUJwZ040TE9ud0lrY0JpQWVRSUNGc25pQU9BeTRMQWFkd3IwVERKZ2lpaFVDTEtGQXRDQnVncGwwRjUyT1hYTUE1SXcwQlVFTFVGR0FBa0hYUmhqN1RHQXM1Q2dEa1FEQWdKZnBNckJrNzRiQUtBSVVJTVdCdzFvWUFURklVRkoyMkZ0ZitpQi8xeUp5MDJtWEdEWjlxZ2M0VXhkc0tmNzJSNnZwRGs2UTJ0Q1g0RXRTbCt5Y1NUcThKcmJGMk5Kb2ExWWpEVGd5dHN4TmZwSUVhYUNlcFB3K2cwSU5uVGhENFVQcEJQem83K0NRZ1lBak9nQWdVQS9rRURHR2NRSnNZQlF6M0FCaUNiQUUwRElnUmdBQllCSVJCRWJDS1ZBeVNxSUdKMllBQ0FLb0psQTJBRlhJVnZtUVlnZ0FRRUZ3L0dBVWl4UVJvQWFjZ1JVQ2dEVWdnSU1JRXJlU0VHVnFBZ2tlb0x1WHpBS2dFRENBR2dBRUl5RUFDQk9Bc0NBeGg5bUVBQkh2NVNBU0FVQU1adzFFQ0RJQXlHSUFBZ0I0eURBRFVKQUN3QURRRFFEcUEwRWdRTUFHTUllUUkwZ0hNQjRJQkJZWmZFQUFocU1mQjdBR0hDV2FaZ3dCL0lZYmdQNEdnREUxQUtCRFQ3OHdBSUNBRUFZM2htV1QrREQ5UUtiQ1VEZUltZ01iMEJSZU9BeDVBQXlBaVlDOEpCVTRieCtWMUlmR0lKQUF5Q0FBZ2dsSzFsQXg5K1VRcUtQQVNBMU1GSFVpMWk4aUdFRWlGZElEYVBoTWlDVUdRK29oSDhGUmdqN3ZnRnNISUxRQWdESFVST0RwSnlCelRJSEJMa2Z3eXIvY1ZOMEZGRy9sbk0zUGhEbDFkQ2ZVL2cyMmlZM2xZaDJsS0M2Y0FEVk43bGtpWnNTek10RWxTZm9OTXJ4Q1R4SjJFSktMRFhzVTFQYmd0VkFTVnl5RGtHY2tvbHhQMGVudlJJNlFyYm8yTGdjK0lEV3lDbGlJY2hBUUR1d0VwSExOakVQeEFDTXZnQUVXa1hnZ0ZTaGdCSUJSZmxlQWFBM093RmNBZGNPTjBGc1BBaUhvWU5BV3lkaUFQbTM5ditNQ0FFcElYd0EwMUJzaElBNUlEeUlHT2tMd0ZNQ2NBZ2hnQUFJZXhVQnZjZ0JvQVhHUVFDQUFBUUFDQWlCZ0FBUUlJQUh2TlJ3S1FpUUNBQkFJQVlFSGtBcUFDYUhuZ1FTQUhDSVora3hBSVVGQTBoOGdRZ2dXSVJNQ0RQQUtpQWlBT1FFMElRTUFSdXI2RDJzVDkvQ04yOGRVR1l2QkFmaGlLUS96ejVtSXdVOGc3VVlVTXNzZ1FNQzhJRGFEUkNDMW9iQ05BTWNTc0FQOEE4R0hEbXNlWmdCc0FBSkpLcUFnWUxoUThNQkJINUFBTUJTUUpjQUVnSlFFQWFDTDBEZEJtUzhUckJGTzRJcVlJRVhUdzhIdkJMaFJjTExBendUV3NmNWlGNUFnU0NnRkhiS1ZBd0F2VDVPQUJCQ1Y4QkF3a0V3YmRiUDNaR2lOM0VJTnAzKzRyU2svd2gvN1FYTFFpWHBuOURva0NCYlNES1JEU3RqeThQMlhaeW1FVnZVakw0ZERwT3l1aWtWTklFdmFYNEk2TDNrVTIwMXlHaUdoRFFRMjZ5SjAyTzJRN2Q2aGRrRXlnbFpEQ1JibnUvd0JEeG9qUEtEakFFTkRmb1JpMFQ3aEFMSWloQWc2Z2l3dFJST01CcllJVVdueGdGOWk1SDJENWd3RkFCRUZwQVlnS0FBb0MyZ0Ivb0FUQXdMNE5BbVN3dXFhU1BPR1JzZ0RBQXlZUmdrQmQ3endnVGdvRUExb0lBVHdnQWoyUUVYNEFBUUFCUUk1SUdBQVFNSW5UZndrUWlnSUl3bEFOQktBZ0NTUUFNU0FJQVlDRExIaEJhWitQQWl2d1FHSUtLQVFCQ0hJZ1hCT3dBY29JTnNrZ2JoL0RBSUFBQU9DQUlJQ29Ba0FBQUFBSUliQUFTQkVBS2dxbVlNWUJ3SkFZbDZJakFiNEEyZXY5Q0FNQk53SUo1SVFZWVlFZ0NhWEJnVEJ3Q2dMUDRyZ0dGeVB3aEhBQWdhNFNvTVVFNHNBRStjQURsQ1BqS3hRZHdBSUQwQUw2YnN5a2FBd1FiaDhnNEFDRUFNSUFnVXhZZ2doNEJKSmw2THhKQUFhR2gzZ0JOS0Q3NjRVS0tFS00zRWZHaGdBQUQ4YWo0cWdLMCtZRGdBT1pPQWtCQXdRSVZRQTVEZ0IySG90aWtZQ0VsQ2h2L0JCTFhsOHNqYXVwR2hyZ1BMUWRDRzZKK2lMbE5CRTNJTE5kZEUxbHB5UkZhcmNFWWNlaDVmbUVpTm85ajFoMVVIMkxhb1RjbEp5QnRhT0NjeTJ2c2FXNVJOTFlURXlDWksvMENheEV1ejFZblBSSnFVN1JBRmthdHJJRVFtVm8yd09LbFBHNkVOSHpTd0FnQnVCU1dDc0VNNzR4QWNJRVFQeHNJWUZrRCtRR3BVd1lFcGhhQUFnS2lzQktiazZIZ0YwNk9sK1BEQWlHT0FuL0FBWkEwSU94QmdBM2dFaVVpR0JTUUF3RFFBTUFJa05JQWtNUU1PZFFCV24raHBrSFlmSkRxR080QW9JQkFBSUFMQUFOZ0dBQ0dFalBiSndGZ0lCUmxDVHNCQ0YvSUFGQUFoZ0FBQVFBT2dDVE1kQUM0RTZDTGdCWFFHTUUrd0FTWUFNQ2dEUWFoQWRNRVZTZzRxQWlDQU1EdGY3d3E4K0w4LzhBZUVBVENBS0x5RWJBMkNVRUFZUkUrSkJCQUlDd01nS0NZQUZnT0FnRmozQWovd0JoUUdyZmpFQlNNQW1TcUV4MlRPS01nQWNIeUN3R1ZHU1BrTS8yOHNCR0RNbUFZSlM0Tm9aRXNxT3ZFUWpROEE5NjYzV1pBaWlCM0FEWU1ScmhEWU1EZ1gzNkdzNWtaZjhBNkJUZ21UVHhBRXhVTUlGWWYxOWlZS3NIYi9NSEtTUzBBU2pLUVNEWmJhSC9BS3lqUi9mcyt4NFE3V0xvb29MWjFLK3lPdHA4U09aQW1ydmZScktmdVExbXc0UDFMeGhEcE9PeVNQMk9JZDVaNkJORFk1aXpQWW1Dc3JhVTlpOXNqWkF6Y2dFTGtDVGVFSUljSGpZb0V6Y2V5cTFmczBMRXU3ZGtxRXdaRngvbzJFSEZ4V0FLYUgrUFNDR0VBYlUwQVI0Q1hYOEdRRWJzd0NvQmlpZ0FQc0I4QUhZQXc0QmVKQ0FIQWhnRVVBUUNnRGJEd0VJRFdSMjBzdmNBWVFrbUdRbXZRRWJYMEE2SWY4QUE1Z0ZtUXFBZ1E3QUFWQUFRRkFMQUJxUVllQUJDMHdwR2czOC9CTWcxditLK0RvR2dFQVZBQkFBU0FoTUFQaEhJQkRBZ0VFWkFhQ0VMQ0VJQUFna1VBRkEya0Zqb0lCNEFvSXdEZ0JSR0pBRHlJR1NFTkFDVWdBUlVac0U4WU1Xb0VHZ3hGQXdZa0ZNdTd6SEdiQklSd0RBaDVCRDRRQlVOQTdBVFNUbCsySWdEazhHRUVFR0RPNG12dmhSd0RTR1lOR0F4d1FGb0VKQU1FYmZGQUtqQXJSSGlnOW8wL2hna0F3ME1JSUJzYUFBRURERE5NRnpBNEJMd2plU2pvc09CK3dVTklPcHdXZUVDd1NTQTRzUVhvNUNJWGZ0WWF4YTRFY0VLakNPREcyZkdLWjRCREFhWjhBaHdjR0hBRUk1NEh1ZjNGeUpVWCtpYjMwbCtpYjBnMjEwYkRaVis1SXluZlJDWVE2TWZWQ1ZTSHB5bkRPU1paWk53OFBQb2sxS1pKRmRGbElRZElVS2JVaW5LeTFBYmhmc0dZMkpLNGdyeU42dGh1WGFiNi9TeDFlbmh4cUovWUxqSzRDbW9rN2pqNk9YZ2w2VHd1MnNBaFFWSDhJQUFJeFNXUlhZbVg4T05nRUF3Qnc4RWtEZHhBZFhBQ2tJY0FCanI0UUZBR3dCQ0lCakFEdGdCZ0FBTjhQY0hPQnloQnptUkVIRVdnTmpoQ2wySE13OHhLMFFRalRBQ1lnU1FJV2dtL0NVRzVEZkFCWUFBeEFNZ29BUUFEUVArdWtoL2dBd0dBeW1oQUFRQUdRRU9RQkFBRWtnQUFnQUFUVStNQUFCZ0NBZ0FRSVFKT0FBZUNRWWNEVzk3a0lTOC9TL2hNR0FFSUVHRGlRTUVRZ0JBQUJPSjcwQVRvRHVBTnhnQXdDZ0FVQVpBRERIck5lQndjL1d2ZzZDSVFDd0RRaDRLUXZpUUNvUG9DZ2FUNExRUVBCb0FUOHlZTk1XZ0FnQm1DeENDUkxpb0luUEVJbFYyRFNBZm1OaUg4SkVLUW9GakVDQUF3SWdJS0NnWUZSZ1VLVWdDSzhCQmFEWGpFRUZzSUtKTW9GUmg3QTU0SXdiZjRDQVBJeFJiQWtQSmVmQ1VQcDhxZ0JBb3lNQjNZQ0JnYktSZ05YNklVcGhXT2hXTUZQa1JRdTJPYlFGbndOOWtrb2hYVmZZcE1RbTA1NEw2Qlh1blEyNTBKeXBkbGxLUnR5Q05aL0l0VnFIK2tLVWkreHBaWVhLazA0UXAvWG82cUJibzJJaTE5am5FMzBKK3lCRFduK0FTV3BiUmNOSzFjOEQ5eUEzWURZbUxXaUxmVE52NkZoTDBMQVgyQ1JYTEErUGRRSFNBZlZTTUlLOGZMYWhKeDBRTEFxRU1JRUNHbUFaMEJ4Z01ZUTRGQmRaRUxxK0FBQUF3QnhUQWFGWmVKQU1FQVVJbEVVUHdDNUg1aXBCbkFnd1BNQmdwUklJNVpCRnJRRWFIVHpRR0pDdVVDQkVKNElsQ01BcHExZUFKQXFHdGpoVGVRd0dwZ3hJTUFBc1FDc0hnZ0t3QWhBRzBBSXZnd1NRVVlGTlFNRUJFSm1FRmduSDhnWklCNGlBQXdrL09BakFsQ2cwQWlBRkFnUjZBY0FCa0FJSHdBZ0JJUllBQ0FzRWIwZE1Ua2tVVVNaQVM4QXpMQ1NMQnlBQmpOUHBtd0lGMmY0WUtSQVNBUU9BQ0JRSUFBRWtHU01CZ0JTQWRnRllCTVRmOFdJQXNFa0VSb2FBRUFBRkFKQ0lFR0dHb01qMEc2WUtvUTBOYkJJR1FMUmVCRzVnLy9aSU5DWUI3TlFVamMrY3pJazlTd0FoS01RaE5abkJTQnJQZ1V2TkpEV1hBOE5FSThXdXhRMjl3elRBUkhFd2lUYnNTdlpnQmJ5NFo5bVJ4L1lqME52UnJxRGxrZC9RMUNrNUpMNlJDSzVHUm9LZVZZelNsanpTclFrZ1BXd0pwcnlSTmlJcU4rbWEzVG9TcWN2YTVFblVoWW5vTVlzNU94YmY0UWtvSjUrbGt5bHYyRzdxL1JEeUlWQnVSTkhEeVBjUXlDbVdYU21IMS9teEtPNUI0R1E1bzJBQnRvQWxnZEFBc3h3UkVyN2tNaEJ3SU5BQmNnSDRBVGtBUllZRkRBcXRwV1FBSUlkQ05nN0JFSHdZaEtBbmdNSUNxQTJBUTFZRUp2aWdFMmdORURvQkdRd1REZ0FnV0NCQVJDR2pBazdjWUMwSWJmakRUQUhCQWc2QURRSUVTQUVBR0FCQUFJTmgvbWdDQUF4MEQ2d09TR1FBai9EZ040QUR3QWVzZzVnS0FBQUJrQWlBSXdBUUJBQUJBSjJCckFLRWdDVER5a0NVUUFCZ0N0RVd0YXJ4VXcvMUlpU0JQNEVndnh5Q0N3QWdISVlDZ1RKWURCVThJRWRCQVJyNEYvRTZna05nTUdXQWdBVlFaQkJCdU1sa1lTQkgvQUlVbkJFY0NTQ0FBSWZJQUNodUlBQ0FhWkJITUNPZytxTVFtbzhra0FBTmVDY2cwR1pBYjNPQnV0aWFHU05lU3dSSnBoRVBFRW55TGdPdDhvREFBUVk1SVFHREJ4VWwvd0NGWDc2RWY0Y2hYTzBrNUFTNUZsdytoeWFFQzdOT2t5a3FPU2k1c21GRVVKTkpEanNJMHBkaW1yb2lhKzZTSENCWlZ3VHMyNkkwa2szYkhQQVRVTjZSeHlXZXlBK3l4MU1NNERkNGJoRG4zY0NoTENEZUEybWlFcTR5NE9TVGM4RklkanJVbjhFRzZUb1dvWm9XZ3JUYWdFZ0I5Y1IwVEtEbUpld3IyQy84QWdhUTZyTGxPNEI4WWFQUWR4RGtUZU9RVzRBTjQvd0FFSUlZQWY0RVFFZGlGbUFIRUNPQUlGQUdPRGdJRWdBVlVzU3JlYURBYW5ENG04Z0VKQU9tZDZBZ2hHb0NGUWpsUmNRVFo4Z1Rnb0J6QXlBRUFGSG53NW83YkxJR2prbytNUUJnRk5BYUFCQUVqQlNBdEFEQUFBYU40UUFRQVpzT1FFVHdBQVNJQStBSUNSQW12K0tCZ1JBQ0VBY0VKQUdnRE9CQXdBb0FDQUFRQkJBRUFEQVVaQmJTQUxnQThHQWdnQkdYSVRCejA5clBKMEY1SUhKRkNDWU9Rd2VIa0FBQVFZR0E1dkFESUFCSy80YXdBREFIQVVBa0I0VVIwQ01Ob2tCbERnUkFBVUdRRElBQUFBRWNZOElBQkNJVVFDSHJDQk5ZMFlSem1Ia0U4NlhDbW1BNkUwQ01PWEJrK0hodVlNQU9VSVNrVzhDSUoxUHhzTUNRQTVLTUFlNVRrMGF1VHRGRFJQZm9rNXZZMjlwU29McHMxSFloQTVKYmpnY3BEWjZGUjBWemJKdUV0amgrNjRGb2EwS2M3aUVTUVVDRmVXU1NPRVIvd3hEYUdvK0JJcnVsOFlDQnI2RTZUV2htUkNiQmRaQXU3WVlPU0d4TndLNjZSS2UwMFhTdG5iWFpzUzN3UXNCbUFBTFJUZll3UmJmd3FCRVdTbzBCOXc1NUFBcEFWZHcreEFQRUVJQklzd0ZzeExBRm12bEFwR0hnQXd3RzRSd0FjZ1FHQWdDRWdkNUdjWUp1RXhTWUpraTFmOEVZMEJqQWVBQmZBSGJBbENBNElZSU9MQkFOSVBBRUlkQUFBQ29QOExHLy9BRlBpQWEzOFV5RUdVYzRGWUJRVWJBa2dBZzBBRkE0QUlFQVJoQ2dBUUJBTG9BSVF3U3dCUGk4b0FRQjJ1RUFBQitmQllBZHFkUG1KaUFFa0hBQkpBQVRvZEFBSUJFQUFJRlJBQ0tDUVJWdFBDRDArNFhBTElGV2hkZytxUEFRUkFVSDJQZ2dRUVlid0VEOER6OEZBZ0JJQXdPUlovd0RteDhBeUFMQTlnTkFCZ1VDQWlEZ0FnUUdBV0FTVUFBSUZTMkJBSmxDa0NqKzNnc0U5REkwTFBGa0FLNjh6RlF4b3dnMWhGejRnV0FqTkRCUUoyeXJYUG5rWUg2eFVJMGpOU2d4M3IyeWZyNk5nUUpKYktWRkNnYVVjZGt1QWpzZGtjdHhFaWU0dGt0UlExdXl1YktZbkQwT243WlRNNk5KYmgva1FoRlZ2UU91WVViY3hra21nVWxSYTVOWE1VcUZuV2gyaFRRcG4wSklFMDNzZHFTeWFlT2ljd1luM1J5ZzVnNlRDRFdVRGR4Q1h0dkFpUVFwZnp3QUJ3SUZYMXVnQm8wUjRKR0lBVzFZQlNnQzFBSndHQUlBZ0E4b1Q0QTl3YUlBa0FBQUFDaHIrSVFCU1NIc3dISjhBVEJvQTFLUllnQjZBQ3lBc1E0THplUkVSOEFER0FBQU9nQWNsK0lJUTBnQXFoQUNzVEFOQVgxUEp5QUNJUVpJQnNNQUFPSDRBQUtBdGdnUS9nUU13QWpRQ1NBZmdBTHdZRllSSkFBVzUvQWdiQUZBQ0FBUkFDVEFLRWdEd2dLdVFyQU1RQlVER0FDd3lDL0FEMFliVDVBNENJQXlIUVNCRVhnei9BSU40QW1oNkE5c3ZBSUNDRmNoYThHU1dRQjhBb0pCSFJDZUtuakJFNURSTHg0SUNnb0RyK1NCb0JBQUNRQWNaSWdRQUFJQUFDQkNHUWdpQU1nWUNRbjdqcUVnd2RBZWxaQURYWWtPZnpFaUdnYm5RUndCMTRBbnpXQmhSdWR0U1d5QUlTK214cFErbUJINjRsWjhxbk1oRW1DRURzSXRCMEViYTUwUG1HeVZiWklPSGtxaXdpOWtGS1NFSy9JbkRadldock1JY1dlb0hoUkpJVEh6UitTQ1pjNW9qNUNHdjNENHc1RmJBMVJEY1M3ejZOK2JQOUJud2dwSHNVRUJYbUJ6eU4yd0VaQi8vQUVRUXpyWEE3YTJ5cHRvNm9XbGx0N080R2tUQXRvZE5nTWhhVXlBeUJKNDAvbVFGVllJK2lPVWlmQVFrQ0E0UUFRa1BDQWhnSWdDQUh3ZzVBQTZnZklCR1JERDZDQUFBYURvNXNNQWpDT05iZ2p3R0lHNEdLeEIvRENBQVFCY1FEVEJ1QS9na2hoZ0dsQkdZQTZBQ1dGUUZoQk1BVEJIeUFaQlhOdnR3SWVJQjVwL2gvd0FCa0ZWZzdRaVFDcURSRVFXQVdnTUFBQjZRQXhlUXdBS0ZESXVEaVRnVUJRT0FRQUZBUUJDQkRJQUVDUVNRQUVCa0FBMEV1QUdnRHNBR2hJT3dPQXdCcEFrQVUzbUFBWElCQUFVQWVNNzl2aERIQkdCY1pFWVFoSGpBZzlBTVFDRWY4SURRS0lFRklTU2NCb1VnR0tBQVJCQVFzUVRCQ0FnZ2dLQ0lJQTRBSUlEQWdnVVFxakFva3NUMW13YUhaQXlrWkdnSDVFQS8waCtkeGhndmdkZ0wvam9Fb0JnMkVKQ01OQ1lRQ3dFZ29wbEJnZ3hTaWVHVW1FSTNKTmpJSTFMTFcwVi8ySEZScVliczNLMlI0NEdVOW1Rb2JLRk1uTVFLNmpnVDNRUWE4Q21hN0VyYUxSSWpaZGNLY3ExMnRqTlU4QUZNYkNnMjI5a2s2UnM1aGt5MmdtazVhT2FleU5SZkpMdUJIcnRzaWxyN0UvQ0pZaE1aeERRQW53VitQQXlBRVFaQm5rQWlaRTdRRldVRW9SZ0kxZkJjb0E3R3ZBRS9CR1JVQ1lCZ0xsUjZFYUFCZW9LZmdsa0E2QUJJS1FDNEkvYmVneFJMcmxZcGhQYURVdHFXQ0hnT2dLSUVHRUNHMi93Z0J0UUY1QVBDQUFjZzduQUdKRVZ0Qi9RaEpCN0FBTEFDb0FNQlJIZ0FnQnNqL3dCQWgrTUNJRGdGQUI4QVpBZC9BVGdxZ0lKb0xBQVdpQmd3UnBUSUlVQWhIWUFDRUFTRUFGQUpaR01DTUVIbC9FS0FJQVp3akRnQUFKZ0N3QXdXQ0ZVWUFBWkd4R0FBQUFBQkFnQmdDSjNvQ1Z3UTBSaUZoRWNLNWV3ZEhDa3ZHQ3dDUUFrTkR6UUZ5TUdCV0RJOVMvbG1oWUlJQ29QQUFFQUFNQUFHQ0dFUUFrSUNoUVlNQXdMeEFIdThBZ01RSUdJUGFMSk9LRFl3VUZvSU9VdDRtcUNlT0F3bndLQUFDTURnZFQrQzhFMFRnb0FRRU1FSUFBZ0dvV2tqR0kyMm1JMnFITlVpclRtdVdLVGx4NzYvS0ljT0JFS1dJS21VcWdaYWpzWFRZK3NFRklhSlp3WEJKUFRvalRVa3gwaHVraEw5UWZkb1NuMkxRYWZjTTF0UXRJSU9vOVZBUWtpa2xnK0VraEhweFAzU0Z0d3dkejdFNFJhb2N4T0FUYW1BSVJyc1BlZTEvd0E0QlVpRkVoUFFnVUdBQmdDald0a0NBZUFPQ0FZQStVQUVBZGdrQUVJT0FBQWtZQWdCRUtnUFV5QklaSUszRnFoMG53Ymc0V0llekEzNGVCMEFzZ1RVQkN2RklCUm9IakE3R1FyUDhwQVlTUm13OUdxRklCaEFrZ05rUUFiQUlnbUFBLzhBdGQzOElCUWFSZW5pQXdBRmlBcUtBRWdtRC9nUUFXaFFZQUFIQ2dBa2dnd0lBSEtCSUFFNEEwQUNnRVRHUUNvRHFvVEFFQUErRUdEYUFvVWdTSUFBR2dBWURJQVFBQWtBQUFCQWhnQWdEMWNQY3dlQjlQaFZObzdIU05DUkVBQ3U0SEJFTTh4Z0NSQUFRSHF3SFFTdjRCQlFVQkJWd2FBSUNGQjBpQklBQVRqOHc1QkNnQUFJQTV3UkNBWUdFb0hRQk5qeEVOZ0FQM0hqbzd0TE8rakpYUEovOVlEMjJXVldJS2Y0NldINUk0TFRHV2lMUUNEWWxtaFFhN1FlZzVuV3lhZHdnTm1LVUNkZ3RNSVFra2JwNjlFTGRRbjRDdFlVeTUwUklRVGhqc3Zsa2l3cTNJa3Y0RnkxZkFrNUJ3R0lIS3RnR29rNzlrTGRHcTlBaml5eER0a2FIREhXd2M4RW01UldrOW90UnlLY3J2c1lhVnRXckNldmNMd0JJbk90amtOZ2NnWEkrQ1NSQWNCUmpBYy95NFIwU0ZZRUNBVWlCc2dvSGdiQk1JZ3dnNlEwQ0xBb0JrQWFjSWdJQkxCQmtBUU1EQVVSRi94ZE9tdE1uc2hFdGc1RFRBVTMrT0drQjNFcm9BV3dmWWc4eUNPZ0FDb0E2QkRJSVZIRk1SWGg5RU1qbjREa0tLQTJBc3pZQUVFU05tL3FTd09SYjZBbnpCZzBrQVJxWTZBd2dTQVlFQ0FnRVFDT1FmekFRQUlCUUFoSW9DT0VXTUNYQkNJQUl3Q3BBRkVJSXdvQUFBY1FDb0FHQUFSQ3lBWVVBMEI0SElBQUNBQ0FCS1Z0am9lQW9RL0FBT3A5angrRlFEUjNNQUcvR0NRcS9oaGdRcWFpaVFnRmt4RUZBMWJFV0lJUUNBSVRHczVEUUZVWG1HQk1EQk1qQUU3UGhKRVlBUUFHU0pIMzhFcUxnTU5DQUpFTVBTbitaaXdPbVRrb3g0dFFhZ0JDQWdBMDQzdjhFVGdZZVlFQWlmS0dDZ3dnYWJFaFlHQnA2a0pyMmhOdW5OanRveXpKS0JpZjlDVzJPNEpZQktxa1NTa01RYmVpQ05zWnMyNGlrTDNGYXpQbDhES1gySy9zSnAva0wyZzFJOU1aMFExUG9PVW9hRUZKcEZqN0czYUxoNU9kTUVLeVEyaFR5RXl0K3lFZlZCczhlQ21TM29vMnZZNGhjSEJGRitDZ0tKaUVzSVZ3SndnWkdmWEFaRVdsOHdDWVRMQWRCSEFZQ1JnaGdEbUMyTVdDZUJpQnhMUU1hZmdBaUpnRmdWanhpTUhBeUVBa0wrVUlDcUFQRFNBd0lBU0I3TUJ3Z0cwRWJsQUdEQWFTQkNLQUNJY1NDQUxvZ2JFTUFBRUFSUUxFQUxJT01MRXdoRVdRRHNmOFVBSFlnWkRJQndCeUFDQUxDZ2drSUFBQmxnQVEwQU5RQUFFU0NTd0JnQUlDa0lCS0JBQVVBTUFHZ0lDMEVDZ0VBQkFBQVFDQWdBUUtnQkRRSVFBQW1JZ0NzQUhFdnl3RjhleU5jWXlTUVFYZnd6VW9KQWJGL09BQUFBQkVBZ2VHTDNRRXdSSUF3K0NTQjhHQlJFRUlSQUFLWUFzQVBoQlF3R0N4Z0lUQWt5WUlVRmc1THhqaEVrMkMvd0FnUi80a0tKenU3RUx3d2tBckFPVmdnd0JuS0NaL0NQd3dGbW1jczc0TVFxT0FnVHFCZ0hzNXd0ck9COEUweVJjeFM3bFZnaktVVVZiZmdmait5YmlSaTFJeHBwdFVtaTR0eUVwRmxLWWdNbUExTm9oSEpCbzhrQk5PbU8zS0JhQTZveHJQRmp5NUllZ2dsMDNhTHV0NFdHV2Z3ZDhCR05pMkZQMEt0cWpraWdnQ1draFBWNHZ3eHcvN0o4QWl5QnNHRUFKazY4RU1TSXBQenRKZ0NoNUFQUUJvQWVZb1VJYUVOaU1NQnZnd2dEQWNVeWkyQU9PRmhmTVVqNE1FckpnRVFlQnZvbmxqQmh4d25mQmlrSWovQUNBY1FRNlUreUE2NENWWUdvRU44RXR3S2dDZ0JOQUp2aURDRVNWQU1BQlV4QUVnVUpJREZBZWFYbVFBZEVCTC9qWHJCd0lDUWtlVUNCQU9vQUtGMXpZUEFBcmdBQ0FHQUFGaWdDRUFDQXBBVUFJZ0RxQXorRUFISTBoQVFBQklJQWFBQ0lnQW9RUWxBSWRBUUZJSThPQkZBbWVJQXNBQ1dHNlk4RlFZVzdUeDRBQ1d3SU5GZ0JDeXA1TmZ5RVpGTUdFNFBRUUdnWURRay9ORm9BSXNFQlRKbW9FQ1lXQTl3QUVQQUFBUUhCcUZrQi9YQ0VUQUt3QnZXTmh2L1dDOEZmNDhrVWh6UndiWmlmbmhxVmd6TkMvNG1RUk9VQWg0c2dqQVlrVUl3QUFDU1UxRytPU1hFY0syckpSSWM2RWN6YUMrMW9icFdLK3hNTlhaMkJrbEphb1pSb2EwaVdla0x3WmRDNGJtSUowcW8waEp3Vjk0ajkxQm9MZ0pUL3VKS1hCcVlzMG53SzJzQjhxOUFVUFZoKytIa1FoRU9sREMrdGd4Z1ErUkNDaUlpdFF1QmpleGRlaHoydEpOVm9DckRLd0hzOEFBb0VzK0lDUXRpSXVKckEvaUNnZEZYY2FKY1lEZ0EyQUVnMWtoWHdBREVRRmNDcEFKb09RQmpvS1pKUWFRWU5nSFNBbGFCQVlPU1lkYStVRFlRQXpZTkVBTXhCcGc3RWFEY0FRa0hwQWdiQ1BZSDRHOEE3N0dSQ0JmSDRBdHB4akFOQUFRUGdnQllRSW5YNVJBQUVnVGdFUUVBREFHWk53R0FST0FFLzhBbjRBTGJnR1VpQU5oQU1BWUFRZ05FZ2dZQ0JBRGdnQ2NRVWdZQTl3TGdnY1RTSlFSZ0FGdUFhQmdPTkFhSXhDR05wcHhJNUpFa0h2bUQvR0NRN2tHcGlrRlRnRFFQK3hnRzI4QVNGb005NkVXRTBaZGdvOGlCa0FCcVFBTFQ0QWpFQURBQndDVHVDNDhHZ1lIWVA4QWFsekxFbVFIc0Vta0hKZ2NLeUVCT0pTYytBY1ZVYjVIcVJnTjZLUVRvR3YrR0ZQVlBBQkNYN1RrZGdUL0FBcWFFS09hSThpUUlDWU1Rb0FrakNSZnVIOWpsTGIreEs1UW5YQW5GMlMxc2R4ZGtFNGduWkU2RU9JeW9Ka3hPeENrYzNPaW1LaU0xZE43Q25BSGdJV25LWTVvQ21yZGpkT1JCWHJqUlJYMkNKa1JaT3RCQnRnbTRFelN4cnpBSTRvR2ZvUXIva1pFSTZEYlVPS2x6WnlpY2dPa1FFVWk5alFCTml0VGxNVHQyUkNBRUVKcEhCaUFWcmdQcUw1cS9nRXd3QTZBRFFBOE1nWUdJUStBQWJVaWtET0lCV0FzUVFCQVBsQ1B5bUJnTjYwTkNQVDBYeWZ4d1lFQUtJTEFNaEFCZUNCZlJDK0l0eE5tQXhnaGlncUFvZ0J0Z0U0RHNvNENWUUJrWVFIZ0J2aHdBQlBXQ0svbGdBd3FORUFRQUFCZ0FRQUdqQVVBRkFZRUZBQWZBQVFZQW8xTUJBQTBnaVFaZ0NJRnh2NFE4QmtlRDVCeWdjQlFCZ2NFQUFCZ0Uyb0FZd0FBUWdOUUJvZ0ZRYUtITGk2L0EwQ1l3WTJsZUF3UUpielFBQUROUkRySEFBbEFROTRYRlVYQTN4Z09CcEVCTU94YjhBL3huSURRa1hrQ2dFb0JhVERjZ0NGRUNud0FJQjZNZ0kyWGtoQ08zaVF6Z01BQTVPQVlFU2dtZGllTmZ5bGo0ZkRENURnQnE2RFllQ2hyQ0pCUTJCaFB3YnhCT1VFSUFqQldSaVo2WkVuREpTZEtTSENJU1NHVzRnYVViRkdvMnl3NzVZamI5RE5LT0dWMiswZVB1R3RpZitzaWhvSWhBU3dGSjBFTTZGdFRjSTUwaXJjbHdYOU1SWC91UEtVUStTb2hwajBhaFY2KzFoaGN6ZlJLVUZSa3NhQzRIT1d2UkN1UWJaWW1MMGlMaWtPL1F5akhJallNQlYzQkczbWdBRkFTSVVDTkFUeks0QVZaaXdBV0JQOEE0UWdNaUlGM2t6Z05vMElRd0dCY2c1WkNaZVJFY1FYZ1ZBTkl3QU5CSmRHVVRRaVFpLzQ4cmpFRWpBMkNiZ0Fmd0RhSkZsQUlnSEFFTUFIQ0NYZ0dtSjNRcUFBQmFnQkNKQW9CSUFXQUhRRGJBRWdCMEFBQTJBeGdZb1FoaUVSQVlBQUFDQXl5ZmVBejQ2U0FJQUJpQWJNQUZvQkNBQ01BUTRDQ1pFaXdBVGhIenJrQkFNSkRBQWdBZ0VQUUZPU3JrR2dBQmtBWnlBZ0dndy8rL2ZaTHlldkJKZUNDSjI4Z0xJQUFFVDQ4RWl3UUQxSlhGbTNzSkJkR2NwaWlmbThEQVJOaUN3Z2VZaUFDWTczemZZRUFBUUIxQkJBQURxRWtyeGdrbTVGcW5nbWRoRVJFR0lSWUJ4T3ZJSkpQUk9GcDRZU0tLUEFWWWZ3QmhxaXBKQ3FBWXdoa0lCcW5LRWJiVXg5amFWS2dlNFd4WHl4UStDa3I0R2ZDaEU0UWUyZzdmSWdxSmJRZ1d2VTJ3NkJRT2pZMnBHV0hiSThxZWJMc1pKcmEyU21VUzVrVmxSS1k2aTJUVk1uWlZKUlprVm9RV2E1N0ZGUWJ0UFE0VmJKR29oTnZVaW9ZbVNOWkJvb0VlYm82Ky9aNXdLM0lJNXpJQ2NoaFFiazJDSWM4Qmh6WUNkNlRtNUlnSjBseVZyL1JDV0FpS0poT05FTkNoc2ZMY0NjQWdBNUFieDlnSDFvR2NCWEFYc0FqZ0tnRFhVQkpIS2VzQkJML0FJYWVsUWR3SnhnUTVGeVFrRHRET1dBM2tOSUNXQzBnMkVoU1NxZ2VVRFFCZ1FHR0VVQTBBTGNGQUFJRUFBZ0l6S0FBQUFCNEU0K0lCa0dBUVI0RFFoS0l3REFJRG1mbkNFQWdHRURSZ0VDRUppQVVnQURsQ2J5SnEwaGlZZ0J0d0FRM3dwTUlDWUFBUEdJWFJHQUJ3Z2JSNElRSURpQldFY1RDaEhYQ2VVRVVlQko3ZzJKcTJBRWpLdlBJM0VnT3dFSlJqaFFoTG54Z2tob2FZTEQ0eUFDR2dnQUNJbk5RaTR5c3dEUUd5RThKbDRBdkJCR2QrTEJoMGV1alF3UUp1UHV1VGo0RWNvRldBSUp3Z005SnZYaEtlRDF3NXFCR1lDOXNpbkFabUpZb2p4NFk0UU9BRWdoRUdJdXBEYm1FSzBHR21tOWxiRS95cGFHVHE3RTdWMGJhYVFrU2VoR1M2T1d4MkVpVDBkRDFQOWlXMnI5Q1VzV3VJZklwYW1pL3FQMjdsYVdLd3VyckIwMndkL29FeHhOZ3R6Qno2U0xUYmVoVTF1U2ZuYWtTOHNCRnM5a004bStmWVVnblF2M2h3WG9pRGpyeFFncG9TUFNNZ0NTVUEvYVdQYUVzV3dDTWdpVkNxdjRBa0R0UUlVTEFGaW1yQnNpQktJQ0FuR0FHbmdSb0o1QVlUQVNRR3BOQkk2L3docEREVVFic01EQWM0TGpBSmhQRCtBQUJBUml1cHNBdGdKNUdJQi9Yd0FZSU9RQkFWQUhBSzJDUzRJRUFEdHY0ekNrREJBRUlSRUFhRUFHRURnQlFBQUFJZ3NCQVRseUNJRUFRL3dEZ2dBbklJTmdDY1FBQkd3QVVBQjZBQUFVQ2dZQUNBTUFBQWpCOElBUUFHQUxBcVFOQVlJQm1BUkNOYXpYN1oyTTUvQUVHd3Mvd1BvQnhBZ2NON3dCU0N3d2NYeGdSZ0FCb0JFRkVDUXRKSUdSc05KSVpYRFBEbUJaVUkrT0FCQVJnRmh0L2J3Q0JUa01NUkd5TFRzQ3hiQW1tNkJGUkNibUJTNVFIbG9pZUFGS1M1QkN3eGc1eVA0d2hnVURBdEFvRmNrVS9ZdFM0SXVFSzBJdjZDb1lTOVR3U2hjc1prQ0RlVTNBYVJCTVZIWWkxeFNqME9lUnZkRUkwNGtleUluVnd5Q29UZG8xTXZRUndTbE1tbWtCUUUyTk93MlJtOUVxUVlqaDdRM25VU29JKzM1c0tXTm5vSnJyOWc2UVVvS1hTR3JnVFVCUk5BbG5DRkFRVnJKYVNHa2dva1gxRElsRm8yUmtCSStrY2poUUpPbEZoRkJYblo5eFpNWWdYZ1RQRUQ4NEhBUklxTk5nZ0FOb0JyQUFRQThCUVhnRDhBSW1CV1F3TUFrcDFFMzhvcUw4a1ZJTWNFR0dBNkQwSkZpRUNpSUg0TkJxQUZrUTBRRUFBRUFBSFVCU09FQmRnTmdNTUFBQ09ENGhBU0Fpd0FkditKaG95QUFTQWNBQUJTQTZnQ2dDQVFpQUVRT0NEQURBQUNCQ0FEZ0FRQUtnVUErQURUQXVnZ0xsS0FZQWdBQUJBQUFXQUpBSUFBUUlBREFDQWc1RFJPUHdLeE1nSkh5OG5BSVJtL3dBcUFCQkdFQW5BdEJEUUNBQUdCT3J6RVRjRUMyUW00UUFhZVdBTDBHaDRraklnRkFZTGowYlpZUHM4U0dOdkJ3eWh2TE1TTGhFNndUQ2dDOTJEUThpUG9aQUpPR0VqNytUb1BCaWhreGdwSnd2b0psUm5nM0UwMlNzNlpJYTZValRoZlkxTGplbUp2M1NyVlQ0OE9FSHNTcEtWMFNyYSt5R3hJWDFBVjF1MFJ3Q1hybm1pYmFLV0Z0TmlMWlZlaVR6aVk2ME9nWTcyTVRHcU1md1BLS0lNR1ZPUmdRMUlqRXVWMVlhNUcweVNCSkdyWGJFNmVrT2NMaDdsL2txbjRIcFBiWWh6VnVSY2xRZHBsMUI5VHdWNEVDaUNmUUExd1JNVDd3RVp5UUE2Q0k5ZjhGdW1nOEpLdVNJY0FEamdSd0JvRWNJRFFSblFBTEFpS0FkQ05rYnNLQ2hDZ2F5QWlnRjlQQ0FDNFFLQUFXeEFOa0Uwb0NrQXRvQ3NBbkFRM1ZBV0VrMlBLQUFBQWNSc2tKUUFFSnVZQlN2NG9GZ0JvR3NBQUVJQ0JCQTRVQVlRQUJGQUlBRkJLVStBQkVNd0FnS2lERUVDQU9JL3hvcEpSUmdHRWg5RG1NQkFCQUVBRllBRnVCQ0lBMEFFSUFBb0Jnd0FnR0JBMEFJL0lLcmdTMHVBV2hDRGdNT2ZQaVNsSUtCdHRXRkZISVFGZ2gvSWdWQkJrRUJnZ0FFVUFscmdXQzBKeEVLQlJna01BcVhCQlBBQ0lCWmdEUS9uRW93U05qTFB3RHhHSWpoQWkxNGFPdkNpVCtzRjBJUm5vSTI0ZmNsZjg1QlRVY0RYS0NFZ0hTUkdBMndRNUJTYjQvUkNac2JWVnNkN1dwQ1VJTkxHbW9IaFdqa2hkc1BtL1ppa1VoMjRhVUs1RUxYVWd2WTRCcTZQeWdCNXJrNWR4RVhmOERnWnpsektMRW5tSzd2NkhUYU0zQ0V5MHVoMUlUVEhXajEyZWhyeVFOOHZvWG5Eb2hMRkUraWJSRG9wMDZPUXpWL3VJMFV1ejdRVlpDQTJuWkpJS2FCN3pBbEQ3QXZrSXllQVFBVVhUZ1BFSTN0Y3ZGQUFJVkZYK1dlU1VwQUtnQzFBQUNRQW9SQVVnSjdDQktBN29mb0c0SVl3Q3ZRU0ZNRHdKcDBDZkJzQXNnQXVnQWtYMUFyRDJFU0FTdnlFQ29NQU1BTU1MaGg1QUFFV0JBUndFQWdZQkZGMEF6RkR2L2tCSUlnT0NnNFVJQUFBV0FHQVlBTUFBQWdBZ0FBQUFMRCtZQXhJUU9FQUFoQVRRQWFZQUlBSkF4QkFBQWtCNFNDQU5BN0FCVktBS0FBQVFDa0ZBS0FBSHVlY0dNSzRjcDVOZ2dDQkIrSUZUUVA4Zzh0cFVBQXVHS3BBM01NWVNJbDRFTDgwQ2tISTArbkE5QnpVSmtISzE0SklJSHZDVVRqeElrQThTR0VDajhZd3BQb01MQUNFSzlNMnhJM2h1NEFmNENLeFUvN1Q1eWtVUEFwenJzZ3RBa0VzcmVLb01lTE5UZjdKYm9KWDdOVkNJQzY3K2hTZEpWd0xIL0VMU1AwVWo3U2czNzd3eXJhMEpQSk5qdG1tOWlSNmVpVG1KT1dPbWlvbmdmTDBwS29VcExDR3VTZHJrWjdFYjlrVTFrOU1ndjBYcXlHQ2txZ2lvdWhsK1JIQURQbEFSdHJpUjJtQ21sZjBLcTlFYkw3blBYSjhnMWUrTWhUOWVBQThxTUNVRW93SVVKZ0trZmJ3VTRaQlJCUEVFa0ZnT1FBRkJDV0FDWDVCS0FBTjhVR0JrSFFJbUlhdml3RU9DVVFBdEJlS0FBQUNJL0JtQ1lEMytIOEVPV0FIQU9RRk9DY2dHS2hRUVBBQjRRSFFBY0FQb3BTYVVTZ0FyQTA2QUkxZ0FjZ2VtQUFqL2d3RURBc0pzQXhCRTlrS0FEQkJBRVFJQUFRQVpBQUJGQUFBWUFBSWdsZ0VDSUVDQVJnQU93Q1BrWWdBRUlFd0NJQk1hRUFBQUFnQUI5aVJqeW95UURJSktBQ2lCVFpBQmYydGhCU1NWWUZnVGo3RERpVTM4VU1Ga093U0lNaGhCQ0VuNE1RRUxBM0JyRGtoUXlRUkNEY29BN2tIaWhCQU1aR2pJbnA4V1FnY0lwOEJvY0ttQUlBUEYwSzRxVXZFWW9PRmpWSEFKc2pFenErTTFVSWhYaVRGRUliZmpBQlFtMzFwa0dwbUo0SlRvUHFodVpQOFVMaW9YQTkyTkt2YkdKMnQ3SE9GMnhOR1M2bGtPQjB2MklJbTE5b3puWUhmVDVIZDFDM0VHRSt1QVFkRVVwcHNUY2tsT2RFTk4wSUpPaHF6RXBCeU4reE02Z3RwTEZDUEF2aGJJcldoVTVkbDFneVFHMTJnbWd0SHBrS1FQQkFCSUkyWkFsb2lONmJHQkliYzdEcDZlTDhnQXpRSVdKUmdBUUFBL3dDWUtDZ0xrZ0J3QUUyQWhneFJBUGtBQmdHQ2ZCQStJbkFCRExBNDhVQUdBUXlNWTRQSUNkNXh1QkpRaVFMQVFmMEFuZzVOOFlSUUZTTnNRMGtOd0FRR01BRXdBMkFDQVVoQW5aOHdnQ0FFQWlqQUN3emIrSER3QWtJaEVBQkZRR1dESEFWTUJ3RWdwaU1NZURZUUJ1SXhjaDhGTkNnQUFmRUhQckpBUHFEOXdQamVBVG9Bb0JvSUJBSUJBQ0FBQkFnVmtESnllNlNzaEw0UUpjVitBTlFDTGVBUUFJWEtMSE9nTXRHS2dtQ1QrQVZRUmtBaEpwMHhKQ3dKWUxiaENSNW9oUkxBaGhEVWNGd1B5NEFHQU1HU0t5QUgzbklvamJQRklESlloSUhNTkJBckhjZ2dlQk9LTStCYU1hc0lBcXhUcnhJRUtEVmxLb040SEQyMGtmd1l4NDV2LzlrPVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wdWJsaWMvaW1hZ2VzL290aGVycy9ob21lLmpwZ1xuLy8gbW9kdWxlIGlkID0gMjA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUFBQVFBQkFBRC8yd0NFQUFrR0J4TVRFaFVTRXhNVkZSVVZGUmNWRlJVWEdCY1ZGeFVWRlJjV0ZoWVhGUmNZSENnZ0dCb2xHeFVWSVRFaEpTa3JMaTR1Rng4MU9ETXROeWd0TGlzQkNnb0tEZzBPR2hBUUd5MGxIeVV0THkwdkxTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdE5TMHRMUzB0TFMwdExmL0FBQkVJQU1JQkF3TUJJZ0FDRVFFREVRSC94QUFjQUFBQkJRRUJBUUFBQUFBQUFBQUFBQUFFQUFJREJRWUJCd2oveEFBL0VBQUNBUU1EQWdRRUFnZ0ZBd1FEQUFBQkFoRUFBeUVFRWpFRlFSTWlVV0VHTW5HUmdhRVVJMEpTc2NIUjhBY1ZNM0x4WXBMaEZvS2lza05UWlAvRUFCb0JBQU1CQVFFQkFBQUFBQUFBQUFBQUFBRUNBd0FFQlFiL3hBQXdFUUFDQWdFREFRVUdCd0VCQUFBQUFBQUFBUUlSRWdNaE1VRUVFekpSb1NKaGdkSHc4UVVVUW5HUnNlSEJNLy9hQUF3REFRQUNFUU1SQUQ4QTgwZGFqSzBROVJrVlJHWkFSWElxY3JYTmdxcWFGYUlxVVZOc0ZJclJ6OXdLSXFVVThyU2ltVWtDaGtWS2pVM2JUZ0tUVWNXaG8yUEJwMU1DMTJvVmZBOWpnMU9GUjA1UldjREpqNHBVMmtUU1loc2RUU0tRYXU3cTJMUnJHa1UwTFVnYXVnVmtZa0F4WFVHRFR3TVVyWXhYV3VVU1pYM1ZxRWlpN2dwa1Z6TmxLQkdXbWhLSlphaml0a0FqQ1YyS2tpdWxhMW1vZ0lwYktraXVSV3N3MktWZHBDc1k1U3A5S3NZTGNVeUtuWmFidG9yVWFEaWlLS1VWTnNwYktQZk1HS0lLVlQ3SzZGRkh2cEd3UkJTQW9nS0s3c29QV2JOaWdlS2NLbTJVdGxMM2xoeElwcmhGUytGWERhcG82aVFIRmtZRmQzVTd3cVliZE4zaWZLQml4YnE0VFhEYnBwQnA0emhmQUdtT3JvTlI3ajZWMFBWSGhMcUx1aVlWME5VVzZ1aWd0R044aHpZYUd4WExmRmN0akZQczhVN1ZNVzlnRzVOTnFaNmpyamZKWkRZcHZoMDVqWE4xQ21aME4yVnhoVG1OUk1hS2l3TmlKcHBOS2xGVVVQSVd6Z05PRmNpbFRyU3NHUThMU3BDbFIvTCs4MlpZbWxGVHZhcGh0MXh4YWZKWjJSeFNpbmVGWGZDTkdvK1lOeGtVdHRTTGJOUDJVQTBRYks2RnFTYWRXbzFFWVd1eFVsTk5hakhLVVVxVmFqSElyaFd1elNyVUFZeTFHVnFjSlhSYnJHb0ZLMHdyUnJXNlliTkd3VUJHMVhWdG1qQmJpbEFwbEpneEhJbmxydGxjR2lMY2JLYmE0TmRrYmRFbVYxeW1WTGRHYWoyVkJ4M0tXUkd1VFVwdFV6d2FlS29EM0l5MWNxWHdhWGhWVk52b0tSeFhDdFRiYTV0cXNWN2hXUXhTaXBTdGNpbW9Cd0NsVWdXdVVURjRiTk9GaWlpbElKWGt4MC9NNm13YndLWGhWZDlGNlUyb3VyYVVnYnU3WVVEMUo5S0gxK2lOdTQxdHVWSkIvRHVQYWozU3VnWmJGWjRWTU5rMGI0ZGMyKzFVV2trREpnSjA5SVdENlVlUjdVZ0tidTRneVlCNFZPWFRVWXlIc0thRmI5Mzgvd0R4UXdpalpNaTFlZ1ZDTmpid1JKT1lEY0VDUjlQdlVIZ1ZkYWpTTUxWcHRoOHhmUE01V09QeG9PNWFaVERLUjljZnhyS01RV3dEd2E1NE5FM0w2Q1pZWTVFOGZXS2lUVjJtTUIxbjBrVFFwZERXTUswMDBZYlZOOEUwTzdTR3lCSnJqbWpQRDlxUXRlMUh1MGJKZ0cyYWI0ZFdmaFZ6d1I2VTYwMEsyUUpiOHRLeGJNR2pWVEZjUk1HdXFLUkpsUXllMU4yMGU5cW1tMVMwaGdIOEs0UlJqVzZqWktkQUJTS1lhbmEyYWI0ZGF6VUQwb29vVzY0VnJXQ2dZclhObEVGYTV0bzJHaU1MU3FjSlNvV2FqVEZLNTVaaVYrNHFrK0llbzNIbXhZUnp5cnNGWStzb3NEMEIvbFdaUFJiNDVzM0FPWk5xNEJIcjh2RmNHWHZMTjBleC9DWFVOTnA3dTdVc2czbGJZMzdkaXFkenZjZVRnRHcxUUgxdUQxb0w0bzFWcTVxaTFwcmJCMERSYVlNaTdJV01aRGVvOU5wNzE1dnJybHg0RjFRR3RXd0R1bFdJSmdTcEVnK1lUL3Q5NmRvTlQ0ZDFiaWpBSkR3eFpTRGd4S2lPNTV6amlLWEwyckoxdlp0UENyb3MwZmZzYkFyRWdoaHVFR1RHZVFNemppb3RiZUR4c1haQUFKbVNTT1RHUUQ5NnBtaHJ2Z3ovQUY5M3MzQ3JGa0FTU09CSkpIcE14QnFrczZxNlhDcmRNRkF4bUR6SWc0N1ZiL0VHbWNxN1NTcXFwWWN5V1lxTjJaQTlKRzNITXdEbDdNcXdZR01EMUFxRGJ0N2dMMXJkeU0zVy92OEFHcXZWM1NweTIrZTU5TXpFazFNeExESm1mckEvQ29yL0FFOXlwY0tTaXdHWURBbmdFK3BxY1cvMU1Oak9rMkpKYVlNUmpIOEswRGRQQjg5d2s3cEpkZ0piMU80ak5WL1RyZGxiTEVzd3Zic0tJSzdJL2E3cVovaHhSZC9xTnhyWXRzNTJJU1ZIWU1lZngvR2wxTGI1SjIzd2Q2OVpzV1VRV0dEbHdBMkkyRW56RHZQdDJyUDZtMHB1M2V3VlpBNHlGSDg2V3J1bG9reUFjWm9ZUDVuenlyZnlxa0kwZ3FMWEpzdmh2cHBTd3BKWWx3SGc4S0NKQVVkc0hQdlZtYk5QK0g3enRiczJDUVYycjRaTUNDeXI1UzNwakJKOXFPdmFZZ2tlaHJwVWgwK2hXbTFUVGJvODJxWWJWTlkxQVJ0MXp3Nk5OcW0rRlJUTlJBcVlyaVc4VVdMZUthTGVEVjArQ1RSWHRicHB0VWFiZFRhUFFOY1lJZ2xqTVpBNEVubjJGVHlHcWlvYTJQU21HM1ZpOXFvMnRVY2c0bGN5Q29qdDlhUHVhV2FnT2pIb0syWWNRY0NtdGJvcndZcU4xUFlWc3pZZzJ5bTdLbU50cVFTaG1IRVlGcFZPcTBxMlJzUVRTZFd2QjdoRjYxOHd5L2h3Y0VTcGtDT09EM0hGVDZ6cXQzYVAxMWtzSUkyYkdqSHN4NHpJamdkcU4xbndrTEJ0czF5eTIxVkpDL3JGWWd5eGFNbVRJejJ4Z0FDcVBxOXl3dDBrV3dOeDN3QUNJT1lXVEN4MndhODVwT1JHT3BsdXVEblU3Tjd5RTNBeXZiVXNROHFaODVVZ2R4R1FCaW4vQUtWYVpVQzJnR1JBc3JLN3ppV1lFNUpQOE9LQnQ2bFdCM2plWStZcXZsODNaamtEK3BxWFR3Q0FzTFBKTUtHVll4QjV5SmtjMDFVcUQrNXR0UGRBdElXSUEyTEo0RXg2bm5OUTNOWVRoRkorb0k5VDh2UGJ2dEh2VGVtOVA4bHNzU1RzWDZqNWUvN1AwV0tPdTI5Z2lOb0FrOWdPY210bWRGR2Q2NW9UdGE2KzRzQW9XQjVSTEhEUUlHQWUvd0I2cDA2WGNZZUlVYllJWGRCMmhqd0pHSndmdFdyK0piYU5wdzZ5WUlEYzhGdktVZ2dSeURJYmxlK2F6TnZxVndBMmxiYWpMTEFmdEgvcVBlbHRrRzIvRDVsaG9sMHkycmd1YnZFUCtudGdqQnp1QjRuSW1jZWhvRFVYblJDcWtvR3d3K1dSNk4zL0FBcUhUYXRVdUt6SGFCbVkzY0E5Z1FhZzFHdDNnRHk0Z1FxN1JnZk5BRVpuL21hQ2l6S0t2YzdvQU56RWljKzNwVWgxVWtxTm9FRStabFVTQjZzUVB3NzBIYnVRSFB1UHVSUk52cEplMGJtNUJBQkNNMjEyVXo1bEI1QWpuM0hyVFlwdTJOZEhOU3ZsQngvWTlxcmYybi8ybitGSEdmREkvZEkreEdPOVY3SHpOOUQvQUFGUEJjaGtlbGRNUUd4YVByYXQvbW9xOTAxeENnUTdqY0o4clRoaEU3U0krWWZtTStzVWZRM0IwOW1PMXEyRC93QmkwZWhqMTlaR0NDTWdnOWlEUWNpcjA3Vm9KZTFGUmxLZmYxOXRWbTdjQ3VTVExFQU1QM2dTY24xSDlhRzAvVWJOdzdiZDIyNWlZVmdUSHJBb3FZWXF5UXBYQ2xOdDZsR1prVmxMTDh3QnlQclVoTkhNYkVRdDRwaTI4Vk9uRmNYZ21yeG53VGNlUVR3NnRPaS9EOTNWTnN0WHJsZ2dFbTdiSkRxSTRVZ2prd09lQ2FCbXRYOEc5V3NXRnVHOWVTMnpFYk4zSmdIZEVmVmFqS2V3TlNPeGxlcGRPYXpjYTA1QlpEQkk0bU8xQk5iclIvR0d0dFhkUTF5eTZ1akJjcnhJVUE5dWF6MXh2eG9xZXcwWTdFQldtbEtrM1V4ald6SHhJaXRSc3RTbW1tdG1IQWhLVXcyNm1OTUlyWm13R0MzU3B3cnRiTTJKVUxvQVZPMjVkRnZFQnNDU0NlU0JIZmo4Nk9QUTN1V3R6QXNxZVVYQ2dBVEU3UzBBbkJtRGorZG4wanBMa2I3ZHhiYko1aVAybFFMdVpqdWJjWXlNU0QyTk82c3RzTXhacmU0TXVGRUFBaFR5V2FJaU05NjQzTjNzY0thNE15OWpaYzJneWhHNWppU0F3OHE0WlFaengyN3hWME5OWXZNRkYwcWkrWm51S1BLMFFGRDRDcXhnWkhQb0JVblUrc1duVzJoc2x0bi9BT1pZVjhrSEtqRE1PeEpqMkZWK3R2RzNiRjFMSVZneWdzekYvTVNTZDZIQ2tsWjQ0ajFxbk5DcHVTOGlIVWRYYXk0Mk52VkZGc0tQbGxJTXo3bVIvd0ExSnF2aTI5ZEtsclFjZ1FKa3hHQkdNd01BMUUvVTkxbmRjTjFqSGxDcXR1MHUxbWlIVnBKek1nQ1lnL0tHcVQ0YXlTaHVnc0doVk52eGlkc2ZMSkJqNVJHUHdnR2hkSzJpM1c3Sys3cnIzaDNBekhiY0t1Nm1QTVFRUkVpY0JWNElxc3VzVmJNbnkxYzllQjNlVFVtOWJabU93YnRscGdKMjdTeFVFQXhqZ0NxclVXdk54Mi9yVHhhTjBIYU5SY0JEREFSanVoY0hCV1hJOGdKRVQ3OFYyN1lLUVRZZTJHSGxMVDVnWXlOdy9oUlBRYnJJeElVc0NtVmxRREFuemJpQ1FJSjhwQmtVSStrMkFDYlpJSEttU1o3RThHSVBIclJmSVVCWExuSS82Z1ovQWlyVHB0cThTZ1R3eHVUQklVQXFEdTh4SWd0RWM1NHFydXI4Mys0ZndOWG5UMExXYlNnR2ZQeUNRUmd4Sytic1B2NlRSbTZSa3R6bnhBYmpiV2RFU1ZDRFpBREMyQU54QzkvTnllWm1zL2UrWS8zMnE3MXlIWmJCSjRZeGpCTE1zZW93b3dmU2VDS3ByNitjaisrQlIwMkNVVXVEVmRGNjBxV3JhbmVTRWlmVGFZQzVPUVI5dnlyUTZMV3M1Tzd3UUJNRmI2TWNDZURFL2hPYXlQVGJPM1RoeWlOdTNCU1NOd3lSTzNmUGNFWTdjMGIwWFVLbmlCMjJnaFlPWk1icGpiUHFQVDYrazVWYktMVWFxZ3I0cjFKUzVZWlN3S2k4dzJtQ0NxaGdaQmtRVkJ4bm1vUGhHMlBGVTZlUzV0WFBFM29qQkRLOFlKSWoxeE9mV2d2aUR6T0NoTHFOK1FJTU9JQks5cWQ4Rm80MVNnRExCbEc2QW93VzgwNGpCeDcwK3lqc1RrOHBaSTFMNkM3Ykc1R3RCaE1BV05NRDN4dUZvRVNKeUlvbjlOU09jK2xFZFo2Z1FpbXl1bExsdHNJb3VNdmxuY2hCSytzZzVCUEhlc3BZdU1RUzNJSkI3Y1I5dWFYVFdYSTBkWEhoR25UV3J0UE5BZFIxZTZ3Nmdzc3dDd2drQWtUaVIyd2M0Qk5VMnE2aUV0RmxJSmxSSE9HNVBJN0EvbFE5bnFoSXVLQ01LcksyVm5PUkI5UkFIdk5kTGpGTDRBZXJKbDFvZGNWdHFDU3hFamNlVEJJQk9UMmp1YWRyVzNyYVlzRTg5eGM3c3hiVS9zcWZYMDdWVmFlK3pySXpreVRCUDM3L0FKZlFWcXowNUxpNlZGS2drZUpjbDFjYjJYdzJCVlJLQ1VVNW5rOWdhaEpMRUV0UjdJcFUxTjJNRU5raWM5aVZBNEhBQUg0ZCthZW5pRldKTUVSQy92U1lPWXhHS0I2eGVzcHFXc29XS0FrQmc1QVpwTWtSd0ptUHJRRnZWWEZlRWU0b0lneGNiTSt1ZmVnblNveTE5dXBiRVhmVUQ4VC9BRnJxczNkbC9EL21vTmJadDI3RzkxYmUvd0RwZ2t0SUI4em1UZ0NJSHJQYU0xMXJjRkVFWkU1eWM1eWFLZGxOUFdVbnd5NjNuM05RM0xrYy9uaXFoN2ovQUw0L0NmNVVPNk1mMmlmdWFPUHZMWis0dVcxaWQyWDcxR2Rjbjd3cXAvUXo2bjdWMjNwSnlBZnhJL2xXcVBtREtma1c0MXFmdlVxcjEwWDkvd0JtbFMrejVqZTM1R3Q2Y29DQWIvQ2hnU0RkdDJqdFdWRUs1M0tlZmJ6REhGUzM3bHRDRk9wY2diSFVTcmlJRzd6S3dBSktoZlljekZWdWkwbSsyMXdFQUlkcmJST1lrTnRuZEdCSmdEbjByVzZUcDRZN2ZDSGlIQ3J1M3NRQUJFZ2p1ZUk3MXlQazRGc3JQUDhBclduWTNRUXJDVkRNR0JsOXpFN3VBQ0NUaUIvV2c3RjRFcUNpdGtCMXVONGF3cFBEcytENWlaUEgweFcwMTNSajR1enlXbXlkckdFOHBQSmVjOXM0ck1kUkNvVVJoYWNEQjh5L01CbGpjdEV1VU15Sk04d01DcnhlMUdpMDkwQXZxOXQyYmFXRllCa0JCWlY1U1dEdGN5NGtpUVlJekVacXo2VmV1NnJ6WEd2c0ZmNVZ1aTNiVldFa0R4Smo3Z1FNOHlJYjlqVEcycGdKNW1CZFBFY0FoUWRoOFFubnk1Mjl1UlJIUjlVbHNvdHRyZHhpeEEzMnlwQldDc0ZRcElKOVpQMG9TbGEyUlZSQU9zRWJuUlh2YmJiM0VLWEdEN1ZRNElaVkFBSmtSbmpreUtEdTJqdTcvS2Z5M1ZwZEgwMWRRekhkRHRjSUttRkVzWG1QYVIzOXFJK0krZ0hUM2ZET1NNR000OHgvcFdUSnZVU2VKUWZENDJ1Wk1mcXpMYmxETEFPVlZ2bitrZ2UrYUdDTzBTUEtCNVRzQ2tET0RBeE9Uem5tdEJvUGhieDBlNkxsdGZDQWJhNUkzZVltQUJrOGRxQTZSbzdTdTVPOGJWRXpzYVMzQUVSNlV6S1JmVXl1cDVmdDV4ajhEV3M2UVI0RmpJVUJia3R0a3lUbWNHY3JBUFAwRlYzVDlkYjArdWE0OXBicXE1SXQzRkRBeWhBTEtjY0dmcm1ySG9sd0N5cnF4VUR4UEtWVWpOemJFc1R1TUdjakVlOWJWOEsrdWhsTGNxZXF2NVZ6UEpMaVlNbVY4cGphWWo5bGZlWXFodm56SCsrMVhHcmtydUpCWnZNMEFBQWtrd0lqdDJqSEF3QlZQcVBtKzM4S3BwQm1hem9Hb3VEVEs0L1lPd0hHQWQ4cHN4dWtIbkpHYzFiWE9tcTF0WXNoR1h6TVhWNXVFWjJxUUkybmNBQjZqM3JQL0R6L0FLb0tMWUozZzc0SklpZktJOWVhM2I2K3lkTkhodDRrd1FTU0FvVUFCZTR6bW95Mmt5V28zdFJucmVpdUpoa1pmS3NBcmJHRHRKSURDVDN3UFhrQ25xaHRsYnF3R0VCR0JBVE1xU1FxZzd1ZS9ia2lCVm9qS3VteWtrM1Yzb3hZbDFFc0NHeHRHWWdjMHRheXZaR3dMYVliaWR3QUx6Z0xqQkVNUG01ZzRwYlFVNWRUTjJBOW01Tmk0d1ZUNVhLTmJsL0tHRzFTU01iY2swZnBTTGlzaUlQRUlDaTFQTFFROXd1VEVRQmdmbFdnWHFGZzJTbmdvTGdGdUc4UUhiczV6UGM5dTNhczMxSzFjdVhoZUFMU1pnQWduUEVnZjNOVXlycUZ4YjNYSmw5YjAxa3Rnd2ZmL3dCczlqK0gzcVhwZW1QaXNvVU5HNEFFYmlZWVJIdngrZGJmcXR5M3FDeWkweXlzS0I1aXAyQmNsZ1pYeXppRDc4UkowVG9nSGlxTEp1WERjQXR2dTJnS1NNbEJMQ2R5L3dEbW1Xb3EzWk55YXEweW0wRjVoS2JXYTR6WVNNbk1RQUZ3QVB5NHF6MVhVaFp0M0ZHNFh3djZ4RnVBcWdMS20wTW9JaVNKRTh4bXJqcC9UZkNkRGVSMVU3MU45VklNc0I4b21lNGt6bVRIYWdkWDhOM0wyb0xOYmZ6a0tHQ25hTWlEQW1ZR2Z3NzhVbVNiRG5sendZelQybXZPVEdXekJJN1pQUE1aTWN4aWorbmFZQmZIdXV1eGUwd3p0TUMySjcrL0FFU1JJclM2ZjRZVmI1dHVRU0gySWluTE5QbHkzeWc4eWNudDdBWGVtM05RQ1I1QmFPeGRvZ1d3QzJSbnNjeVlKUGZOTXhmRnNqTWRhNmtiemxqQXhDZ2ZLQU1BS093ajZWZk00ZlRXTHVUTnNJeC82a0FIcWUyMzArbFovd0RSQ0EwK25mdmtqK3YzbzNvOXhtMHd0aHNnYndEdHh0dzhtSlVRWm4vbzlzRjFSZlRyVGRqbWNEOWtIUDd3VWo2Q1JQNHlCOWVPTTRvSDlFTzRndWhhQVFWWXNQTVRJbUlCNzVpcGl3NEdjN2Naa3pINDByUjE2V3JiWjNWWFBLMGVsTHB6dUZ1QlZMYndweHRFWU1UdWo4cWp2cXpMSzdZT01zc2t6eEc2UjlmYWovaDVpQzBnVHRYQkFZU0p4a0NCQUhCUDF6QUhDRTFtbTlnR0xuZThnSUpCRzNpREhyU3AycDFGc093SWFkeDQyZXA5UlNvNytYOUF5Zm1YdG15R2wxVmtKTWxjWk9PQUZFREhPT2F0ZWxheTVhYnhVSGh4Z1J1NXdaRzdQZXMrRGZJRVdrRUx1eWpNWTM3RGxpWjgyUDhBaWlWWFVLM21JV054SjIybFBramR5TzBpb3UrVVE3bHRVelVkUTF6a2ZyRnRYR2NiaVdjRnZNZlpoMmd4Mm4ycWgxTHJrTlkyOHlVTGViRUVPUE1JeGtabjJwR0FmTmVWanZpUEVqdEoyaERnRVovRDNvRzVwZzVIbll6dDdYWGt1WFpUa1J3QUQ5YVM5OXlrT3p0YklEVFNxcXd4dU9Qa1VNb1JWREhjZHBiY0FTeG5hQnlBWm1yZnBXcHQyTnV4bnR3WmNicldUSWpPQ1dBM1o1eU8yS3F4MDNBTzEyM0JmMkZFQmhJbVhHUVE0KzNyRlNyYnNxa2txR2pHKzdidDhvN2lmbUhKUlluc1JpUlR0MlArV2xXOWxuck5aWmVHVjl0eVdKZ1cvTVR4SlVBa3lUa3o5YzF6cURPUnUzdWVKTzFvbVNlUU1pcTk5WnBWT0wxcFJrZlA0cGpkejVFR2RqSDF5djRWT1BpZlQ3ZHU3ZXhDOFc3b2d3ZU56RHZHZVB6cFBiNkw2L2czNWFGN3YxUkdPcEZTeERNcEVxQ3FrRWd6UGNSMysxRHYxQjJFTlBtYnVBVFB5ek1qMC9LaHRUOFFXWnhhZnVSNWJRd0pIY3Q2UjkveEUxSFhnd0U2ZHNaRTNkdjdnNFcyT3lmL0FDTlZTbStnZTcwMTErdjRKdjhBTDF1c2JtWk9jZ0RnS0JNRWdHSXBOMHAxVWxCQ1kvYUdOeUJ5ZVBlSTlhQy96OHI4dG0wSWlKYTQvQm45OGQvYnRRdHpyZHdqQzJoOUxZUC9BTjVwbEhWWTFhSzYrbjJPOVl0dGJoWEttUmlDcGlJd1krdFZqdDVxSkY5MmJkdUVra3p0VmZNZnBBRlIzRVluUDhxNkk3Yk01NUs5MGFMNGNzZzJKTjFrOHpTUDFZVThjc3pnNW5pSXE2L3pUVG9NNmlDWTNFWEFTUUpJblp1NEpQM1ByWG43cVYrWWZoN2o2Vklzd1pDd09TY3hnUUo1RlNubzVPN0t3MUVsV0pzTmIxZlJ6eGNZZzhRWGoyODRRanRUL3dEUGMrVFMzcEhNcnN4N3p1N0VWUzI3OXdSNGxza0x0aFpkUnNFTVUrWEFJSnlEKzNpcE5MMWU1dlZiTm9oakNxck9HWXNRQWNsQUJKSDRldFNlbXE0OWZzVTd6Zm92aDl5enNhM1VNd0NhZkxpUUd1U0Nzd1BsVVJrVUZxdXVhaTNBZTNiUXpnUmRuTUhNdlZwMG5RNmdYUWpLYlVxV3cyUkp5SlVrR1lCNDl2ZXF5N3BGTjFGMU53QmQ1VnlYQVpZQmFmTVpBOXpqTkpDVUc2MitHNXBPVlg4dmtGV3IycE54bERXRklSbmxXM2VVUUNJM21DUTNCanY2R2c5VDFYVXJCTEw2ZjZWb0ZlT0NWbjB5RFhFMWVqeHZCYUpBbFNRWkVLM0lNZ3lmVGo2VkQxSFdXV1lGTUx0WEdkNWdSbVhMZWdpWWdEQXAwdDk0K2drcnJ4ZW9VdlZOWXdDSzdQTXNGS2dFYmRwTER0eVIzN1ZCcWZpVFZuQnZFZ1p6OXNDTS9XcW01cXlZVWNMdTJuZGM3Z3lRcGJhQ1o3Zm4zTEpCVGFMdThidDIxaCswQm1CN3lCUHFPZlMyS1hLOUNGSWVueFpxWjNieVNSdEpKUHlrYlk5QmlscC9paTh1N2lHRU1CNVEzKzdhUnVqblBwVkc1eVQ3MHdtckxSaDVDNXlOQjFiNG1lK3FxUUFWVlZCRUR5cnUrL3pjbi9peCtFK282ZEJiREJsY0U3ekliZm55Z0w2ZGorTlk2dE4wem9ndVdMVndiWmJlRDV4SkljZ0VqOW5FZmFhbnJLTUk3alFobTZOdDAvUTZkYmhhMjZYRGMzYlVjRWJtdUZnb2JCZ3J1WGptczFyZmd6VjJ4djJpU1NCdGRIWStwMmcrNCs5UVAwTzRibHRFRVduY3A0ak1BZ1BJazhMeGs4VllkSXNhamN0dXkxeDJMTU5pcUdBQkpsbGt3ZVluSEovSGw3eHJobG82S0Job2J2SGhPTUFnaE53bWNocy9YN1ZiOUY2YzF1WERXeXdJVXE5cnhEQnppM3Y1anVSMit0ZWc2ZlFhbEVpL2VUZTBKc3MyUTl5VG1HdU1RQVJNKzFRYXl5MW9rSXF0Q2szSFlXaGJXQVozdHNJa1orVW41bzd4VUgyaExaalMwVzkwL3IrRHl6NGg2TGFYVVhGM09ZSW1GSUVrQW1BY2pOS3JQcVB4RWozR1lBQ1NQMkI2QWVnL2hTcnJVM1JMdW1aeTcxcTN5TGJ0bGN2YzdneWNBSGsxRi9tNUo4bW50WjM1SWR6NXpudU9LdGJTV0dLL3FGQWpoU0JKQTVKRFR6bm1yUFI5TzArL0Zwd0RnaGJ6cWUwK1lYSisrS1I2a0lyZFA2K0pidmRTVHBQMFMvNFZlay96Syt3OEt5L1BsS1dGQTNCZG84emlBWW52Vmlud04xZDQ4UXRiSGxXV3ZLcXJJbFFSYkpLODRKRVZlanAya21QQjFHZi9BT3h4ajhibEVYZWlhTXlQRDFPUU1mcHM4eHpMNXFQNWlLNmVpK1pUdXRWOWZWbEpwdjhBQ1BXTzM2eDBpQWNNTHVEUFpuWDA5YUZYL0R4RjJsbnV1cHgrcnRnTklFbUFOOGppRDNrZXRhbTE4TzZVK0o1ZFlQS09OYW9PWjdsczgrOVo1ZEN4YnkzZFlvaGxBL1NoT1EwR1NlMGo3VnBkcGN1SlVEdWNiY2tWdnhqOEsydEdiWVFzKy9mdTNHWjJFUkVBRGcvY0dzaHFtSWVCQUVlZzkvV3RUOFJXR1VxV2E2NWcvd0N0Y0YySWdIWnRQbG4rbFpUVmZQOEFoL1d1cnM5dVB0T3lXb2xWcFVKbVBxZnY3aW9ucVJ4Z1ZHMVhST1F3ZDZlYVozTlBGTXhFRTZXOFFzUURCN2lmZXBiMThsZ2ZwMjlxSHM4ZmpUMlAxbWFrMHJLWHNhWDRaMTJtVU9OU3R3c3pLVktna0FDUVppRE1rZDZ2TkRwK21JVnV0YzFLdHROMERZUUJEUUdCMm55Q0lrbjBrMVQvQUFsMTYvcHJWNFdkOFBBTzBBd1NseFIreVlNRS9hb3YvVU9zSzdZY2o5RGF4OHAvMFRjM0Z2bDRudjhBblVWcDVPWHpES1RWYmwvcjM2VXBSaGUxQ3l3bVVNbmF5aHRzZ0NRTjJJUGFnOUhyTkNyUEdvZFBOS21HSGNrcytQSVFWVEFuSm9UcTNXTlplczJHdUpjYndpU2x4a0p6S21keFgxVVVCWStKTldMRjZ5RVlpNWVOKzQyMGs3eTF0eVNJZ0RkYlUwSTZQczgrcStRdmVOdjdtbHVkWjZkL3FOZGU0NTVieEx2Slk3djJvQXpJRUhtcWU2M1MvRlk3aVV5WjNOTTdTUUFlREpBQm51M2VwcjN4eHEzdG9yV1VoWklPd2lTUVZQYmlERlZGejRrdmZwemEzWXZpdDRoSUs0SnVXMnR0Sy83V05EUzBYZlZmSC9CcFMyKzRVNDZhU3k1QW1FUGlUejNieThDYWRjdDlObFNYM3lQT0ViWnRQYUF3ZysvRWZuVlpyL2ltL2NOd3NMZjZ4UWpBVzBISGlRUmpCL1d1Sjk2V2wrS0w2TGFWUW42bTNjdHBLS2ZMY1lzMHlNbVR6VmxwVHg2MysvOEFoT1UxYU5ib09rOUh1V2dYdXBhY0hKYlUyeVlHWkM4bjBpUHZVSFU5QjAyUnMxS1BiNC8xTElZRW55NG1TSUVrOXVEUWZTUGpQVXBwazB3czIyUkxnY01iWUxFaDk4SEdjMDdxSFZUZXZ0ZnVkUHNzelRJMmhRWlhiTUFSUHZFeUtXVUhrdC9VVlRwUFl3MTREY1IyREdJNGlhanJyeURGTnJ1c1ZIYTFmdzFwdDlwUnUwNDg1Mm00bTR6dUhMZGh4azRBbXNvRFc5L3c5dEtteTVjdEk0OFI4WEJ1VGFVQ2pjaHdjeVJYUDJwK3hzUENhZzdZL3dEeTI3ZXVYQ3phUGRDc3pNaW5jSGNEeXNRVGlaTVJnSG1tMitqWGwrVzVZSHB0SkJKbU1GZVB5N1ZkZE0wT2tWcjJudkMyVnVOYWk2MGJrQWZ6ZUd4eXZsa0dLQ3VhblFKWWF5dW1zM0dYVTNFOFJpU3pXOXI3V0xESkFtQjZRSzRwTnFray93Q0MyblBOWklZMmkxbHNKdHZpSHRxOHJkdmlRNi9JZHJpZU1pdW0zcjFWVUd0VGJjM0FxYnJ0SkNsanZWZ2Vkc1o1TVVOMTE5RTdhVlYwZHUyeHQyV2RsWmh2eDVndzJ3U1k1NXpUdXVhelFwckhqcDluWnVNQUZ3UDlJckcwUXNib2Jqa1VaUWZlS0xYb3ZtR0dvM0RJQlBUTlVjbDdJSkFNRzJoSWtUQmkyUkltS1ZSV2VsNk1xQ2JiY0Q5cWxTNS9XSytZOWZWLzRQMHRrMVpXTFJIYzBKcEY5elZsYUI5YTBtUnFoam8zN3gvT25CMzlXRlNNcDlhaHVzUjNvZEJrOXlDNWNNbVdZL2wvS29iZHdlaFAycHozVy9zQ2hoZFA5Z0dpa00zWUwxTjFrUmptYXBYczdya0QwL3JXZ0drTjF1SlBIcCtRcXo2WjhNZnJjcVI1ZjVHbWZhSWFTZHZjZGFibEZHU3U2RXdNZjNOQjNiUkJnMTZ4YytEbWhTQVlQdDdqZzFsK3JmQzdlTEFEY0RqUHIzaWswZTM2Y25UWVo2RG94K24weFltQnhSQzlQYitIODYyM1IvaEM1TERiR0JNODFZajRNY1RNOXM0OTYwL3hEVFRxeFk2RDhqelB3OXBJeHpTYjZqbXRCMTdvSnQzV0JudEI5Y0NxRFUyZHBNejJycTA5U09vazBUbkZ4SmJWNGhjR0pqZ2tjZjhBTk1GOXYzbTRqazhlbjBwOWhCdHlCeGltQkJQSS9PcXhvbE93ajlLdTdkdmlQdDlOeGo3VFVDWDdnbUhiT0Rua2UvclJYNk1kc2dqL0FMcUc4SnAvOGlpcUVDVTZuZUFBM3VJNHp4OUtpdWRUdStKNHZpTnZFK2FjNUVIUDBOUFZIajVmNS93b1crRE9SK1ZDS2pmQldUZUk5ZW8zSkozbVd3Wmd5RFU2OVd1ZVR6RHlBaGNEQWJrZTlWNFB0WFo5cXBpdklrMnpUOUw2ODYyL0RoQ3U3ZGxSTXpQTTFjLytvajgzaDJ2KzNIMm1zYm9EL3dCTS9hcmxkUXV6YnQvbVA0MXo2a1ZZa243TkdjMWxzdmRaaUFOekU0NEUrZ3BMMHh6MnJTYWJUQTlxc0UwNEE0cXlrem1sMml0a1pUVGRHWWtTWXJjOUsyV3JZVWdOSHIzb0RZQWE2OTRSekgzb1MzNUpTbTU4Z25YTlhhM01TZ3pFUjJnOXMxbE5SZFVrd3NBbWFzT3J0SjVuNzFUTlRRaWp0MG5VYUxIWDM3VEZDZ1lRb0RTZVNPU0tqdlBhTHlOd0g1OGZTZ0RTRk00N2xFOXFMcTI5bUJMTlAwSDlLVlU4MHFuM1h2S1orNCtoMStEN1Z2VE1nVXZkMmdna1ptQUpCeUFzaGo3VUpxUGhRcVVBMnFYZlpCUGJFTkdTQnpNL2h6VmtmaTVkd0MzYmR6a2J0cFl0bkJhTUE5L3hxMjAvV2Q2U2JPNHp1eVFvbnNRQUQ5YThGYXRQMmp0YTJvcitxZkJWc1d3RU1NZ2xtWVJNOXptUDJUQXhrMWhMdlRXTncyOEt3d1EwalBvUWExZldmaVhVb3BWTmlqM0Jkb21RSmNtWWs5cTh4NjVyYmx4bVozWm1Ka2ttTS9RWUg0VjB3Ym40V0pVVjRncnFGbnd6RndxaEVTckhhd21jd2NuQW5FOGlxalg2NnlueVhEYzlZVmxIM2JtcWhrOU1WS2VtWEdYY0ZZajJCUDhBQ3V4YWFYaVpGeXZoRm4wdjR0TmlkbHRDUzB5OHQyaUlCRmFQcG4rSWw5cnFSWXNzNWhGRU9KTEdCazNJR1RXREhTcmt3WVUrakhNLzdWbHZ5clhmQnZ3bmVOMUg4SzQ0Qm1ZOEllWEpJWmpQNUNwYTNaOUJwdHEyR0dwUGk5aTYxSCtMTjVXSWJSMnpCLzhBMk9PUFR5KzFRNmYvQUJUTGtuL0xrY3oydXRqNi9xekZPK0s3V2t1WHlMTnNKeUN1Q1pRSGRCYVIreWUxWjY0dHNOdGxXYWZMODF3ekFpQXdQY241UU9LNTRkbTdQS045MzZ2NWxNcHI5UjZFM3h1OW9ndG9VL1dJcitUVWI0QkdKSzJpRlAxSXJjOUZkZFRZdDM5dXp4VURiZHdmYnpqY01HdkNldjZncnNERm0yd1ljcXA3eDVDU3dBOXdLOWYrQ3VxSW5UOUxPUDFReGs5elhuOXI3UHB3MDFKTHI3eDA1TjdEdmlENFhTN0pQT0l4OTY4TytOK20vbytvYTNpWVUvYy8rSzkyNm4xMUpnR09NOCtrNHJ4bi9FeWJtcTNyNWg0YVpBNElacG1uL0NweTcybnhSdFZQRGZreXJmS0k5UDR4VUZHYWkzdFJaRGZLdmIxVVJqKythQ0o5ajlxK2lnOWpqbnlTYnFidXBwYjYvWTBUb3RJYmhDb0N6TVNBQUNTU0l3TWMrWVVXMHQySWsyeGl2OWFpdU9mVTBXMmxkR0lNZ2d3Ukt6UHBCb1c1WWZrcTBkekJqN2pGYUxRMHRrUkFuMXFXeWhKNGsxd1dUM0JGWFBTa0FCQldjQ0RtUkJISGJQRkdVcVJKc1drMHR6dkFIb0tza3NFREkvS3JMVmF0V1JBTFNxVldDUlBtTWs3alBmUGIwcUxXdjVnQk1CVkVNWmc3UnVqMEV6QXJteWJaS2ROTTVwaW8rOFVZU3ZvYUF1b3FtVk1sZ3BibjVpTWlENkdhWTEwMVdMdFdjazRWS2dwMlgxSSt4cUM3YVNQbi93RGovUTBKY3UvV2hidCtxQmpCZ25Vclk3TUQ5NnBuV2p0WGRxdmMwOFRzaU5aYTVGSnFRb2xEdEtsTktpRTlLK0crVnIySHBpandoanRTcFY4cjIvazlLQmkvaXJrMTV0MVRrMXlsWFoyUGhFNThnM1JMWWErZ1lBZ25naVI5alhwbXFVRFFxZ0VMK2tmS1BsK1FkdUtWS3JkcjhTRTArcG8vZ3pRV2dGWVdyWU83a0tzL2VLdkNvRnhJRVNsMG1PNTg0ays4QWZhbFNycDAvQXZnY3MvRXp3cjR1dUVYU29KamMySnhscE9QYzFEMVlDM1ovVitTVUpPM3l6anZGS2xVRitrN1NtajlkK0MveGF2VFBoNjRmME94ay82WHI3MHFWUS9FZi9PUDdyK21QcGVKL1hVRHYzRDRuSitiMStsYnZwZWl0UHByUmEyakUyMWtzcWtuSGVSU3BWNVhhTm9xaWtlU3A2cjBxd1ptemFQL0FMRjdjZHZZVmxOWjB5eGo5VGErWDl4ZjZWeWxWZXp6bDVpeVNLVy9wYlk0UlI5RkZTZE1Zb1VaQ1ZJdU1RVndRUUZnZ2l1VXE5RzI0aUxrRDFQbXV5Y2t2Skp5VGtjMVhGUkF3T2FWS3VuVDRGa05GdzR5ZWZYMkZXblQxQkJrVG4rVktsVFNJU0RHR0JUdFI4eC92c0tWS21qeWpnbjFJM0g4djRWRGRybEtyUk9aOHNGWTBMcU9LN1NwMFVqeVZWK2hIcFVxckU2VU1ha0tWS3NPSVVxVktpRS8vOWs9XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3B1YmxpYy9pbWFnZXMvdGVhbS9zb21ld2hlcmUuanBlZ1xuLy8gbW9kdWxlIGlkID0gMjA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFN0YXRpYyBwb29sZXJzLiBTZXZlcmFsIGN1c3RvbSB2ZXJzaW9ucyBmb3IgZWFjaCBwb3RlbnRpYWwgbnVtYmVyIG9mXG4gKiBhcmd1bWVudHMuIEEgY29tcGxldGVseSBnZW5lcmljIHBvb2xlciBpcyBlYXN5IHRvIGltcGxlbWVudCwgYnV0IHdvdWxkXG4gKiByZXF1aXJlIGFjY2Vzc2luZyB0aGUgYGFyZ3VtZW50c2Agb2JqZWN0LiBJbiBlYWNoIG9mIHRoZXNlLCBgdGhpc2AgcmVmZXJzIHRvXG4gKiB0aGUgQ2xhc3MgaXRzZWxmLCBub3QgYW4gaW5zdGFuY2UuIElmIGFueSBvdGhlcnMgYXJlIG5lZWRlZCwgc2ltcGx5IGFkZCB0aGVtXG4gKiBoZXJlLCBvciBpbiB0aGVpciBvd24gZmlsZXMuXG4gKi9cbnZhciBvbmVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChjb3B5RmllbGRzRnJvbSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBjb3B5RmllbGRzRnJvbSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoY29weUZpZWxkc0Zyb20pO1xuICB9XG59O1xuXG52YXIgdHdvQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMik7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyKTtcbiAgfVxufTtcblxudmFyIHRocmVlQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMykge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzKTtcbiAgfVxufTtcblxudmFyIGZvdXJBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMywgYTQpO1xuICB9XG59O1xuXG52YXIgZml2ZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCwgYTUpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMsIGE0LCBhNSk7XG4gIH1cbn07XG5cbnZhciBzdGFuZGFyZFJlbGVhc2VyID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gICEoaW5zdGFuY2UgaW5zdGFuY2VvZiBLbGFzcykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVHJ5aW5nIHRvIHJlbGVhc2UgYW4gaW5zdGFuY2UgaW50byBhIHBvb2wgb2YgYSBkaWZmZXJlbnQgdHlwZS4nKSA6IF9wcm9kSW52YXJpYW50KCcyNScpIDogdm9pZCAwO1xuICBpbnN0YW5jZS5kZXN0cnVjdG9yKCk7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoIDwgS2xhc3MucG9vbFNpemUpIHtcbiAgICBLbGFzcy5pbnN0YW5jZVBvb2wucHVzaChpbnN0YW5jZSk7XG4gIH1cbn07XG5cbnZhciBERUZBVUxUX1BPT0xfU0laRSA9IDEwO1xudmFyIERFRkFVTFRfUE9PTEVSID0gb25lQXJndW1lbnRQb29sZXI7XG5cbi8qKlxuICogQXVnbWVudHMgYENvcHlDb25zdHJ1Y3RvcmAgdG8gYmUgYSBwb29sYWJsZSBjbGFzcywgYXVnbWVudGluZyBvbmx5IHRoZSBjbGFzc1xuICogaXRzZWxmIChzdGF0aWNhbGx5KSBub3QgYWRkaW5nIGFueSBwcm90b3R5cGljYWwgZmllbGRzLiBBbnkgQ29weUNvbnN0cnVjdG9yXG4gKiB5b3UgZ2l2ZSB0aGlzIG1heSBoYXZlIGEgYHBvb2xTaXplYCBwcm9wZXJ0eSwgYW5kIHdpbGwgbG9vayBmb3IgYVxuICogcHJvdG90eXBpY2FsIGBkZXN0cnVjdG9yYCBvbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gQ29weUNvbnN0cnVjdG9yIENvbnN0cnVjdG9yIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwb29sZXIgQ3VzdG9taXphYmxlIHBvb2xlci5cbiAqL1xudmFyIGFkZFBvb2xpbmdUbyA9IGZ1bmN0aW9uIChDb3B5Q29uc3RydWN0b3IsIHBvb2xlcikge1xuICAvLyBDYXN0aW5nIGFzIGFueSBzbyB0aGF0IGZsb3cgaWdub3JlcyB0aGUgYWN0dWFsIGltcGxlbWVudGF0aW9uIGFuZCB0cnVzdHNcbiAgLy8gaXQgdG8gbWF0Y2ggdGhlIHR5cGUgd2UgZGVjbGFyZWRcbiAgdmFyIE5ld0tsYXNzID0gQ29weUNvbnN0cnVjdG9yO1xuICBOZXdLbGFzcy5pbnN0YW5jZVBvb2wgPSBbXTtcbiAgTmV3S2xhc3MuZ2V0UG9vbGVkID0gcG9vbGVyIHx8IERFRkFVTFRfUE9PTEVSO1xuICBpZiAoIU5ld0tsYXNzLnBvb2xTaXplKSB7XG4gICAgTmV3S2xhc3MucG9vbFNpemUgPSBERUZBVUxUX1BPT0xfU0laRTtcbiAgfVxuICBOZXdLbGFzcy5yZWxlYXNlID0gc3RhbmRhcmRSZWxlYXNlcjtcbiAgcmV0dXJuIE5ld0tsYXNzO1xufTtcblxudmFyIFBvb2xlZENsYXNzID0ge1xuICBhZGRQb29saW5nVG86IGFkZFBvb2xpbmdUbyxcbiAgb25lQXJndW1lbnRQb29sZXI6IG9uZUFyZ3VtZW50UG9vbGVyLFxuICB0d29Bcmd1bWVudFBvb2xlcjogdHdvQXJndW1lbnRQb29sZXIsXG4gIHRocmVlQXJndW1lbnRQb29sZXI6IHRocmVlQXJndW1lbnRQb29sZXIsXG4gIGZvdXJBcmd1bWVudFBvb2xlcjogZm91ckFyZ3VtZW50UG9vbGVyLFxuICBmaXZlQXJndW1lbnRQb29sZXI6IGZpdmVBcmd1bWVudFBvb2xlclxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb29sZWRDbGFzcztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QvbGliL1Bvb2xlZENsYXNzLmpzXG4vLyBtb2R1bGUgaWQgPSAxODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiBwcmludFdhcm5pbmcoZm9ybWF0KSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoICh4KSB7fVxuICAgIH07XG5cbiAgICB3YXJuaW5nID0gZnVuY3Rpb24gd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCkge1xuICAgICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgQ29tcG9zaXRlQ29tcG9uZW50IHByb3B0eXBlIGNoZWNrLlxuICAgICAgfVxuXG4gICAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC9+L2ZianMvbGliL3dhcm5pbmcuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=